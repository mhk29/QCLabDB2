!function(e) {
    var t = {};
    function n(i) {
        if (t[i])
            return t[i].exports;
        var r = t[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return e[i].call(r.exports, r, r.exports, n),
        r.l = !0,
        r.exports
    }
    n.m = e,
    n.c = t,
    n.d = function(e, t, i) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: i
        })
    }
    ,
    n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(e, t) {
        if (1 & t && (e = n(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var i = Object.create(null);
        if (n.r(i),
        Object.defineProperty(i, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var r in e)
                n.d(i, r, function(t) {
                    return e[t]
                }
                .bind(null, r));
        return i
    }
    ,
    n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return n.d(t, "a", t),
        t
    }
    ,
    n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    n.p = "",
    n(n.s = 141)
}([function(e, t, n) {
    "use strict";
    n.d(t, "s", (function() {
        return r
    }
    )),
    n.d(t, "p", (function() {
        return s
    }
    )),
    n.d(t, "q", (function() {
        return a
    }
    )),
    n.d(t, "r", (function() {
        return o
    }
    )),
    n.d(t, "g", (function() {
        return l
    }
    )),
    n.d(t, "c", (function() {
        return c
    }
    )),
    n.d(t, "e", (function() {
        return u
    }
    )),
    n.d(t, "h", (function() {
        return d
    }
    )),
    n.d(t, "j", (function() {
        return S
    }
    )),
    n.d(t, "a", (function() {
        return w
    }
    )),
    n.d(t, "b", (function() {
        return x
    }
    )),
    n.d(t, "d", (function() {
        return C
    }
    )),
    n.d(t, "w", (function() {
        return O
    }
    )),
    n.d(t, "u", (function() {
        return k
    }
    )),
    n.d(t, "D", (function() {
        return E
    }
    )),
    n.d(t, "v", (function() {
        return T
    }
    )),
    n.d(t, "E", (function() {
        return M
    }
    )),
    n.d(t, "C", (function() {
        return D
    }
    )),
    n.d(t, "A", (function() {
        return L
    }
    )),
    n.d(t, "z", (function() {
        return A
    }
    )),
    n.d(t, "y", (function() {
        return I
    }
    )),
    n.d(t, "B", (function() {
        return P
    }
    )),
    n.d(t, "x", (function() {
        return R
    }
    )),
    n.d(t, "t", (function() {
        return j
    }
    )),
    n.d(t, "f", (function() {
        return N
    }
    )),
    n.d(t, "i", (function() {
        return V
    }
    )),
    n.d(t, "o", (function() {
        return B
    }
    )),
    n.d(t, "m", (function() {
        return F
    }
    )),
    n.d(t, "l", (function() {
        return _
    }
    )),
    n.d(t, "k", (function() {
        return U
    }
    )),
    n.d(t, "F", (function() {
        return z
    }
    )),
    n.d(t, "n", (function() {
        return G
    }
    ));
    var i = n(1);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function r(e) {
        let t = typeof e;
        if ("number" === t || "string" === t) {
            let t = parseFloat("" + e);
            if (!Number.isNaN(t))
                return t
        }
        throw new Error(`Expected floating-point number, but received: ${JSON.stringify(e)}.`)
    }
    function s(e) {
        let t = r(e);
        if (Number.isFinite(t))
            return t;
        throw new Error(`Expected finite floating-point number, but received: ${t}.`)
    }
    function a(e) {
        let t = r(e);
        if (Number.isFinite(t) && t >= 0)
            return t;
        throw new Error(`Expected finite non-negative floating-point number, but received: ${t}.`)
    }
    function o(e) {
        let t = s(e);
        if (t > 0)
            return t;
        throw new Error(`Expected positive finite floating-point number, but received: ${t}.`)
    }
    function l(e, t, n=r) {
        O(t),
        e[0] = e[1] = e[2] = 0;
        for (const i of Object.keys(t))
            switch (i) {
            case "x":
                e[0] = n(t[i]);
                break;
            case "y":
                e[1] = n(t[i]);
                break;
            case "z":
                e[2] = n(t[i]);
                break;
            default:
                throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${JSON.stringify(t)}.`)
            }
        return e
    }
    function c(e, t) {
        let n = e.length;
        if (!Array.isArray(t) || t.length !== n)
            throw new Error("Incompatible sizes");
        for (let e = 0; e < n; ++e)
            if (!Number.isFinite(parseFloat(t[e])))
                throw new Error("Non-finite value.");
        for (let i = 0; i < n; ++i)
            e[i] = parseFloat(t[i]);
        return e
    }
    function u(e, t) {
        let n = e.length;
        if (!Array.isArray(t) || t.length !== n)
            throw new Error("Incompatible sizes.");
        for (let e = 0; e < n; ++e) {
            let n = parseInt(t[e], void 0);
            if (!Number.isInteger(n))
                throw new Error("Non-integer value.")
        }
        for (let i = 0; i < n; ++i)
            e[i] = parseInt(t[i], void 0);
        return e
    }
    function d(e) {
        if ("object" == typeof e) {
            if (null === e)
                return "null";
            if (Array.isArray(e)) {
                let t = "["
                  , n = e.length
                  , i = 0;
                if (i < n)
                    for (t += d(e[i]); ++i < n; )
                        t += ",",
                        t += d(e[i]);
                return t += "]",
                t
            }
            let t = "{"
              , n = Object.keys(e).sort()
              , i = 0
              , r = n.length;
            if (i < r) {
                let s = n[i];
                for (t += JSON.stringify(s),
                t += ":",
                t += d(e[s]); ++i < r; )
                    t += ",",
                    s = n[i],
                    t += JSON.stringify(s),
                    t += ":",
                    t += d(e[s])
            }
            return t += "}",
            t
        }
        return JSON.stringify(e)
    }
    const h = /('(?:[^'\\]|(?:\\.))*')/
      , p = /("(?:[^"\\]|(?:\\.))*")/
      , f = new RegExp(`${h.source}|${p.source}`)
      , m = new RegExp(`${p.source}|${h.source}`)
      , g = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/
      , v = /^((?:[^"'\\]|(?:\\.))*)'/;
    function b(e, t, n, i) {
        if (e.length >= 2 && e.charAt(0) === t && e.charAt(e.length - 1) === t) {
            let r = e.substr(1, e.length - 2)
              , s = n;
            for (; r.length > 0; ) {
                let e = r.match(i);
                if (null === e) {
                    s += r;
                    break
                }
                s += e[1],
                e[2] === n ? (s += "\\",
                s += n) : s += t,
                r = r.substr(e.index + e[0].length)
            }
            return s += n,
            s
        }
        return e
    }
    function y(e, t, n) {
        const i = /[&_,]/g;
        let r, s, a;
        '"' === n ? (r = "'",
        s = g,
        a = f) : (r = '"',
        s = v,
        a = m);
        let o = "";
        for (; e.length > 0; ) {
            let l, c, u = e.match(a);
            if (null === u)
                l = e,
                e = "",
                c = "";
            else {
                l = e.substr(0, u.index),
                e = e.substr(u.index + u[0].length);
                let t = u[1];
                c = void 0 !== t ? b(t, r, n, s) : u[2]
            }
            o += l.replace(i, t),
            o += c
        }
        return o
    }
    function S(e) {
        return JSON.parse(function(e) {
            return y(e, ",", '"')
        }(e))
    }
    function w(e, t) {
        if (!Array.isArray(e))
            throw new Error(`Expected array, but received: ${JSON.stringify(e)}.`);
        if (void 0 !== t && e.length !== t)
            throw new Error(`Expected array of length ${t}, but received: ${JSON.stringify(e)}.`);
        return e
    }
    function x(e, t) {
        if (!Array.isArray(e))
            throw new Error(`Expected array, but received: ${JSON.stringify(e)}.`);
        return e.map(t)
    }
    function C(e, t, n) {
        const i = e.length;
        if (!Array.isArray(t) || t.length !== i)
            throw new Error(`Expected length ${i} array, but received: ${JSON.stringify(t)}.`);
        for (let r = 0; r < i; ++r)
            e[r] = n(t[r], r);
        return e
    }
    function O(e) {
        if ("object" != typeof e || null == e || Array.isArray(e))
            throw new Error(`Expected JSON object, but received: ${JSON.stringify(e)}.`);
        return e
    }
    function k(e) {
        let t = parseInt(e, 10);
        if (!Number.isInteger(t))
            throw new Error(`Expected integer, but received: ${JSON.stringify(e)}.`);
        return t
    }
    function E(e) {
        let t = k(e);
        if (t <= 0)
            throw new Error(`Expected positive integer, but received: ${t}.`);
        return t
    }
    function T(e, t) {
        let n = t.get(e);
        if (void 0 === n)
            throw new Error(`Expected one of ${JSON.stringify(Array.from(t.keys()))}, ` + `but received: ${JSON.stringify(e)}.`);
        return n
    }
    function M(e) {
        if ("string" != typeof e)
            throw new Error(`Expected string, but received: ${JSON.stringify(e)}.`);
        return e
    }
    function D(e) {
        if (void 0 !== e)
            return M(e)
    }
    function L(e) {
        if (void 0 !== e)
            return k(e)
    }
    function A(e) {
        if (void 0 !== e) {
            if ("boolean" == typeof e)
                return e;
            if ("true" === e)
                return !0;
            if ("false" === e)
                return !1;
            throw new Error(`Expected string or boolean but received: ${JSON.stringify(e)}`)
        }
    }
    function I(e, t, n) {
        let i = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
        try {
            return n(i)
        } catch (e) {
            throw new Error(`Error parsing ${JSON.stringify(t)} property: ${e.message}`)
        }
    }
    function P(e, t, n, i) {
        return I(e, t, e=>void 0 === e ? i : n(e))
    }
    function R(e, t) {
        O(e);
        let n = new Map;
        for (let i of Object.keys(e))
            try {
                n.set(i, t(e[i]))
            } catch (e) {
                throw new Error(`Error parsing value associated with key ${JSON.stringify(i)}: ${e.message}`)
            }
        return n
    }
    function j(e) {
        if ("number" != typeof e || !Number.isFinite(e) || e < 0 || e > 1)
            throw new Error(`Expected floating point number in [0,1], but received: ${JSON.stringify(e)}.`);
        return e
    }
    function N(e) {
        if ("" === e)
            return {};
        if (e.startsWith("{"))
            return S(e);
        {
            let t = {}
              , n = e.split(/[&;]/);
            for (let e of n) {
                let n = e.match(/^([^=&;]+)=([^&;]*)$/);
                if (null === n)
                    throw new Error(`Invalid query string part: ${JSON.stringify(e)}.`);
                t[n[1]] = decodeURIComponent(n[2])
            }
            return t
        }
    }
    function V(e) {
        if (void 0 === e)
            return "";
        const t = Object.keys(e);
        return 0 === t.length ? "" : t.some(t=>"string" != typeof e[t]) ? JSON.stringify(e) : t.map(t=>`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")
    }
    function B(e, t) {
        if ("string" == typeof e && null !== e.match(/^[a-zA-Z]/) && (e = e.toUpperCase(),
        t.hasOwnProperty(e)))
            return t[e];
        throw new Error(`Invalid enum value: ${JSON.stringify(e)}.`)
    }
    function F(e) {
        return C(i.t.create(), e, s)
    }
    function _(e) {
        return C(i.t.create(), e, o)
    }
    function U(e) {
        return C(i.t.create(), e, E)
    }
    function z(e) {
        if (!Array.isArray(e))
            throw new Error(`Expected array, received: ${JSON.stringify(e)}.`);
        for (let t of e)
            if ("string" != typeof t)
                throw new Error(`Expected string, received: ${JSON.stringify(t)}.`);
        return e
    }
    function G(e) {
        if ("boolean" != typeof e)
            throw new Error(`Expected boolean, received: ${JSON.stringify(e)}`);
        return e
    }
}
, function(e, t, n) {
    "use strict";
    var i = {};
    n.r(i),
    n.d(i, "create", (function() {
        return d
    }
    )),
    n.d(i, "fromMat4", (function() {
        return h
    }
    )),
    n.d(i, "clone", (function() {
        return p
    }
    )),
    n.d(i, "copy", (function() {
        return f
    }
    )),
    n.d(i, "fromValues", (function() {
        return m
    }
    )),
    n.d(i, "set", (function() {
        return g
    }
    )),
    n.d(i, "identity", (function() {
        return v
    }
    )),
    n.d(i, "transpose", (function() {
        return b
    }
    )),
    n.d(i, "invert", (function() {
        return y
    }
    )),
    n.d(i, "adjoint", (function() {
        return S
    }
    )),
    n.d(i, "determinant", (function() {
        return w
    }
    )),
    n.d(i, "multiply", (function() {
        return x
    }
    )),
    n.d(i, "translate", (function() {
        return C
    }
    )),
    n.d(i, "rotate", (function() {
        return O
    }
    )),
    n.d(i, "scale", (function() {
        return k
    }
    )),
    n.d(i, "fromTranslation", (function() {
        return E
    }
    )),
    n.d(i, "fromRotation", (function() {
        return T
    }
    )),
    n.d(i, "fromScaling", (function() {
        return M
    }
    )),
    n.d(i, "fromMat2d", (function() {
        return D
    }
    )),
    n.d(i, "fromQuat", (function() {
        return L
    }
    )),
    n.d(i, "normalFromMat4", (function() {
        return A
    }
    )),
    n.d(i, "projection", (function() {
        return I
    }
    )),
    n.d(i, "str", (function() {
        return P
    }
    )),
    n.d(i, "frob", (function() {
        return R
    }
    )),
    n.d(i, "add", (function() {
        return j
    }
    )),
    n.d(i, "subtract", (function() {
        return N
    }
    )),
    n.d(i, "multiplyScalar", (function() {
        return V
    }
    )),
    n.d(i, "multiplyScalarAndAdd", (function() {
        return B
    }
    )),
    n.d(i, "exactEquals", (function() {
        return F
    }
    )),
    n.d(i, "equals", (function() {
        return _
    }
    )),
    n.d(i, "mul", (function() {
        return U
    }
    )),
    n.d(i, "sub", (function() {
        return z
    }
    ));
    var r = {};
    n.r(r),
    n.d(r, "create", (function() {
        return G
    }
    )),
    n.d(r, "clone", (function() {
        return $
    }
    )),
    n.d(r, "copy", (function() {
        return W
    }
    )),
    n.d(r, "fromValues", (function() {
        return H
    }
    )),
    n.d(r, "set", (function() {
        return J
    }
    )),
    n.d(r, "identity", (function() {
        return q
    }
    )),
    n.d(r, "transpose", (function() {
        return Y
    }
    )),
    n.d(r, "invert", (function() {
        return X
    }
    )),
    n.d(r, "adjoint", (function() {
        return K
    }
    )),
    n.d(r, "determinant", (function() {
        return Z
    }
    )),
    n.d(r, "multiply", (function() {
        return Q
    }
    )),
    n.d(r, "translate", (function() {
        return ee
    }
    )),
    n.d(r, "scale", (function() {
        return te
    }
    )),
    n.d(r, "rotate", (function() {
        return ne
    }
    )),
    n.d(r, "rotateX", (function() {
        return ie
    }
    )),
    n.d(r, "rotateY", (function() {
        return re
    }
    )),
    n.d(r, "rotateZ", (function() {
        return se
    }
    )),
    n.d(r, "fromTranslation", (function() {
        return ae
    }
    )),
    n.d(r, "fromScaling", (function() {
        return oe
    }
    )),
    n.d(r, "fromRotation", (function() {
        return le
    }
    )),
    n.d(r, "fromXRotation", (function() {
        return ce
    }
    )),
    n.d(r, "fromYRotation", (function() {
        return ue
    }
    )),
    n.d(r, "fromZRotation", (function() {
        return de
    }
    )),
    n.d(r, "fromRotationTranslation", (function() {
        return he
    }
    )),
    n.d(r, "fromQuat2", (function() {
        return pe
    }
    )),
    n.d(r, "getTranslation", (function() {
        return fe
    }
    )),
    n.d(r, "getScaling", (function() {
        return me
    }
    )),
    n.d(r, "getRotation", (function() {
        return ge
    }
    )),
    n.d(r, "fromRotationTranslationScale", (function() {
        return ve
    }
    )),
    n.d(r, "fromRotationTranslationScaleOrigin", (function() {
        return be
    }
    )),
    n.d(r, "fromQuat", (function() {
        return ye
    }
    )),
    n.d(r, "frustum", (function() {
        return Se
    }
    )),
    n.d(r, "perspective", (function() {
        return we
    }
    )),
    n.d(r, "perspectiveFromFieldOfView", (function() {
        return xe
    }
    )),
    n.d(r, "ortho", (function() {
        return Ce
    }
    )),
    n.d(r, "lookAt", (function() {
        return Oe
    }
    )),
    n.d(r, "targetTo", (function() {
        return ke
    }
    )),
    n.d(r, "str", (function() {
        return Ee
    }
    )),
    n.d(r, "frob", (function() {
        return Te
    }
    )),
    n.d(r, "add", (function() {
        return Me
    }
    )),
    n.d(r, "subtract", (function() {
        return De
    }
    )),
    n.d(r, "multiplyScalar", (function() {
        return Le
    }
    )),
    n.d(r, "multiplyScalarAndAdd", (function() {
        return Ae
    }
    )),
    n.d(r, "exactEquals", (function() {
        return Ie
    }
    )),
    n.d(r, "equals", (function() {
        return Pe
    }
    )),
    n.d(r, "mul", (function() {
        return Re
    }
    )),
    n.d(r, "sub", (function() {
        return je
    }
    ));
    var s = {};
    n.r(s),
    n.d(s, "create", (function() {
        return Ne
    }
    )),
    n.d(s, "clone", (function() {
        return Ve
    }
    )),
    n.d(s, "length", (function() {
        return Be
    }
    )),
    n.d(s, "fromValues", (function() {
        return Fe
    }
    )),
    n.d(s, "copy", (function() {
        return _e
    }
    )),
    n.d(s, "set", (function() {
        return Ue
    }
    )),
    n.d(s, "add", (function() {
        return ze
    }
    )),
    n.d(s, "subtract", (function() {
        return Ge
    }
    )),
    n.d(s, "multiply", (function() {
        return $e
    }
    )),
    n.d(s, "divide", (function() {
        return We
    }
    )),
    n.d(s, "ceil", (function() {
        return He
    }
    )),
    n.d(s, "floor", (function() {
        return Je
    }
    )),
    n.d(s, "min", (function() {
        return qe
    }
    )),
    n.d(s, "max", (function() {
        return Ye
    }
    )),
    n.d(s, "round", (function() {
        return Xe
    }
    )),
    n.d(s, "scale", (function() {
        return Ke
    }
    )),
    n.d(s, "scaleAndAdd", (function() {
        return Ze
    }
    )),
    n.d(s, "distance", (function() {
        return Qe
    }
    )),
    n.d(s, "squaredDistance", (function() {
        return et
    }
    )),
    n.d(s, "squaredLength", (function() {
        return tt
    }
    )),
    n.d(s, "negate", (function() {
        return nt
    }
    )),
    n.d(s, "inverse", (function() {
        return it
    }
    )),
    n.d(s, "normalize", (function() {
        return rt
    }
    )),
    n.d(s, "dot", (function() {
        return st
    }
    )),
    n.d(s, "cross", (function() {
        return at
    }
    )),
    n.d(s, "lerp", (function() {
        return ot
    }
    )),
    n.d(s, "hermite", (function() {
        return lt
    }
    )),
    n.d(s, "bezier", (function() {
        return ct
    }
    )),
    n.d(s, "random", (function() {
        return ut
    }
    )),
    n.d(s, "transformMat4", (function() {
        return dt
    }
    )),
    n.d(s, "transformMat3", (function() {
        return ht
    }
    )),
    n.d(s, "transformQuat", (function() {
        return pt
    }
    )),
    n.d(s, "rotateX", (function() {
        return ft
    }
    )),
    n.d(s, "rotateY", (function() {
        return mt
    }
    )),
    n.d(s, "rotateZ", (function() {
        return gt
    }
    )),
    n.d(s, "angle", (function() {
        return vt
    }
    )),
    n.d(s, "zero", (function() {
        return bt
    }
    )),
    n.d(s, "str", (function() {
        return yt
    }
    )),
    n.d(s, "exactEquals", (function() {
        return St
    }
    )),
    n.d(s, "equals", (function() {
        return wt
    }
    )),
    n.d(s, "sub", (function() {
        return Ct
    }
    )),
    n.d(s, "mul", (function() {
        return Ot
    }
    )),
    n.d(s, "div", (function() {
        return kt
    }
    )),
    n.d(s, "dist", (function() {
        return Et
    }
    )),
    n.d(s, "sqrDist", (function() {
        return Tt
    }
    )),
    n.d(s, "len", (function() {
        return Mt
    }
    )),
    n.d(s, "sqrLen", (function() {
        return Dt
    }
    )),
    n.d(s, "forEach", (function() {
        return Lt
    }
    ));
    var a = {};
    n.r(a),
    n.d(a, "create", (function() {
        return At
    }
    )),
    n.d(a, "clone", (function() {
        return It
    }
    )),
    n.d(a, "fromValues", (function() {
        return Pt
    }
    )),
    n.d(a, "copy", (function() {
        return Rt
    }
    )),
    n.d(a, "set", (function() {
        return jt
    }
    )),
    n.d(a, "add", (function() {
        return Nt
    }
    )),
    n.d(a, "subtract", (function() {
        return Vt
    }
    )),
    n.d(a, "multiply", (function() {
        return Bt
    }
    )),
    n.d(a, "divide", (function() {
        return Ft
    }
    )),
    n.d(a, "ceil", (function() {
        return _t
    }
    )),
    n.d(a, "floor", (function() {
        return Ut
    }
    )),
    n.d(a, "min", (function() {
        return zt
    }
    )),
    n.d(a, "max", (function() {
        return Gt
    }
    )),
    n.d(a, "round", (function() {
        return $t
    }
    )),
    n.d(a, "scale", (function() {
        return Wt
    }
    )),
    n.d(a, "scaleAndAdd", (function() {
        return Ht
    }
    )),
    n.d(a, "distance", (function() {
        return Jt
    }
    )),
    n.d(a, "squaredDistance", (function() {
        return qt
    }
    )),
    n.d(a, "length", (function() {
        return Yt
    }
    )),
    n.d(a, "squaredLength", (function() {
        return Xt
    }
    )),
    n.d(a, "negate", (function() {
        return Kt
    }
    )),
    n.d(a, "inverse", (function() {
        return Zt
    }
    )),
    n.d(a, "normalize", (function() {
        return Qt
    }
    )),
    n.d(a, "dot", (function() {
        return en
    }
    )),
    n.d(a, "cross", (function() {
        return tn
    }
    )),
    n.d(a, "lerp", (function() {
        return nn
    }
    )),
    n.d(a, "random", (function() {
        return rn
    }
    )),
    n.d(a, "transformMat4", (function() {
        return sn
    }
    )),
    n.d(a, "transformQuat", (function() {
        return an
    }
    )),
    n.d(a, "zero", (function() {
        return on
    }
    )),
    n.d(a, "str", (function() {
        return ln
    }
    )),
    n.d(a, "exactEquals", (function() {
        return cn
    }
    )),
    n.d(a, "equals", (function() {
        return un
    }
    )),
    n.d(a, "sub", (function() {
        return dn
    }
    )),
    n.d(a, "mul", (function() {
        return hn
    }
    )),
    n.d(a, "div", (function() {
        return pn
    }
    )),
    n.d(a, "dist", (function() {
        return fn
    }
    )),
    n.d(a, "sqrDist", (function() {
        return mn
    }
    )),
    n.d(a, "len", (function() {
        return gn
    }
    )),
    n.d(a, "sqrLen", (function() {
        return vn
    }
    )),
    n.d(a, "forEach", (function() {
        return bn
    }
    ));
    var o = {};
    n.r(o),
    n.d(o, "create", (function() {
        return yn
    }
    )),
    n.d(o, "identity", (function() {
        return Sn
    }
    )),
    n.d(o, "setAxisAngle", (function() {
        return wn
    }
    )),
    n.d(o, "getAxisAngle", (function() {
        return xn
    }
    )),
    n.d(o, "getAngle", (function() {
        return Cn
    }
    )),
    n.d(o, "multiply", (function() {
        return On
    }
    )),
    n.d(o, "rotateX", (function() {
        return kn
    }
    )),
    n.d(o, "rotateY", (function() {
        return En
    }
    )),
    n.d(o, "rotateZ", (function() {
        return Tn
    }
    )),
    n.d(o, "calculateW", (function() {
        return Mn
    }
    )),
    n.d(o, "exp", (function() {
        return Dn
    }
    )),
    n.d(o, "ln", (function() {
        return Ln
    }
    )),
    n.d(o, "pow", (function() {
        return An
    }
    )),
    n.d(o, "slerp", (function() {
        return In
    }
    )),
    n.d(o, "random", (function() {
        return Pn
    }
    )),
    n.d(o, "invert", (function() {
        return Rn
    }
    )),
    n.d(o, "conjugate", (function() {
        return jn
    }
    )),
    n.d(o, "fromMat3", (function() {
        return Nn
    }
    )),
    n.d(o, "fromEuler", (function() {
        return Vn
    }
    )),
    n.d(o, "str", (function() {
        return Bn
    }
    )),
    n.d(o, "clone", (function() {
        return Wn
    }
    )),
    n.d(o, "fromValues", (function() {
        return Hn
    }
    )),
    n.d(o, "copy", (function() {
        return Jn
    }
    )),
    n.d(o, "set", (function() {
        return qn
    }
    )),
    n.d(o, "add", (function() {
        return Yn
    }
    )),
    n.d(o, "mul", (function() {
        return Xn
    }
    )),
    n.d(o, "scale", (function() {
        return Kn
    }
    )),
    n.d(o, "dot", (function() {
        return Zn
    }
    )),
    n.d(o, "lerp", (function() {
        return Qn
    }
    )),
    n.d(o, "length", (function() {
        return ei
    }
    )),
    n.d(o, "len", (function() {
        return ti
    }
    )),
    n.d(o, "squaredLength", (function() {
        return ni
    }
    )),
    n.d(o, "sqrLen", (function() {
        return ii
    }
    )),
    n.d(o, "normalize", (function() {
        return ri
    }
    )),
    n.d(o, "exactEquals", (function() {
        return si
    }
    )),
    n.d(o, "equals", (function() {
        return ai
    }
    )),
    n.d(o, "rotationTo", (function() {
        return oi
    }
    )),
    n.d(o, "sqlerp", (function() {
        return li
    }
    )),
    n.d(o, "setAxes", (function() {
        return ci
    }
    ));
    var l = {};
    n.r(l),
    n.d(l, "create", (function() {
        return ui
    }
    )),
    n.d(l, "clone", (function() {
        return di
    }
    )),
    n.d(l, "fromValues", (function() {
        return hi
    }
    )),
    n.d(l, "copy", (function() {
        return pi
    }
    )),
    n.d(l, "set", (function() {
        return fi
    }
    )),
    n.d(l, "add", (function() {
        return mi
    }
    )),
    n.d(l, "subtract", (function() {
        return gi
    }
    )),
    n.d(l, "multiply", (function() {
        return vi
    }
    )),
    n.d(l, "divide", (function() {
        return bi
    }
    )),
    n.d(l, "ceil", (function() {
        return yi
    }
    )),
    n.d(l, "floor", (function() {
        return Si
    }
    )),
    n.d(l, "min", (function() {
        return wi
    }
    )),
    n.d(l, "max", (function() {
        return xi
    }
    )),
    n.d(l, "round", (function() {
        return Ci
    }
    )),
    n.d(l, "scale", (function() {
        return Oi
    }
    )),
    n.d(l, "scaleAndAdd", (function() {
        return ki
    }
    )),
    n.d(l, "distance", (function() {
        return Ei
    }
    )),
    n.d(l, "squaredDistance", (function() {
        return Ti
    }
    )),
    n.d(l, "length", (function() {
        return Mi
    }
    )),
    n.d(l, "squaredLength", (function() {
        return Di
    }
    )),
    n.d(l, "negate", (function() {
        return Li
    }
    )),
    n.d(l, "inverse", (function() {
        return Ai
    }
    )),
    n.d(l, "normalize", (function() {
        return Ii
    }
    )),
    n.d(l, "dot", (function() {
        return Pi
    }
    )),
    n.d(l, "cross", (function() {
        return Ri
    }
    )),
    n.d(l, "lerp", (function() {
        return ji
    }
    )),
    n.d(l, "random", (function() {
        return Ni
    }
    )),
    n.d(l, "transformMat2", (function() {
        return Vi
    }
    )),
    n.d(l, "transformMat2d", (function() {
        return Bi
    }
    )),
    n.d(l, "transformMat3", (function() {
        return Fi
    }
    )),
    n.d(l, "transformMat4", (function() {
        return _i
    }
    )),
    n.d(l, "rotate", (function() {
        return Ui
    }
    )),
    n.d(l, "angle", (function() {
        return zi
    }
    )),
    n.d(l, "zero", (function() {
        return Gi
    }
    )),
    n.d(l, "str", (function() {
        return $i
    }
    )),
    n.d(l, "exactEquals", (function() {
        return Wi
    }
    )),
    n.d(l, "equals", (function() {
        return Hi
    }
    )),
    n.d(l, "len", (function() {
        return Ji
    }
    )),
    n.d(l, "sub", (function() {
        return qi
    }
    )),
    n.d(l, "mul", (function() {
        return Yi
    }
    )),
    n.d(l, "div", (function() {
        return Xi
    }
    )),
    n.d(l, "dist", (function() {
        return Ki
    }
    )),
    n.d(l, "sqrDist", (function() {
        return Zi
    }
    )),
    n.d(l, "sqrLen", (function() {
        return Qi
    }
    )),
    n.d(l, "forEach", (function() {
        return er
    }
    ));
    var c = "undefined" != typeof Float32Array ? Float32Array : Array
      , u = Math.random;
    Math.PI;
    function d() {
        var e = new c(9);
        return c != Float32Array && (e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[5] = 0,
        e[6] = 0,
        e[7] = 0),
        e[0] = 1,
        e[4] = 1,
        e[8] = 1,
        e
    }
    function h(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[4],
        e[4] = t[5],
        e[5] = t[6],
        e[6] = t[8],
        e[7] = t[9],
        e[8] = t[10],
        e
    }
    function p(e) {
        var t = new c(9);
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t[3] = e[3],
        t[4] = e[4],
        t[5] = e[5],
        t[6] = e[6],
        t[7] = e[7],
        t[8] = e[8],
        t
    }
    function f(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e
    }
    function m(e, t, n, i, r, s, a, o, l) {
        var u = new c(9);
        return u[0] = e,
        u[1] = t,
        u[2] = n,
        u[3] = i,
        u[4] = r,
        u[5] = s,
        u[6] = a,
        u[7] = o,
        u[8] = l,
        u
    }
    function g(e, t, n, i, r, s, a, o, l, c) {
        return e[0] = t,
        e[1] = n,
        e[2] = i,
        e[3] = r,
        e[4] = s,
        e[5] = a,
        e[6] = o,
        e[7] = l,
        e[8] = c,
        e
    }
    function v(e) {
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 1,
        e[5] = 0,
        e[6] = 0,
        e[7] = 0,
        e[8] = 1,
        e
    }
    function b(e, t) {
        if (e === t) {
            var n = t[1]
              , i = t[2]
              , r = t[5];
            e[1] = t[3],
            e[2] = t[6],
            e[3] = n,
            e[5] = t[7],
            e[6] = i,
            e[7] = r
        } else
            e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8];
        return e
    }
    function y(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8]
          , d = u * a - o * c
          , h = -u * s + o * l
          , p = c * s - a * l
          , f = n * d + i * h + r * p;
        return f ? (f = 1 / f,
        e[0] = d * f,
        e[1] = (-u * i + r * c) * f,
        e[2] = (o * i - r * a) * f,
        e[3] = h * f,
        e[4] = (u * n - r * l) * f,
        e[5] = (-o * n + r * s) * f,
        e[6] = p * f,
        e[7] = (-c * n + i * l) * f,
        e[8] = (a * n - i * s) * f,
        e) : null
    }
    function S(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8];
        return e[0] = a * u - o * c,
        e[1] = r * c - i * u,
        e[2] = i * o - r * a,
        e[3] = o * l - s * u,
        e[4] = n * u - r * l,
        e[5] = r * s - n * o,
        e[6] = s * c - a * l,
        e[7] = i * l - n * c,
        e[8] = n * a - i * s,
        e
    }
    function w(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , o = e[6]
          , l = e[7]
          , c = e[8];
        return t * (c * s - a * l) + n * (-c * r + a * o) + i * (l * r - s * o)
    }
    function x(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = t[4]
          , l = t[5]
          , c = t[6]
          , u = t[7]
          , d = t[8]
          , h = n[0]
          , p = n[1]
          , f = n[2]
          , m = n[3]
          , g = n[4]
          , v = n[5]
          , b = n[6]
          , y = n[7]
          , S = n[8];
        return e[0] = h * i + p * a + f * c,
        e[1] = h * r + p * o + f * u,
        e[2] = h * s + p * l + f * d,
        e[3] = m * i + g * a + v * c,
        e[4] = m * r + g * o + v * u,
        e[5] = m * s + g * l + v * d,
        e[6] = b * i + y * a + S * c,
        e[7] = b * r + y * o + S * u,
        e[8] = b * s + y * l + S * d,
        e
    }
    function C(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = t[4]
          , l = t[5]
          , c = t[6]
          , u = t[7]
          , d = t[8]
          , h = n[0]
          , p = n[1];
        return e[0] = i,
        e[1] = r,
        e[2] = s,
        e[3] = a,
        e[4] = o,
        e[5] = l,
        e[6] = h * i + p * a + c,
        e[7] = h * r + p * o + u,
        e[8] = h * s + p * l + d,
        e
    }
    function O(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = t[4]
          , l = t[5]
          , c = t[6]
          , u = t[7]
          , d = t[8]
          , h = Math.sin(n)
          , p = Math.cos(n);
        return e[0] = p * i + h * a,
        e[1] = p * r + h * o,
        e[2] = p * s + h * l,
        e[3] = p * a - h * i,
        e[4] = p * o - h * r,
        e[5] = p * l - h * s,
        e[6] = c,
        e[7] = u,
        e[8] = d,
        e
    }
    function k(e, t, n) {
        var i = n[0]
          , r = n[1];
        return e[0] = i * t[0],
        e[1] = i * t[1],
        e[2] = i * t[2],
        e[3] = r * t[3],
        e[4] = r * t[4],
        e[5] = r * t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e
    }
    function E(e, t) {
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 1,
        e[5] = 0,
        e[6] = t[0],
        e[7] = t[1],
        e[8] = 1,
        e
    }
    function T(e, t) {
        var n = Math.sin(t)
          , i = Math.cos(t);
        return e[0] = i,
        e[1] = n,
        e[2] = 0,
        e[3] = -n,
        e[4] = i,
        e[5] = 0,
        e[6] = 0,
        e[7] = 0,
        e[8] = 1,
        e
    }
    function M(e, t) {
        return e[0] = t[0],
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = t[1],
        e[5] = 0,
        e[6] = 0,
        e[7] = 0,
        e[8] = 1,
        e
    }
    function D(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = 0,
        e[3] = t[2],
        e[4] = t[3],
        e[5] = 0,
        e[6] = t[4],
        e[7] = t[5],
        e[8] = 1,
        e
    }
    function L(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = n + n
          , o = i + i
          , l = r + r
          , c = n * a
          , u = i * a
          , d = i * o
          , h = r * a
          , p = r * o
          , f = r * l
          , m = s * a
          , g = s * o
          , v = s * l;
        return e[0] = 1 - d - f,
        e[3] = u - v,
        e[6] = h + g,
        e[1] = u + v,
        e[4] = 1 - c - f,
        e[7] = p - m,
        e[2] = h - g,
        e[5] = p + m,
        e[8] = 1 - c - d,
        e
    }
    function A(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8]
          , d = t[9]
          , h = t[10]
          , p = t[11]
          , f = t[12]
          , m = t[13]
          , g = t[14]
          , v = t[15]
          , b = n * o - i * a
          , y = n * l - r * a
          , S = n * c - s * a
          , w = i * l - r * o
          , x = i * c - s * o
          , C = r * c - s * l
          , O = u * m - d * f
          , k = u * g - h * f
          , E = u * v - p * f
          , T = d * g - h * m
          , M = d * v - p * m
          , D = h * v - p * g
          , L = b * D - y * M + S * T + w * E - x * k + C * O;
        return L ? (L = 1 / L,
        e[0] = (o * D - l * M + c * T) * L,
        e[1] = (l * E - a * D - c * k) * L,
        e[2] = (a * M - o * E + c * O) * L,
        e[3] = (r * M - i * D - s * T) * L,
        e[4] = (n * D - r * E + s * k) * L,
        e[5] = (i * E - n * M - s * O) * L,
        e[6] = (m * C - g * x + v * w) * L,
        e[7] = (g * S - f * C - v * y) * L,
        e[8] = (f * x - m * S + v * b) * L,
        e) : null
    }
    function I(e, t, n) {
        return e[0] = 2 / t,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = -2 / n,
        e[5] = 0,
        e[6] = -1,
        e[7] = 1,
        e[8] = 1,
        e
    }
    function P(e) {
        return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"
    }
    function R(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
    }
    function j(e, t, n) {
        return e[0] = t[0] + n[0],
        e[1] = t[1] + n[1],
        e[2] = t[2] + n[2],
        e[3] = t[3] + n[3],
        e[4] = t[4] + n[4],
        e[5] = t[5] + n[5],
        e[6] = t[6] + n[6],
        e[7] = t[7] + n[7],
        e[8] = t[8] + n[8],
        e
    }
    function N(e, t, n) {
        return e[0] = t[0] - n[0],
        e[1] = t[1] - n[1],
        e[2] = t[2] - n[2],
        e[3] = t[3] - n[3],
        e[4] = t[4] - n[4],
        e[5] = t[5] - n[5],
        e[6] = t[6] - n[6],
        e[7] = t[7] - n[7],
        e[8] = t[8] - n[8],
        e
    }
    function V(e, t, n) {
        return e[0] = t[0] * n,
        e[1] = t[1] * n,
        e[2] = t[2] * n,
        e[3] = t[3] * n,
        e[4] = t[4] * n,
        e[5] = t[5] * n,
        e[6] = t[6] * n,
        e[7] = t[7] * n,
        e[8] = t[8] * n,
        e
    }
    function B(e, t, n, i) {
        return e[0] = t[0] + n[0] * i,
        e[1] = t[1] + n[1] * i,
        e[2] = t[2] + n[2] * i,
        e[3] = t[3] + n[3] * i,
        e[4] = t[4] + n[4] * i,
        e[5] = t[5] + n[5] * i,
        e[6] = t[6] + n[6] * i,
        e[7] = t[7] + n[7] * i,
        e[8] = t[8] + n[8] * i,
        e
    }
    function F(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
    }
    function _(e, t) {
        var n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , a = e[4]
          , o = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = t[0]
          , h = t[1]
          , p = t[2]
          , f = t[3]
          , m = t[4]
          , g = t[5]
          , v = t[6]
          , b = t[7]
          , y = t[8];
        return Math.abs(n - d) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(i - h) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - p) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(s - f) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(a - m) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(o - g) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(l - v) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(v)) && Math.abs(c - b) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(b)) && Math.abs(u - y) <= 1e-6 * Math.max(1, Math.abs(u), Math.abs(y))
    }
    Math.hypot || (Math.hypot = function() {
        for (var e = 0, t = arguments.length; t--; )
            e += arguments[t] * arguments[t];
        return Math.sqrt(e)
    }
    );
    var U = x
      , z = N;
    function G() {
        var e = new c(16);
        return c != Float32Array && (e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0),
        e[0] = 1,
        e[5] = 1,
        e[10] = 1,
        e[15] = 1,
        e
    }
    function $(e) {
        var t = new c(16);
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t[3] = e[3],
        t[4] = e[4],
        t[5] = e[5],
        t[6] = e[6],
        t[7] = e[7],
        t[8] = e[8],
        t[9] = e[9],
        t[10] = e[10],
        t[11] = e[11],
        t[12] = e[12],
        t[13] = e[13],
        t[14] = e[14],
        t[15] = e[15],
        t
    }
    function W(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e[9] = t[9],
        e[10] = t[10],
        e[11] = t[11],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15],
        e
    }
    function H(e, t, n, i, r, s, a, o, l, u, d, h, p, f, m, g) {
        var v = new c(16);
        return v[0] = e,
        v[1] = t,
        v[2] = n,
        v[3] = i,
        v[4] = r,
        v[5] = s,
        v[6] = a,
        v[7] = o,
        v[8] = l,
        v[9] = u,
        v[10] = d,
        v[11] = h,
        v[12] = p,
        v[13] = f,
        v[14] = m,
        v[15] = g,
        v
    }
    function J(e, t, n, i, r, s, a, o, l, c, u, d, h, p, f, m, g) {
        return e[0] = t,
        e[1] = n,
        e[2] = i,
        e[3] = r,
        e[4] = s,
        e[5] = a,
        e[6] = o,
        e[7] = l,
        e[8] = c,
        e[9] = u,
        e[10] = d,
        e[11] = h,
        e[12] = p,
        e[13] = f,
        e[14] = m,
        e[15] = g,
        e
    }
    function q(e) {
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = 1,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = 1,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function Y(e, t) {
        if (e === t) {
            var n = t[1]
              , i = t[2]
              , r = t[3]
              , s = t[6]
              , a = t[7]
              , o = t[11];
            e[1] = t[4],
            e[2] = t[8],
            e[3] = t[12],
            e[4] = n,
            e[6] = t[9],
            e[7] = t[13],
            e[8] = i,
            e[9] = s,
            e[11] = t[14],
            e[12] = r,
            e[13] = a,
            e[14] = o
        } else
            e[0] = t[0],
            e[1] = t[4],
            e[2] = t[8],
            e[3] = t[12],
            e[4] = t[1],
            e[5] = t[5],
            e[6] = t[9],
            e[7] = t[13],
            e[8] = t[2],
            e[9] = t[6],
            e[10] = t[10],
            e[11] = t[14],
            e[12] = t[3],
            e[13] = t[7],
            e[14] = t[11],
            e[15] = t[15];
        return e
    }
    function X(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8]
          , d = t[9]
          , h = t[10]
          , p = t[11]
          , f = t[12]
          , m = t[13]
          , g = t[14]
          , v = t[15]
          , b = n * o - i * a
          , y = n * l - r * a
          , S = n * c - s * a
          , w = i * l - r * o
          , x = i * c - s * o
          , C = r * c - s * l
          , O = u * m - d * f
          , k = u * g - h * f
          , E = u * v - p * f
          , T = d * g - h * m
          , M = d * v - p * m
          , D = h * v - p * g
          , L = b * D - y * M + S * T + w * E - x * k + C * O;
        return L ? (L = 1 / L,
        e[0] = (o * D - l * M + c * T) * L,
        e[1] = (r * M - i * D - s * T) * L,
        e[2] = (m * C - g * x + v * w) * L,
        e[3] = (h * x - d * C - p * w) * L,
        e[4] = (l * E - a * D - c * k) * L,
        e[5] = (n * D - r * E + s * k) * L,
        e[6] = (g * S - f * C - v * y) * L,
        e[7] = (u * C - h * S + p * y) * L,
        e[8] = (a * M - o * E + c * O) * L,
        e[9] = (i * E - n * M - s * O) * L,
        e[10] = (f * x - m * S + v * b) * L,
        e[11] = (d * S - u * x - p * b) * L,
        e[12] = (o * k - a * T - l * O) * L,
        e[13] = (n * T - i * k + r * O) * L,
        e[14] = (m * y - f * w - g * b) * L,
        e[15] = (u * w - d * y + h * b) * L,
        e) : null
    }
    function K(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8]
          , d = t[9]
          , h = t[10]
          , p = t[11]
          , f = t[12]
          , m = t[13]
          , g = t[14]
          , v = t[15];
        return e[0] = o * (h * v - p * g) - d * (l * v - c * g) + m * (l * p - c * h),
        e[1] = -(i * (h * v - p * g) - d * (r * v - s * g) + m * (r * p - s * h)),
        e[2] = i * (l * v - c * g) - o * (r * v - s * g) + m * (r * c - s * l),
        e[3] = -(i * (l * p - c * h) - o * (r * p - s * h) + d * (r * c - s * l)),
        e[4] = -(a * (h * v - p * g) - u * (l * v - c * g) + f * (l * p - c * h)),
        e[5] = n * (h * v - p * g) - u * (r * v - s * g) + f * (r * p - s * h),
        e[6] = -(n * (l * v - c * g) - a * (r * v - s * g) + f * (r * c - s * l)),
        e[7] = n * (l * p - c * h) - a * (r * p - s * h) + u * (r * c - s * l),
        e[8] = a * (d * v - p * m) - u * (o * v - c * m) + f * (o * p - c * d),
        e[9] = -(n * (d * v - p * m) - u * (i * v - s * m) + f * (i * p - s * d)),
        e[10] = n * (o * v - c * m) - a * (i * v - s * m) + f * (i * c - s * o),
        e[11] = -(n * (o * p - c * d) - a * (i * p - s * d) + u * (i * c - s * o)),
        e[12] = -(a * (d * g - h * m) - u * (o * g - l * m) + f * (o * h - l * d)),
        e[13] = n * (d * g - h * m) - u * (i * g - r * m) + f * (i * h - r * d),
        e[14] = -(n * (o * g - l * m) - a * (i * g - r * m) + f * (i * l - r * o)),
        e[15] = n * (o * h - l * d) - a * (i * h - r * d) + u * (i * l - r * o),
        e
    }
    function Z(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , o = e[6]
          , l = e[7]
          , c = e[8]
          , u = e[9]
          , d = e[10]
          , h = e[11]
          , p = e[12]
          , f = e[13]
          , m = e[14]
          , g = e[15];
        return (t * a - n * s) * (d * g - h * m) - (t * o - i * s) * (u * g - h * f) + (t * l - r * s) * (u * m - d * f) + (n * o - i * a) * (c * g - h * p) - (n * l - r * a) * (c * m - d * p) + (i * l - r * o) * (c * f - u * p)
    }
    function Q(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = t[4]
          , l = t[5]
          , c = t[6]
          , u = t[7]
          , d = t[8]
          , h = t[9]
          , p = t[10]
          , f = t[11]
          , m = t[12]
          , g = t[13]
          , v = t[14]
          , b = t[15]
          , y = n[0]
          , S = n[1]
          , w = n[2]
          , x = n[3];
        return e[0] = y * i + S * o + w * d + x * m,
        e[1] = y * r + S * l + w * h + x * g,
        e[2] = y * s + S * c + w * p + x * v,
        e[3] = y * a + S * u + w * f + x * b,
        y = n[4],
        S = n[5],
        w = n[6],
        x = n[7],
        e[4] = y * i + S * o + w * d + x * m,
        e[5] = y * r + S * l + w * h + x * g,
        e[6] = y * s + S * c + w * p + x * v,
        e[7] = y * a + S * u + w * f + x * b,
        y = n[8],
        S = n[9],
        w = n[10],
        x = n[11],
        e[8] = y * i + S * o + w * d + x * m,
        e[9] = y * r + S * l + w * h + x * g,
        e[10] = y * s + S * c + w * p + x * v,
        e[11] = y * a + S * u + w * f + x * b,
        y = n[12],
        S = n[13],
        w = n[14],
        x = n[15],
        e[12] = y * i + S * o + w * d + x * m,
        e[13] = y * r + S * l + w * h + x * g,
        e[14] = y * s + S * c + w * p + x * v,
        e[15] = y * a + S * u + w * f + x * b,
        e
    }
    function ee(e, t, n) {
        var i, r, s, a, o, l, c, u, d, h, p, f, m = n[0], g = n[1], v = n[2];
        return t === e ? (e[12] = t[0] * m + t[4] * g + t[8] * v + t[12],
        e[13] = t[1] * m + t[5] * g + t[9] * v + t[13],
        e[14] = t[2] * m + t[6] * g + t[10] * v + t[14],
        e[15] = t[3] * m + t[7] * g + t[11] * v + t[15]) : (i = t[0],
        r = t[1],
        s = t[2],
        a = t[3],
        o = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        d = t[8],
        h = t[9],
        p = t[10],
        f = t[11],
        e[0] = i,
        e[1] = r,
        e[2] = s,
        e[3] = a,
        e[4] = o,
        e[5] = l,
        e[6] = c,
        e[7] = u,
        e[8] = d,
        e[9] = h,
        e[10] = p,
        e[11] = f,
        e[12] = i * m + o * g + d * v + t[12],
        e[13] = r * m + l * g + h * v + t[13],
        e[14] = s * m + c * g + p * v + t[14],
        e[15] = a * m + u * g + f * v + t[15]),
        e
    }
    function te(e, t, n) {
        var i = n[0]
          , r = n[1]
          , s = n[2];
        return e[0] = t[0] * i,
        e[1] = t[1] * i,
        e[2] = t[2] * i,
        e[3] = t[3] * i,
        e[4] = t[4] * r,
        e[5] = t[5] * r,
        e[6] = t[6] * r,
        e[7] = t[7] * r,
        e[8] = t[8] * s,
        e[9] = t[9] * s,
        e[10] = t[10] * s,
        e[11] = t[11] * s,
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15],
        e
    }
    function ne(e, t, n, i) {
        var r, s, a, o, l, c, u, d, h, p, f, m, g, v, b, y, S, w, x, C, O, k, E, T, M = i[0], D = i[1], L = i[2], A = Math.hypot(M, D, L);
        return A < 1e-6 ? null : (M *= A = 1 / A,
        D *= A,
        L *= A,
        r = Math.sin(n),
        a = 1 - (s = Math.cos(n)),
        o = t[0],
        l = t[1],
        c = t[2],
        u = t[3],
        d = t[4],
        h = t[5],
        p = t[6],
        f = t[7],
        m = t[8],
        g = t[9],
        v = t[10],
        b = t[11],
        y = M * M * a + s,
        S = D * M * a + L * r,
        w = L * M * a - D * r,
        x = M * D * a - L * r,
        C = D * D * a + s,
        O = L * D * a + M * r,
        k = M * L * a + D * r,
        E = D * L * a - M * r,
        T = L * L * a + s,
        e[0] = o * y + d * S + m * w,
        e[1] = l * y + h * S + g * w,
        e[2] = c * y + p * S + v * w,
        e[3] = u * y + f * S + b * w,
        e[4] = o * x + d * C + m * O,
        e[5] = l * x + h * C + g * O,
        e[6] = c * x + p * C + v * O,
        e[7] = u * x + f * C + b * O,
        e[8] = o * k + d * E + m * T,
        e[9] = l * k + h * E + g * T,
        e[10] = c * k + p * E + v * T,
        e[11] = u * k + f * E + b * T,
        t !== e && (e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15]),
        e)
    }
    function ie(e, t, n) {
        var i = Math.sin(n)
          , r = Math.cos(n)
          , s = t[4]
          , a = t[5]
          , o = t[6]
          , l = t[7]
          , c = t[8]
          , u = t[9]
          , d = t[10]
          , h = t[11];
        return t !== e && (e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15]),
        e[4] = s * r + c * i,
        e[5] = a * r + u * i,
        e[6] = o * r + d * i,
        e[7] = l * r + h * i,
        e[8] = c * r - s * i,
        e[9] = u * r - a * i,
        e[10] = d * r - o * i,
        e[11] = h * r - l * i,
        e
    }
    function re(e, t, n) {
        var i = Math.sin(n)
          , r = Math.cos(n)
          , s = t[0]
          , a = t[1]
          , o = t[2]
          , l = t[3]
          , c = t[8]
          , u = t[9]
          , d = t[10]
          , h = t[11];
        return t !== e && (e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15]),
        e[0] = s * r - c * i,
        e[1] = a * r - u * i,
        e[2] = o * r - d * i,
        e[3] = l * r - h * i,
        e[8] = s * i + c * r,
        e[9] = a * i + u * r,
        e[10] = o * i + d * r,
        e[11] = l * i + h * r,
        e
    }
    function se(e, t, n) {
        var i = Math.sin(n)
          , r = Math.cos(n)
          , s = t[0]
          , a = t[1]
          , o = t[2]
          , l = t[3]
          , c = t[4]
          , u = t[5]
          , d = t[6]
          , h = t[7];
        return t !== e && (e[8] = t[8],
        e[9] = t[9],
        e[10] = t[10],
        e[11] = t[11],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15]),
        e[0] = s * r + c * i,
        e[1] = a * r + u * i,
        e[2] = o * r + d * i,
        e[3] = l * r + h * i,
        e[4] = c * r - s * i,
        e[5] = u * r - a * i,
        e[6] = d * r - o * i,
        e[7] = h * r - l * i,
        e
    }
    function ae(e, t) {
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = 1,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = 1,
        e[11] = 0,
        e[12] = t[0],
        e[13] = t[1],
        e[14] = t[2],
        e[15] = 1,
        e
    }
    function oe(e, t) {
        return e[0] = t[0],
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = t[1],
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = t[2],
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function le(e, t, n) {
        var i, r, s, a = n[0], o = n[1], l = n[2], c = Math.hypot(a, o, l);
        return c < 1e-6 ? null : (a *= c = 1 / c,
        o *= c,
        l *= c,
        i = Math.sin(t),
        s = 1 - (r = Math.cos(t)),
        e[0] = a * a * s + r,
        e[1] = o * a * s + l * i,
        e[2] = l * a * s - o * i,
        e[3] = 0,
        e[4] = a * o * s - l * i,
        e[5] = o * o * s + r,
        e[6] = l * o * s + a * i,
        e[7] = 0,
        e[8] = a * l * s + o * i,
        e[9] = o * l * s - a * i,
        e[10] = l * l * s + r,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e)
    }
    function ce(e, t) {
        var n = Math.sin(t)
          , i = Math.cos(t);
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = i,
        e[6] = n,
        e[7] = 0,
        e[8] = 0,
        e[9] = -n,
        e[10] = i,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function ue(e, t) {
        var n = Math.sin(t)
          , i = Math.cos(t);
        return e[0] = i,
        e[1] = 0,
        e[2] = -n,
        e[3] = 0,
        e[4] = 0,
        e[5] = 1,
        e[6] = 0,
        e[7] = 0,
        e[8] = n,
        e[9] = 0,
        e[10] = i,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function de(e, t) {
        var n = Math.sin(t)
          , i = Math.cos(t);
        return e[0] = i,
        e[1] = n,
        e[2] = 0,
        e[3] = 0,
        e[4] = -n,
        e[5] = i,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = 1,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function he(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = i + i
          , l = r + r
          , c = s + s
          , u = i * o
          , d = i * l
          , h = i * c
          , p = r * l
          , f = r * c
          , m = s * c
          , g = a * o
          , v = a * l
          , b = a * c;
        return e[0] = 1 - (p + m),
        e[1] = d + b,
        e[2] = h - v,
        e[3] = 0,
        e[4] = d - b,
        e[5] = 1 - (u + m),
        e[6] = f + g,
        e[7] = 0,
        e[8] = h + v,
        e[9] = f - g,
        e[10] = 1 - (u + p),
        e[11] = 0,
        e[12] = n[0],
        e[13] = n[1],
        e[14] = n[2],
        e[15] = 1,
        e
    }
    function pe(e, t) {
        var n = new c(3)
          , i = -t[0]
          , r = -t[1]
          , s = -t[2]
          , a = t[3]
          , o = t[4]
          , l = t[5]
          , u = t[6]
          , d = t[7]
          , h = i * i + r * r + s * s + a * a;
        return h > 0 ? (n[0] = 2 * (o * a + d * i + l * s - u * r) / h,
        n[1] = 2 * (l * a + d * r + u * i - o * s) / h,
        n[2] = 2 * (u * a + d * s + o * r - l * i) / h) : (n[0] = 2 * (o * a + d * i + l * s - u * r),
        n[1] = 2 * (l * a + d * r + u * i - o * s),
        n[2] = 2 * (u * a + d * s + o * r - l * i)),
        he(e, t, n),
        e
    }
    function fe(e, t) {
        return e[0] = t[12],
        e[1] = t[13],
        e[2] = t[14],
        e
    }
    function me(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[4]
          , a = t[5]
          , o = t[6]
          , l = t[8]
          , c = t[9]
          , u = t[10];
        return e[0] = Math.hypot(n, i, r),
        e[1] = Math.hypot(s, a, o),
        e[2] = Math.hypot(l, c, u),
        e
    }
    function ge(e, t) {
        var n = new c(3);
        me(n, t);
        var i = 1 / n[0]
          , r = 1 / n[1]
          , s = 1 / n[2]
          , a = t[0] * i
          , o = t[1] * r
          , l = t[2] * s
          , u = t[4] * i
          , d = t[5] * r
          , h = t[6] * s
          , p = t[8] * i
          , f = t[9] * r
          , m = t[10] * s
          , g = a + d + m
          , v = 0;
        return g > 0 ? (v = 2 * Math.sqrt(g + 1),
        e[3] = .25 * v,
        e[0] = (h - f) / v,
        e[1] = (p - l) / v,
        e[2] = (o - u) / v) : a > d && a > m ? (v = 2 * Math.sqrt(1 + a - d - m),
        e[3] = (h - f) / v,
        e[0] = .25 * v,
        e[1] = (o + u) / v,
        e[2] = (p + l) / v) : d > m ? (v = 2 * Math.sqrt(1 + d - a - m),
        e[3] = (p - l) / v,
        e[0] = (o + u) / v,
        e[1] = .25 * v,
        e[2] = (h + f) / v) : (v = 2 * Math.sqrt(1 + m - a - d),
        e[3] = (o - u) / v,
        e[0] = (p + l) / v,
        e[1] = (h + f) / v,
        e[2] = .25 * v),
        e
    }
    function ve(e, t, n, i) {
        var r = t[0]
          , s = t[1]
          , a = t[2]
          , o = t[3]
          , l = r + r
          , c = s + s
          , u = a + a
          , d = r * l
          , h = r * c
          , p = r * u
          , f = s * c
          , m = s * u
          , g = a * u
          , v = o * l
          , b = o * c
          , y = o * u
          , S = i[0]
          , w = i[1]
          , x = i[2];
        return e[0] = (1 - (f + g)) * S,
        e[1] = (h + y) * S,
        e[2] = (p - b) * S,
        e[3] = 0,
        e[4] = (h - y) * w,
        e[5] = (1 - (d + g)) * w,
        e[6] = (m + v) * w,
        e[7] = 0,
        e[8] = (p + b) * x,
        e[9] = (m - v) * x,
        e[10] = (1 - (d + f)) * x,
        e[11] = 0,
        e[12] = n[0],
        e[13] = n[1],
        e[14] = n[2],
        e[15] = 1,
        e
    }
    function be(e, t, n, i, r) {
        var s = t[0]
          , a = t[1]
          , o = t[2]
          , l = t[3]
          , c = s + s
          , u = a + a
          , d = o + o
          , h = s * c
          , p = s * u
          , f = s * d
          , m = a * u
          , g = a * d
          , v = o * d
          , b = l * c
          , y = l * u
          , S = l * d
          , w = i[0]
          , x = i[1]
          , C = i[2]
          , O = r[0]
          , k = r[1]
          , E = r[2]
          , T = (1 - (m + v)) * w
          , M = (p + S) * w
          , D = (f - y) * w
          , L = (p - S) * x
          , A = (1 - (h + v)) * x
          , I = (g + b) * x
          , P = (f + y) * C
          , R = (g - b) * C
          , j = (1 - (h + m)) * C;
        return e[0] = T,
        e[1] = M,
        e[2] = D,
        e[3] = 0,
        e[4] = L,
        e[5] = A,
        e[6] = I,
        e[7] = 0,
        e[8] = P,
        e[9] = R,
        e[10] = j,
        e[11] = 0,
        e[12] = n[0] + O - (T * O + L * k + P * E),
        e[13] = n[1] + k - (M * O + A * k + R * E),
        e[14] = n[2] + E - (D * O + I * k + j * E),
        e[15] = 1,
        e
    }
    function ye(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = n + n
          , o = i + i
          , l = r + r
          , c = n * a
          , u = i * a
          , d = i * o
          , h = r * a
          , p = r * o
          , f = r * l
          , m = s * a
          , g = s * o
          , v = s * l;
        return e[0] = 1 - d - f,
        e[1] = u + v,
        e[2] = h - g,
        e[3] = 0,
        e[4] = u - v,
        e[5] = 1 - c - f,
        e[6] = p + m,
        e[7] = 0,
        e[8] = h + g,
        e[9] = p - m,
        e[10] = 1 - c - d,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        e
    }
    function Se(e, t, n, i, r, s, a) {
        var o = 1 / (n - t)
          , l = 1 / (r - i)
          , c = 1 / (s - a);
        return e[0] = 2 * s * o,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = 2 * s * l,
        e[6] = 0,
        e[7] = 0,
        e[8] = (n + t) * o,
        e[9] = (r + i) * l,
        e[10] = (a + s) * c,
        e[11] = -1,
        e[12] = 0,
        e[13] = 0,
        e[14] = a * s * 2 * c,
        e[15] = 0,
        e
    }
    function we(e, t, n, i, r) {
        var s, a = 1 / Math.tan(t / 2);
        return e[0] = a / n,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = a,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[11] = -1,
        e[12] = 0,
        e[13] = 0,
        e[15] = 0,
        null != r && r !== 1 / 0 ? (s = 1 / (i - r),
        e[10] = (r + i) * s,
        e[14] = 2 * r * i * s) : (e[10] = -1,
        e[14] = -2 * i),
        e
    }
    function xe(e, t, n, i) {
        var r = Math.tan(t.upDegrees * Math.PI / 180)
          , s = Math.tan(t.downDegrees * Math.PI / 180)
          , a = Math.tan(t.leftDegrees * Math.PI / 180)
          , o = Math.tan(t.rightDegrees * Math.PI / 180)
          , l = 2 / (a + o)
          , c = 2 / (r + s);
        return e[0] = l,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = c,
        e[6] = 0,
        e[7] = 0,
        e[8] = -(a - o) * l * .5,
        e[9] = (r - s) * c * .5,
        e[10] = i / (n - i),
        e[11] = -1,
        e[12] = 0,
        e[13] = 0,
        e[14] = i * n / (n - i),
        e[15] = 0,
        e
    }
    function Ce(e, t, n, i, r, s, a) {
        var o = 1 / (t - n)
          , l = 1 / (i - r)
          , c = 1 / (s - a);
        return e[0] = -2 * o,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = -2 * l,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = 2 * c,
        e[11] = 0,
        e[12] = (t + n) * o,
        e[13] = (r + i) * l,
        e[14] = (a + s) * c,
        e[15] = 1,
        e
    }
    function Oe(e, t, n, i) {
        var r, s, a, o, l, c, u, d, h, p, f = t[0], m = t[1], g = t[2], v = i[0], b = i[1], y = i[2], S = n[0], w = n[1], x = n[2];
        return Math.abs(f - S) < 1e-6 && Math.abs(m - w) < 1e-6 && Math.abs(g - x) < 1e-6 ? q(e) : (u = f - S,
        d = m - w,
        h = g - x,
        r = b * (h *= p = 1 / Math.hypot(u, d, h)) - y * (d *= p),
        s = y * (u *= p) - v * h,
        a = v * d - b * u,
        (p = Math.hypot(r, s, a)) ? (r *= p = 1 / p,
        s *= p,
        a *= p) : (r = 0,
        s = 0,
        a = 0),
        o = d * a - h * s,
        l = h * r - u * a,
        c = u * s - d * r,
        (p = Math.hypot(o, l, c)) ? (o *= p = 1 / p,
        l *= p,
        c *= p) : (o = 0,
        l = 0,
        c = 0),
        e[0] = r,
        e[1] = o,
        e[2] = u,
        e[3] = 0,
        e[4] = s,
        e[5] = l,
        e[6] = d,
        e[7] = 0,
        e[8] = a,
        e[9] = c,
        e[10] = h,
        e[11] = 0,
        e[12] = -(r * f + s * m + a * g),
        e[13] = -(o * f + l * m + c * g),
        e[14] = -(u * f + d * m + h * g),
        e[15] = 1,
        e)
    }
    function ke(e, t, n, i) {
        var r = t[0]
          , s = t[1]
          , a = t[2]
          , o = i[0]
          , l = i[1]
          , c = i[2]
          , u = r - n[0]
          , d = s - n[1]
          , h = a - n[2]
          , p = u * u + d * d + h * h;
        p > 0 && (u *= p = 1 / Math.sqrt(p),
        d *= p,
        h *= p);
        var f = l * h - c * d
          , m = c * u - o * h
          , g = o * d - l * u;
        return (p = f * f + m * m + g * g) > 0 && (f *= p = 1 / Math.sqrt(p),
        m *= p,
        g *= p),
        e[0] = f,
        e[1] = m,
        e[2] = g,
        e[3] = 0,
        e[4] = d * g - h * m,
        e[5] = h * f - u * g,
        e[6] = u * m - d * f,
        e[7] = 0,
        e[8] = u,
        e[9] = d,
        e[10] = h,
        e[11] = 0,
        e[12] = r,
        e[13] = s,
        e[14] = a,
        e[15] = 1,
        e
    }
    function Ee(e) {
        return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"
    }
    function Te(e) {
        return Math.hypot(e[0], e[1], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
    }
    function Me(e, t, n) {
        return e[0] = t[0] + n[0],
        e[1] = t[1] + n[1],
        e[2] = t[2] + n[2],
        e[3] = t[3] + n[3],
        e[4] = t[4] + n[4],
        e[5] = t[5] + n[5],
        e[6] = t[6] + n[6],
        e[7] = t[7] + n[7],
        e[8] = t[8] + n[8],
        e[9] = t[9] + n[9],
        e[10] = t[10] + n[10],
        e[11] = t[11] + n[11],
        e[12] = t[12] + n[12],
        e[13] = t[13] + n[13],
        e[14] = t[14] + n[14],
        e[15] = t[15] + n[15],
        e
    }
    function De(e, t, n) {
        return e[0] = t[0] - n[0],
        e[1] = t[1] - n[1],
        e[2] = t[2] - n[2],
        e[3] = t[3] - n[3],
        e[4] = t[4] - n[4],
        e[5] = t[5] - n[5],
        e[6] = t[6] - n[6],
        e[7] = t[7] - n[7],
        e[8] = t[8] - n[8],
        e[9] = t[9] - n[9],
        e[10] = t[10] - n[10],
        e[11] = t[11] - n[11],
        e[12] = t[12] - n[12],
        e[13] = t[13] - n[13],
        e[14] = t[14] - n[14],
        e[15] = t[15] - n[15],
        e
    }
    function Le(e, t, n) {
        return e[0] = t[0] * n,
        e[1] = t[1] * n,
        e[2] = t[2] * n,
        e[3] = t[3] * n,
        e[4] = t[4] * n,
        e[5] = t[5] * n,
        e[6] = t[6] * n,
        e[7] = t[7] * n,
        e[8] = t[8] * n,
        e[9] = t[9] * n,
        e[10] = t[10] * n,
        e[11] = t[11] * n,
        e[12] = t[12] * n,
        e[13] = t[13] * n,
        e[14] = t[14] * n,
        e[15] = t[15] * n,
        e
    }
    function Ae(e, t, n, i) {
        return e[0] = t[0] + n[0] * i,
        e[1] = t[1] + n[1] * i,
        e[2] = t[2] + n[2] * i,
        e[3] = t[3] + n[3] * i,
        e[4] = t[4] + n[4] * i,
        e[5] = t[5] + n[5] * i,
        e[6] = t[6] + n[6] * i,
        e[7] = t[7] + n[7] * i,
        e[8] = t[8] + n[8] * i,
        e[9] = t[9] + n[9] * i,
        e[10] = t[10] + n[10] * i,
        e[11] = t[11] + n[11] * i,
        e[12] = t[12] + n[12] * i,
        e[13] = t[13] + n[13] * i,
        e[14] = t[14] + n[14] * i,
        e[15] = t[15] + n[15] * i,
        e
    }
    function Ie(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }
    function Pe(e, t) {
        var n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , a = e[4]
          , o = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = e[9]
          , h = e[10]
          , p = e[11]
          , f = e[12]
          , m = e[13]
          , g = e[14]
          , v = e[15]
          , b = t[0]
          , y = t[1]
          , S = t[2]
          , w = t[3]
          , x = t[4]
          , C = t[5]
          , O = t[6]
          , k = t[7]
          , E = t[8]
          , T = t[9]
          , M = t[10]
          , D = t[11]
          , L = t[12]
          , A = t[13]
          , I = t[14]
          , P = t[15];
        return Math.abs(n - b) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(i - y) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(y)) && Math.abs(r - S) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(S)) && Math.abs(s - w) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(a - x) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(x)) && Math.abs(o - C) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(C)) && Math.abs(l - O) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(O)) && Math.abs(c - k) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(k)) && Math.abs(u - E) <= 1e-6 * Math.max(1, Math.abs(u), Math.abs(E)) && Math.abs(d - T) <= 1e-6 * Math.max(1, Math.abs(d), Math.abs(T)) && Math.abs(h - M) <= 1e-6 * Math.max(1, Math.abs(h), Math.abs(M)) && Math.abs(p - D) <= 1e-6 * Math.max(1, Math.abs(p), Math.abs(D)) && Math.abs(f - L) <= 1e-6 * Math.max(1, Math.abs(f), Math.abs(L)) && Math.abs(m - A) <= 1e-6 * Math.max(1, Math.abs(m), Math.abs(A)) && Math.abs(g - I) <= 1e-6 * Math.max(1, Math.abs(g), Math.abs(I)) && Math.abs(v - P) <= 1e-6 * Math.max(1, Math.abs(v), Math.abs(P))
    }
    var Re = Q
      , je = De;
    function Ne() {
        var e = new c(3);
        return c != Float32Array && (e[0] = 0,
        e[1] = 0,
        e[2] = 0),
        e
    }
    function Ve(e) {
        var t = new c(3);
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t
    }
    function Be(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2];
        return Math.hypot(t, n, i)
    }
    function Fe(e, t, n) {
        var i = new c(3);
        return i[0] = e,
        i[1] = t,
        i[2] = n,
        i
    }
    function _e(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e
    }
    function Ue(e, t, n, i) {
        return e[0] = t,
        e[1] = n,
        e[2] = i,
        e
    }
    function ze(e, t, n) {
        return e[0] = t[0] + n[0],
        e[1] = t[1] + n[1],
        e[2] = t[2] + n[2],
        e
    }
    function Ge(e, t, n) {
        return e[0] = t[0] - n[0],
        e[1] = t[1] - n[1],
        e[2] = t[2] - n[2],
        e
    }
    function $e(e, t, n) {
        return e[0] = t[0] * n[0],
        e[1] = t[1] * n[1],
        e[2] = t[2] * n[2],
        e
    }
    function We(e, t, n) {
        return e[0] = t[0] / n[0],
        e[1] = t[1] / n[1],
        e[2] = t[2] / n[2],
        e
    }
    function He(e, t) {
        return e[0] = Math.ceil(t[0]),
        e[1] = Math.ceil(t[1]),
        e[2] = Math.ceil(t[2]),
        e
    }
    function Je(e, t) {
        return e[0] = Math.floor(t[0]),
        e[1] = Math.floor(t[1]),
        e[2] = Math.floor(t[2]),
        e
    }
    function qe(e, t, n) {
        return e[0] = Math.min(t[0], n[0]),
        e[1] = Math.min(t[1], n[1]),
        e[2] = Math.min(t[2], n[2]),
        e
    }
    function Ye(e, t, n) {
        return e[0] = Math.max(t[0], n[0]),
        e[1] = Math.max(t[1], n[1]),
        e[2] = Math.max(t[2], n[2]),
        e
    }
    function Xe(e, t) {
        return e[0] = Math.round(t[0]),
        e[1] = Math.round(t[1]),
        e[2] = Math.round(t[2]),
        e
    }
    function Ke(e, t, n) {
        return e[0] = t[0] * n,
        e[1] = t[1] * n,
        e[2] = t[2] * n,
        e
    }
    function Ze(e, t, n, i) {
        return e[0] = t[0] + n[0] * i,
        e[1] = t[1] + n[1] * i,
        e[2] = t[2] + n[2] * i,
        e
    }
    function Qe(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1]
          , r = t[2] - e[2];
        return Math.hypot(n, i, r)
    }
    function et(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1]
          , r = t[2] - e[2];
        return n * n + i * i + r * r
    }
    function tt(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2];
        return t * t + n * n + i * i
    }
    function nt(e, t) {
        return e[0] = -t[0],
        e[1] = -t[1],
        e[2] = -t[2],
        e
    }
    function it(e, t) {
        return e[0] = 1 / t[0],
        e[1] = 1 / t[1],
        e[2] = 1 / t[2],
        e
    }
    function rt(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = n * n + i * i + r * r;
        return s > 0 && (s = 1 / Math.sqrt(s)),
        e[0] = t[0] * s,
        e[1] = t[1] * s,
        e[2] = t[2] * s,
        e
    }
    function st(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
    }
    function at(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = n[0]
          , o = n[1]
          , l = n[2];
        return e[0] = r * l - s * o,
        e[1] = s * a - i * l,
        e[2] = i * o - r * a,
        e
    }
    function ot(e, t, n, i) {
        var r = t[0]
          , s = t[1]
          , a = t[2];
        return e[0] = r + i * (n[0] - r),
        e[1] = s + i * (n[1] - s),
        e[2] = a + i * (n[2] - a),
        e
    }
    function lt(e, t, n, i, r, s) {
        var a = s * s
          , o = a * (2 * s - 3) + 1
          , l = a * (s - 2) + s
          , c = a * (s - 1)
          , u = a * (3 - 2 * s);
        return e[0] = t[0] * o + n[0] * l + i[0] * c + r[0] * u,
        e[1] = t[1] * o + n[1] * l + i[1] * c + r[1] * u,
        e[2] = t[2] * o + n[2] * l + i[2] * c + r[2] * u,
        e
    }
    function ct(e, t, n, i, r, s) {
        var a = 1 - s
          , o = a * a
          , l = s * s
          , c = o * a
          , u = 3 * s * o
          , d = 3 * l * a
          , h = l * s;
        return e[0] = t[0] * c + n[0] * u + i[0] * d + r[0] * h,
        e[1] = t[1] * c + n[1] * u + i[1] * d + r[1] * h,
        e[2] = t[2] * c + n[2] * u + i[2] * d + r[2] * h,
        e
    }
    function ut(e, t) {
        t = t || 1;
        var n = 2 * u() * Math.PI
          , i = 2 * u() - 1
          , r = Math.sqrt(1 - i * i) * t;
        return e[0] = Math.cos(n) * r,
        e[1] = Math.sin(n) * r,
        e[2] = i * t,
        e
    }
    function dt(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = n[3] * i + n[7] * r + n[11] * s + n[15];
        return a = a || 1,
        e[0] = (n[0] * i + n[4] * r + n[8] * s + n[12]) / a,
        e[1] = (n[1] * i + n[5] * r + n[9] * s + n[13]) / a,
        e[2] = (n[2] * i + n[6] * r + n[10] * s + n[14]) / a,
        e
    }
    function ht(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2];
        return e[0] = i * n[0] + r * n[3] + s * n[6],
        e[1] = i * n[1] + r * n[4] + s * n[7],
        e[2] = i * n[2] + r * n[5] + s * n[8],
        e
    }
    function pt(e, t, n) {
        var i = n[0]
          , r = n[1]
          , s = n[2]
          , a = n[3]
          , o = t[0]
          , l = t[1]
          , c = t[2]
          , u = r * c - s * l
          , d = s * o - i * c
          , h = i * l - r * o
          , p = r * h - s * d
          , f = s * u - i * h
          , m = i * d - r * u
          , g = 2 * a;
        return u *= g,
        d *= g,
        h *= g,
        p *= 2,
        f *= 2,
        m *= 2,
        e[0] = o + u + p,
        e[1] = l + d + f,
        e[2] = c + h + m,
        e
    }
    function ft(e, t, n, i) {
        var r = []
          , s = [];
        return r[0] = t[0] - n[0],
        r[1] = t[1] - n[1],
        r[2] = t[2] - n[2],
        s[0] = r[0],
        s[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i),
        s[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i),
        e[0] = s[0] + n[0],
        e[1] = s[1] + n[1],
        e[2] = s[2] + n[2],
        e
    }
    function mt(e, t, n, i) {
        var r = []
          , s = [];
        return r[0] = t[0] - n[0],
        r[1] = t[1] - n[1],
        r[2] = t[2] - n[2],
        s[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i),
        s[1] = r[1],
        s[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i),
        e[0] = s[0] + n[0],
        e[1] = s[1] + n[1],
        e[2] = s[2] + n[2],
        e
    }
    function gt(e, t, n, i) {
        var r = []
          , s = [];
        return r[0] = t[0] - n[0],
        r[1] = t[1] - n[1],
        r[2] = t[2] - n[2],
        s[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i),
        s[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i),
        s[2] = r[2],
        e[0] = s[0] + n[0],
        e[1] = s[1] + n[1],
        e[2] = s[2] + n[2],
        e
    }
    function vt(e, t) {
        var n = Fe(e[0], e[1], e[2])
          , i = Fe(t[0], t[1], t[2]);
        rt(n, n),
        rt(i, i);
        var r = st(n, i);
        return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r)
    }
    function bt(e) {
        return e[0] = 0,
        e[1] = 0,
        e[2] = 0,
        e
    }
    function yt(e) {
        return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
    }
    function St(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
    }
    function wt(e, t) {
        var n = e[0]
          , i = e[1]
          , r = e[2]
          , s = t[0]
          , a = t[1]
          , o = t[2];
        return Math.abs(n - s) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - a) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - o) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(o))
    }
    var xt, Ct = Ge, Ot = $e, kt = We, Et = Qe, Tt = et, Mt = Be, Dt = tt, Lt = (xt = Ne(),
    function(e, t, n, i, r, s) {
        var a, o;
        for (t || (t = 3),
        n || (n = 0),
        o = i ? Math.min(i * t + n, e.length) : e.length,
        a = n; a < o; a += t)
            xt[0] = e[a],
            xt[1] = e[a + 1],
            xt[2] = e[a + 2],
            r(xt, xt, s),
            e[a] = xt[0],
            e[a + 1] = xt[1],
            e[a + 2] = xt[2];
        return e
    }
    );
    function At() {
        var e = new c(4);
        return c != Float32Array && (e[0] = 0,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0),
        e
    }
    function It(e) {
        var t = new c(4);
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t[3] = e[3],
        t
    }
    function Pt(e, t, n, i) {
        var r = new c(4);
        return r[0] = e,
        r[1] = t,
        r[2] = n,
        r[3] = i,
        r
    }
    function Rt(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e
    }
    function jt(e, t, n, i, r) {
        return e[0] = t,
        e[1] = n,
        e[2] = i,
        e[3] = r,
        e
    }
    function Nt(e, t, n) {
        return e[0] = t[0] + n[0],
        e[1] = t[1] + n[1],
        e[2] = t[2] + n[2],
        e[3] = t[3] + n[3],
        e
    }
    function Vt(e, t, n) {
        return e[0] = t[0] - n[0],
        e[1] = t[1] - n[1],
        e[2] = t[2] - n[2],
        e[3] = t[3] - n[3],
        e
    }
    function Bt(e, t, n) {
        return e[0] = t[0] * n[0],
        e[1] = t[1] * n[1],
        e[2] = t[2] * n[2],
        e[3] = t[3] * n[3],
        e
    }
    function Ft(e, t, n) {
        return e[0] = t[0] / n[0],
        e[1] = t[1] / n[1],
        e[2] = t[2] / n[2],
        e[3] = t[3] / n[3],
        e
    }
    function _t(e, t) {
        return e[0] = Math.ceil(t[0]),
        e[1] = Math.ceil(t[1]),
        e[2] = Math.ceil(t[2]),
        e[3] = Math.ceil(t[3]),
        e
    }
    function Ut(e, t) {
        return e[0] = Math.floor(t[0]),
        e[1] = Math.floor(t[1]),
        e[2] = Math.floor(t[2]),
        e[3] = Math.floor(t[3]),
        e
    }
    function zt(e, t, n) {
        return e[0] = Math.min(t[0], n[0]),
        e[1] = Math.min(t[1], n[1]),
        e[2] = Math.min(t[2], n[2]),
        e[3] = Math.min(t[3], n[3]),
        e
    }
    function Gt(e, t, n) {
        return e[0] = Math.max(t[0], n[0]),
        e[1] = Math.max(t[1], n[1]),
        e[2] = Math.max(t[2], n[2]),
        e[3] = Math.max(t[3], n[3]),
        e
    }
    function $t(e, t) {
        return e[0] = Math.round(t[0]),
        e[1] = Math.round(t[1]),
        e[2] = Math.round(t[2]),
        e[3] = Math.round(t[3]),
        e
    }
    function Wt(e, t, n) {
        return e[0] = t[0] * n,
        e[1] = t[1] * n,
        e[2] = t[2] * n,
        e[3] = t[3] * n,
        e
    }
    function Ht(e, t, n, i) {
        return e[0] = t[0] + n[0] * i,
        e[1] = t[1] + n[1] * i,
        e[2] = t[2] + n[2] * i,
        e[3] = t[3] + n[3] * i,
        e
    }
    function Jt(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1]
          , r = t[2] - e[2]
          , s = t[3] - e[3];
        return Math.hypot(n, i, r, s)
    }
    function qt(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1]
          , r = t[2] - e[2]
          , s = t[3] - e[3];
        return n * n + i * i + r * r + s * s
    }
    function Yt(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3];
        return Math.hypot(t, n, i, r)
    }
    function Xt(e) {
        var t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3];
        return t * t + n * n + i * i + r * r
    }
    function Kt(e, t) {
        return e[0] = -t[0],
        e[1] = -t[1],
        e[2] = -t[2],
        e[3] = -t[3],
        e
    }
    function Zt(e, t) {
        return e[0] = 1 / t[0],
        e[1] = 1 / t[1],
        e[2] = 1 / t[2],
        e[3] = 1 / t[3],
        e
    }
    function Qt(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = n * n + i * i + r * r + s * s;
        return a > 0 && (a = 1 / Math.sqrt(a)),
        e[0] = n * a,
        e[1] = i * a,
        e[2] = r * a,
        e[3] = s * a,
        e
    }
    function en(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
    }
    function tn(e, t, n, i) {
        var r = n[0] * i[1] - n[1] * i[0]
          , s = n[0] * i[2] - n[2] * i[0]
          , a = n[0] * i[3] - n[3] * i[0]
          , o = n[1] * i[2] - n[2] * i[1]
          , l = n[1] * i[3] - n[3] * i[1]
          , c = n[2] * i[3] - n[3] * i[2]
          , u = t[0]
          , d = t[1]
          , h = t[2]
          , p = t[3];
        return e[0] = d * c - h * l + p * o,
        e[1] = -u * c + h * a - p * s,
        e[2] = u * l - d * a + p * r,
        e[3] = -u * o + d * s - h * r,
        e
    }
    function nn(e, t, n, i) {
        var r = t[0]
          , s = t[1]
          , a = t[2]
          , o = t[3];
        return e[0] = r + i * (n[0] - r),
        e[1] = s + i * (n[1] - s),
        e[2] = a + i * (n[2] - a),
        e[3] = o + i * (n[3] - o),
        e
    }
    function rn(e, t) {
        var n, i, r, s, a, o;
        t = t || 1;
        do {
            a = (n = 2 * u() - 1) * n + (i = 2 * u() - 1) * i
        } while (a >= 1);do {
            o = (r = 2 * u() - 1) * r + (s = 2 * u() - 1) * s
        } while (o >= 1);var l = Math.sqrt((1 - a) / o);
        return e[0] = t * n,
        e[1] = t * i,
        e[2] = t * r * l,
        e[3] = t * s * l,
        e
    }
    function sn(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3];
        return e[0] = n[0] * i + n[4] * r + n[8] * s + n[12] * a,
        e[1] = n[1] * i + n[5] * r + n[9] * s + n[13] * a,
        e[2] = n[2] * i + n[6] * r + n[10] * s + n[14] * a,
        e[3] = n[3] * i + n[7] * r + n[11] * s + n[15] * a,
        e
    }
    function an(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = n[0]
          , o = n[1]
          , l = n[2]
          , c = n[3]
          , u = c * i + o * s - l * r
          , d = c * r + l * i - a * s
          , h = c * s + a * r - o * i
          , p = -a * i - o * r - l * s;
        return e[0] = u * c + p * -a + d * -l - h * -o,
        e[1] = d * c + p * -o + h * -a - u * -l,
        e[2] = h * c + p * -l + u * -o - d * -a,
        e[3] = t[3],
        e
    }
    function on(e) {
        return e[0] = 0,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e
    }
    function ln(e) {
        return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }
    function cn(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
    }
    function un(e, t) {
        var n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , a = t[0]
          , o = t[1]
          , l = t[2]
          , c = t[3];
        return Math.abs(n - a) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(r - l) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(s - c) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(c))
    }
    var dn = Vt
      , hn = Bt
      , pn = Ft
      , fn = Jt
      , mn = qt
      , gn = Yt
      , vn = Xt
      , bn = function() {
        var e = At();
        return function(t, n, i, r, s, a) {
            var o, l;
            for (n || (n = 4),
            i || (i = 0),
            l = r ? Math.min(r * n + i, t.length) : t.length,
            o = i; o < l; o += n)
                e[0] = t[o],
                e[1] = t[o + 1],
                e[2] = t[o + 2],
                e[3] = t[o + 3],
                s(e, e, a),
                t[o] = e[0],
                t[o + 1] = e[1],
                t[o + 2] = e[2],
                t[o + 3] = e[3];
            return t
        }
    }();
    function yn() {
        var e = new c(4);
        return c != Float32Array && (e[0] = 0,
        e[1] = 0,
        e[2] = 0),
        e[3] = 1,
        e
    }
    function Sn(e) {
        return e[0] = 0,
        e[1] = 0,
        e[2] = 0,
        e[3] = 1,
        e
    }
    function wn(e, t, n) {
        n *= .5;
        var i = Math.sin(n);
        return e[0] = i * t[0],
        e[1] = i * t[1],
        e[2] = i * t[2],
        e[3] = Math.cos(n),
        e
    }
    function xn(e, t) {
        var n = 2 * Math.acos(t[3])
          , i = Math.sin(n / 2);
        return i > 1e-6 ? (e[0] = t[0] / i,
        e[1] = t[1] / i,
        e[2] = t[2] / i) : (e[0] = 1,
        e[1] = 0,
        e[2] = 0),
        n
    }
    function Cn(e, t) {
        var n = Zn(e, t);
        return Math.acos(2 * n * n - 1)
    }
    function On(e, t, n) {
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = n[0]
          , l = n[1]
          , c = n[2]
          , u = n[3];
        return e[0] = i * u + a * o + r * c - s * l,
        e[1] = r * u + a * l + s * o - i * c,
        e[2] = s * u + a * c + i * l - r * o,
        e[3] = a * u - i * o - r * l - s * c,
        e
    }
    function kn(e, t, n) {
        n *= .5;
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = Math.sin(n)
          , l = Math.cos(n);
        return e[0] = i * l + a * o,
        e[1] = r * l + s * o,
        e[2] = s * l - r * o,
        e[3] = a * l - i * o,
        e
    }
    function En(e, t, n) {
        n *= .5;
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = Math.sin(n)
          , l = Math.cos(n);
        return e[0] = i * l - s * o,
        e[1] = r * l + a * o,
        e[2] = s * l + i * o,
        e[3] = a * l - r * o,
        e
    }
    function Tn(e, t, n) {
        n *= .5;
        var i = t[0]
          , r = t[1]
          , s = t[2]
          , a = t[3]
          , o = Math.sin(n)
          , l = Math.cos(n);
        return e[0] = i * l + r * o,
        e[1] = r * l - i * o,
        e[2] = s * l + a * o,
        e[3] = a * l - s * o,
        e
    }
    function Mn(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2];
        return e[0] = n,
        e[1] = i,
        e[2] = r,
        e[3] = Math.sqrt(Math.abs(1 - n * n - i * i - r * r)),
        e
    }
    function Dn(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = Math.sqrt(n * n + i * i + r * r)
          , o = Math.exp(s)
          , l = a > 0 ? o * Math.sin(a) / a : 0;
        return e[0] = n * l,
        e[1] = i * l,
        e[2] = r * l,
        e[3] = o * Math.cos(a),
        e
    }
    function Ln(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = Math.sqrt(n * n + i * i + r * r)
          , o = a > 0 ? Math.atan2(a, s) / a : 0;
        return e[0] = n * o,
        e[1] = i * o,
        e[2] = r * o,
        e[3] = .5 * Math.log(n * n + i * i + r * r + s * s),
        e
    }
    function An(e, t, n) {
        return Ln(e, t),
        Kn(e, e, n),
        Dn(e, e),
        e
    }
    function In(e, t, n, i) {
        var r, s, a, o, l, c = t[0], u = t[1], d = t[2], h = t[3], p = n[0], f = n[1], m = n[2], g = n[3];
        return (s = c * p + u * f + d * m + h * g) < 0 && (s = -s,
        p = -p,
        f = -f,
        m = -m,
        g = -g),
        1 - s > 1e-6 ? (r = Math.acos(s),
        a = Math.sin(r),
        o = Math.sin((1 - i) * r) / a,
        l = Math.sin(i * r) / a) : (o = 1 - i,
        l = i),
        e[0] = o * c + l * p,
        e[1] = o * u + l * f,
        e[2] = o * d + l * m,
        e[3] = o * h + l * g,
        e
    }
    function Pn(e) {
        var t = u()
          , n = u()
          , i = u()
          , r = Math.sqrt(1 - t)
          , s = Math.sqrt(t);
        return e[0] = r * Math.sin(2 * Math.PI * n),
        e[1] = r * Math.cos(2 * Math.PI * n),
        e[2] = s * Math.sin(2 * Math.PI * i),
        e[3] = s * Math.cos(2 * Math.PI * i),
        e
    }
    function Rn(e, t) {
        var n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = n * n + i * i + r * r + s * s
          , o = a ? 1 / a : 0;
        return e[0] = -n * o,
        e[1] = -i * o,
        e[2] = -r * o,
        e[3] = s * o,
        e
    }
    function jn(e, t) {
        return e[0] = -t[0],
        e[1] = -t[1],
        e[2] = -t[2],
        e[3] = t[3],
        e
    }
    function Nn(e, t) {
        var n, i = t[0] + t[4] + t[8];
        if (i > 0)
            n = Math.sqrt(i + 1),
            e[3] = .5 * n,
            n = .5 / n,
            e[0] = (t[5] - t[7]) * n,
            e[1] = (t[6] - t[2]) * n,
            e[2] = (t[1] - t[3]) * n;
        else {
            var r = 0;
            t[4] > t[0] && (r = 1),
            t[8] > t[3 * r + r] && (r = 2);
            var s = (r + 1) % 3
              , a = (r + 2) % 3;
            n = Math.sqrt(t[3 * r + r] - t[3 * s + s] - t[3 * a + a] + 1),
            e[r] = .5 * n,
            n = .5 / n,
            e[3] = (t[3 * s + a] - t[3 * a + s]) * n,
            e[s] = (t[3 * s + r] + t[3 * r + s]) * n,
            e[a] = (t[3 * a + r] + t[3 * r + a]) * n
        }
        return e
    }
    function Vn(e, t, n, i) {
        var r = .5 * Math.PI / 180;
        t *= r,
        n *= r,
        i *= r;
        var s = Math.sin(t)
          , a = Math.cos(t)
          , o = Math.sin(n)
          , l = Math.cos(n)
          , c = Math.sin(i)
          , u = Math.cos(i);
        return e[0] = s * l * u - a * o * c,
        e[1] = a * o * u + s * l * c,
        e[2] = a * l * c - s * o * u,
        e[3] = a * l * u + s * o * c,
        e
    }
    function Bn(e) {
        return "quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }
    var Fn, _n, Un, zn, Gn, $n, Wn = It, Hn = Pt, Jn = Rt, qn = jt, Yn = Nt, Xn = On, Kn = Wt, Zn = en, Qn = nn, ei = Yt, ti = ei, ni = Xt, ii = ni, ri = Qt, si = cn, ai = un, oi = (Fn = Ne(),
    _n = Fe(1, 0, 0),
    Un = Fe(0, 1, 0),
    function(e, t, n) {
        var i = st(t, n);
        return i < -.999999 ? (at(Fn, _n, t),
        Mt(Fn) < 1e-6 && at(Fn, Un, t),
        rt(Fn, Fn),
        wn(e, Fn, Math.PI),
        e) : i > .999999 ? (e[0] = 0,
        e[1] = 0,
        e[2] = 0,
        e[3] = 1,
        e) : (at(Fn, t, n),
        e[0] = Fn[0],
        e[1] = Fn[1],
        e[2] = Fn[2],
        e[3] = 1 + i,
        ri(e, e))
    }
    ), li = (zn = yn(),
    Gn = yn(),
    function(e, t, n, i, r, s) {
        return In(zn, t, r, s),
        In(Gn, n, i, s),
        In(e, zn, Gn, 2 * s * (1 - s)),
        e
    }
    ), ci = ($n = d(),
    function(e, t, n, i) {
        return $n[0] = n[0],
        $n[3] = n[1],
        $n[6] = n[2],
        $n[1] = i[0],
        $n[4] = i[1],
        $n[7] = i[2],
        $n[2] = -t[0],
        $n[5] = -t[1],
        $n[8] = -t[2],
        ri(e, Nn(e, $n))
    }
    );
    function ui() {
        var e = new c(2);
        return c != Float32Array && (e[0] = 0,
        e[1] = 0),
        e
    }
    function di(e) {
        var t = new c(2);
        return t[0] = e[0],
        t[1] = e[1],
        t
    }
    function hi(e, t) {
        var n = new c(2);
        return n[0] = e,
        n[1] = t,
        n
    }
    function pi(e, t) {
        return e[0] = t[0],
        e[1] = t[1],
        e
    }
    function fi(e, t, n) {
        return e[0] = t,
        e[1] = n,
        e
    }
    function mi(e, t, n) {
        return e[0] = t[0] + n[0],
        e[1] = t[1] + n[1],
        e
    }
    function gi(e, t, n) {
        return e[0] = t[0] - n[0],
        e[1] = t[1] - n[1],
        e
    }
    function vi(e, t, n) {
        return e[0] = t[0] * n[0],
        e[1] = t[1] * n[1],
        e
    }
    function bi(e, t, n) {
        return e[0] = t[0] / n[0],
        e[1] = t[1] / n[1],
        e
    }
    function yi(e, t) {
        return e[0] = Math.ceil(t[0]),
        e[1] = Math.ceil(t[1]),
        e
    }
    function Si(e, t) {
        return e[0] = Math.floor(t[0]),
        e[1] = Math.floor(t[1]),
        e
    }
    function wi(e, t, n) {
        return e[0] = Math.min(t[0], n[0]),
        e[1] = Math.min(t[1], n[1]),
        e
    }
    function xi(e, t, n) {
        return e[0] = Math.max(t[0], n[0]),
        e[1] = Math.max(t[1], n[1]),
        e
    }
    function Ci(e, t) {
        return e[0] = Math.round(t[0]),
        e[1] = Math.round(t[1]),
        e
    }
    function Oi(e, t, n) {
        return e[0] = t[0] * n,
        e[1] = t[1] * n,
        e
    }
    function ki(e, t, n, i) {
        return e[0] = t[0] + n[0] * i,
        e[1] = t[1] + n[1] * i,
        e
    }
    function Ei(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1];
        return Math.hypot(n, i)
    }
    function Ti(e, t) {
        var n = t[0] - e[0]
          , i = t[1] - e[1];
        return n * n + i * i
    }
    function Mi(e) {
        var t = e[0]
          , n = e[1];
        return Math.hypot(t, n)
    }
    function Di(e) {
        var t = e[0]
          , n = e[1];
        return t * t + n * n
    }
    function Li(e, t) {
        return e[0] = -t[0],
        e[1] = -t[1],
        e
    }
    function Ai(e, t) {
        return e[0] = 1 / t[0],
        e[1] = 1 / t[1],
        e
    }
    function Ii(e, t) {
        var n = t[0]
          , i = t[1]
          , r = n * n + i * i;
        return r > 0 && (r = 1 / Math.sqrt(r)),
        e[0] = t[0] * r,
        e[1] = t[1] * r,
        e
    }
    function Pi(e, t) {
        return e[0] * t[0] + e[1] * t[1]
    }
    function Ri(e, t, n) {
        var i = t[0] * n[1] - t[1] * n[0];
        return e[0] = e[1] = 0,
        e[2] = i,
        e
    }
    function ji(e, t, n, i) {
        var r = t[0]
          , s = t[1];
        return e[0] = r + i * (n[0] - r),
        e[1] = s + i * (n[1] - s),
        e
    }
    function Ni(e, t) {
        t = t || 1;
        var n = 2 * u() * Math.PI;
        return e[0] = Math.cos(n) * t,
        e[1] = Math.sin(n) * t,
        e
    }
    function Vi(e, t, n) {
        var i = t[0]
          , r = t[1];
        return e[0] = n[0] * i + n[2] * r,
        e[1] = n[1] * i + n[3] * r,
        e
    }
    function Bi(e, t, n) {
        var i = t[0]
          , r = t[1];
        return e[0] = n[0] * i + n[2] * r + n[4],
        e[1] = n[1] * i + n[3] * r + n[5],
        e
    }
    function Fi(e, t, n) {
        var i = t[0]
          , r = t[1];
        return e[0] = n[0] * i + n[3] * r + n[6],
        e[1] = n[1] * i + n[4] * r + n[7],
        e
    }
    function _i(e, t, n) {
        var i = t[0]
          , r = t[1];
        return e[0] = n[0] * i + n[4] * r + n[12],
        e[1] = n[1] * i + n[5] * r + n[13],
        e
    }
    function Ui(e, t, n, i) {
        var r = t[0] - n[0]
          , s = t[1] - n[1]
          , a = Math.sin(i)
          , o = Math.cos(i);
        return e[0] = r * o - s * a + n[0],
        e[1] = r * a + s * o + n[1],
        e
    }
    function zi(e, t) {
        var n = e[0]
          , i = e[1]
          , r = t[0]
          , s = t[1]
          , a = n * n + i * i;
        a > 0 && (a = 1 / Math.sqrt(a));
        var o = r * r + s * s;
        o > 0 && (o = 1 / Math.sqrt(o));
        var l = (n * r + i * s) * a * o;
        return l > 1 ? 0 : l < -1 ? Math.PI : Math.acos(l)
    }
    function Gi(e) {
        return e[0] = 0,
        e[1] = 0,
        e
    }
    function $i(e) {
        return "vec2(" + e[0] + ", " + e[1] + ")"
    }
    function Wi(e, t) {
        return e[0] === t[0] && e[1] === t[1]
    }
    function Hi(e, t) {
        var n = e[0]
          , i = e[1]
          , r = t[0]
          , s = t[1];
        return Math.abs(n - r) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(r)) && Math.abs(i - s) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(s))
    }
    var Ji = Mi
      , qi = gi
      , Yi = vi
      , Xi = bi
      , Ki = Ei
      , Zi = Ti
      , Qi = Di
      , er = function() {
        var e = ui();
        return function(t, n, i, r, s, a) {
            var o, l;
            for (n || (n = 2),
            i || (i = 0),
            l = r ? Math.min(r * n + i, t.length) : t.length,
            o = i; o < l; o += n)
                e[0] = t[o],
                e[1] = t[o + 1],
                s(e, e, a),
                t[o] = e[0],
                t[o + 1] = e[1];
            return t
        }
    }()
      , tr = n(6);
    n.d(t, "e", (function() {
        return nr
    }
    )),
    n.d(t, "a", (function() {
        return ir
    }
    )),
    n.d(t, "h", (function() {
        return rr
    }
    )),
    n.d(t, "i", (function() {
        return sr
    }
    )),
    n.d(t, "m", (function() {
        return ar
    }
    )),
    n.d(t, "u", (function() {
        return or
    }
    )),
    n.d(t, "q", (function() {
        return lr
    }
    )),
    n.d(t, "r", (function() {
        return cr
    }
    )),
    n.d(t, "n", (function() {
        return ur
    }
    )),
    n.d(t, "k", (function() {
        return dr
    }
    )),
    n.d(t, "c", (function() {
        return hr
    }
    )),
    n.d(t, "g", (function() {
        return pr
    }
    )),
    n.d(t, "f", (function() {
        return fr
    }
    )),
    n.d(t, "b", (function() {
        return mr
    }
    )),
    n.d(t, "p", (function() {
        return gr
    }
    )),
    n.d(t, "d", (function() {
        return vr
    }
    )),
    n.d(t, "j", (function() {
        return i
    }
    )),
    n.d(t, "l", (function() {
        return r
    }
    )),
    n.d(t, "o", (function() {
        return o
    }
    )),
    n.d(t, "s", (function() {
        return l
    }
    )),
    n.d(t, "t", (function() {
        return s
    }
    )),
    n.d(t, "v", (function() {
        return a
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const nr = r.create()
      , ir = ["x", "y", "z"]
      , rr = [s.fromValues(1, 0, 0), s.fromValues(0, 1, 0), s.fromValues(0, 0, 1)]
      , sr = (s.fromValues(0, 0, 0),
    s.fromValues(1, 1, 1));
    s.fromValues(1 / 0, 1 / 0, 1 / 0),
    o.create();
    function ar(e) {
        return e[0] * e[1] * e[2]
    }
    function or(e) {
        return `${e[0]},${e[1]},${e[2]}`
    }
    function lr(e, t, n) {
        let i = t[0]
          , r = t[1]
          , s = t[2];
        return e[0] = n[0] * i + n[4] * r + n[8] * s,
        e[1] = n[1] * i + n[5] * r + n[9] * s,
        e[2] = n[2] * i + n[6] * r + n[10] * s,
        e
    }
    function cr(e, t, n) {
        let i = t[0]
          , r = t[1]
          , s = t[2];
        return e[0] = n[0] * i + n[1] * r + n[2] * s,
        e[1] = n[4] * i + n[5] * r + n[6] * s,
        e[2] = n[8] * i + n[9] * r + n[10] * s,
        e
    }
    function ur(e, t, n, i) {
        const r = e.length;
        let s = function(e, t, n) {
            const i = n.length;
            let r = 0;
            for (let n = 0; n < i; ++n)
                r += (e[n] - t[n]) ** 2;
            let s = 0;
            for (let r = 0; r < i; ++r) {
                const i = e[r];
                s -= (i - n[r]) * (t[r] - i)
            }
            return s / Math.max(r, 1e-6)
        }(t, n, i);
        s = Math.max(0, Math.min(1, s));
        for (let i = 0; i < r; ++i) {
            const r = t[i];
            e[i] = r + s * (n[i] - r)
        }
        return e
    }
    function dr(e, t) {
        const n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[4]
          , a = t[5]
          , o = t[6]
          , l = t[8]
          , c = t[9]
          , u = t[10];
        return e[0] = n,
        e[1] = i,
        e[2] = r,
        e[3] = s,
        e[4] = a,
        e[5] = o,
        e[6] = l,
        e[7] = c,
        e[8] = u,
        e
    }
    function hr(e, t) {
        const n = t[0]
          , i = t[1]
          , r = t[2]
          , s = t[3]
          , a = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[7]
          , u = t[8]
          , d = t[9]
          , h = t[10]
          , p = t[11]
          , f = t[12]
          , m = t[13]
          , g = t[14]
          , v = t[15];
        e[0] = s + n,
        e[1] = c + a,
        e[2] = p + u,
        e[3] = v + f,
        e[4] = s - n,
        e[5] = c - a,
        e[6] = p - u,
        e[7] = v - f,
        e[8] = s + i,
        e[9] = c + o,
        e[10] = p + d,
        e[11] = v + m,
        e[12] = s - i,
        e[13] = c - o,
        e[14] = p - d,
        e[15] = v - m;
        const b = s + r
          , y = c + l
          , S = p + h
          , w = v + g
          , x = Math.sqrt(b ** 2 + y ** 2 + S ** 2);
        return e[16] = b / x,
        e[17] = y / x,
        e[18] = S / x,
        e[19] = w / x,
        e[20] = s - r,
        e[21] = c - l,
        e[22] = p - h,
        e[23] = v - g,
        e
    }
    function pr(e, t, n, i, r, s, a) {
        for (let o = 0; o < 6; ++o) {
            const l = a[4 * o]
              , c = a[4 * o + 1]
              , u = a[4 * o + 2]
              , d = a[4 * o + 3];
            if (Math.max(l * e, l * i) + Math.max(c * t, c * r) + Math.max(u * n, u * s) + d < 0)
                return !1
        }
        return !0
    }
    function fr(e, t, n, i, r, s, a) {
        for (let o = 0; o < 4; ++o) {
            const l = a[4 * o]
              , c = a[4 * o + 1]
              , u = a[4 * o + 2]
              , d = a[4 * o + 3];
            if (Math.max(l * e, l * i) + Math.max(c * t, c * r) + Math.max(u * n, u * s) + d < 0)
                return !1
        }
        {
            const o = 5
              , l = a[4 * o]
              , c = a[4 * o + 1]
              , u = a[4 * o + 2]
              , d = a[4 * o + 3]
              , h = Math.max(l * e, l * i) + Math.max(c * t, c * r) + Math.max(u * n, u * s)
              , p = Math.min(l * e, l * i) + Math.min(c * t, c * r) + Math.min(u * n, u * s)
              , f = 1e-6 * Math.abs(d);
            if (p > -d + f || h < -d - f)
                return !1
        }
        return !0
    }
    function mr(e, t, n, i=!1) {
        const r = n.length
          , s = []
          , a = i ? 1 : t + 1
          , o = i ? t + 1 : 1;
        for (let i = 0; i < r; ++i) {
            const r = n[i];
            for (let n = 0; n < t; ++n)
                0 !== e[n * a + r * o] && (s[n] = !0)
        }
        return Object(tr.e)(s, !0)
    }
    function gr(e, t, n) {
        for (let i = 0; i < 3; ++i) {
            const r = n[i];
            for (let n = 0; n < 3; ++n)
                e[i + 3 * n] = r * t[i + 3 * n]
        }
        return e
    }
    function vr(e) {
        if (1 === e[15]) {
            const t = 2 / Math.abs(e[10]);
            return 2 / Math.abs(e[0]) * (2 / Math.abs(e[5])) * t
        }
        const t = e[10]
          , n = 2 * e[14] / (2 * t - 2)
          , i = (t - 1) * n / (t + 1);
        return 4 / (e[0] * e[5]) / 3 * (Math.abs(i) ** 3 - Math.abs(n) ** 3)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return r
    }
    )),
    n.d(t, "e", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return l
    }
    ));
    function i(e) {
        "object" == typeof e ? e.dispose() : e()
    }
    function r(e) {
        for (let t = e.length; t > 0; --t)
            i(e[t - 1])
    }
    function s(e, t, n, i) {
        return e.addEventListener(t, n, i),
        ()=>e.removeEventListener(t, n, i)
    }
    class a {
        constructor() {
            this.refCount = 1
        }
        addRef() {
            return ++this.refCount,
            this
        }
        dispose() {
            0 == --this.refCount && this.refCountReachedZero()
        }
        refCountReachedZero() {
            this.disposed();
            let {disposers: e} = this;
            void 0 !== e && (r(e),
            this.disposers = void 0),
            this.wasDisposed = !0
        }
        disposed() {}
        registerDisposer(e) {
            let {disposers: t} = this;
            return null == t ? this.disposers = [e] : t.push(e),
            e
        }
        unregisterDisposer(e) {
            let {disposers: t} = this;
            if (null != t) {
                let n = t.indexOf(e);
                -1 !== n && t.splice(n, 1)
            }
            return e
        }
        registerEventListener(e, t, n, i) {
            this.registerDisposer(s(e, t, n, i))
        }
        registerCancellable(e) {
            return this.registerDisposer(()=>{
                e.cancel()
            }
            ),
            e
        }
    }
    class o extends a {
        constructor(e) {
            super(),
            this.value = e
        }
    }
    function l(e) {
        return ()=>{
            if (void 0 !== e) {
                let t = e;
                e = void 0,
                i(t)
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class i {
        constructor() {
            this.handlers = new Set,
            this.count = 0;
            const e = this;
            this.dispatch = function() {
                ++e.count,
                e.handlers.forEach(e=>{
                    e.apply(this, arguments)
                }
                )
            }
        }
        add(e) {
            return this.handlers.add(e),
            ()=>this.remove(e)
        }
        remove(e) {
            return this.handlers.delete(e)
        }
        dispose() {
            this.handlers = void 0
        }
    }
    class r extends i {
    }
    const s = {
        count: 0,
        add: e=>()=>{}
        ,
        remove: e=>!1
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "D", (function() {
        return h
    }
    )),
    n.d(t, "d", (function() {
        return p
    }
    )),
    n.d(t, "z", (function() {
        return g
    }
    )),
    n.d(t, "l", (function() {
        return v
    }
    )),
    n.d(t, "m", (function() {
        return b
    }
    )),
    n.d(t, "f", (function() {
        return S
    }
    )),
    n.d(t, "b", (function() {
        return x
    }
    )),
    n.d(t, "p", (function() {
        return C
    }
    )),
    n.d(t, "o", (function() {
        return O
    }
    )),
    n.d(t, "B", (function() {
        return k
    }
    )),
    n.d(t, "e", (function() {
        return E
    }
    )),
    n.d(t, "C", (function() {
        return D
    }
    )),
    n.d(t, "n", (function() {
        return L
    }
    )),
    n.d(t, "g", (function() {
        return A
    }
    )),
    n.d(t, "A", (function() {
        return I
    }
    )),
    n.d(t, "F", (function() {
        return N
    }
    )),
    n.d(t, "r", (function() {
        return V
    }
    )),
    n.d(t, "x", (function() {
        return B
    }
    )),
    n.d(t, "y", (function() {
        return F
    }
    )),
    n.d(t, "v", (function() {
        return _
    }
    )),
    n.d(t, "w", (function() {
        return U
    }
    )),
    n.d(t, "c", (function() {
        return W
    }
    )),
    n.d(t, "k", (function() {
        return H
    }
    )),
    n.d(t, "a", (function() {
        return J
    }
    )),
    n.d(t, "t", (function() {
        return q
    }
    )),
    n.d(t, "i", (function() {
        return Y
    }
    )),
    n.d(t, "h", (function() {
        return X
    }
    )),
    n.d(t, "j", (function() {
        return K
    }
    )),
    n.d(t, "E", (function() {
        return Z
    }
    )),
    n.d(t, "u", (function() {
        return Q
    }
    )),
    n.d(t, "s", (function() {
        return ee
    }
    )),
    n.d(t, "q", (function() {
        return te
    }
    ));
    var i = n(7)
      , r = n(6)
      , s = n(1)
      , a = n(0)
      , o = n(15)
      , l = n(37)
      , c = n(3)
      , u = n(43);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let d = 0;
    function h() {
        return ++d
    }
    function p(e, t) {
        return Object(r.a)(e.lowerBounds, t.lowerBounds) && Object(r.a)(e.upperBounds, t.upperBounds)
    }
    function f(e, t) {
        return Object(r.a)(e.transform, t.transform) && p(e.box, t.box)
    }
    function m(e, t) {
        return e.valid === t.valid && e.rank === t.rank && Object(r.a)(e.names, t.names) && Object(r.a)(e.ids, t.ids) && Object(r.a)(e.timestamps, t.timestamps) && Object(r.a)(e.units, t.units) && Object(r.a)(e.scales, t.scales) && Object(r.b)(e.boundingBoxes, t.boundingBoxes, f)
    }
    function g(e) {
        const {names: t, units: n, scales: i} = e
          , {valid: r=!0, rank: s=t.length, timestamps: a=t.map(()=>Number.NEGATIVE_INFINITY), ids: o=t.map((e,t)=>-t), boundingBoxes: l=[]} = e
          , {bounds: c=T(l, s)} = e;
        return {
            valid: r,
            rank: s,
            names: t,
            timestamps: a,
            ids: o,
            units: n,
            scales: i,
            boundingBoxes: l,
            bounds: c
        }
    }
    const v = g({
        valid: !1,
        names: [],
        units: [],
        scales: u.c,
        boundingBoxes: []
    })
      , b = g({
        valid: !0,
        names: [],
        units: [],
        scales: u.c,
        boundingBoxes: []
    });
    function y(e) {
        const [t,n] = Object(a.a)(e, 2)
          , i = Object(a.r)(t)
          , r = Object(a.E)(n)
          , s = l.f.get(r);
        if (void 0 === s)
            throw new Error(`Invalid unit: ${JSON.stringify(r)}`);
        return {
            unit: s.unit,
            scale: Object(l.e)(i, s.exponent)
        }
    }
    function S(e, t=!1) {
        if (void 0 === e)
            return v;
        Object(a.w)(e);
        const n = H(Object.keys(e), t)
          , i = n.length
          , r = new Array(i)
          , s = new Float64Array(i);
        for (let t = 0; t < i; ++t)
            Object(a.y)(e, n[t], e=>{
                const {unit: n, scale: i} = y(e);
                r[t] = n,
                s[t] = i
            }
            );
        return g({
            valid: !1,
            names: n,
            units: r,
            scales: s
        })
    }
    function w(e) {
        const {rank: t} = e;
        if (0 === t)
            return;
        const {names: n, units: i, scales: r} = e
          , s = {};
        for (let e = 0; e < t; ++e)
            s[n[e]] = [r[e], i[e]];
        return s
    }
    class x extends i.e {
        constructor() {
            super(v)
        }
        toJSON() {
            return w(this.value)
        }
        reset() {
            this.value = v
        }
        restoreState(e) {
            this.value = S(e)
        }
    }
    function C(e, t) {
        let n = (e + t) / 2;
        return Number.isFinite(n) || (n = Math.min(Math.max(0, e), t)),
        n
    }
    function O(e, t) {
        const {lowerBounds: n, upperBounds: i} = t
          , r = e.length;
        for (let t = 0; t < r; ++t)
            e[t] = C(n[t], i[t]);
        return e
    }
    function k(e) {
        const t = e.lowerBounds.length;
        return {
            box: e,
            transform: o.c(Float64Array, t, t + 1)
        }
    }
    function E(e, t, n) {
        const {box: {lowerBounds: i, upperBounds: r}, transform: s} = e
          , a = i.length
          , o = n
          , l = s[o * a + t];
        let c = l
          , u = l
          , d = !1;
        for (let e = 0; e < a; ++e) {
            let n = s[o * e + t];
            if (0 === n)
                continue;
            const a = n * i[e]
              , l = n * r[e];
            c += Math.min(a, l),
            u += Math.max(a, l),
            d = !0
        }
        if (d)
            return {
                lower: c,
                upper: u
            }
    }
    function T(e, t) {
        const n = new Float64Array(t)
          , i = new Float64Array(t);
        n.fill(Number.NEGATIVE_INFINITY),
        i.fill(Number.POSITIVE_INFINITY);
        for (const r of e)
            for (let e = 0; e < t; ++e) {
                const s = E(r, e, t);
                if (void 0 === s)
                    continue;
                const {lower: a, upper: o} = s;
                n[e] = n[e] === Number.NEGATIVE_INFINITY ? a : Math.min(n[e], a),
                i[e] = i[e] === Number.POSITIVE_INFINITY ? o : Math.max(i[e], o)
            }
        return {
            lowerBounds: n,
            upperBounds: i
        }
    }
    function M(e, t, n) {
        const {transform: i, box: r} = e
          , s = n.length
          , a = r.lowerBounds.length
          , o = new Float64Array((a + 1) * t);
        for (let e = 0; e < s; ++e) {
            const r = n[e];
            if (-1 !== r)
                for (let n = 0; n <= a; ++n)
                    o[n * t + r] = i[n * s + e]
        }
        return {
            transform: o,
            box: r
        }
    }
    function D(e, t) {
        const n = {
            lowerBounds: Float64Array.of(0),
            upperBounds: Float64Array.of(1)
        }
          , i = new Float64Array(2 * e);
        return i[t] = 1,
        {
            transform: i,
            box: n
        }
    }
    function L(e, t, n) {
        if (t === n)
            return e;
        const {box: i} = e
          , r = i.lowerBounds.length
          , s = new Float64Array((r + 1) * n);
        return o.a(s, n, e.transform, t, t, r + 1),
        {
            box: i,
            transform: s
        }
    }
    function A(e, t) {
        const {rank: n, sourceRank: i} = e;
        if (n !== t.rank || i !== t.sourceRank)
            return !1;
        const {inputSpace: s} = e
          , {inputSpace: a} = t;
        return !!(Object(r.a)(a.scales, s.scales) && Object(r.a)(a.units, s.units) && Object(r.a)(t.outputSpace.names, e.outputSpace.names)) && z(e.transform, n, e.outputSpace.scales, t.transform, n, t.outputSpace.scales)
    }
    function I(e) {
        return {
            rank: e.rank,
            sourceRank: e.rank,
            inputSpace: e,
            outputSpace: e,
            transform: o.c(Float64Array, e.rank + 1)
        }
    }
    function P(e, t, n) {
        return e.boundingBoxes.map(i=>function(e, t, n, i) {
            let {transform: r, box: s} = e;
            const a = e.box.lowerBounds.length
              , o = i.length
              , l = new Float64Array((a + 1) * o);
            for (let e = 0; e < o; ++e) {
                const s = i[e];
                for (let i = 0; i < a; ++i) {
                    let a = 0;
                    for (let l = 0; l < o; ++l) {
                        const c = n[l];
                        a += t[(o + 1) * l + e] * r[o * i + l] * (c / s)
                    }
                    l[o * i + e] = a
                }
                let c = t[(o + 1) * o + e];
                for (let i = 0; i < o; ++i) {
                    const l = n[i];
                    c += t[(o + 1) * i + e] * r[o * a + i] * (l / s)
                }
                l[a * o + e] = c
            }
            return {
                transform: l,
                box: s
            }
        }(i, t, e.scales, n))
    }
    function R(e, t, n) {
        const i = g({
            valid: e.valid,
            rank: n.rank,
            ids: n.ids,
            names: n.names,
            timestamps: n.timestamps,
            scales: n.scales,
            units: n.units,
            boundingBoxes: P(e, t, n.scales)
        });
        return m(i, n) ? n : i
    }
    function j(e, t=!1) {
        if (t) {
            const t = Number(e);
            if (Number.isInteger(t) && t >= 0)
                return !0
        }
        return null !== e.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/)
    }
    function N(e, t=!1) {
        const n = new Set;
        for (const i of e) {
            if (!j(i, t))
                return !1;
            if (n.has(i))
                return !1;
            n.add(i)
        }
        return !0
    }
    function V(e) {
        const t = e.length
          , n = new Array(t);
        n.fill(!0);
        for (let i = 0; i < t; ++i) {
            const t = e[i];
            if (!j(t)) {
                n[i] = !1;
                continue
            }
            const r = e.indexOf(t, i + 1);
            -1 !== r && (n[i] = !1,
            n[r] = !1)
        }
        return n
    }
    function B(e) {
        return e.endsWith("'")
    }
    function F(e) {
        return e.endsWith("'") || e.endsWith("^")
    }
    function _(e) {
        return e.endsWith("^")
    }
    function U(e) {
        return !F(e)
    }
    function z(e, t, n, i, r, s) {
        if (!o.d(e, t + 1, i, r + 1, t, t))
            return !1;
        for (let a = 0; a < t; ++a) {
            const o = e[(t + 1) * t + a]
              , l = i[(r + 1) * r + a];
            if (o * (n[a] / s[a]) !== l)
                return !1
        }
        for (let e = t; e < r; ++e)
            if (0 !== i[(r + 1) * r + e])
                return !1;
        for (let e = t; e < r; ++e) {
            for (let n = 0; n < t; ++n)
                if (0 !== i[(r + 1) * n + e])
                    return !1;
            for (let t = 0; t < r; ++t) {
                const n = i[(r + 1) * e + t];
                if (e === t) {
                    if (1 !== n)
                        return !1
                } else if (0 !== n)
                    return !1
            }
        }
        return !0
    }
    function G(e, t) {
        if (!t.includes(e))
            return e;
        const [,n,i] = e.match(/^([^']*)('?)$/);
        for (let e = 0; ; ++e) {
            const r = `${n}${e}${i}`;
            if (!t.includes(r))
                return r
        }
    }
    function $(e) {
        const t = R(e.inputSpace, e.transform, e.outputSpace);
        return t === e.outputSpace ? e : {
            rank: e.rank,
            sourceRank: e.sourceRank,
            inputSpace: e.inputSpace,
            transform: e.transform,
            outputSpace: t
        }
    }
    class W {
        constructor(e, t=!1) {
            this.mutableSourceRank = t,
            this.value_ = void 0,
            this.changed = new c.a,
            this.inputSpaceChanged = new c.a,
            this.defaultTransform = $(e);
            const n = this;
            this.outputSpace = {
                changed: n.changed,
                get value() {
                    return n.value.outputSpace
                },
                set value(e) {
                    const {value: t} = n;
                    if (m(t.outputSpace, e))
                        return;
                    if (t.rank !== e.rank)
                        return;
                    const i = function(e, t, n) {
                        const i = new Float64Array(e)
                          , r = t.length
                          , s = (r + 1) * r;
                        for (let e = 0; e < r; ++e)
                            i[s + e] *= t[e] / n[e];
                        return i
                    }(t.transform, t.outputSpace.scales, e.scales);
                    n.value_ = {
                        sourceRank: t.sourceRank,
                        rank: t.rank,
                        inputSpace: t.inputSpace,
                        outputSpace: R(t.inputSpace, i, e),
                        transform: i
                    },
                    n.changed.dispatch()
                }
            },
            this.inputSpace = {
                changed: n.inputSpaceChanged,
                get value() {
                    return n.value.inputSpace
                },
                set value(e) {
                    const {value: t} = n;
                    m(t.inputSpace, e) || (n.value_ = function(e, t) {
                        const {inputSpace: n, transform: i} = e
                          , {ids: r, rank: s} = n
                          , {rank: a, names: o, units: l, scales: c} = t
                          , u = new Array(s);
                        u.fill(!0);
                        const d = []
                          , p = t.ids.map((e,t)=>{
                            const n = r.indexOf(e);
                            return -1 !== n ? u[n] = !1 : d.push(t),
                            n
                        }
                        )
                          , {outputSpace: f} = e
                          , {names: m, units: v, scales: b, ids: y, timestamps: S} = f
                          , w = u
                          , x = []
                          , C = []
                          , O = new Float64Array(a)
                          , k = []
                          , E = [];
                        let T = 0;
                        const M = new Float64Array((a + 1) ** 2);
                        M[M.length - 1] = 1;
                        for (let e = 0; e < s; ++e)
                            if (!w[e]) {
                                x[T] = m[e],
                                k[T] = y[e],
                                C[T] = v[e],
                                O[T] = b[e],
                                E[T] = S[e];
                                for (let t = 0; t < a; ++t) {
                                    const n = p[t];
                                    -1 !== n && (M[t * (a + 1) + T] = i[n * (s + 1) + e])
                                }
                                M[a * (a + 1) + T] = i[s * (s + 1) + e],
                                ++T
                            }
                        for (const e of d)
                            k[T] = h(),
                            x[T] = G(o[e], x),
                            O[T] = c[e],
                            C[T] = l[e],
                            M[e * (a + 1) + T] = 1,
                            ++T;
                        const D = g({
                            valid: t.valid,
                            rank: a,
                            names: x,
                            ids: k,
                            timestamps: E,
                            units: C,
                            scales: O,
                            boundingBoxes: P(t, M, O)
                        });
                        return {
                            rank: a,
                            sourceRank: e.sourceRank,
                            inputSpace: t,
                            outputSpace: D,
                            transform: M
                        }
                    }(t, e),
                    n.inputSpaceChanged.dispatch(),
                    n.changed.dispatch())
                }
            }
        }
        set value(e) {
            const t = this.value;
            e !== t && (this.value_ = $(e),
            e.inputSpace !== t.inputSpace && this.inputSpaceChanged.dispatch(),
            this.changed.dispatch())
        }
        get value() {
            let {value_: e} = this;
            return void 0 === e && (e = this.value_ = this.defaultTransform),
            e
        }
        reset() {
            this.value_ !== this.defaultTransform && (this.value_ = this.defaultTransform,
            console.log("newValue", this.value_),
            this.inputSpaceChanged.dispatch(),
            this.changed.dispatch())
        }
        get defaultInputSpace() {
            return this.defaultTransform.inputSpace
        }
        get spec() {
            const {value: e} = this
              , {rank: t, transform: n, inputSpace: i, outputSpace: s, sourceRank: a} = e
              , {defaultTransform: o, mutableSourceRank: l} = this
              , {inputSpace: c, rank: u, transform: d, outputSpace: h} = o
              , {units: p, scales: f} = i
              , m = a === t && Object(r.a)(f, l ? s.scales : c.scales) && Object(r.a)(p, l ? s.units : c.units)
              , g = z(d, u, h.scales, n, t, s.scales)
              , v = Object(r.a)(h.names, s.names);
            if (!(g && v && m))
                return {
                    sourceRank: a,
                    transform: g ? void 0 : n,
                    outputSpace: e.outputSpace,
                    inputSpace: m ? void 0 : i
                }
        }
        set transform(e) {
            const {value: t} = this
              , {inputSpace: n} = t;
            this.value_ = {
                rank: t.rank,
                sourceRank: t.sourceRank,
                inputSpace: n,
                transform: e,
                outputSpace: R(n, e, t.outputSpace)
            },
            this.changed.dispatch()
        }
        set spec(e) {
            if (void 0 === e)
                return void this.reset();
            if (this.mutableSourceRank) {
                const t = e.inputSpace || e.outputSpace
                  , n = t.rank
                  , i = g({
                    rank: n,
                    names: t.names.map((e,t)=>`${t}`),
                    units: t.units,
                    scales: t.scales
                });
                return void (this.value = {
                    rank: n,
                    transform: e.transform || o.c(Float64Array, n + 1),
                    sourceRank: e.sourceRank,
                    outputSpace: e.outputSpace,
                    inputSpace: i
                })
            }
            const {inputSpace: t, sourceRank: n, outputSpace: i, transform: r, rank: s} = this.defaultTransform
              , {inputSpace: a, sourceRank: l, outputSpace: c, transform: u} = e
              , d = e.outputSpace.rank
              , h = t.names
              , p = void 0 !== a ? a.names : h
              , f = new Array(n);
            for (let e = 0; e < n; ++e) {
                let t = p.indexOf(h[e]);
                t >= l && (t = -1),
                f[e] = t
            }
            const m = d - l + n;
            for (let e = l; e < d; ++e)
                f[n + e - l] = e;
            const v = new Float64Array(m)
              , b = [];
            for (let e = 0; e < n; ++e) {
                const n = f[e];
                -1 === n || void 0 === a ? (v[e] = t.scales[e],
                b[e] = t.units[e]) : (v[e] = a.scales[n],
                b[e] = a.units[n])
            }
            const y = a || c
              , S = h.slice(0, n)
              , w = i.names.slice(0, n)
              , x = new Float64Array(m)
              , C = [];
            for (let e = 0; e < m; ++e) {
                const t = f[e];
                -1 === t ? (x[e] = i.scales[e],
                C[e] = i.units[e]) : (w[e] = c.names[t],
                C[e] = c.units[t],
                x[e] = c.scales[t])
            }
            if (!N(w))
                return void this.reset();
            for (let e = n; e < m; ++e) {
                const t = e - n + l;
                v[e] = y.scales[t],
                b[e] = y.units[t],
                S[e] = `${e}`
            }
            const O = new Float64Array((m + 1) ** 2);
            O[O.length - 1] = 1;
            for (let e = 0; e < m; ++e) {
                const t = f[e];
                let a;
                a = -1 === t || void 0 === u ? e >= n ? 0 : r[s * (s + 1) + e] * (i.scales[e] / x[e]) : u[d * (d + 1) + t],
                O[m * (m + 1) + e] = a;
                for (let i = 0; i < m; ++i) {
                    const a = f[i];
                    let o;
                    o = -1 === t != (-1 === a) ? 0 : -1 === t || void 0 === u ? t >= n || a >= n ? t === a ? 1 : 0 : r[i * (s + 1) + e] : u[a * (d + 1) + t],
                    O[i * (m + 1) + e] = o
                }
            }
            const k = t.boundingBoxes.map(e=>L(e, s, m));
            for (let e = n; e < m; ++e)
                k.push(D(m, e));
            this.value = {
                rank: m,
                transform: O,
                sourceRank: n,
                outputSpace: g({
                    rank: m,
                    names: w,
                    scales: x,
                    units: C
                }),
                inputSpace: g({
                    rank: m,
                    names: S,
                    scales: v,
                    units: b,
                    boundingBoxes: k
                })
            }
        }
        toJSON() {
            return K(this.spec)
        }
        restoreState(e) {
            this.spec = X(e)
        }
    }
    function H(e, t=!1) {
        const n = Object(a.b)(e, e=>function(e, t=!1) {
            const n = Object(a.E)(e);
            if (!j(n, t))
                throw new Error(`Invalid dimension name: ${JSON.stringify(n)}`);
            return n
        }(e, t));
        if (!N(n, t))
            throw new Error(`Invalid dimensions: ${JSON.stringify(n)}`);
        return n
    }
    class J {
        constructor(e, t) {
            this.combined = e,
            this.bindings = new Set,
            this.retainCount = 0,
            this.prevCombined = this.combined.value,
            this.dimensionRefCounts = new Map,
            this.handleCombinedChanged = ()=>{
                this.combined.value !== this.prevCombined && this.update()
            }
            ,
            this.includeDimensionPredicate_ = t
        }
        getRenameValidity(e) {
            const t = this.combined.value.names
              , n = V(e)
              , i = e.length;
            for (let r = 0; r < i; ++r) {
                if (!n[r])
                    continue;
                const i = e[r];
                if (t.includes(i))
                    continue;
                let s = !0;
                for (const e of this.bindings) {
                    if (e.space.value.names.includes(i)) {
                        s = !1;
                        break
                    }
                }
                n[r] = s
            }
            return n
        }
        get includeDimensionPredicate() {
            return this.includeDimensionPredicate_
        }
        set includeDimensionPredicate(e) {
            this.includeDimensionPredicate_ = e,
            this.update()
        }
        update() {
            const {combined: e, bindings: t} = this
              , n = this.retainCount > 0 ? 1 : 0;
            if (0 === t.size && !n)
                return void (e.value = v);
            const i = this.includeDimensionPredicate_
              , s = e.value;
            let a = Array.from(s.names)
              , o = Array.from(s.units)
              , l = Array.from(s.scales)
              , c = Array.from(s.ids)
              , u = Array.from(s.timestamps)
              , d = s.names.map(()=>n ? 1 : 0);
            const p = [];
            let f = !1;
            for (const e of t) {
                const {space: {value: t}, prevValue: r, mappedDimensionIds: s} = e;
                f = f || t.valid;
                const {names: m, units: g, scales: v, ids: b, timestamps: y} = t
                  , S = []
                  , w = [];
                p.push(w),
                e.mappedDimensionIds = S,
                e.prevValue = t;
                const x = m.length;
                for (let e = 0; e < x; ++e) {
                    const t = m[e];
                    if (!i(t))
                        continue;
                    if (void 0 !== r) {
                        const n = b[e]
                          , i = r.ids.indexOf(n);
                        if (-1 !== i) {
                            const n = s[i];
                            if (void 0 !== n) {
                                const i = c.indexOf(n);
                                if (-1 !== i) {
                                    S[e] = n,
                                    ++d[i],
                                    w[e] = i;
                                    const r = y[e];
                                    void 0 === r || r <= u[i] || (a[i] = t,
                                    l[i] = v[e],
                                    o[i] = g[e],
                                    u[i] = r);
                                    continue
                                }
                            }
                        }
                    }
                    let p = a.indexOf(t);
                    if (-1 !== p) {
                        S[e] = c[p],
                        ++d[p],
                        w[e] = p;
                        continue
                    }
                    p = a.length,
                    w[e] = p,
                    d[p] = 1 + n,
                    a[p] = t,
                    o[p] = g[e],
                    l[p] = v[e],
                    u[p] = y[e];
                    const f = h();
                    c[p] = f,
                    S[e] = f
                }
            }
            const {dimensionRefCounts: b} = this;
            b.clear();
            let y = 0;
            const S = [];
            let w = a.length;
            for (const e of t) {
                const {space: {value: t}} = e
                  , n = p[y++]
                  , {rank: i} = t
                  , s = Array.from(t.names)
                  , c = Array.from(t.timestamps)
                  , d = Float64Array.from(t.scales)
                  , h = Array.from(t.units);
                for (let e = 0; e < i; ++e) {
                    const t = n[e];
                    void 0 !== t && (h[e] = o[t],
                    d[e] = l[t],
                    c[e] = u[t],
                    s[e] = a[t])
                }
                for (const e of s) {
                    let t = b.get(e);
                    void 0 === t ? t = 1 : ++t,
                    b.set(e, t)
                }
                if (!(Object(r.a)(h, t.units) && Object(r.a)(d, t.scales) && Object(r.a)(s, t.names) && Object(r.a)(c, t.timestamps))) {
                    const n = g({
                        valid: t.valid,
                        ids: t.ids,
                        scales: d,
                        units: h,
                        names: s,
                        timestamps: c,
                        boundingBoxes: t.boundingBoxes
                    });
                    e.prevValue = n,
                    e.space.value = n
                }
            }
            {
                for (let e = 0; e < w; ++e)
                    i(a[e]) || (d[e] = 0);
                const e = (e,t)=>0 !== d[t];
                a = a.filter(e),
                o = o.filter(e),
                l = l.filter(e),
                c = c.filter(e),
                u = u.filter(e),
                d = d.filter(e),
                w = a.length
            }
            for (const e of t) {
                const {space: {value: t}} = e
                  , {boundingBoxes: n} = t;
                if (0 === n.length)
                    continue;
                const i = t.names.map(e=>a.indexOf(e));
                for (const e of n)
                    S.push(M(e, w, i))
            }
            const x = g({
                valid: f,
                ids: c,
                names: a,
                units: o,
                scales: new Float64Array(l),
                boundingBoxes: S
            });
            if (n)
                for (let e = 0; e < w; ++e)
                    --d[e];
            m(s, x) || (this.prevCombined = x,
            e.value = x)
        }
        retain() {
            return ++this.retainCount,
            ()=>{
                0 == --this.retainCount && this.update()
            }
        }
        bind(e) {
            const t = {
                space: e,
                mappedDimensionIds: [],
                prevValue: void 0
            }
              , {bindings: n} = this;
            0 === n.size && this.combined.changed.add(this.handleCombinedChanged),
            n.add(t);
            const i = e.changed.add(()=>{
                e.value !== t.prevValue && this.update()
            }
            );
            return this.update(),
            ()=>{
                i();
                const {bindings: e} = this;
                e.delete(t),
                0 === e.size && this.combined.changed.remove(this.handleCombinedChanged),
                this.update()
            }
        }
    }
    function q(e, t, n, i, r) {
        const s = r.length
          , a = new e((s + 1) ** 2);
        a[a.length - 1] = 1;
        for (let e = 0; e < s; ++e) {
            const o = i[e];
            a[(s + 1) * s + e] = t[(n + 1) * n + o];
            for (let i = 0; i < s; ++i) {
                const l = r[i];
                a[(s + 1) * i + e] = t[(n + 1) * l + o]
            }
        }
        return a
    }
    function Y(e) {
        if (void 0 === e)
            return;
        const t = new Float64Array(16);
        if (Array.isArray(e))
            if (16 === e.length)
                for (let n = 0; n < 4; ++n)
                    for (let i = 0; i < 4; ++i)
                        t[4 * n + i] = Object(a.p)(e[4 * i + n]);
            else {
                Object(a.a)(e, 4);
                for (let n = 0; n < 4; ++n) {
                    const i = Object(a.a)(e[n], 4);
                    for (let e = 0; e < 4; ++e)
                        t[4 * e + n] = Object(a.p)(i[e])
                }
            }
        else {
            Object(a.w)(e);
            const n = s.o.create()
              , i = s.t.create()
              , r = s.t.fromValues(1, 1, 1);
            Object(a.B)(e, "rotation", e=>{
                Object(a.c)(n, e),
                s.o.normalize(n, n)
            }
            ),
            Object(a.B)(e, "translation", e=>{
                Object(a.c)(i, e)
            }
            ),
            Object(a.B)(e, "scale", e=>{
                Object(a.c)(r, e)
            }
            );
            const o = s.l.create();
            s.l.fromRotationTranslationScale(o, n, i, r),
            t.set(o)
        }
        return {
            sourceRank: 3,
            transform: t,
            outputSpace: g({
                valid: !0,
                names: ["x", "y", "z"],
                units: ["m", "m", "m"],
                scales: Float64Array.of(1e-9, 1e-9, 1e-9)
            }),
            inputSpace: void 0
        }
    }
    function X(e) {
        if (void 0 === e)
            return;
        const t = Object(a.w)(e)
          , n = Object(a.y)(t, "outputDimensions", S)
          , i = n.rank
          , r = Object(a.y)(t, "sourceRank", e=>{
            if (void 0 === e)
                return i;
            if (!Number.isInteger(e) || e < 0 || e > i)
                throw new Error(`Expected integer in range [0, ${i}] but received: ${JSON.stringify(e)}`);
            return e
        }
        )
          , s = Object(a.B)(t, "inputDimensions", e=>{
            const t = S(e, !0);
            if (t.rank !== i)
                throw new Error(`Expected rank of ${i}, but received rank of: ${t.rank}`);
            return t
        }
        );
        return {
            transform: Object(a.B)(t, "matrix", e=>{
                const t = new Float64Array((i + 1) ** 2)
                  , n = Object(a.a)(e, i);
                t[t.length - 1] = 1;
                for (let e = 0; e < i; ++e)
                    try {
                        const r = Object(a.a)(n[e], i + 1);
                        for (let n = 0; n <= i; ++n)
                            t[(i + 1) * n + e] = Object(a.p)(r[n])
                    } catch (t) {
                        throw new Error(`Error in row ${e}: ${t.message}`)
                    }
                return t
            }
            ),
            outputSpace: n,
            inputSpace: s,
            sourceRank: r
        }
    }
    function K(e) {
        if (void 0 === e)
            return;
        const {transform: t, outputSpace: n, inputSpace: i, sourceRank: r} = e;
        let s;
        const a = n.rank;
        if (void 0 !== t) {
            s = [];
            for (let e = 0; e < a; ++e) {
                const n = [];
                s[e] = n;
                for (let i = 0; i <= a; ++i)
                    n[i] = t[(a + 1) * i + e]
            }
        }
        return {
            sourceRank: r === a ? void 0 : r,
            matrix: s,
            outputDimensions: w(n),
            inputDimensions: void 0 === i ? void 0 : w(i)
        }
    }
    function Z(e, t) {
        const {ids: n, names: i, scales: r, units: s, timestamps: a} = e;
        return g({
            rank: t.length,
            valid: e.valid,
            ids: t.map(e=>n[e]),
            names: t.map(e=>i[e]),
            timestamps: t.map(e=>a[e]),
            scales: Float64Array.from(t, e=>r[e]),
            units: t.map(e=>s[e]),
            boundingBoxes: e.boundingBoxes.map(n=>function(e, t, n) {
                const {box: i, transform: r} = e
                  , s = e.box.lowerBounds.length
                  , a = t.length
                  , o = new Float64Array((s + 1) * a);
                for (let e = 0; e < a; ++e)
                    for (let i = 0; i <= s; ++i) {
                        const s = t[e];
                        o[e + i * a] = r[s + i * n]
                    }
                if (!o.every(e=>0 === e))
                    return {
                        transform: o,
                        box: i
                    }
            }(n, t, e.rank)).filter(e=>void 0 !== e)
        })
    }
    function Q(e, t, n) {
        return t === n ? e : Z(e, Object(r.g)(e.rank, n, t))
    }
    function ee(e, t) {
        const {transform: n, rank: i} = e
          , r = Object(s.b)(n, i, [t]);
        if (1 !== r.length)
            return;
        const [a] = r
          , o = n[(i + 1) * a + t]
          , {inputSpace: l} = e;
        return {
            scale: l.scales[a] * o,
            unit: l.units[a]
        }
    }
    function te(e, t) {
        const {scales: n, units: i} = e.defaultInputSpace;
        return t < n.length ? {
            scale: n[t],
            unit: i[t]
        } : void 0
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        for (; ; ) {
            let t = e.firstChild;
            if (!t)
                break;
            e.removeChild(t)
        }
    }
    function r(e) {
        let {parentElement: t} = e;
        return !!t && (t.removeChild(e),
        !0)
    }
    function s(e, t=Math.max(1, e.value.length)) {
        const n = `${t}ch`;
        e.style.width !== n && (e.style.width = "0px",
        e.offsetWidth,
        e.style.width = n)
    }
    function a(e, t) {
        let n = e.firstElementChild;
        for (const i of t)
            i !== n && e.insertBefore(i, n),
            n = i.nextElementSibling;
        for (; null !== n; ) {
            let t = n.nextElementSibling;
            e.removeChild(n),
            n = t
        }
    }
    function o(e) {
        return e instanceof HTMLElement && !!(e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e.isContentEditable)
    }
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return r
    }
    )),
    n.d(t, "e", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ))
}
, function(e, t, n) {
    "use strict";
    function i(e, t) {
        let n = e.length
          , i = 0;
        for (let r = 0; r < n; ++r)
            t(e[r], r, e) && (e[i] = e[r],
            ++i);
        e.length = i
    }
    function r(e, t) {
        if (e.length === t)
            return e;
        let n = new e.constructor(t);
        return n.set(e),
        n
    }
    function s(e, t, n, i) {
        const r = e.length / t
          , s = e.length * n * i
          , a = new e.constructor(s)
          , o = e.length * i
          , l = t
          , c = t * i;
        for (let s = 0; s < r; ++s)
            for (let r = 0; r < t; ++r) {
                const u = e[s * t + r]
                  , d = s * c + r;
                for (let e = 0; e < n; ++e)
                    for (let t = 0; t < i; ++t)
                        a[e * o + t * l + d] = u
            }
        return a
    }
    function a(e, t, n) {
        let i = t - e;
        for (; i > 0; ) {
            let t = Math.floor(i / 2)
              , r = e + t;
            n(r) ? i = t : (e = r + 1,
            i -= t + 1)
        }
        return e
    }
    function o(e, t) {
        const n = [];
        for (let i = 0, r = e.length; i < r; ++i)
            e[i] === t && n.push(i);
        return n
    }
    function l(e, t) {
        const n = e.length;
        if (t.length !== n)
            return !1;
        for (let i = 0; i < n; ++i)
            if (e[i] !== t[i])
                return !1;
        return !0
    }
    function c(e, t, n=((e,t)=>e === t)) {
        const i = e.length;
        if (t.length !== i)
            return !1;
        for (let r = 0; r < i; ++r)
            if (!n(e[r], t[r]))
                return !1;
        return !0
    }
    function u(e, t, n) {
        const i = [];
        if (n === t) {
            for (let t = 0; t < e; ++t)
                i[t] = t;
            return i
        }
        i[n] = t;
        for (let r = 0, s = 0; r < e; )
            r !== t ? (s === n && ++s,
            i[s++] = r++) : ++r;
        return i
    }
    function d(e, t, n) {
        for (let i = 0, r = n.length; i < r; ++i) {
            const r = n[i];
            -1 !== r && (e[r] = t[i])
        }
        return e
    }
    function h(e, t, n) {
        for (let i = 0, r = n.length; i < r; ++i) {
            const r = n[i];
            -1 !== r && (e[i] = t[r])
        }
        return e
    }
    function p(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; ++n) {
            const i = e[n];
            for (let e = 0, n = i.length; e < n; ++e) {
                let n = t[e];
                void 0 === n && (n = t[e] = []),
                n.push(i[e])
            }
        }
        return t
    }
    n.d(t, "d", (function() {
        return i
    }
    )),
    n.d(t, "h", (function() {
        return r
    }
    )),
    n.d(t, "j", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "g", (function() {
        return u
    }
    )),
    n.d(t, "i", (function() {
        return d
    }
    )),
    n.d(t, "f", (function() {
        return h
    }
    )),
    n.d(t, "k", (function() {
        return p
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return l
    }
    )),
    n.d(t, "i", (function() {
        return u
    }
    )),
    n.d(t, "h", (function() {
        return h
    }
    )),
    n.d(t, "g", (function() {
        return f
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "b", (function() {
        return v
    }
    )),
    n.d(t, "d", (function() {
        return b
    }
    )),
    n.d(t, "j", (function() {
        return y
    }
    )),
    n.d(t, "f", (function() {
        return S
    }
    ));
    var i = n(16)
      , r = n.n(i)
      , s = n(2)
      , a = n(3);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o {
        constructor(e) {
            this.value_ = e,
            this.changed = new a.a
        }
        get value() {
            return this.value_
        }
        set value(e) {
            e !== this.value_ && (this.value_ = e,
            this.changed.dispatch())
        }
    }
    class l extends o {
        constructor(e, t, n=e) {
            super(e),
            this.validator = t,
            this.defaultValue = n
        }
        toJSON() {
            let {value_: e} = this;
            if (e !== this.defaultValue)
                return this.value_
        }
        reset() {
            this.value = this.defaultValue
        }
        restoreState(e) {
            if (void 0 !== e) {
                let {validator: t} = this;
                try {
                    return void (this.value = t(e))
                } catch (e) {}
            }
            this.value = this.defaultValue
        }
    }
    class c extends s.a {
        constructor(e, t) {
            super(),
            this.changed = new a.a,
            this.f = e,
            this.ws = t;
            for (const e of t)
                this.registerDisposer(e.changed.add(this.changed.dispatch))
        }
        get value() {
            return this.f(...this.ws.map(e=>e.value))
        }
    }
    function u(e, ...t) {
        return new c(e,t)
    }
    class d extends s.a {
        constructor(e, t) {
            super(),
            this.changed = new a.a,
            this.valueGeneration = -1,
            this.f = e,
            this.ws = t;
            for (const e of t)
                this.registerDisposer(e.changed.add(this.changed.dispatch))
        }
        get value() {
            const e = this.changed.count;
            return e !== this.valueGeneration && (this.value_ = this.f(...this.ws.map(e=>e.value)),
            this.valueGeneration = e),
            this.value_
        }
    }
    function h(e, ...t) {
        return new d(e,t)
    }
    class p extends s.a {
        constructor(e, t=((e,t)=>e === t)) {
            super(),
            this.changed = new a.a,
            this.value = e.value,
            this.registerDisposer(e.changed.add(()=>{
                const n = e.value;
                t(this.value, n) || (this.value = n,
                this.changed.dispatch())
            }
            ))
        }
    }
    function f(e, t, n) {
        const i = new c(e,t)
          , r = new p(i,n);
        return r.registerDisposer(i),
        r
    }
    class m extends s.a {
        constructor(e) {
            super(),
            this.changed = new a.a;
            const t = e(this)
              , n = Object.keys(t)
              , i = ()=>{
                const e = {};
                for (const i of n)
                    e[i] = t[i].value;
                this.value = e,
                this.changed.dispatch()
            }
            ;
            i();
            for (const e of n) {
                const n = t[e];
                this.registerDisposer(n.changed.add(()=>i()))
            }
        }
    }
    s.a;
    class g extends s.a {
        constructor() {
            super(...arguments),
            this.changed = new a.a
        }
        get value() {
            return this.value_
        }
        set value(e) {
            const {value_: t} = this;
            if (this.value_ = e,
            void 0 !== t && (t.dispose(),
            t.unregisterDisposer(this.valueHandler),
            this.valueHandler = void 0),
            void 0 !== e) {
                const t = this.valueHandler = ()=>{
                    this.value_ === e && (this.value_ = void 0,
                    this.changed.dispatch())
                }
                ;
                e.registerDisposer(t)
            }
            e !== t && this.changed.dispatch()
        }
        reset() {
            this.value = void 0
        }
        disposed() {
            void 0 !== this.value_ && (this.value_.unregisterDisposer(this.valueHandler),
            this.value_.dispose()),
            this.value_ = void 0,
            super.disposed()
        }
    }
    class v extends g {
        constructor(e, t) {
            super(),
            this.validator = e,
            this.jsonConverter = t
        }
        toJSON() {
            const {value: e} = this;
            return e && this.jsonConverter(e)
        }
        restoreState(e) {
            this.value = this.validator(e)
        }
    }
    class b {
        constructor(e) {
            this.changed = new a.a,
            this.values = void 0 === e ? new Set : new Set(e)
        }
        add(e) {
            const {values: t} = this;
            return t.has(e) || (t.add(e),
            this.changed.dispatch()),
            this
        }
        delete(e) {
            const {values: t} = this;
            return !!t.delete(e) && (this.changed.dispatch(),
            !0)
        }
        has(e) {
            return this.values.has(e)
        }
        get size() {
            return this.values.size
        }
        [Symbol.iterator]() {
            return this.values[Symbol.iterator]()
        }
        clear() {
            const {values: e} = this;
            e.size > 0 && (e.clear(),
            this.changed.dispatch())
        }
    }
    function y(e, ...t) {
        let n = t.map(e=>e.value);
        const i = t.length;
        let a = new s.a
          , o = e(a, ...n);
        const l = r()(()=>{
            let r = !1;
            for (let e = 0; e < i; ++e) {
                const i = t[e].value;
                n[e] !== i && (n[e] = i,
                r = !0)
            }
            r && (a.dispose(),
            a = new s.a,
            o = e(a, ...n))
        }
        , 0)
          , c = t.map(e=>e.changed.add(l));
        return {
            flush() {
                l.flush()
            },
            dispose() {
                l.cancel(),
                Object(s.d)(c),
                a.dispose()
            },
            get value() {
                return l.flush(),
                o
            }
        }
    }
    function S(e) {
        return {
            changed: a.c,
            value: e
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return d
    }
    )),
    n.d(t, "e", (function() {
        return i
    }
    )),
    n.d(t, "i", (function() {
        return h
    }
    )),
    n.d(t, "g", (function() {
        return p
    }
    )),
    n.d(t, "l", (function() {
        return f
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "k", (function() {
        return v
    }
    )),
    n.d(t, "h", (function() {
        return x
    }
    )),
    n.d(t, "d", (function() {
        return C
    }
    )),
    n.d(t, "f", (function() {
        return O
    }
    )),
    n.d(t, "m", (function() {
        return k
    }
    )),
    n.d(t, "n", (function() {
        return E
    }
    )),
    n.d(t, "c", (function() {
        return T
    }
    )),
    n.d(t, "j", (function() {
        return M
    }
    ));
    var i, r = n(6), s = n(2), a = n(103), o = n(0), l = n(59), c = n(3), u = n(21);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class d extends s.a {
        constructor(e) {
            super(),
            this.id = e,
            this.changed = new c.a
        }
    }
    !function(e) {
        e[e.POINT = 0] = "POINT",
        e[e.LINE = 1] = "LINE",
        e[e.AXIS_ALIGNED_BOUNDING_BOX = 2] = "AXIS_ALIGNED_BOUNDING_BOX",
        e[e.ELLIPSOID = 3] = "ELLIPSOID"
    }(i || (i = {}));
    const h = [i.POINT, i.LINE, i.AXIS_ALIGNED_BOUNDING_BOX, i.ELLIPSOID]
      , p = {
        rgb: {
            serializedBytes: ()=>3,
            alignment: ()=>1,
            serializeCode: (e,t)=>`dv.setUint16(${t}, ${e}, true);` + `dv.setUint8(${t} + 2, ${e} >>> 16);`,
            deserializeCode: (e,t)=>`${e} = dv.getUint16(${t}, true) | (dv.getUint8(${t} + 2) << 16);`
        },
        rgba: {
            serializedBytes: ()=>4,
            alignment: ()=>1,
            serializeCode: (e,t)=>`dv.setUint32(${t}, ${e}, true);`,
            deserializeCode: (e,t)=>`${e} = dv.getUint32(${t}, true);`
        },
        float32: {
            serializedBytes: ()=>4,
            alignment: ()=>4,
            serializeCode: (e,t)=>`dv.setFloat32(${t}, ${e}, isLittleEndian);`,
            deserializeCode: (e,t)=>`${e} = dv.getFloat32(${t}, isLittleEndian);`
        },
        uint32: {
            serializedBytes: ()=>4,
            alignment: ()=>4,
            serializeCode: (e,t)=>`dv.setUint32(${t}, ${e}, isLittleEndian);`,
            deserializeCode: (e,t)=>`${e} = dv.getUint32(${t}, isLittleEndian);`
        },
        int32: {
            serializedBytes: ()=>4,
            alignment: ()=>4,
            serializeCode: (e,t)=>`dv.setInt32(${t}, ${e}, isLittleEndian);`,
            deserializeCode: (e,t)=>`${e} = dv.getInt32(${t}, isLittleEndian);`
        },
        uint16: {
            serializedBytes: ()=>2,
            alignment: ()=>2,
            serializeCode: (e,t)=>`dv.setUint16(${t}, ${e}, isLittleEndian);`,
            deserializeCode: (e,t)=>`${e} = dv.getUint16(${t}, isLittleEndian);`
        },
        int16: {
            serializedBytes: ()=>2,
            alignment: ()=>2,
            serializeCode: (e,t)=>`dv.setInt16(${t}, ${e}, isLittleEndian);`,
            deserializeCode: (e,t)=>`${e} = dv.getInt16(${t}, isLittleEndian);`
        },
        uint8: {
            serializedBytes: ()=>1,
            alignment: ()=>1,
            serializeCode: (e,t)=>`dv.setUint8(${t}, ${e});`,
            deserializeCode: (e,t)=>`${e} = dv.getUint8(${t});`
        },
        int8: {
            serializedBytes: ()=>2,
            alignment: ()=>1,
            serializeCode: (e,t)=>`dv.setInt8(${t}, ${e});`,
            deserializeCode: (e,t)=>`${e} = dv.getInt8(${t});`
        }
    };
    function f(e, t) {
        let n = 0;
        const i = t.length
          , r = new Array(i);
        for (let e = 0; e < i; ++e)
            r[e] = e;
        const s = n=>p[t[n].type].alignment(e);
        r.sort((e,t)=>s(t) - s(e));
        const a = new Array(i);
        for (let s = 0; s < i; ++s) {
            const i = r[s]
              , o = t[i]
              , l = p[o.type]
              , c = l.serializedBytes(e)
              , u = l.alignment(e);
            n += (u - n % u) % u,
            a[i] = n,
            n += c
        }
        return n += (4 - n % 4) % 4,
        {
            serializedBytes: n,
            offsets: a
        }
    }
    class m {
        constructor(e, t) {
            if (this.rank = e,
            this.propertySpecs = t,
            0 === t.length)
                return this.serializedBytes = 0,
                void (this.serialize = this.deserialize = ()=>{}
                );
            let n = ""
              , i = "";
            const {serializedBytes: r, offsets: s} = f(e, t)
              , a = t.length;
            for (let r = 0; r < a; ++r) {
                const a = t[r]
                  , o = p[a.type]
                  , l = `properties[${r}]`
                  , c = `offset + ${s[r]}`;
                n += o.serializeCode(l, c, e),
                i += o.deserializeCode(l, c, e)
            }
            this.serializedBytes = r,
            this.serialize = new Function("dv","offset","isLittleEndian","properties",n),
            this.deserialize = new Function("dv","offset","isLittleEndian","properties",i)
        }
    }
    const g = new Map;
    function v(e) {
        return g.get(e)
    }
    function b(e, t, n, i, r) {
        for (let s = 0; s < i; ++s)
            e.setFloat32(t, r[s], n),
            t += 4;
        return t
    }
    function y(e, t, n, i, r, s) {
        return t = b(e, t, n, i, r),
        t = b(e, t, n, i, s)
    }
    function S(e, t, n, i, r) {
        for (let s = 0; s < i; ++s)
            r[s] = e.getFloat32(t, n),
            t += 4;
        return t
    }
    function w(e, t, n, i, r, s) {
        return t = S(e, t, n, i, r),
        t = S(e, t, n, i, s)
    }
    function x(e, t) {
        const n = v(e.type).toJSON(e, t.rank);
        n.type = i[e.type].toLowerCase(),
        n.id = e.id,
        n.description = e.description || void 0;
        const {relatedSegments: r} = e;
        return void 0 !== r && r.some(e=>0 !== e.length) && (n.segments = r.map(e=>e.map(e=>e.toString()))),
        0 !== t.properties.length && (n.props = e.properties.slice()),
        n
    }
    g.set(i.LINE, {
        icon: "",
        description: "Line",
        toJSON: e=>({
            pointA: Array.from(e.pointA),
            pointB: Array.from(e.pointB)
        }),
        restoreState(e, t, n) {
            e.pointA = Object(o.y)(t, "pointA", e=>Object(o.d)(new Float32Array(n), e, o.p)),
            e.pointB = Object(o.y)(t, "pointB", e=>Object(o.d)(new Float32Array(n), e, o.p))
        },
        serializedBytes: e=>8 * e,
        serialize(e, t, n, i, r) {
            y(e, t, n, i, r.pointA, r.pointB)
        },
        deserialize: (e,t,n,r,s)=>{
            const a = new Float32Array(r)
              , o = new Float32Array(r);
            return w(e, t, n, r, a, o),
            {
                type: i.LINE,
                pointA: a,
                pointB: o,
                id: s,
                properties: []
            }
        }
    }),
    g.set(i.POINT, {
        icon: "",
        description: "Point",
        toJSON: e=>({
            point: Array.from(e.point)
        }),
        restoreState: (e,t,n)=>{
            e.point = Object(o.y)(t, "point", e=>Object(o.d)(new Float32Array(n), e, o.p))
        }
        ,
        serializedBytes: e=>4 * e,
        serialize: (e,t,n,i,r)=>{
            b(e, t, n, i, r.point)
        }
        ,
        deserialize: (e,t,n,r,s)=>{
            const a = new Float32Array(r);
            return S(e, t, n, r, a),
            {
                type: i.POINT,
                point: a,
                id: s,
                properties: []
            }
        }
    }),
    g.set(i.AXIS_ALIGNED_BOUNDING_BOX, {
        icon: "",
        description: "Bounding Box",
        toJSON: e=>({
            pointA: Array.from(e.pointA),
            pointB: Array.from(e.pointB)
        }),
        restoreState: (e,t,n)=>{
            e.pointA = Object(o.y)(t, "pointA", e=>Object(o.d)(new Float32Array(n), e, o.p)),
            e.pointB = Object(o.y)(t, "pointB", e=>Object(o.d)(new Float32Array(n), e, o.p))
        }
        ,
        serializedBytes: e=>8 * e,
        serialize(e, t, n, i, r) {
            y(e, t, n, i, r.pointA, r.pointB)
        },
        deserialize: (e,t,n,r,s)=>{
            const a = new Float32Array(r)
              , o = new Float32Array(r);
            return w(e, t, n, r, a, o),
            {
                type: i.AXIS_ALIGNED_BOUNDING_BOX,
                pointA: a,
                pointB: o,
                id: s,
                properties: []
            }
        }
    }),
    g.set(i.ELLIPSOID, {
        icon: "",
        description: "Ellipsoid",
        toJSON: e=>({
            center: Array.from(e.center),
            radii: Array.from(e.radii)
        }),
        restoreState: (e,t,n)=>{
            e.center = Object(o.y)(t, "center", e=>Object(o.d)(new Float32Array(n), e, o.p)),
            e.radii = Object(o.y)(t, "radii", e=>Object(o.d)(new Float32Array(n), e, o.q))
        }
        ,
        serializedBytes: e=>8 * e,
        serialize(e, t, n, i, r) {
            y(e, t, n, i, r.center, r.radii)
        },
        deserialize: (e,t,n,r,s)=>{
            const a = new Float32Array(r)
              , o = new Float32Array(r);
            return w(e, t, n, r, a, o),
            {
                type: i.ELLIPSOID,
                center: a,
                radii: o,
                id: s,
                properties: []
            }
        }
    });
    class C extends s.a {
        constructor(e, t=[], n=[]) {
            super(),
            this.relationships = t,
            this.properties = n,
            this.annotationMap = new Map,
            this.changed = new c.a,
            this.readonly = !1,
            this.childAdded = new c.b,
            this.childUpdated = new c.b,
            this.childDeleted = new c.b,
            this.pending = new Set,
            this.references = new Map,
            this.rank_ = e,
            this.annotationPropertySerializer = new m(e,n)
        }
        get rank() {
            return this.rank_
        }
        add(e, t=!0) {
            if (this.ensureUpdated(),
            e.id) {
                if (this.annotationMap.has(e.id))
                    throw new Error(`Annotation id already exists: ${JSON.stringify(e.id)}.`)
            } else
                e.id = k();
            return this.annotationMap.set(e.id, e),
            this.changed.dispatch(),
            this.childAdded.dispatch(e),
            t || this.pending.add(e.id),
            this.getReference(e.id)
        }
        commit(e) {
            this.ensureUpdated();
            const t = e.id;
            this.pending.delete(t)
        }
        update(e, t) {
            if (this.ensureUpdated(),
            null === e.value)
                throw new Error("Annotation already deleted.");
            e.value = t,
            this.annotationMap.set(t.id, t),
            e.changed.dispatch(),
            this.changed.dispatch(),
            this.childUpdated.dispatch(t)
        }
        [Symbol.iterator]() {
            return this.ensureUpdated(),
            this.annotationMap.values()
        }
        get(e) {
            return this.ensureUpdated(),
            this.annotationMap.get(e)
        }
        delete(e) {
            null !== e.value && (e.value = null,
            this.annotationMap.delete(e.id),
            this.pending.delete(e.id),
            e.changed.dispatch(),
            this.changed.dispatch(),
            this.childDeleted.dispatch(e.id))
        }
        getReference(e) {
            let t = this.references.get(e);
            return void 0 !== t ? t.addRef() : (t = new d(e),
            t.value = this.annotationMap.get(e) || null,
            this.references.set(e, t),
            t.registerDisposer(()=>{
                this.references.delete(e)
            }
            ),
            t)
        }
        ensureUpdated() {}
        toJSON() {
            this.ensureUpdated();
            const e = []
              , {pending: t} = this;
            for (const n of this)
                t.has(n.id) || e.push(x(n, this));
            return e
        }
        clear() {
            this.annotationMap.clear(),
            this.pending.clear(),
            this.changed.dispatch()
        }
        restoreState(e) {
            this.ensureUpdated();
            const {annotationMap: t} = this;
            t.clear(),
            this.pending.clear(),
            void 0 !== e && Object(o.b)(e, e=>{
                const n = function(e, t, n=!1) {
                    Object(o.w)(e);
                    const r = Object(o.y)(e, "type", e=>Object(o.o)(e, i))
                      , s = Object(o.y)(e, "id", n ? o.C : o.E) || k()
                      , a = Object(o.y)(e, "segments", e=>{
                        if (void 0 === e)
                            return t.relationships.map(()=>[]);
                        const n = Object(o.a)(e);
                        return 0 === n.length ? t.relationships.map(()=>[]) : 1 !== t.relationships.length || Array.isArray(n[0]) ? Object(o.b)(Object(o.a)(e, t.relationships.length), e=>Object(o.b)(e, e=>u.a.parseString(e))) : [Object(o.b)(n, e=>u.a.parseString(e))]
                    }
                    )
                      , l = Object(o.y)(e, "props", e=>void 0 === e ? t.properties.map(e=>e.default) : Object(o.b)(Object(o.a)(e, t.properties.length), e=>Number(e)))
                      , c = {
                        id: s,
                        description: Object(o.y)(e, "description", o.C),
                        relatedSegments: a,
                        properties: l,
                        type: r
                    };
                    return v(r).restoreState(c, e, t.rank),
                    c
                }(e, this);
                t.set(n.id, n)
            }
            );
            for (const e of this.references.values()) {
                const {id: n} = e
                  , i = t.get(n);
                e.value = i || null,
                e.changed.dispatch()
            }
            this.changed.dispatch()
        }
        reset() {
            this.clear()
        }
    }
    class O extends C {
        constructor(e) {
            super(e.value.sourceRank, ["segments"]),
            this.watchableTransform = e,
            this.curCoordinateTransform = e.value,
            this.registerDisposer(e.changed.add(()=>this.ensureUpdated()))
        }
        get rank() {
            return this.ensureUpdated(),
            this.rank_
        }
        ensureUpdated() {
            const e = this.watchableTransform.value
              , {curCoordinateTransform: t} = this;
            if (e === t)
                return;
            this.curCoordinateTransform = e;
            const n = e.sourceRank
              , s = t.sourceRank;
            if (s === n && (t.inputSpace === e.inputSpace || Object(r.a)(t.inputSpace.ids.slice(0, n), e.inputSpace.ids.slice(0, n))))
                return;
            const {ids: a} = e.inputSpace
              , o = t.inputSpace.ids
              , l = [];
            for (let e = 0; e < n; ++e) {
                let t = o.indexOf(a[e]);
                t >= s && (t = -1),
                l.push(t)
            }
            const c = e=>{
                const t = new Float32Array(n);
                for (let i = 0; i < n; ++i) {
                    const n = l[i];
                    t[i] = -1 === n ? 0 : e[i]
                }
                return t
            }
            ;
            for (const e of this.annotationMap.values())
                switch (e.type) {
                case i.POINT:
                    e.point = c(e.point);
                    break;
                case i.LINE:
                case i.AXIS_ALIGNED_BOUNDING_BOX:
                    e.pointA = c(e.pointA),
                    e.pointB = c(e.pointB);
                    break;
                case i.ELLIPSOID:
                    e.center = c(e.center),
                    e.radii = c(e.radii)
                }
            this.rank_ = n,
            this.changed.dispatch()
        }
    }
    function k() {
        return Object(l.a)(160)
    }
    function E(e) {
        const t = new C(e.lowerBounds.length);
        return t.readonly = !0,
        t.add(function(e) {
            return {
                type: i.AXIS_ALIGNED_BOUNDING_BOX,
                id: "data-bounds",
                description: "Data Bounds",
                pointA: new Float32Array(e.lowerBounds),
                pointB: new Float32Array(e.upperBounds),
                properties: []
            }
        }(e)),
        t
    }
    class T {
        constructor(e) {
            this.propertySerializer = e,
            this.annotations = [[], [], [], []]
        }
        add(e) {
            this.annotations[e.type].push(e)
        }
        serialize() {
            return function(e, t) {
                const {rank: n} = t;
                let i = 0;
                const r = []
                  , s = t.serializedBytes;
                for (const t of h) {
                    r[t] = i;
                    const a = e[t].length;
                    i += (v(t).serializedBytes(n) + s) * a,
                    i += (4 - i % 4) % 4
                }
                const o = t.serialize
                  , l = []
                  , c = []
                  , u = new ArrayBuffer(i)
                  , d = new DataView(u)
                  , p = a.a === a.b.LITTLE;
                for (const t of h) {
                    const i = e[t];
                    l[t] = i.map(e=>e.id),
                    c[t] = new Map(i.map((e,t)=>[e.id, t]));
                    const a = v(t)
                      , u = a.serialize
                      , h = a.serializedBytes(n);
                    let f = r[t];
                    for (const e of i)
                        u(d, f, p, n, e),
                        f += h,
                        o(d, f, p, e.properties),
                        f += s
                }
                return {
                    data: new Uint8Array(u),
                    typeToIds: l,
                    typeToOffset: r,
                    typeToIdMaps: c
                }
            }(this.annotations, this.propertySerializer)
        }
    }
    function M(e) {
        if (null == e)
            return e;
        const {relatedSegments: t} = e;
        if (void 0 !== t)
            for (let e = 0, n = t.length; e < n; ++e) {
                const n = t[e];
                void 0 !== n && (t[e] = n.map(e=>new u.a(e.low,e.high)))
            }
        return e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "e", (function() {
        return u
    }
    )),
    n.d(t, "c", (function() {
        return d
    }
    ));
    var i = n(44)
      , r = n(19);
    n.d(t, "a", (function() {
        return r.a
    }
    ));
    var s, a = n(1), o = n(15), l = n(43);
    !function(e) {
        e[e.UNKNOWN = 0] = "UNKNOWN",
        e[e.IMAGE = 1] = "IMAGE",
        e[e.SEGMENTATION = 2] = "SEGMENTATION"
    }(s || (s = {}));
    function c(e) {
        const {rank: t, dataType: n, compressedSegmentationBlockSize: r} = e
          , {baseVoxelOffset: s=new Float32Array(t)} = e;
        return Object.assign(Object.assign({}, Object(i.m)(e)), {
            compressedSegmentationBlockSize: r,
            baseVoxelOffset: s,
            dataType: n
        })
    }
    function u(e) {
        let {rank: t, compressedSegmentationBlockSize: n, dataType: a, lowerVoxelBound: u, upperVoxelBound: d} = e;
        if (void 0 === n && 3 === t && e.volumeType === s.SEGMENTATION && (a === r.a.UINT32 || a === r.a.UINT64)) {
            let {volumeSourceOptions: {displayRank: n, multiscaleToViewTransform: r}, chunkToMultiscaleTransform: s, chunkToViewTransform: a} = e;
            void 0 === a && (a = o.h(new Float32Array(t * n), n, r, n, s, t + 1, n, t, t));
            const {maxCompressedSegmentationBlockSize: h, chunkDataSize: p} = e;
            return c(Object.assign(Object.assign({}, e), {
                compressedSegmentationBlockSize: Float32Array.from(Object(i.l)({
                    rank: t,
                    chunkToViewTransform: a,
                    displayRank: n,
                    lowerVoxelBound: u,
                    upperVoxelBound: d,
                    maxVoxelsPerChunkLog2: 9,
                    maxBlockSize: void 0 === h ? p : l.d(new Uint32Array(t), p, h)
                }))
            }))
        }
        return c(e)
    }
    function d(e) {
        const {rank: t} = e
          , {volumeSourceOptions: {displayRank: n, multiscaleToViewTransform: r, modelChannelDimensionIndices: s}, chunkToMultiscaleTransform: l} = e
          , c = o.h(new Float32Array(n * t), n, r, n, l, t + 1, n, t, t);
        let {minBlockSize: d} = e;
        void 0 === d ? (d = new Uint32Array(t),
        d.fill(1)) : d = new Uint32Array(d);
        const {lowerVoxelBound: h, upperVoxelBound: p} = e;
        if (0 !== s.length)
            for (const e of Object(a.b)(l, t, s)) {
                let t = p[e];
                void 0 !== h && (t -= h[e]),
                d[e] = t
            }
        const {chunkDataSizes: f=Object(i.k)(Object.assign(Object.assign({
            rank: t
        }, e), {
            minBlockSize: d,
            chunkToViewTransform: c,
            displayRank: n
        }))} = e;
        return f.map(t=>u(Object.assign(Object.assign({}, e), {
            chunkDataSize: t,
            chunkToViewTransform: c
        })))
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var i;
    n.d(t, "g", (function() {
        return i
    }
    )),
    n.d(t, "l", (function() {
        return r
    }
    )),
    n.d(t, "f", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return a
    }
    )),
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "k", (function() {
        return l
    }
    )),
    n.d(t, "j", (function() {
        return c
    }
    )),
    n.d(t, "i", (function() {
        return u
    }
    )),
    n.d(t, "b", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "h", (function() {
        return f
    }
    )),
    function(e) {
        e[e.GPU_MEMORY = 0] = "GPU_MEMORY",
        e[e.SYSTEM_MEMORY = 1] = "SYSTEM_MEMORY",
        e[e.SYSTEM_MEMORY_WORKER = 2] = "SYSTEM_MEMORY_WORKER",
        e[e.DOWNLOADING = 3] = "DOWNLOADING",
        e[e.QUEUED = 4] = "QUEUED",
        e[e.NEW = 5] = "NEW",
        e[e.FAILED = 6] = "FAILED",
        e[e.EXPIRED = 7] = "EXPIRED"
    }(i || (i = {}));
    const r = 8;
    var s;
    !function(e) {
        e[e.FIRST_TIER = 0] = "FIRST_TIER",
        e[e.FIRST_ORDERED_TIER = 0] = "FIRST_ORDERED_TIER",
        e[e.VISIBLE = 0] = "VISIBLE",
        e[e.PREFETCH = 1] = "PREFETCH",
        e[e.LAST_ORDERED_TIER = 1] = "LAST_ORDERED_TIER",
        e[e.RECENT = 2] = "RECENT",
        e[e.LAST_TIER = 2] = "LAST_TIER"
    }(s || (s = {}));
    var a, o;
    !function(e) {
        e[e.totalTime = 0] = "totalTime",
        e[e.totalChunks = 1] = "totalChunks"
    }(a || (a = {})),
    function(e) {
        e[e.numChunks = 0] = "numChunks",
        e[e.systemMemoryBytes = 1] = "systemMemoryBytes",
        e[e.gpuMemoryBytes = 2] = "gpuMemoryBytes"
    }(o || (o = {}));
    const l = 3;
    function c(e, t) {
        return 3 * e + t
    }
    function u(e) {
        return 3 * r * l + e
    }
    const d = "ChunkQueueManager"
      , h = "ChunkManager"
      , p = "ChunkSource.invalidate"
      , f = "ChunkQueueManager.requestChunkStatistics"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    )),
    n.d(t, "b", (function() {
        return h
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "g", (function() {
        return m
    }
    )),
    n.d(t, "f", (function() {
        return g
    }
    ));
    var i = n(23)
      , r = n(2);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = !("undefined" != typeof Window && self instanceof Window);
    var a = new Map;
    function o(e, t) {
        a.set(e, t)
    }
    class l extends Error {
        constructor(e, t) {
            super(t),
            this.name = e,
            this.message = t
        }
    }
    function c(e, t) {
        o(e, (function(e) {
            let n = e.id;
            const r = new i.b;
            let s = t.call(this, e, r);
            this.set(n, {
                promise: s,
                cancellationToken: r
            }),
            s.then(({value: e, transfers: t})=>{
                this.delete(n),
                this.invoke("rpc.promise.response", {
                    id: n,
                    value: e
                }, t)
            }
            , e=>{
                this.delete(n),
                this.invoke("rpc.promise.response", {
                    id: n,
                    error: e.message,
                    errorName: e.name
                })
            }
            )
        }
        ))
    }
    o("rpc.promise.cancel", (function(e) {
        let t = e.id;
        const n = this.get(t);
        if (void 0 !== n) {
            let {cancellationToken: e} = n;
            e.cancel()
        }
    }
    )),
    o("rpc.promise.response", (function(e) {
        let t = e.id
          , {resolve: n, reject: r} = this.get(t);
        if (this.delete(t),
        e.hasOwnProperty("value"))
            n(e.value);
        else {
            e.errorName === i.a.name ? r(i.a) : r(new l(e.errorName,e.error))
        }
    }
    ));
    const u = s ? -1 : 0;
    class d {
        constructor(e) {
            this.target = e,
            this.objects = new Map,
            this.nextId = u,
            e.onmessage = e=>{
                let t = e.data;
                a.get(t.functionName).call(this, t)
            }
        }
        get numObjects() {
            return this.objects.size
        }
        set(e, t) {
            this.objects.set(e, t)
        }
        delete(e) {
            this.objects.delete(e)
        }
        get(e) {
            return this.objects.get(e)
        }
        getRef(e) {
            let t = e.id
              , n = this.get(t);
            return n.referencedGeneration = e.gen,
            n.addRef(),
            n
        }
        invoke(e, t, n) {
            t.functionName = e,
            this.target.postMessage(t, n)
        }
        promiseInvoke(e, t, n=i.e, r) {
            return Object(i.d)(n, (n,i,s)=>{
                const a = t.id = this.newId();
                this.set(a, {
                    resolve: n,
                    reject: i
                }),
                this.invoke(e, t, r),
                s.add(()=>{
                    this.invoke("rpc.promise.cancel", {
                        id: a
                    })
                }
                )
            }
            )
        }
        newId() {
            return s ? this.nextId-- : this.nextId++
        }
    }
    class h extends r.a {
        constructor() {
            super(...arguments),
            this.rpc = null,
            this.rpcId = null
        }
        initializeSharedObject(e, t=e.newId()) {
            this.rpc = e,
            this.rpcId = t,
            this.isOwner = !1,
            e.set(t, this)
        }
        initializeCounterpart(e, t={}) {
            this.initializeSharedObject(e),
            this.unreferencedGeneration = 0,
            this.referencedGeneration = 0,
            this.isOwner = !0,
            t.id = this.rpcId,
            t.type = this.RPC_TYPE_ID,
            e.invoke("SharedObject.new", t)
        }
        dispose() {
            super.dispose()
        }
        addCounterpartRef() {
            return {
                id: this.rpcId,
                gen: ++this.referencedGeneration
            }
        }
        refCountReachedZero() {
            !0 === this.isOwner ? this.referencedGeneration === this.unreferencedGeneration && this.ownerDispose() : !1 === this.isOwner ? this.rpc.invoke("SharedObject.refCountReachedZero", {
                id: this.rpcId,
                gen: this.referencedGeneration
            }) : super.refCountReachedZero()
        }
        ownerDispose() {
            let {rpc: e, rpcId: t} = this;
            super.refCountReachedZero(),
            e.delete(t),
            e.invoke("SharedObject.dispose", {
                id: t
            })
        }
        counterpartRefCountReachedZero(e) {
            this.unreferencedGeneration = e,
            0 === this.refCount && e === this.referencedGeneration && this.ownerDispose()
        }
    }
    class p extends h {
        constructor(e, t={}) {
            super(),
            function(e, t, n={}) {
                null != t && e.initializeSharedObject(t, n.id)
            }(this, e, t)
        }
    }
    o("SharedObject.dispose", (function(e) {
        let t = this.get(e.id);
        if (0 !== t.refCount)
            throw new Error("Attempted to dispose object with non-zero reference count.");
        t.disposed(),
        this.delete(t.rpcId),
        t.rpcId = null,
        t.rpc = null
    }
    )),
    o("SharedObject.refCountReachedZero", (function(e) {
        let t = this.get(e.id)
          , n = e.gen;
        t.counterpartRefCountReachedZero(n)
    }
    ));
    const f = new Map;
    function m(e) {
        return t=>{
            t.prototype.RPC_TYPE_ID = e
        }
    }
    function g(e) {
        return t=>{
            if (void 0 !== e)
                t.prototype.RPC_TYPE_ID = e;
            else if (void 0 === (e = t.prototype.RPC_TYPE_ID))
                throw new Error("RPC_TYPE_ID should have already been defined");
            f.set(e, t)
        }
    }
    o("SharedObject.new", (function(e) {
        let t = e.type;
        --new (f.get(t))(this,e).refCount
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(13);
    n.d(t, "a", (function() {
        return r.a
    }
    )),
    n.d(t, "c", (function() {
        return r.d
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = new Set(["f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "escape", "pause"])
      , a = new Set(["color", "date", "datetime", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"]);
    class o extends i.a {
        constructor(e, t) {
            super(),
            this.target = e,
            this.eventMap = t,
            this.modifierShortcutsAreGlobal = !0,
            this.allShortcutsAreGlobal = !1,
            this.allowSpaceKeyOnButtons = !1,
            this.registerEventListener(e, "keydown", this.handleKeyDown.bind(this), !1)
        }
        shouldIgnoreEvent(e, t) {
            var n = t.target;
            let {tagName: i} = n;
            if (n === this.target)
                return !1;
            var r = "TEXTAREA" === i || "INPUT" === i || "BUTTON" === i || "SELECT" === i
              , o = !r && (n.isContentEditable || n.ownerDocument && "on" === n.ownerDocument.designMode);
            return !(!r && !o) && (!this.allShortcutsAreGlobal && !s.has(e) && (!!o || (!(!this.modifierShortcutsAreGlobal || !(t.altKey || t.ctrlKey || t.metaKey)) || ("INPUT" === i && a.has(n.type) ? "enter" !== e : "INPUT" !== i && "BUTTON" !== i || !this.allowSpaceKeyOnButtons && "space" === e))))
        }
        handleKeyDown(e) {
            const t = function(e) {
                return e.code.toLowerCase()
            }(e);
            this.shouldIgnoreEvent(t, e) || Object(r.c)(t, e, e, this.eventMap)
        }
    }
}
, function(e, t, n) {
    "use strict";
    var i, r = n(2);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function s(e, t) {
        let n = "";
        return 1 & t && (n += "control+"),
        2 & t && (n += "alt+"),
        4 & t && (n += "meta+"),
        8 & t && (n += "shift+"),
        n += e,
        n
    }
    function a(e) {
        return "string" == typeof e ? {
            action: e
        } : e
    }
    function *o(e) {
        const t = e.indexOf(":")
          , n = function(e) {
            let t, n = e.split("+"), i = 0;
            for (let e of n)
                switch (e) {
                case "control":
                    i |= 1;
                    break;
                case "alt":
                    i |= 2;
                    break;
                case "meta":
                    i |= 4;
                    break;
                case "shift":
                    i |= 8;
                    break;
                default:
                    if (void 0 !== t)
                        return;
                    t = e
                }
            if (void 0 !== t)
                return s(t, i)
        }(e.substring(t + 1));
        if (void 0 === n)
            throw new Error(`Invalid event identifier: ${JSON.stringify(e)}`);
        if (-1 !== t) {
            const i = e.substring(0, t);
            if ("at" !== i && "bubble" !== i)
                throw new Error(`Invalid event phase: ${JSON.stringify(i)}`);
            yield`${i}:${n}`
        } else
            yield`at:${n}`,
            yield`bubble:${n}`
    }
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return u
    }
    )),
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "d", (function() {
        return h
    }
    )),
    function(e) {
        e[e.CONTROL = 1] = "CONTROL",
        e[e.ALT = 2] = "ALT",
        e[e.META = 4] = "META",
        e[e.SHIFT = 8] = "SHIFT"
    }(i || (i = {}));
    class l extends class {
        constructor(e) {
            if (this.parents = new Array,
            this.parentPriorities = new Array,
            this.bindings = new Map,
            void 0 !== e) {
                this.parents.push(...e.parents),
                this.parentPriorities.push(...e.parentPriorities);
                for (const [t,n] of e.bindings)
                    this.bindings.set(t, n)
            }
        }
        addParent(e, t) {
            const {parents: n, parentPriorities: i} = this;
            let r = 0;
            const {length: s} = n;
            for (; r < s && t < i[r]; )
                ++r;
            return n.splice(r, 0, e),
            i.splice(r, 0, t),
            ()=>{
                this.removeParent(e)
            }
        }
        removeParent(e) {
            const t = this.parents.indexOf(e);
            if (-1 === t)
                throw new Error("Attempt to remove non-existent parent map.");
            this.parents.splice(t, 1),
            this.parentPriorities.splice(t, 1)
        }
        set(e, t) {
            this.bindings.set(e, t)
        }
        delete(e) {
            this.bindings.delete(e)
        }
        clear() {
            this.bindings.clear(),
            this.parents.length = 0,
            this.parentPriorities.length = 0
        }
        get(e) {
            const {parents: t, parentPriorities: n} = this
              , i = n.length;
            let r, s = 0;
            for (; s < i && n[s] > 0; ++s)
                if (r = t[s].get(e),
                void 0 !== r)
                    return r;
            if (r = this.bindings.get(e),
            void 0 !== r)
                return r;
            for (; s < i; ++s)
                if (r = t[s].get(e),
                void 0 !== r)
                    return r
        }
        *getAll(e) {
            const {parents: t, parentPriorities: n} = this
              , i = n.length;
            let r;
            for (; 0 < i && n[0] > 0; )
                r = t[0].get(e),
                void 0 !== r && (yield r);
            for (r = this.bindings.get(e),
            void 0 !== r && (yield r); 0 < i; )
                r = t[0].get(e),
                void 0 !== r && (yield r)
        }
        *entries() {
            const {parents: e, parentPriorities: t} = this
              , n = t.length;
            for (; 0 < n && t[0] > 0; )
                yield*e[0].entries();
            for (yield*this.bindings.entries(); 0 < n; )
                yield*e[0].entries()
        }
    }
    {
        static fromObject(e, t={}) {
            const n = new l;
            if (n.label = t.label,
            void 0 !== t.parents)
                for (const [e,i] of t.parents)
                    n.addParent(e, i);
            for (const t of Object.keys(e))
                n.set(t, a(e[t]));
            return n
        }
        setFromObject(e) {
            for (const t of Object.keys(e))
                this.set(t, a(e[t]))
        }
        set(e, t) {
            const n = a(t);
            for (const t of o(e))
                super.set(t, n)
        }
        delete(e) {
            for (const t of o(e))
                super.delete(t)
        }
        describe() {
            const e = []
              , t = new Map;
            for (const [e,n] of this.entries()) {
                const i = e.indexOf(":");
                t.set(e.substring(i + 1), n.action)
            }
            for (const [n,i] of t)
                e.push(`${n}${i}`);
            return e.join(", ")
        }
    }
    const c = [];
    function u(e, t, n, i, r) {
        const s = c[n] + ":" + e;
        !function(e, t, n) {
            if (void 0 === n)
                return;
            !1 !== n.stopPropagation && e.stopPropagation();
            const i = new CustomEvent("action:" + n.action,{
                bubbles: !0,
                detail: t,
                cancelable: !0
            })
              , r = !e.target.dispatchEvent(i);
            (!1 !== n.preventDefault || r) && e.preventDefault()
        }(t, i, r.get(s))
    }
    function d(e, t, n, i) {
        var r;
        u(s(e, ((r = t).ctrlKey ? 1 : 0) | (r.altKey ? 2 : 0) | (r.metaKey ? 4 : 0) | (r.shiftKey ? 8 : 0)), t, t.eventPhase, n, i)
    }
    function h(e, t, n, i) {
        return Object(r.e)(e, `action:${t}`, n, i)
    }
    c[Event.AT_TARGET] = "at",
    c[Event.CAPTURING_PHASE] = "capture",
    c[Event.BUBBLING_PHASE] = "bubble"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return p
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "d", (function() {
        return g
    }
    )),
    n.d(t, "c", (function() {
        return b
    }
    )),
    n.d(t, "e", (function() {
        return y
    }
    )),
    n.d(t, "f", (function() {
        return S
    }
    ));
    var i = n(10)
      , r = n(61)
      , s = n(7)
      , a = n(23)
      , o = n(0)
      , l = n(98)
      , c = n(42)
      , u = n(3)
      , d = n(11)
      , h = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    };
    class p {
        constructor(e) {
            this.source = e,
            this.state = i.g.SYSTEM_MEMORY
        }
        get gl() {
            return this.source.gl
        }
        copyToGPU(e) {
            this.state = i.g.GPU_MEMORY
        }
        freeGPUMemory(e) {
            this.state = i.g.SYSTEM_MEMORY
        }
    }
    function f(e) {
        if ("number" != typeof e || e < 0)
            throw new Error(`Expected non-negative number as limit, but received: ${JSON.stringify(e)}`);
        return e
    }
    class m {
        constructor({defaultItemLimit: e=Number.POSITIVE_INFINITY, defaultSizeLimit: t=Number.POSITIVE_INFINITY}={}) {
            this.sizeLimit = new s.c(t,f),
            this.itemLimit = new s.c(e,f)
        }
    }
    let g = class extends d.b {
        constructor(e, t, n, i) {
            super(),
            this.gl = t,
            this.frameNumberCounter = n,
            this.capacities = i,
            this.visibleChunksChanged = new u.a,
            this.pendingChunkUpdates = null,
            this.pendingChunkUpdatesTail = null,
            this.chunkUpdateDeadline = null,
            this.chunkUpdateDelay = 30;
            const s = t=>({
                itemLimit: this.registerDisposer(r.a.makeFromExisting(e, t.itemLimit)).rpcId,
                sizeLimit: this.registerDisposer(r.a.makeFromExisting(e, t.sizeLimit)).rpcId
            });
            this.initializeCounterpart(e, {
                gpuMemoryCapacity: s(i.gpuMemory),
                systemMemoryCapacity: s(i.systemMemory),
                downloadCapacity: s(i.download),
                computeCapacity: s(i.compute)
            })
        }
        scheduleChunkUpdate() {
            let e, t = this.chunkUpdateDeadline;
            e = null === t || Date.now() < t ? 0 : this.chunkUpdateDelay,
            setTimeout(this.processPendingChunkUpdates.bind(this), e)
        }
        processPendingChunkUpdates() {
            let e = this.chunkUpdateDeadline;
            null === e && (e = Date.now() + 30);
            let t = !1;
            for (; ; ) {
                if (Date.now() > e) {
                    this.chunkUpdateDeadline = null,
                    setTimeout(()=>this.processPendingChunkUpdates(), this.chunkUpdateDelay);
                    break
                }
                let n = this.pendingChunkUpdates;
                if (this.applyChunkUpdate(n) && (t = !0),
                null == (this.pendingChunkUpdates = n.nextUpdate)) {
                    this.pendingChunkUpdatesTail = null;
                    break
                }
            }
            t && this.visibleChunksChanged.dispatch()
        }
        handleFetch_(e, t) {
            const {resolve: n, reject: i, cancellationToken: r} = t.promise;
            if (r.isCanceled)
                return void i(a.a);
            const s = t.key
              , o = e.chunks.get(s);
            if (!o)
                return void i(new Error(`No chunk found at ${s} for source ${e.constructor.name}`));
            const l = o.data;
            l ? n({
                value: l
            }) : i(new Error(`At ${s} for source ${e.constructor.name}: chunk has no data`))
        }
        applyChunkUpdate(e) {
            let t = !1
              , {rpc: n} = this;
            const r = n.get(e.source);
            if (void 0 !== e.promise)
                this.handleFetch_(r, e);
            else if (void 0 === e.id) {
                for (const e of r.chunks.keys())
                    r.deleteChunk(e);
                t = !0
            } else {
                let n = e.state;
                if (n === i.g.EXPIRED)
                    r.deleteChunk(e.id);
                else {
                    let s, a = e.id;
                    if (e.new ? (s = r.getChunk(e),
                    r.addChunk(a, s)) : s = r.chunks.get(a),
                    n !== s.state)
                        switch (n) {
                        case i.g.GPU_MEMORY:
                            s.copyToGPU(this.gl),
                            t = !0;
                            break;
                        case i.g.SYSTEM_MEMORY:
                            s.freeGPUMemory(this.gl);
                            break;
                        default:
                            throw new Error(`INTERNAL ERROR: Invalid chunk state: ${i.g[n]}`)
                        }
                }
            }
            return t
        }
    }
    ;
    function v(e, t) {
        let n = e.get(t.source);
        let i = n.chunkManager.chunkQueueManager;
        if (n.immediateChunkUpdates)
            return void (i.applyChunkUpdate(t) && i.visibleChunksChanged.dispatch());
        let r = i.pendingChunkUpdatesTail;
        null == r ? (i.pendingChunkUpdates = t,
        i.pendingChunkUpdatesTail = t,
        i.scheduleChunkUpdate()) : (r.nextUpdate = t,
        i.pendingChunkUpdatesTail = t)
    }
    g = h([Object(d.g)(i.b)], g),
    Object(d.e)("Chunk.update", (function(e) {
        v(this, e)
    }
    )),
    Object(d.d)("Chunk.retrieve", (function(e, t) {
        return new Promise((n,i)=>{
            e.promise = {
                resolve: n,
                reject: i,
                cancellationToken: t
            },
            v(this, e)
        }
        )
    }
    ));
    let b = class extends d.b {
        constructor(e) {
            super(),
            this.chunkQueueManager = e,
            this.memoize = new l.b,
            this.registerDisposer(e.addRef()),
            this.initializeCounterpart(e.rpc, {
                chunkQueueManager: e.rpcId
            })
        }
        get gl() {
            return this.chunkQueueManager.gl
        }
        getChunkSource(e, t) {
            const n = e.encodeOptions(t);
            n.constructorId = Object(c.a)(e);
            const i = Object(o.h)(n);
            return this.memoize.get(i, ()=>{
                const i = new e(this,t);
                return i.initializeCounterpart(this.rpc, {}),
                i.key = n,
                i
            }
            )
        }
    }
    ;
    b = h([Object(d.g)(i.a)], b);
    class y extends d.b {
        constructor(e, t={}) {
            super(),
            this.chunkManager = e,
            this.chunks = new Map,
            this.immediateChunkUpdates = !1
        }
        initializeCounterpart(e, t) {
            t.chunkManager = this.chunkManager.rpcId,
            super.initializeCounterpart(e, t)
        }
        get gl() {
            return this.chunkManager.chunkQueueManager.gl
        }
        deleteChunk(e) {
            const t = this.chunks.get(e);
            t.state === i.g.GPU_MEMORY && t.freeGPUMemory(this.gl),
            this.chunks.delete(e)
        }
        addChunk(e, t) {
            this.chunks.set(e, t)
        }
        getChunk(e) {
            throw new Error("Not implemented.")
        }
        invalidateCache() {
            this.rpc.invoke(i.c, {
                id: this.rpcId
            })
        }
        static encodeOptions(e) {
            return {}
        }
    }
    function S(e, t) {
        let n = class extends e {
            constructor(...e) {
                super(...e);
                const t = e[1];
                this.parameters = t.parameters
            }
            initializeCounterpart(e, t) {
                t.parameters = this.parameters,
                super.initializeCounterpart(e, t)
            }
            static encodeOptions(e) {
                return Object.assign({
                    parameters: e.parameters
                }, super.encodeOptions(e))
            }
        }
        ;
        return n = h([Object(d.g)(t.RPC_ID)], n),
        n
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e, t, n, i, r, s, a, o, l) {
        for (let c = 0; c < a; ++c)
            for (let a = 0; a < l; ++a) {
                let l = 0;
                for (let e = 0; e < o; ++e)
                    l += n[c + i * e] * r[e + s * a];
                e[c + t * a] = l
            }
        return e
    }
    function r(e, t, n=t) {
        return function(e, t, n) {
            for (let i = 0; i < n; ++i) {
                const r = t * i;
                e.fill(0, r, r + n),
                e[r + i] = 1
            }
            return e
        }(new e(t * n), t, Math.min(t, n))
    }
    function s(e, t, n=!0) {
        const i = t.length
          , r = n ? i + 1 : i
          , s = new e(r * (i + 1));
        n && (s[s.length - 1] = 1);
        for (let e = 0; e < i; ++e)
            s[(r + 1) * e] = t[e];
        return s
    }
    function a(e, t, n) {
        for (let i = 0; i < n; ++i)
            for (let r = 0; r < n; ++r)
                if (e[i * t + r] != (i === r ? 1 : 0))
                    return !1;
        return !0
    }
    function o(e, t, n, i, r, s) {
        for (let a = 0; a < s; ++a) {
            const s = a * i
              , o = a * t;
            for (let t = 0; t < r; ++t)
                e[o + t] = n[s + t]
        }
        return e
    }
    function l(e, t, n, i) {
        o(e, t + 1, n, i + 1, i, i);
        for (let r = 0; r < i; ++r)
            e[(t + 1) * t + r] = n[(i + 1) * i + r];
        e[e.length - 1] = 1;
        for (let n = i; n < t; ++n)
            e[(t + 1) * n + n] = 1;
        return e
    }
    let c;
    function u(e, t, n, i, r) {
        return o(e, t, n, i, r, r),
        function(e, t, n) {
            let i = 1;
            (void 0 === c || c.length < n) && (c = new Uint32Array(n));
            for (let e = 0; e < n; ++e)
                c[e] = e;
            for (let r = 0; r < n; ++r) {
                const s = t * r;
                let a = r;
                {
                    let t = Math.abs(e[s + r]);
                    for (let i = r + 1; i < n; ++i) {
                        const n = Math.abs(e[s + i]);
                        n > t && (t = n,
                        a = i)
                    }
                }
                if (r !== a) {
                    i *= -1;
                    for (let i = 0; i < n; ++i) {
                        const n = t * i
                          , s = e[n + r];
                        e[n + r] = e[n + a],
                        e[n + a] = s
                    }
                    {
                        const e = c[r];
                        c[r] = c[a],
                        c[a] = e
                    }
                }
                const o = e[s + r]
                  , l = 1 / o;
                i *= o;
                for (let i = 0; i < n; ++i)
                    e[t * i + r] *= l;
                e[s + r] = l;
                for (let i = 0; i < n; ++i) {
                    if (i === r)
                        continue;
                    const s = -e[t * r + i];
                    for (let a = 0; a < n; ++a) {
                        const n = t * a;
                        e[n + i] += s * e[n + r]
                    }
                    e[t * r + i] = s * l
                }
            }
            for (let i = 0; i < n; ++i) {
                let r = c[i];
                for (; r !== i; ) {
                    const s = t * i
                      , a = t * r;
                    for (let t = 0; t < n; ++t) {
                        const n = s + t
                          , i = a + t
                          , r = e[n];
                        e[n] = e[i],
                        e[i] = r
                    }
                    const o = c[i] = c[r];
                    c[r] = r,
                    r = o
                }
            }
            return i
        }(e, t, r)
    }
    function d(e, t, n, i, r, s) {
        for (let a = 0; a < s; ++a) {
            const s = t * a
              , o = i * a;
            for (let t = 0; t < r; ++t)
                if (e[s + t] !== n[o + t])
                    return !1
        }
        return !0
    }
    function h(e, t, n, i, r) {
        for (let s = 0; s < r; ++s) {
            let a = t[n * r + s];
            for (let e = 0; e < r; ++e)
                a += t[n * e + s] * i[e];
            e[s] = a
        }
        return e
    }
    function p(e, t, n, i, r) {
        for (let s = 0; s < r; ++s) {
            let a = 0;
            for (let e = 0; e < r; ++e)
                a += t[n * e + s] * i[e];
            e[s] = a
        }
        return e
    }
    n.d(t, "h", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "g", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "e", (function() {
        return l
    }
    )),
    n.d(t, "f", (function() {
        return u
    }
    )),
    n.d(t, "d", (function() {
        return d
    }
    )),
    n.d(t, "i", (function() {
        return h
    }
    )),
    n.d(t, "j", (function() {
        return p
    }
    ))
}
, function(e, t, n) {
    var i = n(119)
      , r = n(142)
      , s = n(144)
      , a = Math.max
      , o = Math.min;
    e.exports = function(e, t, n) {
        var l, c, u, d, h, p, f = 0, m = !1, g = !1, v = !0;
        if ("function" != typeof e)
            throw new TypeError("Expected a function");
        function b(t) {
            var n = l
              , i = c;
            return l = c = void 0,
            f = t,
            d = e.apply(i, n)
        }
        function y(e) {
            return f = e,
            h = setTimeout(w, t),
            m ? b(e) : d
        }
        function S(e) {
            var n = e - p;
            return void 0 === p || n >= t || n < 0 || g && e - f >= u
        }
        function w() {
            var e = r();
            if (S(e))
                return x(e);
            h = setTimeout(w, function(e) {
                var n = t - (e - p);
                return g ? o(n, u - (e - f)) : n
            }(e))
        }
        function x(e) {
            return h = void 0,
            v && l ? b(e) : (l = c = void 0,
            d)
        }
        function C() {
            var e = r()
              , n = S(e);
            if (l = arguments,
            c = this,
            p = e,
            n) {
                if (void 0 === h)
                    return y(p);
                if (g)
                    return clearTimeout(h),
                    h = setTimeout(w, t),
                    b(p)
            }
            return void 0 === h && (h = setTimeout(w, t)),
            d
        }
        return t = s(t) || 0,
        i(n) && (m = !!n.leading,
        u = (g = "maxWait"in n) ? a(s(n.maxWait) || 0, t) : u,
        v = "trailing"in n ? !!n.trailing : v),
        C.cancel = function() {
            void 0 !== h && clearTimeout(h),
            f = 0,
            l = p = c = h = void 0
        }
        ,
        C.flush = function() {
            return void 0 === h ? d : x(r())
        }
        ,
        C
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return l
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    ));
    var i = n(16)
      , r = n.n(i)
      , s = n(2)
      , a = n(3);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o {
        constructor(e, t=e) {
            this.value_ = e,
            this.defaultValue = t,
            this.changed = new a.a
        }
        get value() {
            return this.value_
        }
        set value(e) {
            e !== this.value_ && (this.value_ = e,
            this.changed.dispatch())
        }
        toggle() {
            this.value = !this.value
        }
        toJSON() {
            let {value_: e} = this;
            if (e !== this.defaultValue)
                return this.value_
        }
        restoreState(e) {
            this.value = !0 !== e && !1 !== e ? this.defaultValue : e
        }
        reset() {
            this.value = this.defaultValue
        }
    }
    class l extends s.a {
        constructor(e) {
            super(),
            this.model = e,
            this.element = document.createElement("input");
            let {element: t} = this;
            t.type = "checkbox",
            this.registerDisposer(e.changed.add(()=>{
                this.updateCheckbox()
            }
            )),
            this.updateCheckbox(),
            this.registerEventListener(t, "change", (function(t) {
                e.value = this.checked
            }
            )),
            t.addEventListener("mousedown", e=>{
                e.preventDefault()
            }
            )
        }
        updateCheckbox() {
            this.element.checked = this.model.value
        }
        disposed() {
            let {element: e} = this
              , {parentElement: t} = e;
            t && t.removeChild(e),
            super.disposed()
        }
    }
    class c extends s.a {
        constructor(e, t) {
            super(),
            this.model = e,
            this.element = t,
            this.initialDisplay = this.element.style.display,
            this.updateVisibility(),
            this.registerDisposer(e.changed.add(this.registerCancellable(r()(()=>this.updateVisibility(), 0))))
        }
        updateVisibility() {
            this.element.style.display = this.model.value ? this.initialDisplay : "none"
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "h", (function() {
        return i
    }
    )),
    n.d(t, "k", (function() {
        return S
    }
    )),
    n.d(t, "e", (function() {
        return O
    }
    )),
    n.d(t, "j", (function() {
        return k
    }
    )),
    n.d(t, "d", (function() {
        return E
    }
    )),
    n.d(t, "p", (function() {
        return T
    }
    )),
    n.d(t, "f", (function() {
        return D
    }
    )),
    n.d(t, "q", (function() {
        return A
    }
    )),
    n.d(t, "n", (function() {
        return I
    }
    )),
    n.d(t, "c", (function() {
        return P
    }
    )),
    n.d(t, "a", (function() {
        return R
    }
    )),
    n.d(t, "g", (function() {
        return j
    }
    )),
    n.d(t, "r", (function() {
        return N
    }
    )),
    n.d(t, "l", (function() {
        return B
    }
    )),
    n.d(t, "o", (function() {
        return F
    }
    )),
    n.d(t, "m", (function() {
        return _
    }
    )),
    n.d(t, "b", (function() {
        return U
    }
    )),
    n.d(t, "i", (function() {
        return z
    }
    ));
    var i, r, s = n(4), a = n(6), o = n(2), l = n(1), c = n(0), u = n(3), d = n(30), h = n(91), p = n(43);
    !function(e) {
        e[e.LINKED = 0] = "LINKED",
        e[e.RELATIVE = 1] = "RELATIVE",
        e[e.UNLINKED = 2] = "UNLINKED"
    }(i || (i = {})),
    function(e) {
        e[e.LINKED = 0] = "LINKED",
        e[e.UNLINKED = 2] = "UNLINKED"
    }(r || (r = {}));
    class f extends h.a {
        constructor(e=i.LINKED) {
            super(i, e)
        }
    }
    class m extends h.a {
        constructor(e=r.LINKED) {
            super(r, e)
        }
    }
    const g = l.t.create()
      , v = l.o.create();
    function b(e, t, n, r) {
        let s, a = !1;
        e.registerDisposer(t);
        let o = i.UNLINKED;
        const l = ()=>{
            const a = n.value;
            if (a !== o)
                switch (a) {
                case i.UNLINKED:
                    s = void 0;
                    break;
                case i.LINKED:
                    s = void 0,
                    r.assign(e, t);
                    break;
                case i.RELATIVE:
                    s = r.difference(e, t)
                }
            o = a,
            e.changed.dispatch()
        }
        ;
        return e.registerDisposer(e.changed.add(()=>{
            if (!a)
                switch (n.value) {
                case i.UNLINKED:
                    break;
                case i.LINKED:
                    r.assign(t, e);
                    break;
                case i.RELATIVE:
                    r.subtract(t, e, s)
                }
        }
        )),
        e.registerDisposer(t.changed.add(()=>{
            switch (a = !0,
            n.value) {
            case i.UNLINKED:
                if (r.isValid(e))
                    break;
            case i.LINKED:
                r.assign(e, t);
                break;
            case i.RELATIVE:
                r.add(e, t, s)
            }
            a = !1
        }
        )),
        e.registerDisposer(n.changed.add(l)),
        l(),
        e
    }
    function y(e, t, n, i) {
        return b(e, t, n, i)
    }
    class S extends o.a {
        constructor(e) {
            super(),
            this.coordinateSpace = e,
            this.coordinates_ = p.b,
            this.changed = new u.a,
            this.registerDisposer(e.changed.add(()=>{
                this.handleCoordinateSpaceChanged()
            }
            ))
        }
        get valid() {
            return this.coordinateSpace.value.valid
        }
        get value() {
            return this.handleCoordinateSpaceChanged(),
            this.coordinates_
        }
        reset() {
            this.curCoordinateSpace = void 0,
            this.coordinates_ = p.b,
            this.changed.dispatch()
        }
        set value(e) {
            const {curCoordinateSpace: t} = this;
            if (void 0 === t || !t.valid || t.rank !== e.length)
                return;
            const {coordinates_: n} = this;
            n.set(e),
            this.changed.dispatch()
        }
        handleCoordinateSpaceChanged() {
            const e = this.coordinateSpace.value
              , t = this.curCoordinateSpace;
            if (e === t)
                return;
            this.curCoordinateSpace = e;
            const {rank: n} = e;
            if (!e.valid)
                return;
            if (void 0 === t || !t.valid) {
                let {coordinates_: t} = this;
                return void 0 !== t && t.length === n || (t = this.coordinates_ = new Float32Array(n),
                Object(s.o)(t, e.bounds)),
                void this.changed.dispatch()
            }
            const i = new Float32Array(n)
              , r = this.coordinates_
              , {ids: a, scales: o} = e
              , {ids: l, scales: c} = t;
            for (let t = 0; t < n; ++t) {
                const n = a[t]
                  , u = l.indexOf(n);
                i[t] = -1 === u ? Object(s.p)(e.bounds.lowerBounds[t], e.bounds.upperBounds[t]) : r[u] * (c[u] / o[t])
            }
            this.coordinates_ = i,
            this.changed.dispatch()
        }
        toJSON() {
            if (!this.valid)
                return;
            this.handleCoordinateSpaceChanged();
            const {value: e} = this;
            return 0 !== e.length ? Array.from(e) : void 0
        }
        restoreState(e) {
            void 0 !== e ? (this.curCoordinateSpace = void 0,
            this.coordinates_ = Float32Array.from(Object(c.b)(e, c.p)),
            this.handleCoordinateSpaceChanged(),
            this.changed.dispatch()) : this.reset()
        }
        snapToVoxel() {
            this.handleCoordinateSpaceChanged();
            const {coordinates_: e} = this
              , t = e.length;
            for (let n = 0; n < t; ++n)
                e[n] = Math.round(e[n]);
            this.changed.dispatch()
        }
        assign(e) {
            e.handleCoordinateSpaceChanged();
            const {curCoordinateSpace: t, coordinates_: n} = e;
            this.curCoordinateSpace = t,
            this.coordinates_ = Float32Array.from(n),
            this.changed.dispatch()
        }
        static getOffset(e, t) {
            const n = e.coordinates_
              , i = t.coordinates_;
            if (n.length === i.length)
                return p.h(new Float32Array(n.length), n, i)
        }
        static addOffset(e, t, n, i=1) {
            e.handleCoordinateSpaceChanged();
            const {value: r} = t;
            void 0 !== n && r.length === n.length && (p.g(e.value, r, n, i),
            e.changed.dispatch())
        }
        get legacyJsonView() {
            const e = this;
            return {
                changed: e.changed,
                toJSON: ()=>e.toJSON(),
                reset() {
                    e.reset()
                },
                restoreState(t) {
                    void 0 === t || Array.isArray(t) ? e.restoreState(t) : (Object(c.w)(t),
                    Object(d.c)(t, "voxelCoordinates", e))
                }
            }
        }
    }
    function w(e, t, n) {
        void 0 !== n && 0 !== Object.keys(n).length ? (Object(c.w)(n),
        e.value = i.UNLINKED,
        Object(c.y)(n, "value", e=>{
            void 0 !== e && t.restoreState(e)
        }
        ),
        Object(c.y)(n, "link", t=>e.restoreState(t))) : e.value = i.LINKED
    }
    class x {
        constructor(e, t=new f) {
            this.peer = e,
            this.link = t
        }
        get changed() {
            return this.value.changed
        }
        toJSON() {
            const {link: e} = this;
            if (e.value !== i.LINKED)
                return {
                    link: e.toJSON(),
                    value: this.getValueJson()
                }
        }
        getValueJson() {
            return this.value.toJSON()
        }
        reset() {
            this.link.value = i.LINKED
        }
        restoreState(e) {
            w(this.link, this.value, e)
        }
        copyToPeer() {
            this.link.value !== i.LINKED && (this.link.value = i.UNLINKED,
            this.peer.assign(this.value),
            this.link.value = i.LINKED)
        }
    }
    class C extends x {
        constructor(e, t=new m) {
            super(e, t)
        }
    }
    class O extends x {
        constructor() {
            super(...arguments),
            this.value = b(new S(this.peer.coordinateSpace), this.peer, this.link, {
                assign: (e,t)=>e.assign(t),
                isValid: e=>e.valid,
                difference: S.getOffset,
                add: S.addOffset,
                subtract: (e,t,n)=>{
                    S.addOffset(e, t, n, -1)
                }
            })
        }
    }
    class k extends o.a {
        constructor(e) {
            super(),
            this.changed = new u.a,
            null == e && (e = l.o.create()),
            this.orientation = e
        }
        toJSON() {
            let {orientation: e} = this;
            var t;
            if (l.o.normalize(this.orientation, this.orientation),
            0 !== (t = e)[0] || 0 !== t[1] || 0 !== t[2] || 1 !== t[3])
                return Array.prototype.slice.call(this.orientation)
        }
        restoreState(e) {
            try {
                Object(c.c)(this.orientation, e),
                l.o.normalize(this.orientation, this.orientation)
            } catch (e) {
                l.o.identity(this.orientation)
            }
            this.changed.dispatch()
        }
        reset() {
            l.o.identity(this.orientation),
            this.changed.dispatch()
        }
        snap() {
            let e = l.j.create();
            l.j.fromQuat(e, this.orientation);
            let t = [!1, !1, !1];
            for (let n = 0; n < 3; ++n) {
                let i = 0
                  , r = 0;
                for (let s = 0; s < 3; ++s) {
                    let a = e[3 * n + s];
                    e[3 * n + s] = 0,
                    t[s] || Math.abs(a) > Math.abs(i) && (i = a,
                    r = s)
                }
                e[3 * n + r] = Math.sign(i),
                t[r] = !0
            }
            l.o.fromMat3(this.orientation, e),
            this.changed.dispatch()
        }
        static makeRelative(e, t) {
            let n = new k(l.o.multiply(l.o.create(), e.orientation, t))
              , i = !1;
            n.registerDisposer(e.changed.add(()=>{
                i || (r = !0,
                l.o.multiply(n.orientation, e.orientation, t),
                n.changed.dispatch(),
                r = !1)
            }
            ));
            let r = !1;
            const s = l.o.invert(l.o.create(), t);
            return n.registerDisposer(n.changed.add(()=>{
                r || (i = !0,
                l.o.multiply(e.orientation, n.orientation, s),
                e.changed.dispatch(),
                i = !1)
            }
            )),
            n
        }
        assign(e) {
            l.o.copy(this.orientation, e.orientation),
            this.changed.dispatch()
        }
    }
    class E extends x {
        constructor() {
            super(...arguments),
            this.value = b(new k, this.peer, this.link, {
                assign: (e,t)=>e.assign(t),
                isValid: ()=>!0,
                difference: (e,t)=>{
                    const n = l.o.create();
                    return l.o.multiply(n, l.o.invert(n, t.orientation), e.orientation)
                }
                ,
                add: (e,t,n)=>{
                    l.o.multiply(e.orientation, t.orientation, n),
                    e.changed.dispatch()
                }
                ,
                subtract: (e,t,n)=>{
                    l.o.multiply(e.orientation, t.orientation, l.o.invert(v, n)),
                    e.changed.dispatch()
                }
            })
        }
    }
    class T extends o.a {
        constructor(e) {
            super(),
            this.coordinateSpace = e,
            this.changed = new u.a,
            this.curCoordinateSpace = s.l,
            this.value_ = {
                factors: new Float64Array(0)
            },
            this.registerDisposer(e.changed.add(()=>this.update())),
            this.update()
        }
        get value() {
            return this.update()
        }
        reset() {
            this.value_ = {
                factors: new Float64Array(0)
            },
            this.curCoordinateSpace = s.l,
            this.changed.dispatch()
        }
        toJSON() {
            const e = {};
            let t = !1;
            const {value: n} = this
              , {factors: i} = n
              , {names: r, rank: s} = this.curCoordinateSpace;
            for (let n = 0; n < s; ++n) {
                const s = i[n];
                1 !== s && (e[r[n]] = s,
                t = !0)
            }
            if (t)
                return e
        }
        restoreState(e) {
            const {coordinateSpace: {value: t}} = this
              , {names: n, rank: i} = t
              , r = new Float64Array(i);
            if (r.fill(-1),
            void 0 !== e) {
                const t = Object(c.w)(e);
                for (let e = 0; e < i; ++e)
                    r[e] = Object(c.y)(t, n[e], e=>void 0 === e ? 1 : Object(c.r)(e))
            }
            this.value_ = {
                factors: r
            },
            this.curCoordinateSpace = t,
            this.changed.dispatch()
        }
        setFactors(e) {
            const {coordinateSpace: {value: t}} = this;
            e.length === t.rank && (this.value_ = {
                factors: e
            },
            this.curCoordinateSpace = t,
            this.changed.dispatch())
        }
        update() {
            const {coordinateSpace: {value: e}} = this;
            let t = this.value_;
            const {curCoordinateSpace: n} = this;
            if (n === e)
                return t;
            const {ids: i} = n
              , {ids: r, rank: s} = e
              , o = t.factors
              , l = new Float64Array(s);
            l.fill(1);
            for (let e = 0; e < s; ++e) {
                const t = r[e]
                  , n = i.indexOf(t);
                -1 !== n && (l[e] = o[n])
            }
            return Object(a.a)(l, o) ? t : (t = this.value_ = {
                factors: l
            },
            this.curCoordinateSpace = e,
            this.changed.dispatch(),
            t)
        }
        assign(e) {
            this.setFactors(e.value.factors)
        }
    }
    function M(e, t, n, i, r) {
        if (n === i)
            return t;
        const {ids: s} = n
          , {rank: a, ids: o} = i
          , l = new e(a);
        for (let e = 0; e < a; ++e) {
            const n = o[e]
              , i = s.indexOf(n);
            l[e] = -1 === i ? r(e) : t[i]
        }
        return l
    }
    class D extends x {
        constructor() {
            super(...arguments),
            this.value = b(new T(this.peer.coordinateSpace), this.peer, this.link, {
                assign: (e,t)=>e.assign(t),
                difference: (e,t)=>{
                    const {factors: n} = e.value
                      , i = e.coordinateSpace.value
                      , r = t.value.factors;
                    return {
                        coordinateSpace: i,
                        offsets: p.h(new Float64Array(n.length), n, r)
                    }
                }
                ,
                add: (e,t,n)=>{
                    const i = M(Float64Array, n.offsets, n.coordinateSpace, e.coordinateSpace.value, ()=>0);
                    e.setFactors(p.a(new Float64Array(i.length), i, t.value.factors))
                }
                ,
                subtract: (e,t,n)=>{
                    const i = M(Float64Array, n.offsets, n.coordinateSpace, e.coordinateSpace.value, ()=>0);
                    e.setFactors(p.h(new Float64Array(i.length), t.value.factors, i))
                }
                ,
                isValid: ()=>!0
            })
        }
    }
    function L(e, t, n) {
        const {rank: i, names: r, units: s} = e
          , {displayRank: a, displayDimensionIndices: o} = t
          , l = new Float64Array(3);
        let c, u = new Float64Array(3);
        const {factors: d} = n
          , h = new Array(3)
          , p = new Float64Array(3);
        if (l.fill(1),
        u.fill(1),
        p.fill(1),
        h.fill(""),
        0 === a)
            c = 1;
        else {
            c = Number.POSITIVE_INFINITY;
            const {scales: t} = e;
            for (let e = 0; e < a; ++e) {
                const n = o[e]
                  , i = u[e] = d[n] * t[n];
                c = Math.min(c, i),
                h[e] = s[n],
                p[e] = t[n]
            }
            for (let e = 0; e < a; ++e)
                l[e] = u[e] / c
        }
        return {
            globalRank: i,
            globalDimensionNames: r,
            displayRank: a,
            displayDimensionIndices: o,
            displayDimensionUnits: h,
            displayDimensionScales: p,
            canonicalVoxelFactors: l,
            voxelPhysicalScales: u,
            canonicalVoxelPhysicalSize: c
        }
    }
    class A extends o.a {
        constructor(e, t) {
            super(),
            this.relativeDisplayScales = e,
            this.displayDimensions = t,
            this.changed = new u.a,
            this.curRelativeDisplayScales = this.relativeDisplayScales.value,
            this.curDisplayDimensions = this.displayDimensions.value,
            this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value,
            this.value_ = L(this.curCoordinateSpace, this.curDisplayDimensions, this.curRelativeDisplayScales),
            this.registerDisposer(e),
            this.registerDisposer(t);
            const n = ()=>{
                this.value
            }
            ;
            this.registerDisposer(e.changed.add(n)),
            this.registerDisposer(t.changed.add(n))
        }
        get value() {
            const {relativeDisplayScales: {value: e, coordinateSpace: {value: t}}, displayDimensions: {value: n}, curRelativeDisplayScales: i, curDisplayDimensions: r, curCoordinateSpace: s} = this;
            let o = this.value_;
            if (i !== e || r !== n || s !== t) {
                this.curRelativeDisplayScales = e,
                this.curDisplayDimensions = n,
                this.curCoordinateSpace = t;
                const i = L(t, n, e);
                l = o,
                c = i,
                Object(a.a)(l.globalDimensionNames, c.globalDimensionNames) && Object(a.a)(l.displayDimensionIndices, c.displayDimensionIndices) && Object(a.a)(l.canonicalVoxelFactors, c.canonicalVoxelFactors) && Object(a.a)(l.voxelPhysicalScales, c.voxelPhysicalScales) && l.canonicalVoxelPhysicalSize === c.canonicalVoxelPhysicalSize && Object(a.a)(l.displayDimensionUnits, c.displayDimensionUnits) && Object(a.a)(l.displayDimensionScales, c.displayDimensionScales) || (this.value_ = o = i,
                this.changed.dispatch())
            }
            var l, c;
            return o
        }
    }
    class I extends o.a {
        constructor(e) {
            super(),
            this.coordinateSpace = e,
            this.changed = new u.a,
            this.default_ = !0,
            this.value_ = void 0,
            this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch)),
            this.update()
        }
        get value() {
            return this.update(),
            this.value_
        }
        update() {
            const {coordinateSpace: {value: e}} = this
              , t = this.value_;
            if (void 0 !== t && t.coordinateSpace === e)
                return;
            if (void 0 === t || this.default_)
                return void this.setToDefault(e);
            const n = new Int32Array(3)
              , {ids: i} = t.coordinateSpace
              , {ids: r} = e
              , s = t.displayDimensionIndices
              , a = t.displayRank;
            let o = 0;
            for (let e = 0; e < a; ++e) {
                const t = r.indexOf(i[s[e]]);
                -1 !== t && (n[o] = t,
                ++o)
            }
            if (n.fill(-1, o),
            0 === o)
                return this.default_ = !0,
                void this.setToDefault(e);
            this.assignValue(e, o, n),
            this.changed.dispatch()
        }
        setToDefault(e) {
            const t = Math.min(e.rank, 3)
              , n = new Int32Array(3);
            n.fill(-1);
            for (let e = 0; e < t; ++e)
                n[e] = e;
            this.assignValue(e, t, n)
        }
        assignValue(e, t, n) {
            this.value_ = {
                coordinateSpace: e,
                displayRank: t,
                displayDimensionIndices: n
            },
            this.changed.dispatch()
        }
        reset() {
            this.default_ = !0,
            this.value_ = void 0,
            this.changed.dispatch()
        }
        restoreState(e) {
            if (void 0 === e)
                return void this.reset();
            const t = Object(s.k)(e);
            if (t.length > 3)
                throw new Error("Number of spatial dimensions must be <= 3");
            const {coordinateSpace: {value: n}} = this
              , i = new Int32Array(3);
            i.fill(-1);
            const {names: r} = n;
            let a = 0;
            for (const e of t) {
                const t = r.indexOf(e);
                -1 !== t && (i[a++] = t)
            }
            0 !== a ? (this.default_ = !1,
            this.assignValue(n, a, i)) : this.reset()
        }
        get default() {
            return this.update(),
            this.default_
        }
        set default(e) {
            this.default_ !== e && (e ? (this.default_ = !0,
            this.setToDefault(this.coordinateSpace.value)) : (this.default_ = !1,
            this.changed.dispatch()))
        }
        setDimensionIndices(e, t) {
            this.default_ = !1,
            this.assignValue(this.coordinateSpace.value, e, t)
        }
        toJSON() {
            if (this.default_)
                return;
            const {value: e} = this
              , t = []
              , {displayRank: n, displayDimensionIndices: i, coordinateSpace: {names: r}} = e;
            if (0 !== n) {
                for (let e = 0; e < n; ++e)
                    t[e] = r[i[e]];
                return t
            }
        }
        assign(e) {
            if (e.default)
                this.default = !0;
            else {
                const {displayRank: t, displayDimensionIndices: n} = e.value;
                this.setDimensionIndices(t, n)
            }
        }
    }
    class P extends C {
        constructor(e) {
            super(e),
            this.value = y(new I(this.peer.coordinateSpace), this.peer, this.link, {
                assign: (e,t)=>e.assign(t),
                isValid: ()=>!0
            })
        }
    }
    class R extends o.a {
        constructor(e, t, n) {
            super(),
            this.position = e,
            this.displayDimensionRenderInfo = t,
            this.orientation = n,
            this.changed = new u.a,
            this.registerDisposer(e),
            this.registerDisposer(n),
            this.registerDisposer(t),
            this.registerDisposer(e.changed.add(this.changed.dispatch)),
            this.registerDisposer(n.changed.add(this.changed.dispatch)),
            this.registerDisposer(t.changed.add(this.changed.dispatch))
        }
        get displayDimensions() {
            return this.displayDimensionRenderInfo.displayDimensions
        }
        get relativeDisplayScales() {
            return this.displayDimensionRenderInfo.relativeDisplayScales
        }
        get valid() {
            return this.position.valid
        }
        reset() {
            this.position.reset(),
            this.orientation.reset(),
            this.displayDimensions.reset()
        }
        updateDisplayPosition(e, t=g) {
            const {coordinateSpace: {value: n}, value: i} = this.position
              , {displayDimensionIndices: r, displayRank: s} = this.displayDimensions.value;
            if (void 0 === n)
                return !1;
            t.fill(0);
            for (let e = 0; e < s; ++e) {
                const n = r[e];
                t[e] = i[n]
            }
            if (!1 !== e(t)) {
                for (let e = 0; e < s; ++e) {
                    i[r[e]] = t[e]
                }
                return this.position.changed.dispatch(),
                !0
            }
            return !1
        }
        toMat4(e, t) {
            l.l.fromQuat(e, this.orientation.orientation);
            const {value: n} = this.position
              , {canonicalVoxelFactors: i, displayDimensionIndices: r} = this.displayDimensionRenderInfo.value;
            for (let s = 0; s < 3; ++s) {
                const a = r[s]
                  , o = t / i[s];
                e[s] *= o,
                e[4 + s] *= o,
                e[8 + s] *= o,
                e[12 + s] = n[a] || 0
            }
        }
        toMat3(e, t) {
            l.j.fromQuat(e, this.orientation.orientation);
            const {canonicalVoxelFactors: n, displayRank: i} = this.displayDimensionRenderInfo.value;
            for (let r = 0; r < i; ++r) {
                const i = t / n[r];
                e[r] *= i,
                e[3 + r] *= i,
                e[6 + r] *= i
            }
        }
        snap() {
            this.orientation.snap(),
            this.position.snapToVoxel(),
            this.changed.dispatch()
        }
        translateDimensionRelative(e, t) {
            if (!this.valid)
                return;
            const {position: n} = this
              , {value: i} = n
              , {bounds: {lowerBounds: r, upperBounds: s}} = n.coordinateSpace.value;
            let a = i[e] + t;
            if (t > 0) {
                const t = s[e];
                Number.isFinite(t) && (a = Math.min(a, Math.ceil(t - 1)))
            } else {
                const t = r[e];
                Number.isFinite(t) && (a = Math.max(a, Math.floor(t)))
            }
            i[e] = a,
            n.changed.dispatch()
        }
        translateVoxelsRelative(e) {
            if (!this.valid)
                return;
            const t = l.t.transformQuat(g, e, this.orientation.orientation)
              , {position: n} = this
              , {value: i} = n
              , {displayDimensionIndices: r, displayRank: s} = this.displayDimensions.value
              , {bounds: {lowerBounds: a, upperBounds: o}} = n.coordinateSpace.value;
            for (let e = 0; e < s; ++e) {
                const n = r[e]
                  , s = t[e];
                let l = i[n] + s;
                if (s > 0) {
                    const e = o[n];
                    Number.isFinite(e) && (l = Math.min(l, Math.ceil(e - 1)))
                } else {
                    const e = a[n];
                    Number.isFinite(e) && (l = Math.max(l, Math.floor(e)))
                }
                i[n] = l
            }
            this.position.changed.dispatch()
        }
        rotateRelative(e, t) {
            var n = l.o.create();
            l.o.setAxisAngle(n, e, t);
            var i = this.orientation.orientation;
            l.o.multiply(i, i, n),
            this.orientation.changed.dispatch()
        }
        rotateAbsolute(e, t, n) {
            const {coordinateSpace: {value: i}, value: r} = this.position;
            if (void 0 === i)
                return;
            const {relativeDisplayScales: {value: {factors: s}}, displayDimensions: {value: {displayDimensionIndices: a, displayRank: o}}} = this
              , {scales: c} = i
              , u = l.o.create();
            l.o.setAxisAngle(u, e, t);
            const d = this.orientation.orientation
              , h = g;
            g.fill(0);
            for (let e = 0; e < o; ++e) {
                const t = a[e]
                  , i = n[t] - r[t];
                h[e] = i * c[t] * s[t]
            }
            const p = l.o.invert(v, d);
            l.t.transformQuat(h, h, p),
            l.o.multiply(d, u, d),
            l.t.transformQuat(h, h, d);
            for (let e = 0; e < o; ++e) {
                const t = a[e];
                r[t] = n[t] - h[e] / (c[t] * s[e])
            }
            this.position.changed.dispatch(),
            this.orientation.changed.dispatch()
        }
        translateNonDisplayDimension(e, t) {
            if (!this.valid)
                return;
            const {displayDimensionIndices: n} = this.displayDimensions.value
              , {position: i} = this
              , r = i.coordinateSpace.value.rank;
            for (let i = 0; i < r; ++i)
                if (-1 === n.indexOf(i) && 0 == e--)
                    return void this.translateDimensionRelative(i, t)
        }
    }
    class j extends x {
        constructor(e, t) {
            super(e),
            this.value = (()=>{
                const n = new e.constructor(t);
                return b(n, this.peer, this.link, {
                    assign: (e,t)=>{
                        e.assign(t)
                    }
                    ,
                    isValid: e=>e.coordinateSpaceValue.valid && 0 !== e.canonicalVoxelPhysicalSize,
                    difference: (e,t)=>e.value / t.value * (e.canonicalVoxelPhysicalSize / t.canonicalVoxelPhysicalSize),
                    add: (e,t,n)=>{
                        e.setPhysicalScale(t.value * n, t.canonicalVoxelPhysicalSize)
                    }
                    ,
                    subtract: (e,t,n)=>{
                        e.setPhysicalScale(t.value / n, t.canonicalVoxelPhysicalSize)
                    }
                }),
                n
            }
            )()
        }
    }
    function N(e) {
        return {
            changed: e.changed,
            toJSON: ()=>e.toJSON(),
            restoreState(t) {
                w(e.link, e.value.legacyJsonView, t)
            },
            reset() {
                e.reset()
            }
        }
    }
    class V extends o.a {
        constructor(e) {
            super(),
            this.displayDimensionRenderInfo = e,
            this.changed = new u.a,
            this.curCanonicalVoxelPhysicalSize = 0,
            this.value_ = Number.NaN,
            this.legacyValue_ = Number.NaN,
            this.registerDisposer(e),
            this.registerDisposer(e.changed.add(()=>this.handleCoordinateSpaceChanged())),
            this.registerDisposer(e.relativeDisplayScales.coordinateSpace.changed.add(()=>this.handleCoordinateSpaceChanged())),
            this.handleCoordinateSpaceChanged()
        }
        get value() {
            return this.handleCoordinateSpaceChanged(),
            this.value_
        }
        set value(e) {
            const {canonicalVoxelPhysicalSize: t} = this;
            Object.is(e, this.value_) && t === this.curCanonicalVoxelPhysicalSize || (this.curCanonicalVoxelPhysicalSize = t,
            this.legacyValue_ = Number.NaN,
            this.value_ = e,
            this.changed.dispatch())
        }
        get canonicalVoxelPhysicalSize() {
            return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize
        }
        get coordinateSpaceValue() {
            return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value
        }
        set legacyValue(e) {
            Object.is(e, this.legacyValue_) || (this.value_ = Number.NaN,
            this.legacyValue_ = e,
            this.curCanonicalVoxelPhysicalSize = 0,
            this.changed.dispatch())
        }
        get legacyValue() {
            return this.legacyValue_
        }
        handleCoordinateSpaceChanged() {
            const {value_: e} = this
              , {displayDimensionRenderInfo: {value: {canonicalVoxelPhysicalSize: t}, relativeDisplayScales: {coordinateSpace: {value: n}}}} = this
              , {curCanonicalVoxelPhysicalSize: i} = this;
            (Number.isNaN(e) || t !== i) && (Number.isNaN(e) ? n.valid && 0 !== t && (this.curCanonicalVoxelPhysicalSize = t,
            this.value_ = this.getDefaultValue(),
            this.changed.dispatch()) : 0 !== i && (this.value_ = e * (i / t),
            this.curCanonicalVoxelPhysicalSize = t,
            this.changed.dispatch()))
        }
        toJSON() {
            const {value: e} = this;
            return Number.isNaN(e) ? void 0 : e
        }
        restoreState(e) {
            this.curCanonicalVoxelPhysicalSize = 0,
            this.legacyValue_ = Number.NaN,
            this.value_ = void 0 === e ? Number.NaN : Object(c.r)(e),
            this.changed.dispatch()
        }
        reset() {
            this.curCanonicalVoxelPhysicalSize = 0,
            this.value_ = Number.NaN,
            this.legacyValue_ = Number.NaN,
            this.changed.dispatch()
        }
        get legacyJsonView() {
            const e = this;
            return {
                changed: e.changed,
                toJSON: ()=>e.toJSON(),
                reset: ()=>e.reset(),
                restoreState(t) {
                    e.legacyValue = Object(c.r)(t)
                }
            }
        }
        setPhysicalScale(e, t) {
            const n = this.curCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
            this.value = e * (t / n)
        }
        assign(e) {
            const {legacyValue: t} = e;
            Number.isNaN(t) ? this.setPhysicalScale(e.value, e.canonicalVoxelPhysicalSize) : this.legacyValue = t
        }
    }
    class B extends V {
        getDefaultValue() {
            const {legacyValue_: e} = this;
            if (Number.isNaN(e))
                return 1;
            const {canonicalVoxelPhysicalSize: t} = this;
            return 1e-9 * this.legacyValue_ / t
        }
    }
    class F extends V {
        getDefaultValue() {
            const {legacyValue_: e} = this;
            if (!Number.isNaN(e)) {
                this.legacyValue_ = Number.NaN;
                const {canonicalVoxelPhysicalSize: t} = this;
                return 200 * Math.tan(Math.PI / 8) * 1e-9 * e / t
            }
            const {coordinateSpaceValue: {bounds: {lowerBounds: t, upperBounds: n}}} = this
              , {canonicalVoxelFactors: i, displayDimensionIndices: r} = this.displayDimensionRenderInfo.value;
            let s = i.reduce((e,i,s)=>{
                const a = r[s]
                  , o = (n[a] - t[a]) * i;
                return Math.max(e, o)
            }
            , 0);
            return s = Number.isFinite(s) ? 2 ** Math.ceil(Math.log2(s)) : 1024,
            s
        }
    }
    class _ extends o.a {
        constructor(e, t) {
            super(),
            this.defaultValue = e,
            this.displayDimensionRenderInfo = t,
            this.changed = new u.a,
            this.value_ = e,
            this.canonicalVoxelPhysicalSize = t.value.canonicalVoxelPhysicalSize,
            this.registerDisposer(t.changed.add(()=>{
                this.value
            }
            ))
        }
        get value() {
            let {value_: e} = this;
            if (e > 0) {
                const {canonicalVoxelPhysicalSize: t} = this.displayDimensionRenderInfo.value
                  , n = this.canonicalVoxelPhysicalSize;
                t !== n && (this.canonicalVoxelPhysicalSize = t,
                e = this.value_ = e = n / t,
                this.changed.dispatch())
            }
            return e
        }
        set value(e) {
            if (e === this.value)
                return;
            this.value_ = e;
            const {canonicalVoxelPhysicalSize: t} = this.displayDimensionRenderInfo.value;
            this.canonicalVoxelPhysicalSize = t,
            this.changed.dispatch()
        }
        toJSON() {
            const {value: e} = this;
            if (e !== this.defaultValue)
                return e
        }
        reset() {
            this.value = this.defaultValue
        }
        restoreState(e) {
            "number" == typeof e && Number.isFinite(e) && 0 !== e ? this.value = e : this.value = this.defaultValue
        }
        setValueAbsolute(e, t) {
            if (e > 0) {
                const {canonicalVoxelPhysicalSize: n} = this.displayDimensionRenderInfo.value;
                e *= t / n
            }
            this.value = e
        }
        assign(e) {
            this.setValueAbsolute(e.value, e.canonicalVoxelPhysicalSize)
        }
    }
    class U extends C {
        constructor(e, t) {
            super(e),
            this.value = y(new _(e.defaultValue,t), this.peer, this.link, {
                assign: (e,t)=>e.assign(t),
                isValid: ()=>!0
            })
        }
    }
    class z extends o.a {
        constructor(e, t, n) {
            super(),
            this.pose = e,
            this.zoomFactor = t,
            this.depthRange = n,
            this.changed = new u.a,
            this.registerDisposer(e),
            this.registerDisposer(t),
            this.registerDisposer(n),
            this.registerDisposer(this.pose.changed.add(this.changed.dispatch)),
            this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch)),
            this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch))
        }
        get coordinateSpace() {
            return this.pose.position.coordinateSpace
        }
        reset() {
            this.pose.reset(),
            this.zoomFactor.reset()
        }
        get position() {
            return this.pose.position
        }
        get displayDimensions() {
            return this.pose.displayDimensions
        }
        get relativeDisplayScales() {
            return this.pose.relativeDisplayScales
        }
        get displayDimensionRenderInfo() {
            return this.pose.displayDimensionRenderInfo
        }
        toMat4(e) {
            this.pose.toMat4(e, this.zoomFactor.value)
        }
        toMat3(e) {
            this.pose.toMat3(e, this.zoomFactor.value)
        }
        get relativeDepthRange() {
            let e = this.depthRange.value;
            return e > 0 ? e /= this.zoomFactor.value : e *= -1,
            e
        }
        get valid() {
            return this.pose.valid && !Number.isNaN(this.zoomFactor.value)
        }
        zoomBy(e) {
            this.zoomFactor.value *= e
        }
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var i;
    n.d(t, "a", (function() {
        return i
    }
    )),
    function(e) {
        e[e.UINT8 = 0] = "UINT8",
        e[e.UINT16 = 1] = "UINT16",
        e[e.UINT32 = 2] = "UINT32",
        e[e.UINT64 = 3] = "UINT64",
        e[e.FLOAT32 = 4] = "FLOAT32"
    }(i || (i = {}));
    const r = [];
    r[i.UINT8] = 1,
    r[i.UINT16] = 2,
    r[i.UINT32] = 4,
    r[i.UINT64] = 8,
    r[i.FLOAT32] = 4
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "f", (function() {
        return o
    }
    )),
    n.d(t, "g", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "e", (function() {
        return u
    }
    )),
    n.d(t, "d", (function() {
        return d
    }
    ));
    var i = n(23)
      , r = n(21);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends Error {
        constructor(e, t, n) {
            let i = `Fetching ${JSON.stringify(e)} resulted in HTTP error ${t}`;
            n && (i += `: ${n}`),
            i += ".",
            super(i),
            this.name = "HttpError",
            this.message = i,
            this.url = e,
            this.status = t,
            this.statusText = n
        }
        static fromResponse(e) {
            return new s(e.url,e.status,e.statusText)
        }
    }
    async function a(e, t) {
        let n;
        try {
            n = await fetch(e, t)
        } catch (t) {
            if (t instanceof TypeError) {
                let t;
                throw t = "string" == typeof e ? e : e.url,
                new s(t,0,"Network or CORS error")
            }
            throw t
        }
        if (!n.ok)
            throw s.fromResponse(n);
        return n
    }
    function o(e) {
        return e.arrayBuffer()
    }
    function l(e) {
        return e.json()
    }
    async function c(e, t, n, r=i.e) {
        if (r === i.e) {
            const i = await a(e, t);
            return await n(i)
        }
        const s = new AbortController
          , o = r.add(()=>s.abort());
        try {
            const i = await a(e, t);
            return await n(i)
        } finally {
            o()
        }
    }
    new r.a;
    function u(e) {
        let t = e.match(/^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/);
        if (null === t)
            throw new Error(`Invalid URL: ${JSON.stringify(e)}`);
        return {
            protocol: t[1],
            host: t[2],
            path: t[3]
        }
    }
    function d(e) {
        const t = u(e);
        return "gs" === t.protocol ? `https://storage.googleapis.com/${t.host}${t.path}` : e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = new Uint32Array(2);
    let r = [];
    for (let e = 2; e <= 36; ++e) {
        let t = Math.floor(32 / Math.log2(e))
          , n = Math.pow(e, t)
          , i = `^[0-${String.fromCharCode("0".charCodeAt(0) + Math.min(9, e - 1))}`;
        e > 10 && (i += `a-${String.fromCharCode("a".charCodeAt(0) + e - 11)}`,
        i += `A-${String.fromCharCode("A".charCodeAt(0) + e - 11)}`),
        i += `]{1,${Math.ceil(64 / Math.log2(e))}}$`;
        let s = new RegExp(i);
        r[e] = {
            lowDigits: t,
            lowBase: n,
            pattern: s
        }
    }
    function s(e, t) {
        const n = 65535 & (e >>>= 0)
          , i = e >>> 16
          , r = 65535 & (t >>>= 0)
          , s = t >>> 16;
        let a = (n * r >>> 16) + i * r
          , o = a >>> 16;
        a = (65535 & a) + n * s,
        o += a >>> 16;
        let l = o >>> 16;
        return o = (65535 & o) + i * s,
        l += o >>> 16,
        ((65535 & l) << 16 | 65535 & o) >>> 0
    }
    class a {
        constructor(e=0, t=0) {
            this.low = e,
            this.high = t
        }
        clone() {
            return new a(this.low,this.high)
        }
        assign(e) {
            this.low = e.low,
            this.high = e.high
        }
        toString(e=10) {
            let t = this.low
              , n = this.high;
            if (0 === n)
                return t.toString(e);
            n *= 4294967296;
            let {lowBase: i, lowDigits: s} = r[e]
              , a = n % i;
            n = Math.floor(n / i),
            t += a,
            n += Math.floor(t / i),
            t %= i;
            let o = t.toString(e);
            return n.toString(e) + "0".repeat(s - o.length) + o
        }
        static less(e, t) {
            return e.high < t.high || e.high === t.high && e.low < t.low
        }
        static compare(e, t) {
            return e.high - t.high || e.low - t.low
        }
        static equal(e, t) {
            return e.low === t.low && e.high === t.high
        }
        static min(e, t) {
            return a.less(e, t) ? e : t
        }
        static max(e, t) {
            return a.less(e, t) ? t : e
        }
        static random() {
            return crypto.getRandomValues(i),
            new a(i[0],i[1])
        }
        tryParseString(e, t=10) {
            const {lowDigits: n, lowBase: i, pattern: a} = r[t];
            if (!a.test(e))
                return !1;
            if (e.length <= n)
                return this.low = parseInt(e, t),
                this.high = 0,
                !0;
            const o = e.length - n
              , l = parseInt(e.substr(o), t)
              , c = parseInt(e.substr(0, o), t);
            let u, d;
            if (4294967296 === i)
                u = c,
                d = l;
            else {
                const e = Math.imul(c, i) >>> 0;
                u = s(c, i) + (Math.imul(Math.floor(c / 4294967296), i) >>> 0),
                d = l + e,
                d >= 4294967296 && (++u,
                d -= 4294967296)
            }
            return d >>> 0 === d && u >>> 0 === u && (this.low = d,
            this.high = u,
            !0)
        }
        parseString(e, t=10) {
            if (!this.tryParseString(e, t))
                throw new Error(`Failed to parse string as uint64 value: ${JSON.stringify(e)}.`);
            return this
        }
        static parseString(e, t=10) {
            return (new a).parseString(e, t)
        }
        valid() {
            let {low: e, high: t} = this;
            return e >>> 0 === e && t >>> 0 === t
        }
        toJSON() {
            return this.toString()
        }
        static lshift(e, t, n) {
            const {low: i, high: r} = t;
            return 0 === n ? (e.low = i,
            e.high = r) : n < 32 ? (e.low = i << n,
            e.high = r << n | i >>> 32 - n) : (e.low = 0,
            e.high = i << n - 32),
            e
        }
        static rshift(e, t, n) {
            const {low: i, high: r} = t;
            return 0 === n ? (e.low = i,
            e.high = r) : n < 32 ? (e.low = i >>> n | r << 32 - n,
            e.high = r >>> n) : (e.low = r >>> n - 32,
            e.high = 0),
            e
        }
        static or(e, t, n) {
            return e.low = t.low | n.low,
            e.high = t.high | n.high,
            e
        }
        static xor(e, t, n) {
            return e.low = t.low ^ n.low,
            e.high = t.high ^ n.high,
            e
        }
        static and(e, t, n) {
            return e.low = t.low & n.low,
            e.high = t.high & n.high,
            e
        }
        static add(e, t, n) {
            let i = t.low + n.low
              , r = t.high + n.high;
            const s = i >>> 0;
            return s !== i && (r += 1),
            e.low = s,
            e.high = r >>> 0,
            e
        }
        static addUint32(e, t, n) {
            let i = t.low + n
              , r = t.high;
            const s = i >>> 0;
            return s !== i && (r += 1),
            e.low = s,
            e.high = r >>> 0,
            e
        }
        static decrement(e, t) {
            let {low: n, high: i} = t;
            return 0 === n && (i -= 1),
            e.low = n - 1 >>> 0,
            e.high = i >>> 0,
            e
        }
        static increment(e, t) {
            let {low: n, high: i} = t;
            return 4294967295 === n && (i += 1),
            e.low = n + 1 >>> 0,
            e.high = i >>> 0,
            e
        }
        static subtract(e, t, n) {
            let i = t.low - n.low
              , r = t.high - n.high;
            const s = i >>> 0;
            return s !== i && (r -= 1),
            e.low = s,
            e.high = r >>> 0,
            e
        }
        static multiplyUint32(e, t, n) {
            const {low: i, high: r} = t;
            return e.low = Math.imul(i, n) >>> 0,
            e.high = Math.imul(r, n) + s(i, n) >>> 0,
            e
        }
        static lowMask(e, t) {
            return 0 === t ? e.high = e.low = 0 : t <= 32 ? (e.high = 0,
            e.low = 4294967295 >>> 32 - t) : (e.high = 4294967295 >>> t - 32,
            e.low = 4294967295),
            e
        }
    }
    a.ZERO = new a(0,0),
    a.ONE = new a(1,0)
}
, function(e, t, n) {
    "use strict";
    var i = n(16)
      , r = n.n(i)
      , s = n(4)
      , a = n(33)
      , o = n(71)
      , l = n(18)
      , c = n(104)
      , u = n(7)
      , d = (n(160),
    n(49))
      , h = n(56)
      , p = n(28)
      , f = n(17)
      , m = n(29)
      , g = n(19)
      , v = n(2)
      , b = n(5)
      , y = n(48)
      , S = n(94)
      , w = n.n(S)
      , x = n(36);
    n(162);
    var C = n(133)
      , O = n.n(C)
      , k = n(6)
      , E = n(12)
      , T = n(15)
      , M = n(51)
      , D = n(37);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function L(e, t=e.value) {
        e.style.minWidth = t.length + 1 + "ch"
    }
    function A(e, t) {
        let n, i;
        return n = e === Number.NEGATIVE_INFINITY ? "(-," : `[${Math.floor(e)},`,
        i = t === Number.POSITIVE_INFINITY ? "+)" : `${Math.floor(t)})`,
        {
            lower: n,
            upper: i
        }
    }
    const I = M.a.fromObject({
        arrowup: {
            action: "move-up"
        },
        arrowdown: {
            action: "move-down"
        },
        arrowleft: {
            action: "move-left",
            preventDefault: !1
        },
        arrowright: {
            action: "move-right",
            preventDefault: !1
        },
        enter: {
            action: "commit"
        },
        escape: {
            action: "cancel"
        }
    });
    function P() {
        const e = document.createElement("div")
          , t = document.createElement("input");
        e.classList.add("neuroglancer-coordinate-space-transform-scale-container"),
        t.spellcheck = !1,
        t.autocomplete = "off",
        t.size = 1,
        t.classList.add("neuroglancer-coordinate-space-transform-scale"),
        e.appendChild(t);
        const n = document.createElement("div")
          , i = document.createElement("span");
        i.innerHTML = O.a,
        n.appendChild(i);
        const r = document.createTextNode("");
        return n.appendChild(r),
        n.classList.add("neuroglancer-coordinate-space-transform-scale-suggestion"),
        e.appendChild(n),
        {
            cellElement: e,
            inputElement: t,
            suggestionElement: n
        }
    }
    function R(e, t, n, i, r) {
        if (void 0 === t || t.scale === n && t.unit === i)
            e.style.display = "none";
        else {
            e.style.display = "";
            const n = Object(D.b)(t.scale, t.unit, {
                elide1: !1
            });
            e.lastChild.textContent = n,
            e.title = `${r}${n}`
        }
    }
    function j() {
        const e = document.createElement("input");
        return e.spellcheck = !1,
        e.autocomplete = "off",
        e.size = 1,
        e.placeholder = " ",
        e.classList.add("neuroglancer-coordinate-space-transform-output-name"),
        e
    }
    function N(e, t, n) {
        const i = e.map(e=>Object(D.c)(e.value));
        if (i.includes(void 0))
            return !1;
        const r = Float64Array.from(i, e=>e.scale)
          , a = Array.from(i, e=>e.unit)
          , o = n.value
          , {scales: l, units: c, rank: u} = o;
        for (let e = 0; e < u; ++e)
            t[e] || (r[e] = l[e],
            a[e] = c[e]);
        if (Object(k.a)(l, r) && Object(k.a)(c, a))
            return !1;
        const d = o.timestamps.map((e,t)=>r[t] === l[t] && a[t] === c[t] ? e : Date.now())
          , h = Object(s.z)({
            valid: o.valid,
            rank: o.rank,
            scales: r,
            units: a,
            timestamps: d,
            ids: o.ids,
            names: o.names,
            boundingBoxes: o.boundingBoxes
        });
        return n.value = h,
        !0
    }
    function V(e, t, n, i) {
        const r = new Float64Array(e.scales)
          , s = Array.from(e.units);
        if (r[t] === n && s[t] === i)
            return e;
        const a = Array.from(e.timestamps);
        return r[t] = n,
        s[t] = i,
        a[t] = Date.now(),
        Object.assign(Object.assign({}, e), {
            scales: r,
            units: s,
            timestamps: a
        })
    }
    class B extends v.a {
        constructor(e, t, n) {
            super(),
            this.transform = e,
            this.localCombiner = t,
            this.globalCombiner = n,
            this.element = document.createElement("div"),
            this.coefficientContainer = document.createElement("div"),
            this.translationContainer = document.createElement("div"),
            this.outputNameContainer = document.createElement("div"),
            this.outputScaleContainer = document.createElement("div"),
            this.inputNameContainer = document.createElement("div"),
            this.inputScaleContainer = document.createElement("div"),
            this.inputLowerBoundsContainer = document.createElement("div"),
            this.inputUpperBoundsContainer = document.createElement("div"),
            this.coefficientElements = [],
            this.inputNameElements = [],
            this.outputNameElements = [],
            this.outputScaleElements = [],
            this.outputScaleSuggestionElements = [],
            this.inputScaleSuggestionElements = [],
            this.inputScaleElements = [],
            this.inputBoundsElements = [],
            this.outputBoundsElements = [],
            this.addSourceDimensionIcon = Object(x.a)({
                svg: w.a,
                text: "S"
            }),
            this.addOutputDimensionIcon = Object(x.a)({
                svg: w.a,
                text: "V"
            }),
            this.addOutputDimensionCell = document.createElement("div"),
            this.addOutputDimensionInput = j(),
            this.inputScaleModified = [],
            this.outputScaleModified = [],
            this.curSourceRank = -1,
            this.curRank = -1,
            this.curTransform = void 0,
            this.addingSourceDimension = !1,
            this.resetToIdentityButton = Object(x.a)({
                text: "Set to identity",
                title: "Reset to identity transform",
                onClick: ()=>{
                    const {transform: e} = this
                      , t = e.value.rank;
                    e.transform = Object(T.c)(Float64Array, t + 1)
                }
            }),
            this.resetToDefaultButton = Object(x.a)({
                text: "Reset to default",
                title: "Reset to default input scales, transform, and output dimensions.",
                onClick: ()=>{
                    const {transform: e} = this;
                    if (e.mutableSourceRank)
                        return;
                    const {defaultTransform: t} = e;
                    let {outputSpace: n} = t;
                    const i = n.ids.map(()=>Object(s.D)());
                    e.value = Object.assign(Object.assign({}, t), {
                        outputSpace: Object.assign(Object.assign({}, n), {
                            ids: i
                        })
                    })
                }
            });
            const {element: i} = this;
            this.registerDisposer(new E.b(i,I)).allShortcutsAreGlobal = !0,
            i.classList.add("neuroglancer-coordinate-space-transform-widget"),
            this.registerDisposer(new M.b(i,I));
            const r = Object(m.a)(()=>this.updateView());
            this.registerDisposer(e.changed.add(r));
            const {coefficientContainer: a, translationContainer: o, outputNameContainer: l, inputNameContainer: c, inputScaleContainer: u, inputLowerBoundsContainer: d, inputUpperBoundsContainer: h, outputScaleContainer: p, addOutputDimensionCell: f, addOutputDimensionIcon: g, addSourceDimensionIcon: v, resetToIdentityButton: b, resetToDefaultButton: y} = this;
            a.style.display = "contents",
            o.style.display = "contents",
            l.style.display = "contents",
            c.style.display = "contents",
            u.style.display = "contents",
            p.style.display = "contents",
            d.style.display = "contents",
            h.style.display = "contents";
            const S = document.createElement("div");
            S.classList.add("neuroglancer-coordinate-space-transform-widget-reset-buttons"),
            b.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-identity"),
            y.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-default"),
            S.appendChild(b),
            S.appendChild(y),
            i.appendChild(S);
            for (const [e,t] of [["source", "Source dimensions"], ["output", "Output dimensions"], ["input-lower", "Lower"], ["input-upper", "Upper"], ["input-scale", "Scale"], ["translation", "Translation"]]) {
                const n = document.createElement("div");
                n.classList.add(`neuroglancer-coordinate-space-transform-${e}-label`),
                n.classList.add("neuroglancer-coordinate-space-transform-label"),
                n.textContent = t,
                i.appendChild(n)
            }
            e.mutableSourceRank && f.appendChild(v),
            f.appendChild(g),
            f.classList.add("neuroglancer-coordinate-space-transform-output-extend");
            g.title = "Embed in additional output dimension",
            v.title = "Extend to additional source dimension",
            f.appendChild(this.addOutputDimensionInput),
            f.dataset.isActive = "false",
            g.addEventListener("click", ()=>{
                this.addingSourceDimension = !1,
                this.addOutputDimensionInput.title = "Embed in additional output dimension",
                this.addOutputDimensionCell.dataset.isActive = "true",
                this.addOutputDimensionInput.focus()
            }
            ),
            v.addEventListener("click", ()=>{
                this.addingSourceDimension = !0,
                this.addOutputDimensionInput.title = "Extend to additional source dimension",
                this.addOutputDimensionCell.dataset.isActive = "true",
                this.addOutputDimensionInput.focus()
            }
            ),
            this.addOutputDimensionInput.addEventListener("blur", ()=>{
                this.updateAddOutputDimensionCellStyle()
            }
            ),
            i.appendChild(a),
            i.appendChild(l),
            i.appendChild(c),
            i.appendChild(u),
            i.appendChild(p),
            i.appendChild(d),
            i.appendChild(h),
            a.appendChild(o),
            i.addEventListener("input", e=>{
                const {target: t} = e;
                if (t instanceof HTMLInputElement) {
                    L(t);
                    let e = this.inputScaleElements.indexOf(t);
                    if (-1 !== e)
                        return this.inputScaleModified[e] = !0,
                        void this.updateScaleValidity(t);
                    if (e = this.outputScaleElements.indexOf(t),
                    -1 !== e)
                        return this.outputScaleModified[e] = !0,
                        void this.updateScaleValidity(t);
                    if (e = this.outputNameElements.indexOf(t),
                    -1 !== e)
                        return void this.updateOutputNameValidity();
                    if (this.coefficientContainer.contains(t))
                        return void this.updateCoefficientValidity(t)
                }
            }
            );
            const C = (e,t,n)=>{
                Object(E.c)(i, e, e=>{
                    e.stopPropagation();
                    const i = e.target;
                    if (!(i instanceof HTMLInputElement))
                        return;
                    if (0 !== n && (i.selectionStart !== i.selectionEnd || i.selectionStart !== (1 === n ? i.value.length : 0)))
                        return;
                    const r = this.getElementGridPosition(i);
                    if (void 0 === r)
                        return;
                    const s = this.getElementByGridPosition(r.row + t, r.col + n);
                    null !== s && (s.focus(),
                    e.preventDefault())
                }
                )
            }
            ;
            C("move-up", -1, 0),
            C("move-down", 1, 0),
            C("move-left", 0, -1),
            C("move-right", 0, 1);
            const O = (e,t)=>{
                e.addEventListener("focusout", n=>{
                    const {relatedTarget: i} = n;
                    i instanceof Node && e.contains(i) || t(n)
                }
                )
            }
            ;
            O(a, ()=>{
                this.updateModelTransform() || this.updateViewTransformCoefficients()
            }
            ),
            O(l, ()=>{
                this.updateModelOutputNames() || this.updateViewOutputNames()
            }
            ),
            O(u, ()=>{
                this.updateModelInputScales() || this.updateViewInputScales()
            }
            ),
            O(p, ()=>{
                this.updateModelOutputScales() || this.updateViewOutputScales()
            }
            ),
            Object(E.c)(i, "cancel", e=>{
                this.curTransform = void 0,
                this.updateView(),
                e.target.blur()
            }
            ),
            Object(E.c)(a, "commit", ()=>{
                this.updateModelTransform()
            }
            ),
            Object(E.c)(l, "commit", ()=>{
                this.updateModelOutputNames()
            }
            ),
            Object(E.c)(u, "commit", ()=>{
                this.updateModelInputScales()
            }
            ),
            Object(E.c)(p, "commit", ()=>{
                this.updateModelOutputScales()
            }
            ),
            i.addEventListener("focusin", e=>{
                const {target: t} = e;
                t instanceof HTMLInputElement && t.select()
            }
            ),
            this.updateView()
        }
        updateWillBeDeletedAttributes(e) {
            const {rank: t} = this.transform.value;
            void 0 === e && (e = new Array(t)).fill(!1);
            const {coefficientElements: n, inputBoundsElements: i, inputScaleElements: r} = this;
            for (let s = 0; s < t; ++s) {
                const a = e[s];
                for (let i = 0; i <= t; ++i) {
                    const r = n[t * i + s]
                      , o = i < t && e[i];
                    r.dataset.willBeDeleted = (a || o).toString()
                }
                r[s].dataset.willBeDeleted = a.toString();
                const {lower: o, upper: l} = i[s];
                o.dataset.willBeDeleted = a.toString(),
                l.dataset.willBeDeleted = a.toString()
            }
        }
        updateAddOutputDimensionCellStyle() {
            const {addOutputDimensionInput: e} = this;
            this.addOutputDimensionCell.dataset.isActive = (0 !== e.value.length || document.activeElement === e).toString()
        }
        updateOutputNameValidity() {
            const {outputNameElements: e} = this
              , t = e.map(e=>e.value)
              , {value: {sourceRank: n, rank: i}, mutableSourceRank: r} = this.transform;
            if (e.length !== i + 1)
                return;
            const a = Object(s.r)(t);
            let o = new Array(i);
            o.fill(!1);
            for (let s = 0; s <= i; ++s) {
                let i = a[s];
                0 === t[s].length && (r || s >= n) && (i = !0,
                o[s] = !0),
                e[s].dataset.isValid = i.toString()
            }
            this.updateWillBeDeletedAttributes(o),
            this.updateAddOutputDimensionCellStyle()
        }
        updateScaleValidity(e) {
            const t = void 0 !== Object(D.c)(e.value);
            e.dataset.isValid = t.toString()
        }
        updateCoefficientValidity(e) {
            const t = Number.isFinite(Number(e.value));
            e.dataset.isValid = t.toString()
        }
        getElementGridPosition(e) {
            {
                const t = this.outputNameElements.indexOf(e);
                if (-1 !== t)
                    return {
                        row: t,
                        col: -2
                    }
            }
            {
                const t = this.inputScaleElements.indexOf(e);
                if (-1 !== t)
                    return {
                        row: -1,
                        col: t
                    }
            }
            {
                const t = this.coefficientElements.indexOf(e)
                  , {rank: n} = this.transform.value;
                if (-1 !== t)
                    return {
                        row: t % n,
                        col: Math.floor(t / n)
                    }
            }
            {
                const t = this.outputScaleElements.indexOf(e);
                if (-1 !== t)
                    return {
                        row: t,
                        col: -1
                    }
            }
        }
        getElementByGridPosition(e, t) {
            const {rank: n} = this.transform.value;
            return -1 === e ? t < 0 || t >= n ? null : this.inputScaleElements[t] : -2 === t ? e < 0 || e > n ? null : this.outputNameElements[e] : -1 === t ? e < 0 || e >= n ? null : this.outputScaleElements[e] : e < 0 || e >= n || t < 0 || t > n ? null : this.coefficientElements[t * n + e]
        }
        dimensionRefCount(e) {
            return (Object(s.x)(e) ? this.localCombiner : this.globalCombiner).dimensionRefCounts.get(e) || 0
        }
        updateModelInputScales() {
            return N(this.inputScaleElements, this.inputScaleModified, this.transform.inputSpace)
        }
        updateModelOutputScales() {
            return N(this.outputScaleElements, this.outputScaleModified, this.transform.outputSpace)
        }
        updateModelOutputNames() {
            const e = this.outputNameElements.map(e=>e.value)
              , {value: t, mutableSourceRank: n} = this.transform
              , {outputSpace: i, rank: r, sourceRank: a} = t;
            if (e.length !== r + 1)
                return;
            const o = []
              , l = []
              , c = 0 !== e[r].length;
            let u = a;
            for (let t = 0; t <= r; ++t) {
                const i = e[t];
                if (0 !== i.length)
                    l.push(i),
                    o.push(t);
                else if (t < a) {
                    if (!n)
                        return !1;
                    --u
                }
            }
            if (!Object(s.F)(l))
                return !1;
            const d = i.names;
            if (!c && Object(k.a)(d, l))
                return !0;
            let h = t.inputSpace
              , p = t.outputSpace
              , f = t.transform;
            if (c) {
                this.addingSourceDimension && ++u;
                const t = e[r]
                  , n = (Object(s.x)(t) ? this.localCombiner : this.globalCombiner).combined.value
                  , a = n.names.indexOf(t);
                let o, l;
                -1 !== a ? (o = n.units[a],
                l = n.scales[a]) : (o = "",
                l = 1);
                const c = h.boundingBoxes.map(e=>Object(s.n)(e, r, r + 1));
                this.addingSourceDimension || c.push(Object(s.C)(r + 1, r)),
                h = Object(s.z)({
                    valid: h.valid,
                    rank: r + 1,
                    names: [...h.names, ""],
                    ids: [...h.ids, Object(s.D)()],
                    timestamps: [...h.timestamps, Date.now()],
                    scales: Float64Array.from([...h.scales, l]),
                    units: [...h.units, o],
                    boundingBoxes: c
                }),
                p = Object(s.z)({
                    valid: i.valid,
                    rank: r + 1,
                    names: [...i.names, t],
                    ids: [...i.ids, Object(s.D)()],
                    timestamps: [...i.timestamps, Date.now()],
                    scales: Float64Array.from([...i.scales, l]),
                    units: [...i.units, o]
                }),
                f = Object(T.e)(new Float64Array((r + 2) ** 2), r + 1, f, r)
            }
            f = Object(s.t)(Float64Array, f, h.rank, o, o),
            h = Object(s.E)(h, o),
            p = Object(s.E)(p, o);
            const m = p.ids.map((e,t)=>{
                const n = o[t];
                if (n === r)
                    return e;
                const i = l[t]
                  , a = d[n];
                return i === a || 1 === this.dimensionRefCount(a) && this.dimensionRefCount(i) === (d.includes(i) ? 1 : 0) ? e : Object(s.D)()
            }
            )
              , g = p.timestamps.map((e,t)=>{
                const n = o[t];
                return n === r || l[t] === d[n] ? e : Date.now()
            }
            );
            p = Object.assign(Object.assign({}, p), {
                names: l,
                ids: m,
                timestamps: g
            });
            let v = {
                rank: p.rank,
                sourceRank: u,
                outputSpace: p,
                inputSpace: h,
                transform: f
            };
            return this.transform.value = v,
            !0
        }
        updateModelTransform() {
            const e = this.coefficientElements
              , {rank: t} = this.transform.value
              , n = new Float64Array((t + 1) ** 2);
            n[n.length - 1] = 1;
            for (let i = 0; i < t; ++i)
                for (let r = 0; r <= t; ++r) {
                    const s = e[r * t + i]
                      , a = parseFloat(s.value);
                    if (!Number.isFinite(a))
                        return !1;
                    n[r * (t + 1) + i] = a
                }
            return this.transform.transform = n,
            !0
        }
        updateViewOutputNames() {
            const {transform: {value: {outputSpace: e, rank: t}}} = this;
            if (t !== this.curRank)
                return;
            const {outputNameElements: n} = this
              , {names: i} = e;
            for (let e = 0; e < t; ++e) {
                const t = n[e];
                t.value = i[e],
                t.dataset.isValid = "true",
                L(t)
            }
            n[t].value = "",
            this.updateWillBeDeletedAttributes()
        }
        updateViewTransformCoefficients() {
            const {transform: {value: {transform: e, rank: t}}} = this
              , {coefficientElements: n} = this;
            for (let i = 0; i < t; ++i)
                for (let r = 0; r <= t; ++r) {
                    const s = n[r * t + i];
                    s.value = e[r * (t + 1) + i].toString(),
                    s.dataset.isValid = "true",
                    L(s)
                }
        }
        ensureViewRankUpdated() {
            const e = this.transform.value
              , {rank: t} = e
              , n = e.sourceRank;
            if (this.curSourceRank === n && this.curRank === t)
                return;
            const {inputBoundsElements: i, inputNameElements: r, inputScaleElements: a} = this
              , {element: o, coefficientElements: l, outputNameElements: c, outputScaleElements: u, outputScaleSuggestionElements: d, inputScaleSuggestionElements: h, outputBoundsElements: p, coefficientContainer: f, translationContainer: m, outputNameContainer: g, inputNameContainer: v, inputScaleContainer: y, inputLowerBoundsContainer: S, inputUpperBoundsContainer: w, outputScaleContainer: x} = this;
            o.style.gridTemplateColumns = "[outputLabel headerStart] min-content [outputNames] 1fr [outputScales] 1fr [headerEnd] " + `repeat(${Math.max(1, t) + 1}, [sourceDim] 1fr)`,
            o.style.gridTemplateRows = "[sourceLabel headerStart] auto [sourceNames] auto [sourceLower] auto [sourceUpper] auto [sourceScales] auto [headerEnd]" + `repeat(${t + 1}, [outputDim] auto)`,
            Object(b.b)(f),
            Object(b.b)(m),
            f.appendChild(m),
            Object(b.b)(g),
            Object(b.b)(v),
            Object(b.b)(y),
            Object(b.b)(S),
            Object(b.b)(w),
            Object(b.b)(x),
            r.length = 0,
            a.length = 0,
            i.length = 0,
            u.length = 0,
            d.length = 0,
            h.length = 0,
            l.length = 0,
            c.length = 0,
            p.length = 0;
            for (let e = 0; e < t; ++e) {
                const t = t=>{
                    t.classList.add("neuroglancer-coordinate-space-transform-input"),
                    e >= n && t.classList.add("neuroglancer-coordinate-space-transform-singleton")
                }
                ;
                {
                    const n = document.createElement("div");
                    n.classList.add("neuroglancer-coordinate-space-transform-input-name"),
                    t(n),
                    n.style.gridRowStart = "sourceNames",
                    n.style.gridColumnStart = `sourceDim ${e + 1}`,
                    v.appendChild(n),
                    r.push(n)
                }
                {
                    const {cellElement: n, inputElement: i, suggestionElement: r} = P();
                    n.classList.add("neuroglancer-coordinate-space-transform-input-scale-container"),
                    t(n),
                    n.style.gridRowStart = "sourceScales",
                    n.style.gridColumnStart = `sourceDim ${e + 1}`,
                    y.appendChild(n),
                    a.push(i),
                    h.push(r);
                    const o = e;
                    r.addEventListener("click", ()=>{
                        const e = Object(s.q)(this.transform, o);
                        void 0 !== e && (this.transform.inputSpace.value = V(this.transform.inputSpace.value, o, e.scale, e.unit))
                    }
                    )
                }
                {
                    const n = document.createElement("div");
                    t(n),
                    n.classList.add("neuroglancer-coordinate-space-transform-input-bounds"),
                    n.style.gridRowStart = "sourceLower",
                    n.style.gridColumnStart = `sourceDim ${e + 1}`,
                    S.appendChild(n);
                    const r = document.createElement("div");
                    t(r),
                    r.classList.add("neuroglancer-coordinate-space-transform-input-bounds"),
                    r.style.gridRowStart = "sourceUpper",
                    r.style.gridColumnStart = `sourceDim ${e + 1}`,
                    w.appendChild(r),
                    i.push({
                        lower: n,
                        upper: r
                    })
                }
            }
            for (let e = 0; e < t; ++e) {
                for (let i = 0; i <= t; ++i) {
                    const r = document.createElement("input");
                    r.classList.add("neuroglancer-coordinate-space-transform-coeff"),
                    r.spellcheck = !1,
                    r.autocomplete = "off",
                    r.size = 1,
                    r.style.gridRowStart = `outputDim ${e + 1}`,
                    r.placeholder = " ",
                    r.style.gridColumnStart = `sourceDim ${i + 1}`,
                    l[i * t + e] = r,
                    i === t ? r.classList.add("neuroglancer-coordinate-space-transform-translation-coeff") : i == n && r.classList.add("neuroglancer-coordinate-space-transform-singleton"),
                    (i === t ? m : f).appendChild(r)
                }
                {
                    const {cellElement: t, suggestionElement: n, inputElement: i} = P();
                    t.classList.add("neuroglancer-coordinate-space-transform-output-scale-container"),
                    t.style.gridRowStart = `outputDim ${e + 1}`,
                    t.style.gridColumnStart = "outputScales";
                    const r = e;
                    n.addEventListener("click", ()=>{
                        const {value: e} = this.transform
                          , t = Object(s.s)(e, r);
                        void 0 !== t && (this.transform.outputSpace.value = V(e.outputSpace, r, t.scale, t.unit))
                    }
                    ),
                    d.push(n),
                    x.appendChild(t),
                    u.push(i)
                }
                {
                    const t = document.createElement("div");
                    t.classList.add("neuroglancer-coordinate-space-transform-output-name-container"),
                    t.style.gridRowStart = `outputDim ${e + 1}`,
                    t.style.gridColumnStart = "outputNames";
                    const i = j();
                    i.title = "Rebind to a different dimension",
                    e >= n ? i.title += ", or delete to remove singleton dimension" : this.transform.mutableSourceRank && (i.title += ", or delete to remove source dimension"),
                    i.title += ".  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).",
                    c.push(i),
                    g.appendChild(t),
                    t.appendChild(i);
                    const r = document.createElement("div");
                    r.classList.add("neuroglancer-coordinate-space-transform-output-bounds"),
                    t.appendChild(r);
                    const s = document.createElement("div");
                    s.classList.add("neuroglancer-coordinate-space-transform-output-bounds"),
                    t.appendChild(s),
                    p.push({
                        lower: r,
                        upper: s
                    }),
                    t.addEventListener("mousedown", e=>{
                        e.target !== i && (i.focus(),
                        e.preventDefault())
                    }
                    )
                }
            }
            c.push(this.addOutputDimensionInput),
            this.addOutputDimensionInput.value = "",
            g.appendChild(this.addOutputDimensionCell),
            this.curSourceRank = n,
            this.curRank = t
        }
        updateViewInputScales() {
            this.ensureViewRankUpdated(),
            this.inputScaleModified.length = 0;
            const {inputSpace: e, rank: t, sourceRank: n} = this.transform.value
              , {inputBoundsElements: i, inputNameElements: r, inputScaleElements: a, inputScaleSuggestionElements: o} = this
              , {names: l, scales: c, units: u, bounds: {lowerBounds: d, upperBounds: h}} = e;
            for (let e = 0; e < t; ++e) {
                const t = a[e]
                  , p = c[e]
                  , f = u[e];
                let m;
                if (t.value = Object(D.b)(p, f, {
                    elide1: !1
                }),
                t.dataset.isValid = "true",
                L(t),
                e < n) {
                    let n = l[e];
                    n || (n = `${e}`),
                    r[e].textContent = n,
                    m = `source dimension ${n}`,
                    t.title = `Override scale of ${m}`
                } else
                    m = "singleton dimension",
                    t.title = `Set extent of ${m}`;
                const {lower: g, upper: v} = A(d[e], h[e])
                  , b = i[e];
                b.lower.textContent = g,
                b.lower.title = `Lower bound of ${m}`,
                b.upper.title = `Upper bound of ${m}`,
                b.upper.textContent = v,
                R(o[e], Object(s.q)(this.transform, e), p, f, `Revert scale of ${m} to `)
            }
        }
        updateViewOutputScales() {
            const {value: e} = this.transform
              , {rank: t, names: n, units: i, scales: r, bounds: {lowerBounds: a, upperBounds: o}} = e.outputSpace
              , {outputScaleElements: l, outputBoundsElements: c, outputScaleSuggestionElements: u} = this;
            for (let d = 0; d < t; ++d) {
                const t = l[d]
                  , h = r[d]
                  , p = i[d];
                t.value = Object(D.b)(h, p, {
                    elide1: !1
                }),
                L(t);
                const f = n[d];
                t.dataset.isValid = "true";
                const m = `Change coordinates of ${Object(s.x)(f) ? "local" : "global"} dimension ${f}`;
                t.title = `${m} (does not rescale the source)`;
                const {lower: g, upper: v} = A(a[d], o[d])
                  , b = c[d];
                b.lower.textContent = g,
                b.upper.textContent = v,
                R(u[d], Object(s.s)(e, d), h, p, `${m} to inferred scale of `)
            }
        }
        updateResetButtonVisibility(e=!1, t=!1) {
            const {transform: {value: n, mutableSourceRank: i, defaultTransform: r}} = this
              , {rank: a} = n;
            this.resetToIdentityButton.style.visibility = e || !Object(T.g)(n.transform, a + 1, a + 1) ? "visible" : "hidden",
            this.resetToDefaultButton.style.visibility = i || !e && !t && Object(s.g)(r, n) ? "hidden" : "visible"
        }
        updateView() {
            const e = this.transform.value;
            this.curTransform !== e && (this.curTransform = e,
            this.ensureViewRankUpdated(),
            this.updateViewInputScales(),
            this.updateViewOutputNames(),
            this.updateViewTransformCoefficients(),
            this.updateViewOutputScales(),
            this.updateAddOutputDimensionCellStyle(),
            this.updateResetButtonVisibility())
        }
        disposed() {
            Object(b.c)(this.element),
            super.disposed()
        }
    }
    n(163);
    var F = n(23);
    var _ = n(3)
      , U = n(77);
    class z {
        constructor() {
            this.anchorIndex = 0,
            this.anchorClientOffset = 0,
            this.anchorOffset = 0,
            this.generation = -1
        }
    }
    class G {
        constructor() {
            this.startIndex = 0,
            this.endIndex = 0,
            this.anchorIndex = 0,
            this.anchorOffset = 0,
            this.scrollOffset = 0
        }
    }
    class $ {
        constructor() {
            this.itemSize = [],
            this.totalKnownSize = 0,
            this.numItemsInTotalKnownSize = 0
        }
        getEstimatedSize(e) {
            const t = this.itemSize[e];
            return void 0 === t ? this.totalKnownSize / this.numItemsInTotalKnownSize : t
        }
        getEstimatedTotalSize() {
            return this.totalKnownSize / this.numItemsInTotalKnownSize * this.itemSize.length
        }
        getEstimatedOffset(e, t=0, n=0) {
            for (; t < e; ++t)
                n += this.getEstimatedSize(t);
            for (; t > e; --t)
                n -= this.getEstimatedSize(t - 1);
            return n
        }
    }
    function W(e, t, n, i, r, s) {
        const {anchorIndex: a, anchorClientOffset: o, anchorOffset: l} = s;
        let c, u, d, h, p;
        if (0 === i || 0 === r.totalKnownSize)
            c = Math.max(0, a - 5),
            u = Math.min(n, c + 10),
            p = a,
            d = l,
            h = o;
        else {
            const e = l - o - 1 * i
              , s = l - o - .5 * i
              , f = l - o + i + .5 * i
              , m = l - o + i + 1 * i;
            c = t.startIndex;
            let g = r.getEstimatedOffset(c, a, l);
            if (g < e)
                for (; c + 1 < n; ++c) {
                    const e = r.getEstimatedSize(c);
                    if (g + e >= s)
                        break;
                    g += e
                }
            if (g >= s)
                for (; g > e && c > 0; --c) {
                    g -= r.getEstimatedSize(c - 1)
                }
            u = t.endIndex;
            let v = r.getEstimatedOffset(u, a, l);
            if (v < f)
                for (; v <= m && u + 1 <= n; ++u) {
                    v += r.getEstimatedSize(u)
                }
            else if (v >= m)
                for (; u > c; --u) {
                    const e = r.getEstimatedSize(u - 1);
                    if (v - e < f)
                        break;
                    v -= e
                }
            for (p = a,
            d = l; p < c; ++p) {
                d += r.getEstimatedSize(p)
            }
            for (; p > u; --p) {
                d -= r.getEstimatedSize(p - 1)
            }
            h = l - o
        }
        e.startIndex = c,
        e.endIndex = u,
        e.anchorIndex = p,
        e.anchorOffset = d,
        e.scrollOffset = h
    }
    class H extends v.a {
        constructor(e) {
            super(),
            this.element = document.createElement("div"),
            this.spacer = document.createElement("div"),
            this.topItems = document.createElement("div"),
            this.bottomItems = document.createElement("div"),
            this.renderedItems = [],
            this.newRenderedItems = [],
            this.state = new z,
            this.renderParams = new G,
            this.newRenderParams = new G,
            this.sizes = new $,
            this.debouncedUpdateView = this.registerCancellable(Object(m.a)(()=>this.updateView())),
            this.resizeObserver = new U.a(()=>this.updateView());
            const {selectedIndex: t} = e;
            void 0 !== t && (this.state.anchorIndex = t,
            this.state.anchorOffset = 0,
            this.state.anchorClientOffset = 0);
            const n = this.source = e.source;
            this.sizes.itemSize.length = n.length;
            const {element: i, spacer: r, topItems: s, bottomItems: a} = this;
            this.resizeObserver.observe(i),
            this.registerDisposer(()=>this.resizeObserver.disconnect()),
            i.appendChild(r),
            i.appendChild(s),
            s.style.position = "absolute",
            s.style.left = "0px",
            s.style.right = "0px",
            a.style.left = "0px",
            a.style.right = "0px",
            a.style.position = "absolute",
            i.appendChild(a),
            i.addEventListener("scroll", ()=>{
                const e = i.scrollTop;
                this.state.anchorClientOffset = this.renderParams.anchorOffset - e,
                this.renderParams.scrollOffset = e,
                this.debouncedUpdateView()
            }
            )
        }
        updateView() {
            const {element: e} = this;
            if (null === e.offsetParent)
                return;
            const t = e.offsetHeight
              , {source: n, state: i, sizes: r} = this
              , s = n.length
              , {spacer: a, topItems: o, bottomItems: l} = this;
            let c;
            for (; ; ) {
                c = this.newRenderParams;
                const e = this.renderParams;
                if (W(c, e, s, t, r, i),
                h = e,
                !((d = c).startIndex < h.startIndex || d.endIndex > h.endIndex)) {
                    e.scrollOffset = c.scrollOffset,
                    c = e;
                    break
                }
                this.renderParams = c,
                this.newRenderParams = e;
                const n = this.renderedItems
                  , a = this.newRenderedItems;
                this.renderedItems = a,
                this.newRenderedItems = n;
                const {render: p} = this.source
                  , {startIndex: f, endIndex: m} = e
                  , {startIndex: g, endIndex: v, anchorIndex: y} = c;
                function *u(e, t) {
                    for (let i = e; i < t; ++i) {
                        let e;
                        e = i >= f && i < m ? n[i - f] : p(i),
                        a[i - g] = e,
                        yield e
                    }
                }
                Object(b.d)(o, u(g, y)),
                Object(b.d)(l, u(y, v));
                for (let e = g; e < v; ++e) {
                    const t = a[e - g].getBoundingClientRect().height
                      , n = r.itemSize[e];
                    void 0 !== n && (r.totalKnownSize -= n,
                    --r.numItemsInTotalKnownSize),
                    r.itemSize[e] = t,
                    r.totalKnownSize += t,
                    ++r.numItemsInTotalKnownSize
                }
            }
            var d, h;
            !function(e, t) {
                const n = t.getEstimatedOffset(e.anchorIndex)
                  , i = e.anchorOffset;
                e.anchorOffset = n,
                e.scrollOffset += n - i
            }(c, r),
            i.anchorIndex = c.anchorIndex,
            i.anchorOffset = c.anchorOffset,
            i.anchorClientOffset = c.anchorOffset - c.scrollOffset,
            a.style.height = `${r.getEstimatedTotalSize()}px`,
            o.style.bottom = `calc(100% - ${c.anchorOffset}px)`,
            l.style.top = `${c.anchorOffset}px`,
            e.scrollTop = c.scrollOffset
        }
        getItemElement(e) {
            const {renderParams: {startIndex: t, endIndex: n}, renderedItems: i} = this;
            if (e >= t && e < n)
                return i[e - t]
        }
        scrollItemIntoView(e) {
            const t = this.sizes.getEstimatedOffset(e)
              , n = t + this.sizes.getEstimatedSize(e)
              , i = this.element.scrollTop;
            if (t < i)
                this.state.anchorIndex = e,
                this.state.anchorOffset = t,
                this.state.anchorClientOffset = 0;
            else {
                if (!(t > i && n > i + this.element.offsetHeight))
                    return;
                this.state.anchorIndex = e + 1,
                this.state.anchorOffset = n,
                this.state.anchorClientOffset = this.element.offsetHeight
            }
            this.debouncedUpdateView()
        }
        disposed() {
            Object(b.c)(this.element)
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function J(e) {
        let t = document.createElement("div");
        return t.textContent = e.value,
        t
    }
    function *q(e) {
        for (; e.length > 0; ) {
            const t = e.match(/[:/_]+/);
            if (null === t)
                return void (yield e);
            const n = t.index + t[0].length;
            yield e.substring(0, n),
            e = e.substring(n)
        }
    }
    function Y(e) {
        let t = document.createElement("div");
        t.className = "neuroglancer-multiline-autocomplete-completion-with-description",
        t.textContent = e.value;
        let n = document.createElement("div");
        return n.className = "neuroglancer-multiline-autocomplete-completion-description",
        n.textContent = e.description || "",
        t.appendChild(n),
        t
    }
    const X = E.a.fromObject({
        arrowdown: {
            action: "cycle-next-active-completion"
        },
        arrowup: {
            action: "cycle-prev-active-completion"
        },
        home: {
            action: "home"
        },
        end: {
            action: "end"
        },
        tab: {
            action: "choose-active-completion-or-prefix",
            preventDefault: !1
        },
        enter: {
            action: "commit"
        },
        escape: {
            action: "cancel",
            preventDefault: !1,
            stopPropagation: !1
        }
    })
      , K = 200;
    class Z extends v.a {
        constructor(e) {
            super(),
            this.element = document.createElement("div"),
            this.inputElement = document.createElement("span"),
            this.hintElement = document.createElement("span"),
            this.completionsVirtualList = void 0,
            this.onCommit = new _.b,
            this.onInput = new _.b,
            this.prevInputValue = "",
            this.completionsVisible = !1,
            this.activeCompletionPromise = null,
            this.activeCompletionCancellationToken = void 0,
            this.hasFocus = !1,
            this.completionResult = null,
            this.dropdownContentsStale = !0,
            this.hasResultForDropdown = !1,
            this.commonPrefix = "",
            this.completionDisabled = -1,
            this.activeIndex = -1,
            this.dropdownStyleStale = !0,
            this.resizeHandler = ()=>{
                this.completionsVisible && this.updateDropdownStyle()
            }
            ,
            this.resizeObserver = new U.a(this.resizeHandler),
            this.debouncedUpdateHintState = this.registerCancellable(r()(()=>this.updateHintState(), 0)),
            this.completer = e.completer;
            const {delay: t=K} = e;
            let n = this.scheduleUpdateCompletions = r()(()=>{
                const e = this.activeCompletionCancellationToken = new F.b;
                let t = this.activeCompletionPromise = this.completer(this.value, e);
                null !== t && t.then(e=>{
                    this.activeCompletionPromise === t && (this.setCompletions(e),
                    this.activeCompletionPromise = null)
                }
                )
            }
            , t);
            this.registerDisposer(()=>{
                n.cancel()
            }
            );
            const {element: i, inputElement: s, hintElement: a} = this;
            i.classList.add("neuroglancer-multiline-autocomplete"),
            this.registerEventListener(window, "resize", this.resizeHandler),
            this.resizeObserver.observe(i),
            this.registerDisposer(()=>this.resizeObserver.unobserve(s)),
            s.contentEditable = "true",
            s.spellcheck = !1,
            i.appendChild(document.createTextNode("")),
            i.appendChild(s),
            i.appendChild(a),
            s.classList.add("neuroglancer-multiline-autocomplete-input"),
            a.classList.add("neuroglancer-multiline-autocomplete-hint"),
            s.addEventListener("input", ()=>{
                this.completionDisabled = -1,
                this.setValueAndSelection(this.value, this.getSelectionRange()),
                this.debouncedUpdateHintState()
            }
            ),
            this.registerEventListener(document, "selectionchange", ()=>{
                const e = this.getSelectionRange()
                  , {completionDisabled: t} = this;
                void 0 !== e && e.begin === t && e.end === t || (this.completionDisabled = -1,
                this.debouncedUpdateHintState())
            }
            ),
            this.setValueAndSelection(""),
            this.updateHintState(),
            i.addEventListener("pointerdown", e=>{
                const {target: t} = e;
                if (t instanceof Node) {
                    if (s.contains(t))
                        return;
                    const {completionsVirtualList: e} = this;
                    if (void 0 !== e && e.element.contains(t))
                        return
                }
                s === document.activeElement && (this.moveCaretToEndOfInput(),
                e.stopPropagation(),
                e.preventDefault())
            }
            ),
            i.addEventListener("click", ()=>{
                s.focus()
            }
            ),
            this.registerEventListener(this.inputElement, "focus", ()=>{
                if (!this.hasFocus) {
                    this.hasFocus = !0,
                    this.dropdownStyleStale = !0,
                    this.updateDropdown();
                    const e = document.createRange()
                      , {childNodes: t} = s;
                    e.setStart(s, 0),
                    0 === t.length ? e.setEnd(s, 0) : e.setEndAfter(t[t.length - 1]);
                    const n = window.getSelection();
                    null !== n && (n.removeAllRanges(),
                    n.addRange(e)),
                    this.debouncedUpdateHintState()
                }
            }
            ),
            this.registerEventListener(this.inputElement, "blur", ()=>{
                this.hasFocus && (this.hasFocus = !1,
                this.updateDropdown()),
                this.debouncedUpdateHintState();
                const e = window.getSelection();
                null !== e && e.containsNode(this.inputElement, !0) && e.removeAllRanges(),
                this.onCommit.dispatch(this.value, !1)
            }
            ),
            this.registerEventListener(window, "resize", ()=>{
                this.dropdownStyleStale = !0
            }
            ),
            this.registerEventListener(window, "scroll", ()=>{
                this.dropdownStyleStale = !0
            }
            ),
            this.registerDisposer(new E.b(s,X)).allShortcutsAreGlobal = !0,
            Object(E.c)(s, "cycle-next-active-completion", ()=>{
                this.cycleActiveCompletion(1)
            }
            ),
            Object(E.c)(s, "cycle-prev-active-completion", ()=>{
                this.cycleActiveCompletion(-1)
            }
            ),
            Object(E.c)(s, "home", ()=>{
                this.moveCaretToBeginningOfInput()
            }
            ),
            Object(E.c)(s, "end", ()=>{
                this.moveCaretToEndOfInput()
            }
            ),
            Object(E.c)(s, "choose-active-completion-or-prefix", e=>{
                this.selectActiveCompletion(!0) && e.preventDefault()
            }
            ),
            Object(E.c)(s, "commit", e=>{
                if (this.selectActiveCompletion(!1))
                    e.stopPropagation();
                else {
                    let e = !this.completionsVisible;
                    this.disableCompletion(),
                    this.hideCompletions(),
                    this.onCommit.dispatch(this.value, e)
                }
            }
            ),
            Object(E.c)(s, "cancel", e=>{
                e.stopPropagation(),
                this.cancel() && (e.detail.preventDefault(),
                e.detail.stopPropagation())
            }
            )
        }
        disableCompletion() {
            const e = this.getSelectionRange();
            this.completionDisabled = void 0 !== e && e.end === e.begin ? e.end : -1
        }
        get placeholder() {
            return this.inputElement.dataset.placeholder || ""
        }
        set placeholder(e) {
            this.inputElement.dataset.placeholder = e
        }
        getSelectionRange() {
            const e = window.getSelection();
            if (null === e)
                return;
            if (0 === e.rangeCount)
                return;
            const t = e.getRangeAt(0)
              , {inputElement: n} = this
              , i = document.createRange();
            i.setStart(n, 0),
            i.setEnd(t.startContainer, t.startOffset);
            const r = i.toString().length;
            return {
                begin: r,
                end: r + e.toString().length
            }
        }
        setValueAndSelection(e, t) {
            const n = -1 !== this.completionDisabled;
            this.onInput.dispatch(e);
            const {inputElement: i} = this;
            Object(b.b)(i);
            let r = 0;
            const s = void 0 !== t ? document.createRange() : void 0;
            let a = !0;
            for (const n of q(e)) {
                a || i.appendChild(document.createElement("wbr")),
                a = !1;
                const e = r + n.length
                  , o = document.createTextNode(n);
                if (i.appendChild(o),
                void 0 !== s) {
                    const {begin: n, end: i} = t;
                    n >= r && n <= e && s.setStart(o, n - r),
                    i >= r && i <= e && s.setEnd(o, i - r)
                }
                r = e
            }
            if (void 0 !== s) {
                a && (s.setStart(i, 0),
                s.setEnd(i, 0));
                const e = window.getSelection();
                null !== e && (e.removeAllRanges(),
                e.addRange(s))
            }
            this.completionDisabled = n && void 0 !== t && t.end === t.begin ? t.end : -1
        }
        shouldAttemptCompletion() {
            const {inputElement: e} = this;
            if (document.activeElement !== e)
                return !1;
            const t = this.getSelectionRange();
            return void 0 !== t && t.end === t.begin && t.end != this.completionDisabled && t.end === this.value.length
        }
        hideCompletions() {
            this.cancelActiveCompletion(),
            this.clearCompletions(),
            this.hintElement.textContent = ""
        }
        updateHintState() {
            if (this.debouncedUpdateHintState.cancel(),
            this.shouldAttemptCompletion()) {
                const {value: e} = this;
                if (e === this.prevInputValue)
                    return;
                this.hideCompletions(),
                this.prevInputValue = e,
                this.scheduleUpdateCompletions()
            } else
                this.hideCompletions()
        }
        handleDropdownClick(e) {
            let {completionsVirtualList: t} = this;
            if (void 0 === t)
                return;
            const n = t.element;
            for (let t = e.target; t instanceof HTMLElement && t !== n; t = t.parentElement) {
                const e = t.dataset.completionIndex;
                if (void 0 !== e) {
                    this.selectCompletion(Number(e));
                    break
                }
            }
        }
        cycleActiveCompletion(e) {
            if (null === this.completionResult)
                return;
            let {activeIndex: t} = this
              , n = this.completionResult.completions.length;
            t = -1 === t ? e > 0 ? 0 : n - 1 : (t + e + n) % n,
            this.setActiveIndex(t)
        }
        shouldShowDropdown() {
            let {completionResult: e} = this;
            return !(null === e || !this.hasFocus) && this.hasResultForDropdown
        }
        updateDropdownStyle() {
            const {completionsVirtualList: e, element: t} = this;
            void 0 !== e && /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            function(e, t, {horizontal: n=!1, vertical: i=!0, topMargin: r=6, bottomMargin: s=6, leftMargin: a=6, rightMargin: o=6, maxHeight: l=!0, maxWidth: c=!0}={}) {
                let u = t.getBoundingClientRect();
                if (n) {
                    let t = e.ownerDocument.documentElement.clientHeight
                      , n = u.right
                      , i = t - u.left;
                    n > i ? (e.style.left = "",
                    e.style.right = "0",
                    c && (e.style.maxWidth = n - a + "px")) : (e.style.right = "",
                    e.style.left = "0",
                    c && (e.style.maxWidth = i - o + "px"))
                }
                if (i) {
                    let t = e.ownerDocument.documentElement.clientHeight
                      , n = u.top - r
                      , i = t - u.bottom - s;
                    n > 3 * i ? (e.style.top = "",
                    e.style.bottom = "100%",
                    l && (e.style.maxHeight = n + "px")) : (e.style.top = "100%",
                    e.style.bottom = "",
                    l && (e.style.maxHeight = i + "px"))
                }
            }/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            (e.element, t, {
                horizontal: !1
            }),
            this.dropdownStyleStale = !1
        }
        updateDropdown() {
            let {completionsVirtualList: e} = this;
            if (this.shouldShowDropdown()) {
                if (this.dropdownContentsStale) {
                    void 0 !== e && e.dispose();
                    const t = this.completionResult
                      , {makeElement: n=J} = t;
                    e = this.completionsVirtualList = new H({
                        source: {
                            length: t.completions.length,
                            render: e=>{
                                const i = t.completions[e]
                                  , r = n.call(t, i);
                                return r.classList.add("neuroglancer-multiline-autocomplete-completion"),
                                r.dataset.completionIndex = `${e}`,
                                this.activeIndex === e && r.classList.add("neuroglancer-multiline-autocomplete-completion-active"),
                                r
                            }
                        },
                        selectedIndex: -1 === this.activeIndex ? void 0 : this.activeIndex
                    }),
                    e.element.classList.add("neuroglancer-multiline-autocomplete-dropdown"),
                    e.element.addEventListener("mousedown", e=>{
                        this.inputElement.focus(),
                        e.preventDefault()
                    }
                    ),
                    e.element.addEventListener("mouseup", this.handleDropdownClick.bind(this)),
                    this.element.appendChild(e.element),
                    this.dropdownContentsStale = !1
                }
                this.dropdownStyleStale && this.updateDropdownStyle(),
                this.completionsVisible || (this.completionsVisible = !0);
                const {activeIndex: t} = this;
                -1 !== t && this.completionsVirtualList.scrollItemIntoView(t)
            } else
                this.completionsVisible && (void 0 !== e && (e.dispose(),
                this.completionsVirtualList = void 0,
                this.dropdownContentsStale = !0),
                this.completionsVisible = !1)
        }
        setCompletions(e) {
            this.clearCompletions();
            let {completions: t} = e;
            if (0 === t.length)
                return;
            const n = this.prevInputValue;
            if (void 0 !== n) {
                if (this.completionResult = e,
                1 === t.length) {
                    let i = t[0];
                    e.showSingleResult ? this.hasResultForDropdown = !0 : i.value.startsWith(n) ? this.hasResultForDropdown = !1 : this.hasResultForDropdown = !0,
                    e.selectSingleResult ? this.setActiveIndex(0) : this.setHintValue(this.getCompletedValueByIndex(0))
                } else {
                    this.hasResultForDropdown = !0;
                    let t = function(e) {
                        let t = e[Symbol.iterator]()
                          , {value: n, done: i} = t.next();
                        if (i)
                            return "";
                        let r = n.length;
                        for (; r > 0; ) {
                            let {value: e, done: i} = t.next();
                            if (i)
                                break;
                            let s = 0;
                            for (; s < r && n.charCodeAt(s) === e.charCodeAt(s); ++s)
                                ;
                            r = s
                        }
                        return n.substring(0, r)
                    }(function*() {
                        for (let t of e.completions)
                            yield t.value
                    }())
                      , i = this.getCompletedValue(t);
                    i.startsWith(n) && (this.commonPrefix = i,
                    this.setHintValue(i))
                }
                this.updateDropdown()
            }
        }
        setHintValue(e) {
            const t = this.prevInputValue;
            if (void 0 === t)
                return;
            e !== t && e.startsWith(t) || (e = ""),
            e = e.substring(t.length);
            const {hintElement: n} = this;
            Object(b.b)(n);
            let i = !0;
            for (const t of q(e)) {
                i || n.appendChild(document.createElement("wbr")),
                i = !1;
                const e = document.createTextNode(t);
                n.appendChild(e)
            }
        }
        setActiveIndex(e) {
            if (!this.dropdownContentsStale) {
                let {activeIndex: t} = this;
                const {completionsVirtualList: n} = this;
                if (void 0 !== n) {
                    if (-1 !== t) {
                        const e = n.getItemElement(t);
                        void 0 !== e && e.classList.remove("neuroglancer-multiline-autocomplete-completion-active")
                    }
                    if (-1 !== e) {
                        let t = n.getItemElement(e);
                        void 0 !== t && t.classList.add("neuroglancer-multiline-autocomplete-completion-active"),
                        n.scrollItemIntoView(e)
                    }
                }
            }
            -1 !== e && this.setHintValue(this.getCompletedValueByIndex(e)),
            this.activeIndex = e
        }
        getCompletedValueByIndex(e) {
            return this.getCompletedValue(this.completionResult.completions[e].value)
        }
        getCompletedValue(e) {
            let t = this.completionResult
              , n = this.prevInputValue;
            return void 0 === n ? "" : n.substring(0, t.offset) + e
        }
        moveCaretToBeginningOfInput() {
            const e = document.createRange()
              , {inputElement: t} = this;
            e.setStart(t, 0),
            e.setEnd(t, 0);
            const n = window.getSelection();
            null !== n && (n.removeAllRanges(),
            n.addRange(e),
            this.debouncedUpdateHintState())
        }
        moveCaretToEndOfInput() {
            const e = document.createRange()
              , {inputElement: t} = this
              , {childNodes: n} = t
              , i = n[n.length - 1];
            void 0 === i ? (e.setStart(t, 0),
            e.setEnd(t, 0)) : (e.setStartAfter(i),
            e.setEndAfter(i));
            const r = window.getSelection();
            null !== r && (r.removeAllRanges(),
            r.addRange(e),
            this.debouncedUpdateHintState())
        }
        selectActiveCompletion(e) {
            let {activeIndex: t} = this;
            if (-1 === t) {
                if (!e)
                    return !1;
                let {completionResult: n} = this;
                if (null === n || 1 !== n.completions.length) {
                    let {commonPrefix: e} = this;
                    return e.length > this.value.length && (this.value = e,
                    this.moveCaretToEndOfInput(),
                    !0)
                }
                t = 0
            }
            let n = this.getCompletedValueByIndex(t);
            return this.value !== n && (this.value = n,
            this.moveCaretToEndOfInput(),
            !0)
        }
        selectCompletion(e) {
            this.value = this.getCompletedValueByIndex(e),
            this.moveCaretToEndOfInput()
        }
        cancel() {
            return !1
        }
        cancelActiveCompletion() {
            this.prevInputValue = void 0;
            const e = this.activeCompletionCancellationToken;
            void 0 !== e && e.cancel(),
            this.activeCompletionCancellationToken = void 0,
            this.activeCompletionPromise = null
        }
        clearCompletions() {
            if (null !== this.completionResult) {
                this.activeIndex = -1,
                this.completionResult = null,
                this.dropdownContentsStale = !0,
                this.dropdownStyleStale = !0,
                this.commonPrefix = "";
                const {completionsVirtualList: e} = this;
                void 0 !== e && (e.dispose(),
                this.completionsVirtualList = void 0),
                this.updateDropdown()
            }
        }
        get value() {
            return this.inputElement.textContent || ""
        }
        set value(e) {
            e !== this.value && (this.completionDisabled = -1,
            this.setValueAndSelection(e),
            this.debouncedUpdateHintState())
        }
        disposed() {
            const {completionsVirtualList: e} = this;
            void 0 !== e && e.dispose(),
            Object(b.c)(this.element),
            this.cancelActiveCompletion(),
            super.disposed()
        }
    }
    var Q = n(41);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class ee extends Z {
        constructor(e) {
            const {manager: t} = e.source.layer;
            super({
                completer: (e,n)=>t.dataSourceProviderRegistry.completeUrl({
                    url: e,
                    chunkManager: t.chunkManager,
                    cancellationToken: n
                }).then(e=>({
                    completions: e.completions,
                    makeElement: Y,
                    offset: e.offset,
                    showSingleResult: !0
                })),
                delay: 0
            }),
            this.placeholder = "Data source URL",
            this.dataSourceView = e,
            this.element.classList.add("neuroglancer-layer-data-source-url-input"),
            this.dirty = new u.e(!1);
            const n = e=>{
                e !== this.dataSourceView.source.spec.url && (this.dirty.value = !0)
            }
            ;
            n(""),
            this.onInput.add(n)
        }
        cancel() {
            return this.value = this.dataSourceView.source.spec.url,
            this.dirty.value = !1,
            this.inputElement.blur(),
            !0
        }
    }
    class te extends v.a {
        constructor(e) {
            super(),
            this.model = e,
            this.element = document.createElement("ul"),
            this.generation = -1,
            this.element.classList.add("neuroglancer-layer-data-sources-source-messages");
            const t = this.registerCancellable(Object(m.a)(()=>this.updateView()));
            this.registerDisposer(e.changed.add(t)),
            this.registerDisposer(()=>Object(b.c)(this.element)),
            this.updateView()
        }
        updateView() {
            const {model: e} = this
              , t = e.changed.count;
            if (t === this.generation)
                return;
            this.generation = t;
            const {element: n} = this;
            Object(b.b)(n);
            const i = new Set;
            for (const t of e) {
                const e = `${t.severity} ${t.message}`;
                if (i.has(e))
                    continue;
                i.add(e);
                const r = document.createElement("li");
                n.appendChild(r),
                r.classList.add("neuroglancer-message"),
                r.classList.add(`neuroglancer-message-${y.b[t.severity]}`),
                r.textContent = t.message
            }
        }
    }
    class ne extends v.a {
        constructor(e, t) {
            super(),
            this.loadedSubsource = t,
            this.element = document.createElement("div");
            const {element: n} = this;
            n.classList.add("neuroglancer-layer-data-source-subsource");
            const i = document.createElement("label")
              , r = document.createElement("span")
              , s = ()=>{
                i.dataset.isActive = (void 0 !== t.activated || !t.enabled).toString()
            }
            ;
            s(),
            this.registerDisposer(t.isActiveChanged.add(s)),
            this.registerDisposer(e.enabledSubsourcesChanged.add(s));
            const o = this.registerDisposer(new f.c({
                get value() {
                    return t.enabled
                },
                set value(n) {
                    t.enabled = n,
                    e.enableDefaultSubsources = !1,
                    e.enabledSubsourcesChanged.dispatch()
                },
                changed: e.enabledSubsourcesChanged
            }));
            i.classList.add("neuroglancer-layer-data-sources-info-line"),
            i.appendChild(o.element);
            const l = document.createElement("span");
            l.classList.add("neuroglancer-layer-data-sources-source-id");
            const {id: c} = t.subsourceEntry;
            "default" !== c && (l.textContent = c),
            i.appendChild(l),
            r.classList.add("neuroglancer-layer-data-sources-source-type");
            const u = this.registerDisposer(new te(this.loadedSubsource.messages));
            n.appendChild(i),
            i.appendChild(r),
            n.appendChild(u.element);
            let m = "";
            const {subsource: v} = t.subsourceEntry
              , {volume: b} = v;
            if (b instanceof p.a)
                m = `${g.a[b.dataType].toLowerCase()} volume`;
            else if (v.mesh instanceof d.b)
                m = "meshes (single-res.)";
            else if (v.mesh instanceof d.d)
                m = "meshes (multi-res.)";
            else if (v.mesh instanceof h.d)
                m = "skeletons";
            else if (void 0 !== v.local)
                switch (v.local) {
                case a.c.annotations:
                    m = "Local annotations"
                }
            else
                void 0 !== v.staticAnnotations ? m = "default annotations" : void 0 !== v.annotation ? m = "annotations" : void 0 !== v.singleMesh && (m = "single mesh");
            r.textContent = m
        }
    }
    class ie extends v.a {
        constructor(e) {
            super(),
            this.source = e,
            this.element = document.createElement("div");
            const {element: t} = this
              , n = document.createElement("label");
            n.classList.add("neuroglancer-layer-data-sources-source-default"),
            n.appendChild(this.registerDisposer(new f.c({
                changed: e.enabledSubsourcesChanged,
                get value() {
                    return e.enableDefaultSubsources
                },
                set value(t) {
                    if (e.enableDefaultSubsources !== t) {
                        if (e.enableDefaultSubsources = t,
                        t)
                            for (const t of e.subsources)
                                t.enabled = t.subsourceEntry.default;
                        e.enabledSubsourcesChanged.dispatch()
                    }
                }
            })).element),
            n.appendChild(document.createTextNode("Enable default subsource set")),
            n.title = "Enable the default set of subsources for this data source.",
            t.appendChild(n);
            for (const n of e.subsources)
                t.appendChild(this.registerDisposer(new ne(e,n)).element);
            const i = this.registerDisposer(new B(e.transform,e.layer.localCoordinateSpaceCombiner,e.layer.manager.root.coordinateSpaceCombiner));
            this.element.appendChild(i.element),
            this.registerDisposer(()=>Object(b.c)(this.element))
        }
    }
    class re extends v.a {
        constructor(e, t) {
            super(),
            this.tab = e,
            this.source = t,
            this.element = document.createElement("div"),
            this.seenGeneration = 0,
            this.generation = -1;
            const n = this.urlInput = this.registerDisposer(new ee(this));
            n.onCommit.add((t,i)=>{
                const {source: r} = this
                  , s = r.spec
                  , a = this.source.layer;
                if ((t = a.manager.dataSourceProviderRegistry.normalizeUrl({
                    url: t
                })) !== n.value && (n.disableCompletion(),
                n.setValueAndSelection(t, {
                    begin: t.length,
                    end: t.length
                })),
                n.dirty.value = !1,
                t && t === s.url)
                    i && void 0 !== e.detectedLayerConstructor && se(r.layer);
                else {
                    if (a instanceof Fe)
                        try {
                            const e = a.manager.dataSourceProviderRegistry.suggestLayerName(t);
                            je(a.managedLayer, e)
                        } catch (e) {}
                    r.spec = Object.assign(Object.assign({}, s), {
                        url: t
                    })
                }
            }
            );
            const {element: i} = this;
            i.classList.add("neuroglancer-layer-data-source"),
            i.appendChild(n.element),
            i.appendChild(this.registerDisposer(new te(t.messages)).element),
            this.updateView()
        }
        updateView() {
            const e = this.source.changed.count;
            if (e === this.generation)
                return;
            this.generation = e,
            this.urlInput.value = this.source.spec.url,
            this.urlInput.dirty.value = !1;
            const {loadState: t} = this.source;
            let {loadedView: n} = this;
            if (void 0 !== n) {
                if (n.source === t)
                    return;
                n.dispose(),
                n = this.loadedView = void 0
            }
            t instanceof o.b && (n = this.loadedView = new ie(t),
            this.element.appendChild(n.element))
        }
        disposed() {
            const {loadedView: e} = this;
            void 0 !== e && e.dispose(),
            Object(b.c)(this.element),
            super.disposed()
        }
    }
    function se(e) {
        if (e instanceof Fe) {
            const t = e.detectedLayerConstructor;
            if (void 0 !== t)
                return Re(e.managedLayer, t),
                !0
        }
        return !1
    }
    class ae extends Q.b {
        constructor(e) {
            super(),
            this.layer = e,
            this.generation = -1,
            this.sourceViews = new Map,
            this.addDataSourceIcon = /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            function(e={}) {
                return Object(x.a)(Object.assign({
                    svg: w.a
                }, e))
            }({
                title: "Add additional data source"
            }),
            this.layerTypeDetection = document.createElement("div"),
            this.layerTypeElement = document.createElement("span"),
            this.dataSourcesContainer = document.createElement("div"),
            this.detectedLayerConstructor = void 0;
            const {element: t, dataSourcesContainer: n} = this;
            t.classList.add("neuroglancer-layer-data-sources-tab"),
            n.classList.add("neuroglancer-layer-data-sources-container");
            const {addDataSourceIcon: i} = this;
            if (i.style.alignSelf = "start",
            i.addEventListener("click", ()=>{
                const e = this.layer.addDataSource(void 0);
                this.updateView();
                const t = this.sourceViews.get(e);
                void 0 !== t && t.urlInput.inputElement.focus()
            }
            ),
            t.appendChild(this.dataSourcesContainer),
            e instanceof Fe) {
                const {layerTypeDetection: n, layerTypeElement: i} = this;
                n.style.display = "none",
                i.classList.add("neuroglancer-layer-data-sources-tab-type-detection-type"),
                n.appendChild(document.createTextNode("Create as ")),
                n.appendChild(i),
                n.appendChild(document.createTextNode(" layer")),
                t.appendChild(n),
                n.classList.add("neuroglancer-layer-data-sources-tab-type-detection"),
                n.addEventListener("click", ()=>{
                    se(e)
                }
                )
            }
            const r = this.reRender = Object(m.a)(()=>this.updateView());
            this.registerDisposer(e.dataSourcesChanged.add(r)),
            this.registerDisposer(this.visibility.changed.add(r)),
            this.updateView()
        }
        updateLayerTypeDetection() {
            const e = (()=>{
                const e = this.layer;
                if (!(e instanceof Fe))
                    return;
                const t = e.detectedLayerConstructor;
                if (void 0 !== t) {
                    for (const e of this.sourceViews.values())
                        if (e.urlInput.dirty.value)
                            return;
                    return t
                }
            }
            )();
            if (e === this.detectedLayerConstructor)
                return;
            const {layerTypeDetection: t} = this;
            if (this.detectedLayerConstructor = e,
            void 0 !== e) {
                const {layerTypeElement: n} = this;
                n.textContent = e.type,
                t.title = "Click here or press enter in the data source URL input box to create as " + `${e.type} layer`,
                t.style.display = ""
            } else
                t.style.display = "none"
        }
        disposed() {
            const {sourceViews: e} = this;
            for (const t of e.values())
                t.dispose();
            e.clear(),
            super.disposed()
        }
        updateView() {
            if (!this.visible)
                return;
            const e = this.layer.dataSourcesChanged.count;
            if (e !== this.generation) {
                this.generation = e;
                const t = Date.now()
                  , {sourceViews: n} = this
                  , {layer: i} = this;
                Object(b.d)(this.dataSourcesContainer, function*() {
                    let e = !0;
                    const {dataSources: r} = i;
                    for (const i of r) {
                        let s = n.get(i);
                        void 0 === s && (s = new re(this,i),
                        s.registerDisposer(s.urlInput.dirty.changed.add(this.reRender)),
                        n.set(i, s)),
                        s.seenGeneration = t,
                        s.updateView();
                        const a = i.spec.url;
                        1 === r.length && "" === a && setTimeout(()=>{
                            s.urlInput.inputElement.focus()
                        }
                        , 0),
                        e = 0 === i.spec.url.length,
                        yield s.element
                    }
                    e || (yield this.addDataSourceIcon)
                }
                .call(this));
                for (const [e,i] of n)
                    i.seenGeneration !== t && (i.dispose(),
                    n.delete(e))
            }
            this.updateLayerTypeDetection()
        }
    }
    var oe = n(88)
      , le = n(0);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function ce(e, t) {
        e.remove(t)
    }
    function ue(e, t) {
        e.add(t)
    }
    var de = n(21)
      , he = n(43);
    n.d(t, "j", (function() {
        return pe
    }
    )),
    n.d(t, "e", (function() {
        return me
    }
    )),
    n.d(t, "a", (function() {
        return ge
    }
    )),
    n.d(t, "f", (function() {
        return ve
    }
    )),
    n.d(t, "c", (function() {
        return be
    }
    )),
    n.d(t, "p", (function() {
        return xe
    }
    )),
    n.d(t, "h", (function() {
        return Ce
    }
    )),
    n.d(t, "b", (function() {
        return Oe
    }
    )),
    n.d(t, "i", (function() {
        return Ee
    }
    )),
    n.d(t, "d", (function() {
        return Te
    }
    )),
    n.d(t, "o", (function() {
        return Me
    }
    )),
    n.d(t, "q", (function() {
        return Ae
    }
    )),
    n.d(t, "r", (function() {
        return Ie
    }
    )),
    n.d(t, "s", (function() {
        return Pe
    }
    )),
    n.d(t, "m", (function() {
        return Re
    }
    )),
    n.d(t, "l", (function() {
        return je
    }
    )),
    n.d(t, "n", (function() {
        return Ne
    }
    )),
    n.d(t, "g", (function() {
        return Fe
    }
    )),
    n.d(t, "k", (function() {
        return Ue
    }
    ));
    class pe extends v.a {
        constructor(e, t) {
            super(),
            this.managedLayer = e,
            this.layersChanged = new _.a,
            this.readyStateChanged = new _.a,
            this.specificationChanged = new _.a,
            this.renderLayers = new Array,
            this.loadingCounter = 1,
            this.tabs = this.registerDisposer(new Q.c),
            this.tool = this.registerDisposer(new u.b(e=>Object(oe.c)(this, e),e=>e.toJSON())),
            this.dataSourcesChanged = new _.a,
            this.dataSources = [],
            this.localCoordinateSpaceCombiner.includeDimensionPredicate = s.y,
            this.tabs.changed.add(this.specificationChanged.dispatch),
            this.tool.changed.add(this.specificationChanged.dispatch),
            this.localPosition.changed.add(this.specificationChanged.dispatch),
            this.dataSourcesChanged.add(this.specificationChanged.dispatch),
            this.dataSourcesChanged.add(()=>this.updateDataSubsourceActivations()),
            this.tabs.add("source", {
                label: "Source",
                order: -100,
                getter: ()=>new ae(this)
            })
        }
        get localPosition() {
            return this.managedLayer.localPosition
        }
        get localCoordinateSpaceCombiner() {
            return this.managedLayer.localCoordinateSpaceCombiner
        }
        get localCoordinateSpace() {
            return this.managedLayer.localCoordinateSpace
        }
        get type() {
            return this.constructor.type
        }
        get isReady() {
            return 0 === this.loadingCounter
        }
        get manager() {
            return this.managedLayer.manager
        }
        canAddDataSource() {
            return !0
        }
        addDataSource(e) {
            const t = new o.a(this,e);
            return this.dataSources.push(t),
            this.dataSourcesChanged.dispatch(),
            t
        }
        activateDataSubsources(e) {}
        updateDataSubsourceActivations() {
            this.activateDataSubsources(function*() {
                for (const e of this.dataSources) {
                    const {loadState: t} = e;
                    if (void 0 !== t && void 0 === t.error)
                        for (const e of t.subsources)
                            if (e.enabled)
                                yield e;
                            else {
                                const {activated: n} = e;
                                e.messages.clearMessages(),
                                void 0 !== n && (n.dispose(),
                                e.activated = void 0,
                                t.activatedSubsourcesChanged.dispatch())
                            }
                }
            }
            .call(this))
        }
        decrementLoadingCounter() {
            0 == --this.loadingCounter && this.readyStateChanged.dispatch()
        }
        markLoading() {
            const e = this.localCoordinateSpaceCombiner.retain()
              , t = this.manager.root.coordinateSpaceCombiner.retain();
            1 == ++this.loadingCounter && this.readyStateChanged.dispatch();
            return ()=>{
                e(),
                t(),
                this.decrementLoadingCounter()
            }
        }
        addCoordinateSpace(e) {
            const t = this.manager.root.coordinateSpaceCombiner.bind(e)
              , n = this.localCoordinateSpaceCombiner.bind(e);
            return ()=>{
                t(),
                n()
            }
        }
        initializationDone() {
            this.decrementLoadingCounter()
        }
        getLegacyDataSourceSpecifications(e, t, n) {
            return void 0 === e ? [] : [Object(o.c)(e, n)]
        }
        getDataSourceSpecifications(e) {
            let t = void 0
              , n = Object(le.y)(e, "source", e=>Array.isArray(e) ? e.map(e=>Object(o.c)(e)) : "object" == typeof e ? [Object(o.c)(e)] : (t = e,
            []));
            const i = Object(le.y)(e, "transform", s.i);
            return n.push(...this.getLegacyDataSourceSpecifications(t, e, i)),
            n = n.filter(e=>e.url),
            0 === n.length && n.push(Object(a.f)()),
            n
        }
        restoreState(e) {
            this.tool.restoreState(e.tool),
            this.tabs.restoreState(e.tab),
            this.localCoordinateSpace.restoreState(e.localDimensions),
            this.localPosition.restoreState(e.localPosition);
            for (const t of this.getDataSourceSpecifications(e))
                this.addDataSource(t)
        }
        addRenderLayer(e) {
            this.renderLayers.push(e);
            const {layersChanged: t} = this;
            return e.layerChanged.add(t.dispatch),
            t.dispatch(),
            ()=>this.removeRenderLayer(e)
        }
        removeRenderLayer(e) {
            const {renderLayers: t, layersChanged: n} = this
              , i = t.indexOf(e);
            if (-1 === i)
                throw new Error("Attempted to remove invalid RenderLayer");
            t.splice(i, 1),
            e.layerChanged.remove(n.dispatch),
            e.dispose(),
            n.dispatch()
        }
        disposed() {
            const {layersChanged: e} = this;
            Object(v.d)(this.dataSources);
            for (const t of this.renderLayers)
                t.layerChanged.remove(e.dispatch),
                t.dispose();
            this.renderLayers.length = 0,
            super.disposed()
        }
        getValueAt(e, t) {
            let n, {renderLayers: i} = this, {pickedRenderLayer: r} = t;
            if (null !== r && -1 !== i.indexOf(r))
                return n = r.transformPickedValue(t.pickedValue, t.pickedOffset),
                this.transformPickedValue(n);
            for (let t of i)
                if (n = t.getValueAt(e),
                null != n)
                    break;
            return this.transformPickedValue(n)
        }
        transformPickedValue(e) {
            return e
        }
        toJSON() {
            return {
                type: this.type,
                source: fe(this.dataSources),
                tab: this.tabs.toJSON(),
                tool: this.tool.toJSON(),
                localDimensions: this.localCoordinateSpace.toJSON(),
                localPosition: this.localPosition.toJSON()
            }
        }
        handleAction(e) {}
    }
    function fe(e) {
        if (0 !== e.length)
            return 1 === e.length ? e[0].toJSON() : e.map(e=>e.toJSON())
    }
    class me extends v.a {
        constructor(e, t, n) {
            super(),
            this.initialSpecification = t,
            this.manager = n,
            this.localCoordinateSpace = new s.b,
            this.localCoordinateSpaceCombiner = new s.a(this.localCoordinateSpace,s.x),
            this.localPosition = this.registerDisposer(new l.k(this.localCoordinateSpace)),
            this.readyStateChanged = new _.a,
            this.layerChanged = new _.a,
            this.specificationChanged = new _.a,
            this.containers = new Set,
            this.layer_ = null,
            this.visible = !0,
            this.name_ = e
        }
        get layer() {
            return this.layer_
        }
        set layer(e) {
            let t = this.layer_;
            if (null != t && (this.unregisterUserLayer(),
            t.dispose()),
            this.layer_ = e,
            null != e) {
                const t = [e.layersChanged.add(this.layerChanged.dispatch), e.readyStateChanged.add(this.readyStateChanged.dispatch), e.specificationChanged.add(this.specificationChanged.dispatch)];
                this.unregisterUserLayer = ()=>{
                    t.forEach(e=>e())
                }
                ,
                this.readyStateChanged.dispatch(),
                this.layerChanged.dispatch()
            }
        }
        isReady() {
            const {layer: e} = this;
            return null !== e && e.isReady
        }
        get name() {
            return this.name_
        }
        set name(e) {
            e !== this.name_ && (this.name_ = e,
            this.layerChanged.dispatch())
        }
        toJSON() {
            let e = this.layer;
            if (!e)
                return this.initialSpecification;
            let t = e.toJSON();
            return t.name = this.name,
            this.visible || (t.visible = !1),
            t
        }
        setVisible(e) {
            e !== this.visible && (this.visible = e,
            this.layerChanged.dispatch())
        }
        disposed() {
            this.layer = null,
            super.disposed()
        }
    }
    class ge extends v.a {
        constructor() {
            super(),
            this.managedLayers = new Array,
            this.layerSet = new Set,
            this.layersChanged = new _.a,
            this.readyStateChanged = new _.a,
            this.specificationChanged = new _.a,
            this.boundPositions = new WeakSet,
            this.numDirectUsers = 0,
            this.renderLayerToManagedLayerMapGeneration = -1,
            this.renderLayerToManagedLayerMap_ = new Map,
            this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(r()(()=>this.removeLayersWithSingleRef(), 0)),
            this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef)
        }
        get renderLayerToManagedLayerMap() {
            const e = this.layersChanged.count
              , t = this.renderLayerToManagedLayerMap_;
            if (this.renderLayerToManagedLayerMapGeneration !== e) {
                this.renderLayerToManagedLayerMapGeneration = e,
                t.clear();
                for (const e of this.managedLayers) {
                    const n = e.layer;
                    if (null !== n)
                        for (const i of n.renderLayers)
                            t.set(i, e)
                }
            }
            return t
        }
        filter(e) {
            let t = !1;
            this.managedLayers = this.managedLayers.filter(n=>!!e(n) || (this.unbindManagedLayer(n),
            this.layerSet.delete(n),
            t = !0,
            !1)),
            t && this.layersChanged.dispatch()
        }
        removeLayersWithSingleRef() {
            this.numDirectUsers > 0 || this.filter(e=>1 !== e.refCount)
        }
        updateSignalBindings(e, t) {
            t(e.layerChanged, this.layersChanged.dispatch),
            t(e.readyStateChanged, this.readyStateChanged.dispatch),
            t(e.specificationChanged, this.specificationChanged.dispatch)
        }
        useDirectly() {
            return 1 == ++this.numDirectUsers && this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef),
            ()=>{
                0 == --this.numDirectUsers && (this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef),
                this.scheduleRemoveLayersWithSingleRef())
            }
        }
        addManagedLayer(e, t) {
            return this.updateSignalBindings(e, ue),
            this.layerSet.add(e),
            e.containers.add(this),
            void 0 === t && (t = this.managedLayers.length),
            this.managedLayers.splice(t, 0, e),
            this.layersChanged.dispatch(),
            this.readyStateChanged.dispatch(),
            e
        }
        *readyRenderLayers() {
            for (let e of this.managedLayers)
                e.visible && e.layer && (yield*e.layer.renderLayers)
        }
        unbindManagedLayer(e) {
            this.updateSignalBindings(e, ce),
            e.containers.delete(this),
            e.dispose()
        }
        clear() {
            for (let e of this.managedLayers)
                this.unbindManagedLayer(e);
            this.managedLayers.length = 0,
            this.layerSet.clear(),
            this.layersChanged.dispatch()
        }
        remove(e) {
            const t = this.managedLayers[e];
            this.unbindManagedLayer(t),
            this.managedLayers.splice(e, 1),
            this.layerSet.delete(t),
            this.layersChanged.dispatch()
        }
        removeManagedLayer(e) {
            let t = this.managedLayers.indexOf(e);
            if (-1 === t)
                throw new Error("Internal error: invalid managed layer.");
            this.remove(t)
        }
        reorderManagedLayer(e, t) {
            const n = this.managedLayers.length;
            if (e === t || e < 0 || e >= n || t < 0 || t >= n)
                return;
            let[i] = this.managedLayers.splice(e, 1);
            this.managedLayers.splice(t, 0, i),
            this.layersChanged.dispatch()
        }
        disposed() {
            this.clear(),
            super.disposed()
        }
        getLayerByName(e) {
            return this.managedLayers.find(t=>t.name === e)
        }
        getUniqueLayerName(e) {
            let t = e
              , n = 0;
            for (; void 0 !== this.getLayerByName(t); )
                t = e + ++n;
            return t
        }
        has(e) {
            return this.layerSet.has(e)
        }
        get renderLayers() {
            let e = this;
            return {
                *[Symbol.iterator]() {
                    for (let t of e.managedLayers)
                        if (null !== t.layer)
                            for (let e of t.layer.renderLayers)
                                yield e
                }
            }
        }
        get visibleRenderLayers() {
            let e = this;
            return {
                *[Symbol.iterator]() {
                    for (let t of e.managedLayers)
                        if (null !== t.layer && t.visible)
                            for (let e of t.layer.renderLayers)
                                yield e
                }
            }
        }
        invokeAction(e) {
            for (let t of this.managedLayers) {
                if (null === t.layer || !t.visible)
                    continue;
                let n = t.layer;
                n.handleAction(e);
                for (let t of n.renderLayers)
                    t.handleAction(e)
            }
        }
    }
    class ve {
        constructor() {
            this.changed = new _.a,
            this.position = he.b,
            this.active = !1,
            this.displayDimensions = void 0,
            this.pickedRenderLayer = null,
            this.pickedValue = new de.a(0,0),
            this.pickedOffset = 0,
            this.pickedAnnotationLayer = void 0,
            this.pickedAnnotationId = void 0,
            this.pickedAnnotationBuffer = void 0,
            this.pickedAnnotationBufferOffset = void 0,
            this.forcerFunction = void 0
        }
        removeForcer(e) {
            e === this.forcerFunction && (this.forcerFunction = void 0,
            this.setActive(!1))
        }
        setForcer(e) {
            this.forcerFunction = e,
            void 0 === e && this.setActive(!1)
        }
        updateUnconditionally() {
            const {forcerFunction: e} = this;
            return void 0 !== e && (e(),
            this.active)
        }
        setActive(e) {
            this.active === e && !0 !== e || (this.active = e,
            this.changed.dispatch())
        }
    }
    class be extends v.a {
        constructor(e, t) {
            super(),
            this.layerManager = e,
            this.mouseState = t,
            this.values = new Map,
            this.changed = new _.a,
            this.needsUpdate = !0,
            this.registerDisposer(t.changed.add(()=>{
                this.handleChange()
            }
            )),
            this.registerDisposer(e.layersChanged.add(()=>{
                this.handleLayerChange()
            }
            ))
        }
        handleLayerChange() {
            this.mouseState.active && this.handleChange()
        }
        handleChange() {
            this.needsUpdate = !0,
            this.changed.dispatch()
        }
        update() {
            if (!this.needsUpdate)
                return;
            this.needsUpdate = !1;
            let e = this.values
              , t = this.mouseState;
            if (e.clear(),
            t.active) {
                let n = t.position;
                for (let i of this.layerManager.managedLayers) {
                    let r = i.layer;
                    i.visible && r && e.set(r, r.getValueAt(n, t))
                }
            }
        }
        get(e) {
            return this.update(),
            this.values.get(e)
        }
        toJSON() {
            this.update();
            const e = {}
              , {values: t} = this;
            for (const n of this.layerManager.managedLayers) {
                const i = n.layer;
                if (i) {
                    let r = t.get(i);
                    void 0 !== r && (r instanceof de.a && (r = {
                        t: "u64",
                        v: r
                    }),
                    e[n.name] = r)
                }
            }
            return e
        }
    }
    class ye extends v.a {
        constructor(e) {
            super(),
            this.view = e,
            this.messages = new y.a,
            this.seenGeneration = -1,
            this.state = void 0
        }
    }
    let Se = 0;
    class we extends v.a {
        constructor(e, t, n, i, s, a) {
            super(),
            this.layerManager = e,
            this.renderLayerType = t,
            this.view = n,
            this.roles = i,
            this.layerAdded = s,
            this.visibility = a,
            this.visibleLayers_ = new Map,
            this.debouncedUpdateVisibleLayers = this.registerCancellable(r()(()=>this.updateVisibleLayers(), 0)),
            this.registerDisposer(e.layersChanged.add(this.debouncedUpdateVisibleLayers)),
            this.registerDisposer(i.changed.add(this.debouncedUpdateVisibleLayers)),
            this.updateVisibleLayers()
        }
        disposed() {
            this.visibleLayers.forEach(e=>e.dispose()),
            this.visibleLayers.clear(),
            super.disposed()
        }
        updateVisibleLayers() {
            const e = ++Se
              , {visibleLayers_: t, renderLayerType: n, layerAdded: i, roles: r} = this;
            for (let s of this.layerManager.readyRenderLayers())
                if (s instanceof n && r.has(s.role)) {
                    let n = s
                      , r = t.get(n);
                    void 0 === r && (r = new ye(this.view),
                    r.registerDisposer(n.messages.addChild(r.messages)),
                    r.registerDisposer(n.addRef()),
                    r.registerDisposer(n.visibility.add(this.visibility)),
                    t.set(n, r),
                    i(n, r),
                    n.attach(r)),
                    r.seenGeneration = e
                }
            for (const [n,i] of t)
                i.seenGeneration !== e && (t.delete(n),
                i.dispose())
        }
        get visibleLayers() {
            return this.debouncedUpdateVisibleLayers.flush(),
            this.visibleLayers_
        }
    }
    function xe(e, t, n, i, r) {
        return i.registerDisposer(new we(e,t,i,n,(e,t)=>{
            t.registerDisposer(e.redrawNeeded.add(()=>i.scheduleRedraw()));
            const {backend: n} = e;
            n && (n.rpc.invoke(c.c, {
                layer: n.rpcId,
                view: i.rpcId
            }),
            t.registerDisposer(()=>n.rpc.invoke(c.d, {
                layer: n.rpcId,
                view: i.rpcId
            }))),
            void 0 !== r && r(e, t),
            i.scheduleRedraw(),
            t.registerDisposer(()=>i.scheduleRedraw())
        }
        ,i.visibility))
    }
    class Ce extends v.a {
        constructor(e) {
            super(),
            this.layerManager = e,
            this.changed = new _.a,
            this.visible_ = !1,
            this.size = new u.c(300,le.D),
            this.registerDisposer(e),
            this.size.changed.add(this.changed.dispatch)
        }
        get layer() {
            return this.layer_
        }
        get visible() {
            return this.visible_
        }
        set visible(e) {
            const t = this.layer_;
            void 0 === t && (e = !1),
            this.visible_ !== e && (this.visible_ = e,
            e || void 0 === t || this.maybeDeleteNewLayer(t),
            this.changed.dispatch())
        }
        maybeDeleteNewLayer(e) {
            if (e.wasDisposed)
                return;
            const t = e.layer;
            null !== t && t instanceof Fe && (t.dataSources.some(e=>0 !== e.spec.url.length) || Ne(e))
        }
        set layer(e) {
            if (e === this.layer_)
                return;
            const t = this.layer_;
            if (void 0 !== t && (this.existingLayerDisposer(),
            this.existingLayerDisposer = void 0,
            this.maybeDeleteNewLayer(t)),
            this.layer_ = e,
            void 0 !== e) {
                const t = ()=>{
                    this.layer_ = void 0,
                    this.visible = !1,
                    this.existingLayerDisposer = void 0,
                    this.changed.dispatch()
                }
                ;
                e.registerDisposer(t);
                const n = e.specificationChanged.add(()=>{
                    this.changed.dispatch()
                }
                );
                this.existingLayerDisposer = ()=>{
                    const i = e.layer;
                    if (null !== i) {
                        const e = i.tool.value;
                        void 0 !== e && e.deactivate()
                    }
                    e.unregisterDisposer(t),
                    n()
                }
            } else
                this.visible_ = !1;
            this.changed.dispatch()
        }
        toJSON() {
            if (void 0 !== this.layer)
                return {
                    layer: this.layer.name,
                    visible: !0 === this.visible || void 0,
                    size: this.size.toJSON()
                }
        }
        restoreState(e) {
            if (void 0 === e)
                return void this.reset();
            Object(le.w)(e);
            const t = Object(le.y)(e, "layer", le.C)
              , n = void 0 !== t ? this.layerManager.getLayerByName(t) : void 0;
            this.layer = n,
            this.visible = !!Object(le.y)(e, "visible", le.z),
            Object(le.y)(e, "size", e=>this.size.restoreState(e))
        }
        reset() {
            this.layer = void 0
        }
    }
    class Oe extends v.a {
        constructor(e, t) {
            super(),
            this.layerManager = e,
            this.filter = t,
            this.changed = new _.a,
            this.validate = r()(()=>{
                const {layerName_: e} = this;
                if (void 0 !== e) {
                    const t = this.layerManager.getLayerByName(e);
                    void 0 !== t && this.filter(t) ? (this.layer_ = t,
                    this.changed.dispatch()) : (this.layer_ = void 0,
                    this.layerName_ = void 0,
                    this.changed.dispatch())
                }
            }
            , 0),
            this.registerDisposer(e),
            this.registerDisposer(e.specificationChanged.add(()=>{
                const {layer_: e} = this;
                if (void 0 !== e)
                    if (this.layerManager.layerSet.has(e) && this.filter(e)) {
                        const {name: t} = e;
                        t !== this.layerName_ && (this.layerName_ = t,
                        this.changed.dispatch())
                    } else
                        this.layer_ = void 0,
                        this.layerName_ = void 0,
                        this.changed.dispatch()
            }
            ))
        }
        get layer() {
            return this.layer_
        }
        get layerName() {
            return this.layerName_
        }
        set layer(e) {
            this.layer_ !== e && (void 0 !== e && this.layerManager.layerSet.has(e) && this.filter(e) ? (this.layer_ = e,
            this.layerName_ = e.name) : (this.layer_ = void 0,
            this.layerName_ = void 0),
            this.changed.dispatch())
        }
        set layerName(e) {
            e !== this.layerName_ && (this.layer_ = void 0,
            this.layerName_ = e,
            this.changed.dispatch(),
            this.validate())
        }
        restoreState(e) {
            const t = Object(le.C)(e);
            this.layerName = t
        }
        toJSON() {
            const {layer_: e} = this;
            return void 0 !== e ? e.name : this.layerName_
        }
        reset() {
            this.layerName_ = void 0,
            this.layer_ = void 0,
            this.changed.dispatch()
        }
    }
    class ke extends v.a {
        constructor() {
            super(...arguments),
            this.changed = new _.a
        }
        get worker() {
            return this.rpc
        }
    }
    class Ee extends ke {
        constructor(e, t, n, i, r, a) {
            super(),
            this.dataSourceProviderRegistry = e,
            this.layerManager = t,
            this.chunkManager = n,
            this.layerSelectedValues = i,
            this.coordinateSpace = r,
            this.globalPosition = a,
            this.coordinateSpaceCombiner = new s.a(this.coordinateSpace,s.w),
            this.registerDisposer(t.layersChanged.add(this.changed.dispatch)),
            this.registerDisposer(t.specificationChanged.add(this.changed.dispatch))
        }
        get rpc() {
            return this.chunkManager.rpc
        }
        get root() {
            return this
        }
        reset() {
            this.layerManager.clear()
        }
        restoreState(e) {
            if (this.layerManager.clear(),
            Array.isArray(e))
                for (const t of e) {
                    Object(le.w)(t);
                    const e = this.layerManager.getUniqueLayerName(Object(le.y)(t, "name", le.E));
                    this.layerManager.addManagedLayer(this.getLayer(e, t))
                }
            else {
                Object(le.w)(e);
                for (let t of Object.keys(e))
                    this.layerManager.addManagedLayer(this.getLayer(t, e[t]))
            }
        }
        initializeLayerFromSpec(e, t) {
            e.initialSpecification = t,
            "string" == typeof t && (t = {
                source: t
            }),
            Object(le.w)(t);
            const n = Object(le.B)(t, "type", le.E, "auto");
            e.visible = Object(le.B)(t, "visible", le.n, !0);
            const i = new (Me.get(n) || Fe)(e,t);
            i.restoreState(t),
            i.initializationDone(),
            e.layer = i
        }
        getLayer(e, t) {
            let n = new me(e,t,this);
            return this.initializeLayerFromSpec(n, t),
            n
        }
        add(e, t) {
            -1 === this.layerManager.managedLayers.indexOf(e) && (e.name = this.layerManager.getUniqueLayerName(e.name)),
            this.layerManager.addManagedLayer(e, t)
        }
        toJSON() {
            const e = [];
            let t = 0;
            for (let n of this.layerManager.managedLayers) {
                const i = n.toJSON();
                null != i && (e.push(i),
                ++t)
            }
            if (0 !== t)
                return e
        }
        get rootLayers() {
            return this.layerManager
        }
    }
    class Te extends ke {
        constructor(e) {
            super(),
            this.master = e,
            this.changed = new _.a,
            this.layerManager = this.registerDisposer(new ge),
            this.registerDisposer(e);
            const {layerManager: t} = this;
            this.registerDisposer(t.layersChanged.add(this.changed.dispatch)),
            this.registerDisposer(t.specificationChanged.add(this.changed.dispatch))
        }
        get rpc() {
            return this.master.rpc
        }
        get dataSourceProviderRegistry() {
            return this.master.dataSourceProviderRegistry
        }
        get chunkManager() {
            return this.master.chunkManager
        }
        get layerSelectedValues() {
            return this.master.layerSelectedValues
        }
        get root() {
            return this.master
        }
        reset() {
            this.layerManager.clear()
        }
        restoreState(e) {
            const t = this.master.layerManager
              , n = [];
            for (const i of new Set(Object(le.b)(e, le.E))) {
                const e = t.getLayerByName(i);
                if (void 0 === e)
                    throw new Error(`Undefined layer referenced in subset specification: ${JSON.stringify(i)}`);
                n.push(e)
            }
            this.layerManager.clear();
            for (const e of n)
                this.layerManager.addManagedLayer(e.addRef())
        }
        toJSON() {
            return this.layerManager.managedLayers.map(e=>e.name)
        }
        initializeLayerFromSpec(e, t) {
            this.master.initializeLayerFromSpec(e, t)
        }
        getLayer(e, t) {
            return this.master.getLayer(e, t)
        }
        add(e, t) {
            -1 === this.master.layerManager.managedLayers.indexOf(e) && (e.name = this.master.layerManager.getUniqueLayerName(e.name),
            this.master.layerManager.addManagedLayer(e.addRef())),
            this.layerManager.addManagedLayer(e, t)
        }
        get rootLayers() {
            return this.master.rootLayers
        }
    }
    const Me = new Map
      , De = new Map
      , Le = [];
    function Ae(e, t) {
        Me.set(e, t)
    }
    function Ie(e) {
        Le.push(e)
    }
    function Pe(e, t) {
        De.set(e, t)
    }
    function Re(e, t) {
        const n = e.layer;
        if (null === n)
            return;
        const i = n.toJSON();
        i.tab = n.tabs.value;
        const r = new t(e,i);
        r.restoreState(i),
        r.initializationDone(),
        e.layer = r
    }
    function je(e, t) {
        return t !== e.name && (t = e.manager.root.layerManager.getUniqueLayerName(t),
        e.name = t,
        e.layerChanged.dispatch(),
        !0)
    }
    function Ne(e) {
        if (!e.wasDisposed)
            for (const t of e.containers)
                t.removeManagedLayer(e)
    }
    function Ve(e) {
        for (const t of Le) {
            const n = t(e);
            if (void 0 !== n)
                return n
        }
        const {volume: t} = e;
        if (void 0 !== t) {
            const e = De.get(t.volumeType);
            if (void 0 !== e)
                return e
        }
    }
    function Be(e) {
        for (const t of e) {
            const {subsourceEntry: e} = t
              , {subsource: n} = e
              , i = Ve(n);
            if (void 0 !== i)
                return i
        }
    }
    class Fe extends pe {
        activateDataSubsources(e) {
            this.detectedLayerConstructor = Be(e)
        }
    }
    Fe.type = "new";
    class _e extends pe {
        activateDataSubsources(e) {
            const t = Be(e);
            void 0 !== t && Re(this.managedLayer, t)
        }
    }
    function Ue(e, t) {
        const n = new me("new layer",{},e);
        e.initializeLayerFromSpec(n, {
            type: "new"
        }),
        e.add(n),
        t.layer = n,
        t.visible = !0
    }
    _e.type = "auto",
    Ae("new", Fe),
    Ae("auto", _e)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "e", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return l
    }
    ));
    const i = new /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class {
        constructor() {
            this.name = "CancellationError",
            this.message = "CANCELED"
        }
        toString() {
            return "CANCELED"
        }
    }
    ;
    const r = ()=>{}
      , s = {
        isCanceled: !1,
        add: ()=>r,
        remove: r
    };
    class a {
        cancel() {
            const {handlers: e} = this;
            if (null !== e && (this.handlers = null,
            void 0 !== e))
                for (let t of e)
                    t()
        }
        get isCanceled() {
            return null === this.handlers
        }
        add(e) {
            let {handlers: t} = this;
            return null === t ? (e(),
            r) : (void 0 === t && (t = this.handlers = new Set),
            t.add(e),
            ()=>{
                this.remove(e)
            }
            )
        }
        remove(e) {
            const {handlers: t} = this;
            null != t && t.delete(e)
        }
    }
    class o extends a {
        constructor() {
            super(...arguments),
            this.consumers = new Set
        }
        addConsumer(e=s) {
            const {consumers: t} = this;
            t.has(e) || e.isCanceled || (t.add(e),
            e.add(()=>{
                t.delete(e),
                0 === t.size && this.cancel()
            }
            ))
        }
    }
    function l(e, t) {
        return new Promise((n,i)=>{
            if (e === s)
                return void t(n, i, s);
            const r = new a
              , o = e.add(()=>{
                r.cancel()
            }
            );
            t(e=>{
                o(),
                n(e)
            }
            , e=>{
                o(),
                i(e)
            }
            , r)
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "f", (function() {
        return r
    }
    )),
    n.d(t, "j", (function() {
        return s
    }
    )),
    n.d(t, "l", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "k", (function() {
        return l
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "h", (function() {
        return u
    }
    )),
    n.d(t, "i", (function() {
        return d
    }
    )),
    n.d(t, "e", (function() {
        return h
    }
    )),
    n.d(t, "g", (function() {
        return p
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    )),
    n.d(t, "a", (function() {
        return v
    }
    ));
    var i = n(19)
      , r = "\nvec3 hueToRgb(float hue) {\n  float hue6 = hue * 6.0;\n  float r = abs(hue6 - 3.0) - 1.0;\n  float g = 2.0 - abs(hue6 - 2.0);\n  float b = 2.0 - abs(hue6 - 4.0);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 hsvToRgb(vec3 c) {\n  vec3 hueRgb = hueToRgb(c.x);\n  return c.z * ((hueRgb - 1.0) * c.y + 1.0);\n}\n";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = "\nstruct uint64_t {\n  highp uvec2 value;\n};\nstruct uint64x2_t {\n  highp uvec4 value;\n};\nuint64_t toUint64(uint64_t x) { return x; }\n"
      , a = [s, "\nuint64_t unpackUint64leFromUint32(highp uvec2 x) {\n  uint64_t result;\n  result.value = x;\n  return result;\n}\nuint64x2_t unpackUint64leFromUint32(highp uvec4 x) {\n  uint64x2_t result;\n  result.value = x;\n  return result;\n}\n"]
      , o = [s, "\nbool equals(uint64_t a, uint64_t b) {\n  return a.value == b.value;\n}\n"]
      , l = [s, "\nstruct uint8_t {\n  highp uint value;\n};\nstruct uint8x2_t {\n  highp uvec2 value;\n};\nstruct uint8x3_t {\n  highp uvec3 value;\n};\nstruct uint8x4_t {\n  highp uvec4 value;\n};\nhighp uint toRaw(uint8_t x) { return x.value; }\nhighp float toNormalized(uint8_t x) { return float(x.value) / 255.0; }\nhighp uvec2 toRaw(uint8x2_t x) { return x.value; }\nhighp vec2 toNormalized(uint8x2_t x) { return vec2(x.value) / 255.0; }\nhighp uvec3 toRaw(uint8x3_t x) { return x.value; }\nvec3 toNormalized(uint8x3_t x) { return vec3(x.value) / 255.0; }\nhighp uvec4 toRaw(uint8x4_t x) { return x.value; }\nvec4 toNormalized(uint8x4_t x) { return vec4(x.value) / 255.0; }\nuint64_t toUint64(uint8_t x) {\n  uint64_t result;\n  result.value[0] = x.value;\n  result.value[1] = 0u;\n  return result;\n}\n"]
      , c = "\nfloat toRaw(float x) { return x; }\nfloat toNormalized(float x) { return x; }\nvec2 toRaw(vec2 x) { return x; }\nvec2 toNormalized(vec2 x) { return x; }\nvec3 toRaw(vec3 x) { return x; }\nvec3 toNormalized(vec3 x) { return x; }\nvec4 toRaw(vec4 x) { return x; }\nvec4 toNormalized(vec4 x) { return x; }\n"
      , u = [s, "\nstruct uint16_t {\n  highp uint value;\n};\nstruct uint16x2_t {\n  highp uvec2 value;\n};\nhighp uint toRaw(uint16_t x) { return x.value; }\nhighp float toNormalized(uint16_t x) { return float(toRaw(x)) / 65535.0; }\nhighp uvec2 toRaw(uint16x2_t x) { return x.value; }\nhighp vec2 toNormalized(uint16x2_t x) { return vec2(toRaw(x)) / 65535.0; }\nuint64_t toUint64(uint16_t x) {\n  uint64_t result;\n  result.value[0] = x.value;\n  result.value[1] = 0u;\n  return result;\n}\n"]
      , d = [s, "\nstruct uint32_t {\n  highp uint value;\n};\nhighp float toNormalized(uint32_t x) { return float(x.value) / 4294967295.0; }\nhighp uint toRaw(uint32_t x) { return x.value; }\nuint64_t toUint64(uint32_t x) {\n  uint64_t result;\n  result.value[0] = x.value;\n  result.value[1] = 0u;\n  return result;\n}\n"];
    var h = "\nhighp int getFortranOrderIndex(ivec3 subscripts, ivec3 size) {\n  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);\n}\n";
    const p = "\nhighp uint log2Exact(highp uint i) {\n  highp uint r;\n  r = uint((i & 0xAAAAAAAAu) != 0u);\n  r |= uint((i & 0xFFFF0000u) != 0u) << 4;\n  r |= uint((i & 0xFF00FF00u) != 0u) << 3;\n  r |= uint((i & 0xF0F0F0F0u) != 0u) << 2;\n  r |= uint((i & 0xCCCCCCCCu) != 0u) << 1;\n  return r;\n}\n";
    function f(e, t=1) {
        switch (e) {
        case i.a.FLOAT32:
            if (1 === t)
                return "float";
            if (t > 1 && t <= 4)
                return `vec${t}`;
            break;
        case i.a.UINT8:
            if (1 === t)
                return "uint8_t";
            if (t > 1 && t <= 4)
                return `uint8x${t}_t`;
            break;
        case i.a.UINT16:
            if (1 === t)
                return "uint16_t";
            if (2 === t)
                return "uint16x2_t";
            break;
        case i.a.UINT32:
            if (1 === t)
                return "uint32_t";
            break;
        case i.a.UINT64:
            if (1 === t)
                return "uint64_t"
        }
        throw new Error(`No shader type for ${i.a[e]}[${t}].`)
    }
    function m(e, t) {
        return 1 === t ? e : "float" === e ? `vec${t}` : `${e[0]}vec${t}`
    }
    const g = {
        [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
        [WebGL2RenderingContext.BYTE]: 1,
        [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
        [WebGL2RenderingContext.SHORT]: 2,
        [WebGL2RenderingContext.FLOAT]: 4,
        [WebGL2RenderingContext.INT]: 4,
        [WebGL2RenderingContext.UNSIGNED_INT]: 4
    };
    function v(e, t, n, i, r, s, a=1) {
        let o = 0
          , l = s * a;
        for (; l > 0; ) {
            const n = Math.min(4, l)
              , i = m(t, n);
            l -= n,
            e.addAttribute("highp " + i, `a${r}${o}`),
            ++o
        }
        l = s * a;
        let c = "";
        for (let e = 0; e < a; ++e) {
            c += `highp ${t}[${s}] get${r}${e}() {\n  highp ${t}[${s}] result;\n`;
            for (let t = 0; t < s; ++t) {
                const n = e * s + t
                  , i = Math.floor(n / 4)
                  , a = n % 4;
                c += `  result[${t}] = a${r}${i}`,
                0 === a && n === l - 1 || (c += `[${a}]`),
                c += ";\n"
            }
            c += "  return result;\n",
            c += "}\n"
        }
        e.addVertexCode(c);
        const u = g[n];
        e.addInitializer(e=>{
            const s = [];
            for (let t = 0; t < o; ++t)
                s[t] = e.attribute(`a${r}${t}`);
            e.vertexShaderInputBinders[r] = {
                enable(t) {
                    const {gl: n} = e;
                    for (let e = 0; e < o; ++e) {
                        const i = s[e];
                        n.enableVertexAttribArray(i),
                        n.vertexAttribDivisor(i, t)
                    }
                },
                disable() {
                    const {gl: t} = e;
                    for (let e = 0; e < o; ++e) {
                        const n = s[e];
                        t.vertexAttribDivisor(n, 0),
                        t.disableVertexAttribArray(n)
                    }
                },
                bind(r, a) {
                    const {gl: c} = e;
                    for (let e = 0; e < o; ++e) {
                        const o = s[e]
                          , d = Math.min(4, l - 4 * e);
                        "float" === t ? c.vertexAttribPointer(o, d, n, i, r, a) : c.vertexAttribIPointer(o, Math.min(4, l - 4 * e), n, r, a),
                        a += u * d
                    }
                }
            }
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(0)
      , s = n(42);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class a {
        constructor(e, t=WebGL2RenderingContext.ARRAY_BUFFER) {
            this.gl = e,
            this.bufferType = t,
            this.gl = e,
            this.buffer = e.createBuffer()
        }
        bind() {
            this.gl.bindBuffer(this.bufferType, this.buffer)
        }
        bindToVertexAttrib(e, t, n=WebGL2RenderingContext.FLOAT, i=!1, r=0, s=0) {
            this.bind(),
            this.gl.enableVertexAttribArray(e),
            this.gl.vertexAttribPointer(e, t, n, i, r, s)
        }
        bindToVertexAttribI(e, t, n=WebGL2RenderingContext.UNSIGNED_INT, i=0, r=0) {
            this.bind(),
            this.gl.enableVertexAttribArray(e),
            this.gl.vertexAttribIPointer(e, t, n, i, r)
        }
        setData(e, t=WebGL2RenderingContext.STATIC_DRAW) {
            let n = this.gl;
            this.bind(),
            n.bufferData(this.bufferType, e, t)
        }
        dispose() {
            this.gl.deleteBuffer(this.buffer),
            this.buffer = void 0,
            this.gl = void 0
        }
        static fromData(e, t, n, i) {
            let r = new a(e,n);
            return r.setData(t, i),
            r
        }
    }
    function o(e, t, n, ...o) {
        return e.memoize.get(Object(r.h)({
            id: "getMemoizedBuffer",
            getter: Object(s.a)(n),
            args: o
        }), ()=>{
            const r = new i.b(a.fromData(e, n(...o), t, WebGL2RenderingContext.STATIC_DRAW));
            return r.registerDisposer(r.value),
            r
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    ));
    var i = n(61)
      , r = n(7);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends r.e {
        constructor(e=Number.NEGATIVE_INFINITY) {
            super(e)
        }
        get visible() {
            return this.value === Number.POSITIVE_INFINITY
        }
        get ignored() {
            return this.value === Number.NEGATIVE_INFINITY
        }
    }
    s.VISIBLE = Number.POSITIVE_INFINITY,
    s.IGNORED = Number.NEGATIVE_INFINITY;
    class a extends s {
        constructor() {
            super(...arguments),
            this.contributors = new Map
        }
        add(e) {
            const {contributors: t} = this
              , n = e.changed.add(()=>{
                this.update()
            }
            )
              , i = ()=>{
                t.delete(i),
                n(),
                this.update()
            }
            ;
            return t.set(i, e),
            this.update(),
            i
        }
        update() {
            let e = Number.NEGATIVE_INFINITY;
            for (const t of this.contributors.values())
                e = Math.max(e, t.value);
            this.value = e
        }
    }
    function o(e) {
        return class extends e {
            constructor() {
                super(...arguments),
                this.visibility = new a
            }
            initializeCounterpart(e, t={}) {
                t.visibility = this.registerDisposer(i.a.makeFromExisting(e, this.visibility)).rpcId,
                super.initializeCounterpart(e, t)
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "e", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    ));
    var i = n(7)
      , r = n(0)
      , s = n(26)
      , a = n(3);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const o = 40;
    function l(e) {
        return (Math.log2(e) - -4) / .5
    }
    function c(e) {
        return 2 ** (.5 * e - 4)
    }
    function u(e) {
        return new i.c(e,r.r)
    }
    class d {
        constructor() {
            this.visibility = new s.a,
            this.changed = new a.a,
            this.frameNumber = -1,
            this.spatialScales = new Map,
            this.numHistogramRows = 1,
            this.value = new Uint32Array(o * this.numHistogramRows * 2)
        }
        begin(e) {
            e !== this.frameNumber && (this.value.fill(0),
            this.frameNumber = e,
            this.spatialScales.clear(),
            this.changed.dispatch())
        }
        add(e, t, n, i) {
            let {spatialScales: r, numHistogramRows: s, value: a} = this
              , c = r.get(e);
            if (void 0 === c && (c = r.size,
            r.set(e, c)),
            c >= s) {
                this.numHistogramRows = s *= 2;
                const e = new Uint32Array(s * o * 2);
                e.set(a),
                this.value = a = e
            }
            const u = c * o * 2 + Math.min(Math.max(0, Math.round(l(t))), o - 1);
            a[u] += n,
            a[u + o] += i
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    ));
    var i = n(52)
      , r = new Array;
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function s(e) {
        r.push(e)
    }
    class a extends i.d {
        constructor(e, t) {
            super(e, t),
            this.chunkFormatHandler = this.registerDisposer(function(e, t) {
                for (let n of r) {
                    let i = n(e, t);
                    if (null != i)
                        return i
                }
                throw new Error("No chunk format handler found.")
            }(e.chunkQueueManager.gl, this.spec));
            const n = this.spec.upperVoxelBound.length;
            this.tempChunkGridPosition = new Float32Array(n),
            this.tempPositionWithinChunk = new Uint32Array(n)
        }
        static encodeSpec(e) {
            const t = e;
            return Object.assign(Object.assign({}, super.encodeSpec(e)), {
                dataType: t.dataType,
                compressedSegmentationBlockSize: t.compressedSegmentationBlockSize && Array.from(t.compressedSegmentationBlockSize),
                baseVoxelOffset: Array.from(t.baseVoxelOffset)
            })
        }
        get chunkFormat() {
            return this.chunkFormatHandler.chunkFormat
        }
        getValueAt(e) {
            const t = this.spec.rank
              , n = this.tempChunkGridPosition
              , i = this.tempPositionWithinChunk
              , {spec: r} = this;
            {
                const {chunkDataSize: s} = r;
                for (let r = 0; r < t; ++r) {
                    const t = e[r]
                      , a = s[r]
                      , o = Math.floor(t / a);
                    n[r] = o,
                    i[r] = Math.floor(t - a * o)
                }
            }
            const s = this.chunks.get(n.join());
            if (void 0 === s)
                return null;
            const a = s.chunkDataSize;
            for (let e = 0; e < 3; ++e)
                if (i[e] >= a[e])
                    return;
            return s.getValueAt(i)
        }
        getChunk(e) {
            return this.chunkFormatHandler.getChunk(this, e)
        }
    }
    class o extends i.c {
        constructor(e, t) {
            super(e, t),
            this.chunkDataSize = t.chunkDataSize || e.spec.chunkDataSize
        }
        get chunkFormat() {
            return this.source.chunkFormat
        }
    }
    class l extends i.a {
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        let t = -1;
        return Object.assign(()=>{
            -1 === t && (t = requestAnimationFrame(()=>{
                t = -1,
                e()
            }
            ))
        }
        , {
            flush: ()=>{
                -1 !== t && (t = -1,
                e())
            }
            ,
            cancel: ()=>{
                -1 !== t && (cancelAnimationFrame(t),
                t = -1)
            }
        })
    }
    n.d(t, "a", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    ));
    var i = n(2)
      , r = n(0)
      , s = n(3);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function a(e, t, n) {
        Object(r.B)(e, t, e=>n.restoreState(e))
    }
    class o extends i.a {
        constructor() {
            super(...arguments),
            this.children = new Map,
            this.changed = new s.a
        }
        add(e, t) {
            const {children: n} = this;
            if (n.has(e))
                throw new Error(`Key ${JSON.stringify(e)} already registered.`);
            return this.children.set(e, t),
            t.changed.add(this.changed.dispatch),
            this.changed.dispatch(),
            ()=>{
                this.remove(e)
            }
        }
        remove(e) {
            const {children: t} = this;
            if (t.has(e))
                throw new Error(`Key ${JSON.stringify(e)} not registered.`);
            const n = t.get(e);
            this.children.delete(e),
            n.changed.remove(this.changed.dispatch),
            this.changed.dispatch()
        }
        disposed() {
            const {changed: e} = this;
            for (let t of this.children.values())
                t.changed.remove(e.dispatch);
            this.children = void 0,
            super.disposed()
        }
        toJSON() {
            const e = this.baseJSON();
            for (let[t,n] of this.children)
                e[t] = n.toJSON();
            return e
        }
        baseJSON() {
            return {}
        }
        reset() {
            for (let e of this.children.values())
                e.reset()
        }
        restoreState(e) {
            Object(r.w)(e);
            for (let[t,n] of this.children)
                try {
                    if (e.hasOwnProperty(t)) {
                        const i = e[t];
                        if (void 0 === i)
                            continue;
                        n.restoreState(i)
                    }
                } catch (e) {
                    throw new Error(`Error restoring property ${JSON.stringify(t)}: ${e.message}`)
                }
        }
    }
    const l = new WeakMap;
    function c(e) {
        let t = l.get(e);
        const n = e.changed.count;
        if (void 0 !== t && t.generation === n)
            return t;
        let i;
        if (e instanceof o) {
            i = e.baseJSON();
            for (let[t,n] of e.children)
                i[t] = c(n).value
        } else
            i = e.toJSON();
        return void 0 === t ? (t = {
            generation: n,
            value: i
        },
        l.set(e, t)) : (t.generation = n,
        t.value = i),
        t
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "f", (function() {
        return b
    }
    )),
    n.d(t, "b", (function() {
        return y
    }
    )),
    n.d(t, "e", (function() {
        return S
    }
    )),
    n.d(t, "g", (function() {
        return w
    }
    )),
    n.d(t, "a", (function() {
        return x
    }
    )),
    n.d(t, "d", (function() {
        return C
    }
    ));
    var i, r = n(16), s = n.n(r), a = n(75), o = n(38), l = n(104), c = n(7), u = n(2), d = n(1), h = n(48), p = n(3), f = n(26), m = n(11), g = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }, v = function(e, t) {
        var n = {};
        for (var i in e)
            Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
            var r = 0;
            for (i = Object.getOwnPropertySymbols(e); r < i.length; r++)
                t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]])
        }
        return n
    };
    function b() {
        return new c.d([i.DATA, i.ANNOTATION, i.DEFAULT_ANNOTATION])
    }
    !function(e) {
        e[e.DATA = 0] = "DATA",
        e[e.ANNOTATION = 1] = "ANNOTATION",
        e[e.DEFAULT_ANNOTATION = 2] = "DEFAULT_ANNOTATION"
    }(i || (i = {}));
    class y extends u.a {
        constructor() {
            super(...arguments),
            this.role = i.DATA,
            this.messages = new h.a,
            this.layerChanged = new p.a,
            this.redrawNeeded = new p.a
        }
        handleAction(e) {}
        getValueAt(e) {}
        transformPickedValue(e, t) {
            return e
        }
        updateMouseState(e, t, n, i) {}
    }
    class S extends y {
        constructor() {
            super(...arguments),
            this.visibility = new f.a
        }
        attach(e) {}
    }
    function w(e, t, n) {
        let {state: i} = n;
        if (void 0 === i || i.transform !== e || i.displayDimensionRenderInfo !== t) {
            if (n.messages.clearMessages(),
            i = n.state = {
                transform: e,
                displayDimensionRenderInfo: t,
                modelTransform: void 0
            },
            void 0 !== e.error)
                return void n.messages.addMessage({
                    severity: h.b.error,
                    message: e.error
                });
            try {
                const n = d.l.create();
                Object(o.b)(n, t, e),
                i.modelTransform = n
            } catch (e) {
                n.messages.addMessage({
                    severity: h.b.error,
                    message: e.message
                })
            }
        }
        return i.modelTransform
    }
    class x extends u.a {
        constructor(e) {
            super(),
            this.width = 0,
            this.height = 0,
            this.changed = new p.b;
            const {parametersConstructor: t=a.a, navigationState: n, update: i, isEqual: r=a.b} = e;
            this.oldValue_ = new t,
            this.value_ = new t;
            const o = ()=>{
                const {oldValue_: e, value_: t} = this;
                e.displayDimensionRenderInfo = n.displayDimensionRenderInfo.value,
                e.width = this.width,
                e.height = this.height,
                i(e, n),
                r(e, t) || (this.value_ = e,
                this.oldValue_ = t,
                this.changed.dispatch(t, e))
            }
              , l = this.update = this.registerCancellable(s()(o, 0));
            this.registerDisposer(n.changed.add(l)),
            o()
        }
        setViewportShape(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.update())
        }
        get value() {
            return this.update.flush(),
            this.value_
        }
    }
    let C = class extends m.b {
        constructor(e, t, n=10) {
            super(),
            this.base = t,
            this.updateInterval = n,
            this.update = this.registerCancellable(s()((e,t)=>{
                let n;
                if (t.displayDimensionRenderInfo !== e.displayDimensionRenderInfo)
                    n = t;
                else {
                    const {displayDimensionRenderInfo: e} = t;
                    n = v(t, ["displayDimensionRenderInfo"])
                }
                this.rpc.invoke(l.a, {
                    id: this.rpcId,
                    value: n
                })
            }
            , this.updateInterval)),
            this.initializeCounterpart(e, {
                value: t.value
            }),
            this.registerDisposer(t.changed.add(this.update))
        }
        flush() {
            this.update.flush()
        }
    }
    ;
    C = g([Object(m.g)(l.b)], C)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "e", (function() {
        return m
    }
    )),
    n.d(t, "d", (function() {
        return g
    }
    )),
    n.d(t, "f", (function() {
        return v
    }
    )),
    n.d(t, "g", (function() {
        return b
    }
    )),
    n.d(t, "a", (function() {
        return w
    }
    )),
    n.d(t, "c", (function() {
        return x
    }
    ));
    var i = n(6)
      , r = n(19)
      , s = n(24)
      , a = n(90);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o {
    }
    const l = [-1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.RG_INTEGER, WebGL2RenderingContext.RGB_INTEGER, WebGL2RenderingContext.RGBA_INTEGER]
      , c = [-1, WebGL2RenderingContext.RED, WebGL2RenderingContext.RG, WebGL2RenderingContext.RGB, WebGL2RenderingContext.RGBA]
      , u = ["", "r", "rg", "rgb", "rgba"]
      , d = [-1, WebGL2RenderingContext.R8UI, WebGL2RenderingContext.RG8UI, WebGL2RenderingContext.RGB8UI, WebGL2RenderingContext.RGBA8UI]
      , h = [-1, WebGL2RenderingContext.R16UI, WebGL2RenderingContext.RG16UI, WebGL2RenderingContext.RGB16UI, WebGL2RenderingContext.RGBA16UI]
      , p = [-1, WebGL2RenderingContext.R32UI, WebGL2RenderingContext.RG32UI, WebGL2RenderingContext.RGB32UI, WebGL2RenderingContext.RGBA32UI]
      , f = [-1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RG32F, WebGL2RenderingContext.RGB32F, WebGL2RenderingContext.RGBA32F];
    function m(e) {
        return e === r.a.FLOAT32 ? "" : "u"
    }
    function g(e, t, n=1) {
        switch (t) {
        case r.a.UINT8:
            if (n < 1 || n > 4)
                break;
            return e.texelsPerElement = 1,
            e.textureInternalFormat = d[n],
            e.textureFormat = l[n],
            e.texelType = WebGL2RenderingContext.UNSIGNED_BYTE,
            e.arrayElementsPerTexel = n,
            e.arrayConstructor = Uint8Array,
            e.samplerPrefix = "u",
            e;
        case r.a.UINT16:
            if (n < 1 || n > 4)
                break;
            return e.texelsPerElement = 1,
            e.textureInternalFormat = h[n],
            e.textureFormat = l[n],
            e.texelType = WebGL2RenderingContext.UNSIGNED_SHORT,
            e.arrayElementsPerTexel = n,
            e.arrayConstructor = Uint16Array,
            e.samplerPrefix = "u",
            e;
        case r.a.UINT64:
            if (n < 1 || n > 2)
                break;
            return e.texelsPerElement = 1,
            e.textureInternalFormat = p[2 * n],
            e.textureFormat = l[2 * n],
            e.texelType = WebGL2RenderingContext.UNSIGNED_INT,
            e.arrayElementsPerTexel = 2 * n,
            e.arrayConstructor = Uint32Array,
            e.samplerPrefix = "u",
            e;
        case r.a.UINT32:
            if (n < 1 || n > 4)
                break;
            return e.texelsPerElement = 1,
            e.textureInternalFormat = p[n],
            e.textureFormat = l[n],
            e.texelType = WebGL2RenderingContext.UNSIGNED_INT,
            e.arrayElementsPerTexel = 1,
            e.arrayConstructor = Uint32Array,
            e.samplerPrefix = "u",
            e;
        case r.a.FLOAT32:
            if (n < 1 || n > 4)
                break;
            return e.texelsPerElement = 1,
            e.textureInternalFormat = f[n],
            e.textureFormat = c[n],
            e.texelType = WebGL2RenderingContext.FLOAT,
            e.arrayElementsPerTexel = n,
            e.arrayConstructor = Float32Array,
            e.samplerPrefix = "",
            e
        }
        throw new Error(`No supported texture format for ${r.a[t]}[${n}].`)
    }
    function v(e, t, n) {
        const {arrayConstructor: r, arrayElementsPerTexel: s, textureInternalFormat: o, textureFormat: l, texelsPerElement: c} = t
          , {maxTextureSize: u} = e
          , d = n.length / s;
        if (d * c > u * u)
            throw new Error("Number of elements exceeds maximum texture size: " + c + " * " + d);
        const h = Math.ceil(d / u)
          , p = Math.ceil(Math.log2(h))
          , f = (1 << p) * c
          , m = Math.ceil(d / (1 << p))
          , g = f * m * s;
        n.constructor !== r && (n = new r(n.buffer,n.byteOffset,n.byteLength / r.BYTES_PER_ELEMENT));
        let v = Object(i.h)(n, g);
        e.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1),
        Object(a.c)(e),
        e.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, o, f, m, 0, l, t.texelType, v)
    }
    function b(e, t, n, i, r, s) {
        const {arrayConstructor: o, textureInternalFormat: l, textureFormat: c, texelsPerElement: u} = t;
        n.constructor !== o && (n = new o(n.buffer,n.byteOffset,n.byteLength / o.BYTES_PER_ELEMENT)),
        e.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1),
        Object(a.b)(e),
        e.texImage3D(WebGL2RenderingContext.TEXTURE_3D, 0, l, i * u, r, s, 0, c, t.texelType, n)
    }
    function y(e) {
        switch (e) {
        case r.a.UINT8:
            return s.k;
        case r.a.UINT16:
            return s.h;
        case r.a.UINT32:
            return s.i;
        case r.a.UINT64:
            return s.j;
        case r.a.FLOAT32:
            return s.d
        }
    }
    function S(e, t, n, i, a, o) {
        const l = Object(s.b)(a, o);
        let c = [y(a)]
          , d = `\n${l} ${e}(${i} index) {\n`;
        switch (a) {
        case r.a.UINT8:
        case r.a.UINT16:
        case r.a.UINT32:
            d += `\n  ${l} result;\n  highp uvec4 temp;\n  ${t}(${n}, index, temp);\n  result.value = temp.${u[o]};\n  return result;\n`;
            break;
        case r.a.UINT64:
            c.push(s.l),
            d += `\n  highp uvec4 temp;\n  ${t}(${n}, index, temp);\n  return unpackUint64leFromUint32(temp.${u[2 * o]});\n`;
            break;
        case r.a.FLOAT32:
            c.push(s.d),
            d += `\n  highp vec4 temp;\n  ${t}(${n}, index, temp);\n  return temp.${u[o]};\n`
        }
        return d += "\n}\n",
        c.push(d),
        c
    }
    class w {
        constructor(e) {
            this.key = e,
            this.readTextureValue = `readTextureValue_${this.key}`
        }
        defineShader(e) {}
        getReadTextureValueCode(e, t) {
            let n = `\nvoid ${this.readTextureValue}(highp ${t}sampler2D sampler, highp uint index`;
            for (let i = 0; i < e; ++i)
                n += `, out ${t}vec4 output${i}`;
            n += `) {\n  highp int width = textureSize(sampler, 0).x / ${e};\n  highp uint log2width = log2Exact(uint(width));\n  highp int y = int(index >> log2width);\n  highp int x = int((index - (uint(y) << log2width)) * ${e}u);\n`;
            for (let t = 0; t < e; ++t)
                n += `\n  output${t} = texelFetch(sampler, ivec2(x + ${t}, y), 0);\n`;
            return n += "\n}\n",
            [s.g, n]
        }
        getAccessor(e, t, n, i=1) {
            const r = m(n);
            return [this.getReadTextureValueCode(1, r), ...S(e, this.readTextureValue, t, "highp uint", n, i)]
        }
    }
    class x {
        constructor(e) {
            this.key = e,
            this.readTextureValue = `readTextureValue_${this.key}`
        }
        getReadTextureValueCode(e, t) {
            let n = `\nvoid ${this.readTextureValue}(highp ${t}sampler3D sampler, highp ivec3 p`;
            for (let i = 0; i < e; ++i)
                n += `, out ${t}vec4 output${i}`;
            n += ") {\n";
            for (let t = 0; t < e; ++t)
                n += `\n  output${t} = texelFetch(sampler, ivec3(p.x * ${e} + ${t}, p.y, p.z), 0);\n`;
            return n += "\n}\n",
            n
        }
        getAccessor(e, t, n, i=1) {
            const r = m(n);
            return [this.getReadTextureValueCode(1, r), ...S(e, this.readTextureValue, t, "highp ivec3", n, i)]
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "f", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return p
    }
    )),
    n.d(t, "b", (function() {
        return g
    }
    ));
    var i, r = n(4), s = n(23), a = n(39), o = n(2), l = n(15);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class c extends Error {
        constructor(e) {
            super(`Redirected to: ${e}`),
            this.redirectTarget = e
        }
    }
    function u(e, t) {
        void 0 === t && (t = -1 === e.indexOf("/") ? ":" : "/");
        let n = e.lastIndexOf(t);
        return -1 === n ? 0 : n + 1
    }
    function d() {
        return {
            url: "",
            transform: void 0,
            enableDefaultSubsources: !0,
            subsources: new Map
        }
    }
    !function(e) {
        e[e.annotations = 0] = "annotations"
    }(i || (i = {}));
    class h extends o.a {
        normalizeUrl(e) {
            return e.url
        }
        convertLegacyUrl(e) {
            return e.url
        }
        async completeUrl(e) {
            throw null
        }
    }
    const p = "local://annotations";
    class f extends h {
        constructor() {
            super(...arguments),
            this.description = "Local in-memory"
        }
        async get(e) {
            if (e.url === p) {
                const {transform: t} = e;
                let n;
                if (void 0 === t) {
                    const t = e.globalCoordinateSpace.value
                      , {rank: i, names: s, scales: a, units: o} = t;
                    n = {
                        rank: i,
                        sourceRank: i,
                        inputSpace: Object(r.z)({
                            rank: i,
                            scales: a,
                            units: o,
                            names: s.map((e,t)=>`${t}`)
                        }),
                        outputSpace: Object(r.z)({
                            rank: i,
                            scales: a,
                            units: o,
                            names: s
                        }),
                        transform: Object(l.c)(Float64Array, i + 1)
                    }
                } else
                    n = Object(r.A)(r.m);
                return {
                    modelTransform: n,
                    canChangeModelSpaceRank: !0,
                    subsources: [{
                        id: "default",
                        default: !0,
                        subsource: {
                            local: i.annotations
                        }
                    }]
                }
            }
            throw new Error("Invalid local data source URL")
        }
        async completeUrl(e) {
            return {
                offset: 0,
                completions: Object(a.d)(e.providerUrl, [{
                    value: "annotations",
                    description: "Annotations stored in the JSON state"
                }], e=>e.value, e=>e.description)
            }
        }
    }
    const m = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
    class g extends o.a {
        constructor() {
            super(...arguments),
            this.dataSources = new Map([["local", new f]])
        }
        register(e, t) {
            this.dataSources.set(e, this.registerDisposer(t))
        }
        getProvider(e) {
            const t = e.match(m);
            if (null === t || void 0 === t[1])
                throw new Error('Data source URL must have the form "<protocol>://<path>".');
            const [,n,i] = t
              , r = this.dataSources.get(n);
            if (void 0 === r)
                throw new Error(`Unsupported data source: ${JSON.stringify(n)}.`);
            return [r, i, n]
        }
        async get(e) {
            const t = new Set
              , {cancellationToken: n=s.e} = e;
            let i = e.url;
            for (; ; ) {
                const [r,s,a] = this.getProvider(e.url);
                t.add(e.url);
                try {
                    return r.get(Object.assign(Object.assign({}, e), {
                        url: i,
                        providerProtocol: a,
                        providerUrl: s,
                        registry: this,
                        cancellationToken: n
                    }))
                } catch (e) {
                    if (e instanceof c) {
                        const n = e.redirectTarget;
                        if (t.has(n))
                            throw Error(`Layer source redirection contains loop: ${JSON.stringify(Array.from(t))}`);
                        if (t.size >= 10)
                            throw Error(`Too many layer source redirections: ${JSON.stringify(Array.from(t))}`);
                        i = n;
                        continue
                    }
                    throw e
                }
            }
        }
        convertLegacyUrl(e) {
            try {
                const [t,n,i] = this.getProvider(e.url);
                return t.convertLegacyUrl(Object.assign(Object.assign({}, e), {
                    providerUrl: n,
                    providerProtocol: i,
                    registry: this
                }))
            } catch (t) {
                return e.url
            }
        }
        normalizeUrl(e) {
            try {
                const [t,n,i] = this.getProvider(e.url);
                return t.normalizeUrl(Object.assign(Object.assign({}, e), {
                    providerUrl: n,
                    providerProtocol: i,
                    registry: this
                }))
            } catch (t) {
                return e.url
            }
        }
        async completeUrl(e) {
            const {url: t, cancellationToken: n=s.e} = e;
            let i = t.match(m)
              , r = i[1];
            if (void 0 === r)
                return Promise.resolve({
                    offset: 0,
                    completions: Object(a.d)(t, this.dataSources, ([e])=>`${e}://`, ([,e])=>e.description)
                });
            {
                const s = this.dataSources.get(r);
                if (void 0 !== s) {
                    const o = await s.completeUrl({
                        registry: this,
                        url: t,
                        providerUrl: i[2],
                        chunkManager: e.chunkManager,
                        cancellationToken: n
                    });
                    return Object(a.a)(r.length + 3, o)
                }
                throw null
            }
        }
        suggestLayerName(e) {
            let[t,n] = this.getProvider(e);
            n.endsWith("/") && (n = n.substring(0, n.length - 1));
            let i = t.suggestLayerName;
            return void 0 !== i ? i(n) : function(e, t) {
                let n = u(e, t);
                return e.substring(n)
            }(n)
        }
        findSourceGroup(e) {
            let[t,n,i] = this.getProvider(e);
            return (t.findSourceGroup || u)(n) + i.length + 3
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "c", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "e", (function() {
        return d
    }
    ));
    var i = n(7)
      , r = n(0)
      , s = n(42)
      , a = n(60);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function o() {
        return new i.e(void 0)
    }
    function l(e) {
        return new i.c(e,r.E)
    }
    function c(e, t, n) {
        const s = new Map
          , {parameters: o, fallbackParameters: l, shaderError: c, encodeParameters: u=(e=>e), extraParameters: d=Object(i.f)(void 0), encodeExtraParameters: h=(e=>e), getContextKey: p, defineShader: f} = n;
        void 0 !== c && (c.value = void 0);
        const {encodeContext: m=p} = n
          , g = Object(r.h)(n.memoizeKey);
        function v(e, n, i) {
            const r = JSON.stringify({
                id: g,
                context: m(e),
                parameters: u(n),
                extraParameters: h(i)
            });
            return t.memoize.get(r, ()=>{
                const r = new a.a(t);
                return f(r, e, n, i),
                r.build()
            }
            )
        }
        return e.registerDisposer(()=>{
            for (const e of s.values()) {
                const {shader: t} = e;
                null !== t && t.dispose()
            }
        }
        ),
        function(e) {
            const t = m(e);
            let n = s.get(t);
            void 0 === n && (n = {
                parametersGeneration: -1,
                extraParametersGeneration: -1,
                shader: null,
                fallback: !1,
                parameters: o.value,
                extraParameters: d.value
            },
            s.set(t, n));
            const i = o.changed.count
              , r = d.changed.count;
            if (i === n.parametersGeneration && r === n.extraParametersGeneration)
                return n;
            const a = n.parameters = o.value
              , u = n.extraParameters = d.value
              , h = n.shader;
            n.parametersGeneration = i,
            n.extraParametersGeneration = r;
            let p = null;
            try {
                p = v(e, a, u),
                n.fallback = !1,
                void 0 !== l && (l.value = a),
                void 0 !== c && (c.value = null)
            } catch (t) {
                if (void 0 !== c && (c.value = t),
                void 0 !== l)
                    try {
                        const t = l.value;
                        p = v(e, t, u),
                        n.parameters = t,
                        n.fallback = !0
                    } catch (e) {}
            }
            return null !== h && h.dispose(),
            n.shader = p,
            n
        }
    }
    function u(e, t, n) {
        return c(e, t, {
            memoizeKey: n.memoizeKey,
            fallbackParameters: n.fallbackParameters,
            encodeParameters: n.encodeParameters,
            parameters: n.parameters,
            getContextKey: e=>e,
            encodeContext: e=>Object(s.a)(e),
            shaderError: n.shaderError,
            extraParameters: n.extraParameters,
            encodeExtraParameters: n.encodeExtraParameters,
            defineShader: (e,t,i,r)=>(e.require(t),
            n.defineShader(e, i, r))
        })
    }
    function d(e, t=1, n=0) {
        return `\n#line ${n} ${t}\n` + e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    n(150);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let i = null;
    class r {
        constructor(e=!1) {
            if (null === i) {
                i = document.createElement("ul"),
                i.id = "statusContainer";
                const e = document.getElementById("neuroglancer-container");
                e ? e.appendChild(i) : document.body.appendChild(i)
            }
            let t = document.createElement("li");
            this.element = t,
            !0 === e && (e = 200),
            !1 !== e ? (this.setVisible(!1),
            this.timer = setTimeout(this.setVisible.bind(this, !0), e)) : this.timer = null,
            i.appendChild(t)
        }
        dispose() {
            i.removeChild(this.element),
            this.element = void 0,
            null !== this.timer && clearTimeout(this.timer)
        }
        setText(e, t) {
            this.element.textContent = e,
            t && this.setVisible(!0)
        }
        setHTML(e, t) {
            this.element.innerHTML = e,
            t && this.setVisible(!0)
        }
        setVisible(e) {
            null !== this.timer && (clearTimeout(this.timer),
            this.timer = null),
            this.element.style.display = e ? "block" : "none"
        }
        static forPromise(e, t) {
            let n = new r(t.delay);
            n.setText(t.initialMessage);
            let i = n.dispose.bind(n);
            return e.then(i, e=>{
                let i;
                i = e instanceof Error ? e.message : "" + e;
                let {errorPrefix: r=""} = t;
                n.setErrorMessage(r + i),
                n.setVisible(!0)
            }
            ),
            e
        }
        setErrorMessage(e) {
            this.element.textContent = e + " ";
            let t = document.createElement("button");
            t.textContent = "Dismiss",
            t.addEventListener("click", ()=>{
                this.dispose()
            }
            ),
            this.element.appendChild(t)
        }
        static showMessage(e) {
            const t = new r;
            return t.element.textContent = e,
            t.setVisible(!0),
            t
        }
        static showTemporaryMessage(e, t=2e3) {
            const n = this.showMessage(e);
            return setTimeout(()=>n.dispose(), t),
            n
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    n(161);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        const {title: t, onClick: n, href: i} = e;
        let r;
        void 0 !== i ? (r = document.createElement("a"),
        r.href = i,
        r.target = "_blank") : r = document.createElement("div"),
        void 0 !== t && (r.title = t),
        void 0 !== n && r.addEventListener("click", n);
        const {svg: s} = e;
        return r.className = "neuroglancer-icon",
        void 0 !== s && (r.innerHTML = s),
        void 0 !== e.text && r.appendChild(document.createTextNode(e.text)),
        r
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "f", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return l
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return u
    }
    )),
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "g", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return p
    }
    ));
    var i = n(6);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const r = [{
        prefix: "Y",
        exponent: 24
    }, {
        prefix: "Z",
        exponent: 21
    }, {
        prefix: "E",
        exponent: 18
    }, {
        prefix: "P",
        exponent: 15
    }, {
        prefix: "T",
        exponent: 12
    }, {
        prefix: "G",
        exponent: 9
    }, {
        prefix: "M",
        exponent: 6
    }, {
        prefix: "k",
        exponent: 3
    }, {
        prefix: "",
        exponent: 0
    }, {
        prefix: "c",
        exponent: -2
    }, {
        prefix: "m",
        exponent: -3
    }, {
        prefix: "",
        exponent: -6
    }, {
        prefix: "n",
        exponent: -9
    }, {
        prefix: "p",
        exponent: -12
    }, {
        prefix: "f",
        exponent: -15
    }, {
        prefix: "a",
        exponent: -18
    }, {
        prefix: "z",
        exponent: -21
    }, {
        prefix: "y",
        exponent: -24
    }]
      , s = [{
        prefix: "u",
        exponent: -6
    }, ...r]
      , a = new Map;
    a.set("", {
        unit: "",
        exponent: 0
    });
    const o = new Map;
    for (const {prefix: e, exponent: t} of s) {
        o.set(t, e);
        for (const n of ["m", "s", "Hz", "rad/s"])
            a.set(`${e}${n}`, {
                unit: n,
                exponent: t
            })
    }
    function l(e) {
        const t = Math.log10(e)
          , n = r.length
          , s = Object(i.c)(0, n, e=>r[e].exponent <= t);
        return r[Math.min(s, n - 1)]
    }
    function c(e, t, n={}) {
        const {precision: i=6, elide1: r=!0} = n;
        let s, a = e, o = "";
        if ("" !== t) {
            const t = l(e);
            o = t.prefix,
            a = p(e, -t.exponent)
        }
        if (r && 1 === a)
            return {
                scale: "",
                unit: t,
                prefix: o
            };
        if (0 != i) {
            s = a < 1 || a >= 1e3 ? a.toPrecision(i) : a.toFixed(i);
            const e = s.indexOf("e");
            let t, n;
            -1 !== e ? (t = s.substring(0, e),
            n = s.substring(e)) : (t = s,
            n = "");
            const r = t.match(/.*\.(?:[0-9]*[1-9])?(0+)$/);
            null !== r && (t = t.substring(0, t.length - r[1].length),
            t.endsWith(".") && (t = t.substring(0, t.length - 1)),
            s = t + n)
        } else
            s = a.toString();
        return {
            scale: s,
            unit: t,
            prefix: o
        }
    }
    function u(e, t, n) {
        const {scale: i, unit: r, prefix: s} = c(e, t, n);
        return `${i}${s}${r}`
    }
    function d(e) {
        if ("" === e)
            return {
                scale: 1,
                unit: ""
            };
        const t = e.match(/^((?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)?([a-zA-Z]+)?$/);
        if (null === t)
            return;
        const n = t[1];
        let i = void 0 === n ? 1 : Number(n);
        if (Number.isNaN(i))
            return;
        let r = "";
        if (void 0 !== t[2]) {
            const e = a.get(t[2]);
            if (void 0 === e)
                return;
            r = e.unit,
            e.exponent > 0 ? i *= 10 ** e.exponent : i /= 10 ** -e.exponent
        }
        return i <= 0 || !Number.isFinite(i) ? void 0 : {
            scale: i,
            unit: r
        }
    }
    function h(e) {
        const t = a.get(e);
        if (void 0 === t)
            throw new Error(`Invalid unit: ${JSON.stringify(e)}`);
        return t
    }
    function p(e, t) {
        return t >= 0 ? e * 10 ** t : e / 10 ** -t
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "g", (function() {
        return u
    }
    )),
    n.d(t, "h", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return p
    }
    )),
    n.d(t, "f", (function() {
        return f
    }
    )),
    n.d(t, "c", (function() {
        return m
    }
    )),
    n.d(t, "d", (function() {
        return g
    }
    )),
    n.d(t, "b", (function() {
        return v
    }
    ));
    var i = n(4)
      , r = n(7)
      , s = n(6)
      , a = n(1)
      , o = n(15);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function l(e, t, n, i, r, s) {
        const {scales: a} = n
          , {scales: o, rank: l} = r
          , c = t + 1;
        for (let n = 0; n < l; ++n) {
            const r = s[n];
            if (-1 === r)
                continue;
            const l = o[n];
            for (let n = 0; n < t; ++n) {
                const t = a[i[n]];
                e[c * n + r] *= t / l
            }
        }
    }
    function c(e, t) {
        return e === t || void 0 === e.error && void 0 === t.error && (Object(s.a)(e.modelDimensionNames, t.modelDimensionNames) && Object(s.a)(e.layerDimensionNames, t.layerDimensionNames) && Object(s.a)(e.globalToRenderLayerDimensions, t.globalToRenderLayerDimensions) && Object(s.a)(e.localToRenderLayerDimensions, t.localToRenderLayerDimensions) && Object(s.a)(e.channelToRenderLayerDimensions, t.channelToRenderLayerDimensions) && Object(s.a)(e.modelToRenderLayerTransform, t.modelToRenderLayerTransform) && Object(i.d)(e.channelDimensionBounds, t.channelDimensionBounds))
    }
    function u(e, t, n, s, u) {
        return Object(r.g)((e,t,n,r)=>function(e, t, n, r, s=i.m) {
            const {inputSpace: c, rank: u, sourceRank: d, outputSpace: h, transform: p} = n
              , {names: f} = c
              , {names: m} = h;
            let g;
            if (void 0 !== r)
                g = Array.from(r.modelSubspaceDimensionIndices);
            else {
                g = [];
                for (let e = 0; e < d; ++e)
                    g[e] = e
            }
            const v = g.length;
            for (let e = d; e < u; ++e)
                g.push(e);
            const b = Object(a.b)(n.transform, u, g, !0)
              , y = g.length
              , S = g.map(e=>f[e] || `${e}`)
              , w = b.map(e=>m[e]);
            if (y !== b.length)
                return {
                    error: "Rank mismatch between model subspace dimensions (" + S.join(", ") + ") and corresponding layer/global dimensions (" + w.join(", ") + ")"
                };
            let x = Object(i.t)(Float32Array, p, u, b, g);
            const C = b.map(e=>m[e])
              , O = t.names.map(e=>C.indexOf(e))
              , k = e.names.map(e=>C.indexOf(e));
            l(x, y, c, g, e, k),
            l(x, y, c, g, t, O);
            const E = s.names.map(e=>C.indexOf(e));
            l(x, y, c, g, s, E);
            const T = []
              , M = E.length;
            if (void 0 !== r) {
                let {subsourceToModelSubspaceTransform: e} = r;
                v !== y && (e = o.e(new Float32Array((y + 1) ** 2), y, e, v)),
                x = o.h(new Float32Array((y + 1) ** 2), y + 1, x, y + 1, e, y + 1, y + 1, y + 1, y + 1)
            }
            for (let e = 0; e < M; ++e) {
                const t = E[e];
                let n = -1;
                if (-1 !== t)
                    for (let e = 0; e < y; ++e) {
                        const i = x[t + e * (y + 1)];
                        if (0 !== i) {
                            if (1 !== i || -1 !== n)
                                return {
                                    error: `Channel dimension ${w[t]} ` + "must map to a single source dimension"
                                };
                            n = e
                        }
                    }
                T[e] = n
            }
            return {
                rank: y,
                unpaddedRank: v,
                modelDimensionNames: S,
                layerDimensionNames: w,
                localToRenderLayerDimensions: O,
                globalToRenderLayerDimensions: k,
                channelToRenderLayerDimensions: E,
                modelToRenderLayerTransform: x,
                channelToModelDimensions: T,
                channelDimensionBounds: s.bounds
            }
        }(e, t, n, s, r), [e, t, n, void 0 === u ? Object(r.f)(void 0) : u], c)
    }
    function d(e, t, n, i) {
        const {globalToRenderLayerDimensions: r} = n;
        for (let n = 0; n < 3; ++n) {
            let s = 0;
            const a = i[n];
            if (-1 !== a) {
                const e = r[a];
                -1 !== e && (s = t[e])
            }
            e[n] = s
        }
    }
    function h(e, t, n, i) {
        const {globalToRenderLayerDimensions: r} = n;
        for (let n = 0; n < 3; ++n) {
            const s = i[n];
            if (-1 !== s) {
                const i = r[s];
                -1 !== i && (e[i] = t[n])
            }
        }
    }
    function p(e, t) {
        const n = e.rank
          , i = e.unpaddedRank;
        let r;
        i !== n && void 0 !== t && (t = o.e(new Float32Array((n + 1) ** 2), n, t, i)),
        void 0 !== t ? (r = new Float32Array((n + 1) * (n + 1)),
        o.h(r, n + 1, e.modelToRenderLayerTransform, n + 1, t, n + 1, n + 1, n + 1, n + 1)) : r = e.modelToRenderLayerTransform;
        const s = new Float32Array((n + 1) * (n + 1))
          , a = o.f(s, n + 1, r, n + 1, n + 1);
        if (0 === a)
            throw new Error("Transform is singular");
        const {globalToRenderLayerDimensions: l, localToRenderLayerDimensions: c, channelToRenderLayerDimensions: u} = e
          , d = l.length
          , h = c.length
          , p = d + h
          , f = new Float32Array((p + 1) * n);
        for (let e = 0; e < n; ++e) {
            for (let t = 0; t < d; ++t) {
                const i = l[t];
                -1 !== i && (f[e + t * n] = s[e + i * (n + 1)])
            }
            for (let t = 0; t < h; ++t) {
                const i = c[t];
                -1 !== i && (f[e + (d + t) * n] = s[e + i * (n + 1)])
            }
            f[e + p * n] = s[e + n * (n + 1)]
        }
        const m = u.length;
        let g = new Array(m);
        for (let t = 0; t < m; ++t) {
            const i = u[t];
            let s = -1;
            if (-1 !== i) {
                for (let t = 0; t < n; ++t) {
                    const a = r[i + t * (n + 1)];
                    if (0 !== a) {
                        if (1 !== a || -1 !== s)
                            throw new Error(`Channel dimension ${e.layerDimensionNames[i]} ` + "must map with stride 1 to a single data chunk dimensions");
                        s = t
                    }
                }
                if (-1 !== s && 0 !== r[i + n * (n + 1)])
                    throw new Error(`Channel dimension ${e.layerDimensionNames[i]} ` + "must have an offset of 0 in the chunk coordinate space")
            }
            g[t] = s
        }
        return {
            layerRank: n,
            modelTransform: e,
            chunkToLayerTransform: r,
            layerToChunkTransform: s,
            chunkToLayerTransformDet: a,
            combinedGlobalLocalRank: p,
            combinedGlobalLocalToChunkTransform: f,
            chunkChannelDimensionIndices: g
        }
    }
    function f(e, t) {
        const {globalToRenderLayerDimensions: n} = e
          , i = []
          , r = [];
        for (let e = 0; e < 3; ++e) {
            const s = t[e];
            if (-1 == s)
                continue;
            const a = n[s];
            r.push(a),
            -1 !== a && i.push(a)
        }
        for (let e = r.length; e < 3; ++e)
            r[e] = -1;
        return {
            layerDisplayDimensionIndices: i,
            displayToLayerDimensionIndices: r
        }
    }
    function m(e, t) {
        const {chunkToLayerTransform: n, modelTransform: i} = e
          , r = i.rank
          , {layerDisplayDimensionIndices: s, displayToLayerDimensionIndices: o} = t
          , l = s.length
          , c = Object(a.b)(n, r, s);
        if (c.length !== l) {
            const {modelDimensionNames: e, layerDimensionNames: t} = i;
            throw new Error("Rank mismatch between displayed layer dimensions " + `(${Array.from(s, e=>t[e]).join(",")}) ` + "and corresponding chunk dimensions " + `(${Array.from(c, t=>e[t]).join(",")})`)
        }
        const u = a.l.create();
        for (let e = 0; e < 3; ++e) {
            const t = o[e];
            if (-1 !== t) {
                for (let i = 0; i < l; ++i) {
                    const s = c[i];
                    u[4 * i + e] = n[s * (r + 1) + t]
                }
                u[12 + e] = n[r * (r + 1) + t]
            }
        }
        const d = a.l.create();
        a.l.invert(d, u);
        for (let e = c.length; e < 3; ++e)
            c[e] = -1;
        return {
            modelTransform: e.modelTransform,
            chunkTransform: e,
            displaySubspaceModelMatrix: u,
            displaySubspaceInvModelMatrix: d,
            chunkDisplayDimensionIndices: c,
            numChunkDisplayDims: l
        }
    }
    function g(e, t, n, i, r) {
        const s = t.length
          , a = n.length
          , o = e.length;
        let l = !0;
        for (let c = 0; c < i; ++c) {
            let u = c
              , d = 0;
            for (let e = 0; e < s; ++e)
                d += r[u + e * i] * t[e];
            u += s * i;
            for (let e = 0; e < a; ++e)
                d += r[u + e * i] * n[e];
            d += r[u + a * i],
            c < o ? e[c] = d : (d < 0 || d >= 1) && (l = !1)
        }
        return l
    }
    function v(e, t, n) {
        e.fill(0),
        e[15] = 1;
        let i = !0;
        const {displayDimensionIndices: r} = t
          , {globalToRenderLayerDimensions: s, modelToRenderLayerTransform: a} = n
          , o = n.rank;
        for (let t = 0; t < 3; ++t) {
            const n = r[t];
            if (-1 === n) {
                i = !1;
                continue
            }
            const l = s[n];
            if (-1 !== l) {
                e[t + 12] = a[l + o * (o + 1)];
                for (let n = 0; n < 3; ++n)
                    e[t + 4 * n] = a[l + (o + 1) * n]
            } else
                i = !1
        }
        if (!i) {
            const {globalDimensionNames: e} = t
              , i = Array.from(r.filter(e=>-1 !== e), t=>e[t]).join(",");
            throw new Error(`Transform from model dimensions (${n.modelDimensionNames.join(",")}) ` + `to display dimensions (${i}) does not have full rank`)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return l
    }
    ));
    var i = n(108);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const r = {
        offset: 0,
        completions: []
    };
    function s(e, t) {
        return t.offset += e,
        t
    }
    function a(e, t) {
        let n = [];
        for (let i of t)
            i.startsWith(e) && n.push({
                value: i
            });
        return n.sort((e,t)=>Object(i.a)(e.value, t.value)),
        n
    }
    function o(e, t, n, r) {
        let s = [];
        for (let i of t) {
            let t = n(i);
            t.startsWith(e) && s.push({
                value: t,
                description: r(i)
            })
        }
        return s.sort((e,t)=>Object(i.a)(e.value, t.value)),
        s
    }
    async function l(e, t) {
        return async function(e, t, n) {
            if (e.startsWith("{"))
                return r;
            const i = e.match(/^(?:(.*)[&;])?([^&;]*)$/)[2];
            let a = e.length - i.length;
            const o = i.indexOf("=");
            if (-1 === o) {
                const e = await t(i);
                return {
                    offset: e.offset + a,
                    completions: e.completions.map(e=>Object.assign(Object.assign({}, e), {
                        value: `${e.value}=`
                    }))
                }
            }
            return s(a + o + 1, await n(i.substring(0, o), i.substring(o + 1)))
        }(e, async e=>{
            const n = [];
            for (const i of t) {
                const t = i.key;
                t.value.startsWith(e) && n.push(t)
            }
            return {
                offset: 0,
                completions: n
            }
        }
        , async(e,n)=>{
            for (const i of t)
                if (i.key.value === e)
                    return {
                        offset: 0,
                        completions: i.values.filter(e=>e.value.startsWith(n))
                    };
            return r
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "d", (function() {
        return v
    }
    ));
    var i = n(7)
      , r = n(62)
      , s = n(2)
      , a = n(0)
      , o = n(3);
    const l = new Map([["slider", function(e, t) {
        let n, i, r, s, a = [];
        "float" !== e && "uint" !== e && "int" !== e && a.push("type must be float, int, or uint");
        for (const [o,l] of t) {
            const t = ()=>{
                if ("number" == typeof l)
                    return "int" !== e && "uint" !== e || (Number.isInteger(l) || a.push(`Expected ${o} argument to be an integer`),
                    "uint" === e && l < 0 && a.push(`Expected ${o} argument to be an unsigned integer`)),
                    l;
                a.push(`Expected ${o} argument to be a number`)
            }
            ;
            "min" === o ? n = t() : "max" === o ? i = t() : "default" === o ? s = t() : "step" === o ? r = t() : a.push(`Invalid parameter: ${o}`)
        }
        return void 0 === n && a.push("min must be specified"),
        void 0 === i && a.push("max must be specified"),
        void 0 !== n && void 0 !== i && (n > i && a.push("min must be less than max"),
        void 0 === r && (r = "float" === e ? (i - n) / 100 : 1),
        void 0 !== s ? (s < n || s > i) && a.push("default must be within valid range") : s = "float" === e ? (n + i) / 2 : n),
        a.length > 0 ? {
            errors: a
        } : {
            control: {
                type: "slider",
                valueType: e,
                min: n,
                max: i,
                step: r,
                default: s
            },
            errors: void 0
        }
    }
    ], ["color", function(e, t) {
        let n = "white"
          , i = [];
        "vec3" !== e && i.push("type must be vec3");
        for (const [e,r] of t)
            "default" === e ? "string" != typeof r ? i.push("Expected default argument to be a string") : n = r : i.push(`Invalid parameter: ${e}`);
        return i.length > 0 ? {
            errors: i
        } : {
            control: {
                type: "color",
                valueType: e,
                defaultString: n,
                default: Object(r.c)(n)
            },
            errors: void 0
        }
    }
    ]]);
    function c(e) {
        e = /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function(e) {
            return e.replace(/\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/gm, e=>e.startsWith("/") ? e.replace(/[^\s]/g, " ") : e)
        }(e);
        const t = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9]*)[ \t]+([a-z]+)[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
        let n = [];
        const i = new Map
          , r = e.replace(/^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/gm, (r,s,a)=>{
            const o = s.match(t)
              , c = ()=>Math.max(0, e.substring(0, a).split("\n").length - 1);
            if (null === o)
                return n.push({
                    line: c(),
                    message: "Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)"
                }),
                "";
            const u = o[1]
              , d = o[2]
              , h = o[3]
              , p = o[4]
              , {parameters: f, errors: m} = function(e) {
                let t = []
                  , n = new Map;
                if (void 0 === e)
                    return {
                        errors: t,
                        parameters: n
                    };
                const i = /^[ \t]*([_a-z][_a-zA-Z0-9]*)[ \t]*=[ \t]*(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*")[ \t]*/;
                for (; 0 != (e = e.trim()).length; ) {
                    const r = e.match(i);
                    if (null === r) {
                        t.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
                        break
                    }
                    const s = r[1];
                    let a;
                    try {
                        a = JSON.parse(r[2])
                    } catch (e) {
                        t.push(`Invalid #uicontrol parameter value: ${a}`);
                        break
                    }
                    n.has(s) ? t.push(`Duplicate #uicontrol parameter: ${s}`) : n.set(s, a),
                    (e = e.substring(r[0].length)).length > 0 && !e.startsWith(",") && t.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ..."),
                    e = e.substring(1)
                }
                return {
                    parameters: n,
                    errors: t
                }
            }(p);
            for (const e of m)
                n.push({
                    line: c(),
                    message: e
                });
            if (i.has(d) && n.push({
                line: c(),
                message: `Duplicate definition for control ${d}`
            }),
            m.length > 0)
                return "";
            const g = l.get(h);
            if (void 0 === g)
                return n.push({
                    line: c(),
                    message: `Invalid control type ${h}`
                }),
                "";
            const v = g(u, f);
            if (void 0 !== v.errors) {
                for (const e of v.errors)
                    n.push({
                        line: c(),
                        message: e
                    });
                return ""
            }
            return i.set(d, v.control),
            ""
        }
        );
        return {
            source: e,
            code: r,
            errors: n,
            controls: i
        }
    }
    function u(e) {
        return `u_shaderControl_${e}`
    }
    function d(e, t) {
        for (const [n,i] of e)
            t.addUniform(`highp ${i.valueType}`, u(n)),
            t.addVertexCode(`#define ${n} ${u(n)}\n`),
            t.addFragmentCode(`#define ${n} ${u(n)}\n`)
    }
    function h(e) {
        if (void 0 !== e)
            return JSON.stringify(function(e) {
                const t = {};
                for (const [n,i] of e)
                    t[n] = i;
                return t
            }(e))
    }
    class p {
        constructor() {
            this.changed = new o.a,
            this.controls = void 0
        }
        get value() {
            return this.controls
        }
        set value(e) {
            h(e) !== h(this.controls) && (this.controls = e,
            this.changed.dispatch())
        }
    }
    function f(e) {
        switch (e.type) {
        case "slider":
            return new i.c(e.default,t=>{
                let n;
                if (n = "float" === e.valueType ? Object(a.p)(t) : Object(a.u)(t),
                n < e.min || n > e.max)
                    throw new Error(`${JSON.stringify(t)} is outside valid range [${e.min}, ${e.max}]`);
                return n
            }
            );
        case "color":
            return new r.a(e.default)
        }
    }
    class m extends s.a {
        constructor(e) {
            super(),
            this.fragmentMain = e,
            this.changed = new o.a,
            this.controls = new p,
            this.fragmentMainGeneration = -1,
            this.parseErrors_ = [],
            this.processedFragmentMain_ = "",
            this.controlsGeneration = -1,
            this.state_ = new Map,
            this.unparsedJson = void 0,
            this.registerDisposer(e.changed.add(()=>this.handleFragmentMainChanged())),
            this.registerDisposer(this.controls.changed.add(()=>this.handleControlsChanged())),
            this.handleFragmentMainChanged();
            const t = this;
            this.parseErrors = {
                changed: e.changed,
                get value() {
                    return t.handleFragmentMainChanged(),
                    t.parseErrors_
                }
            },
            this.processedFragmentMain = {
                changed: e.changed,
                get value() {
                    return t.handleFragmentMainChanged(),
                    t.processedFragmentMain_
                }
            },
            this.parseResult = {
                changed: e.changed,
                get value() {
                    return t.parseResult_
                }
            }
        }
        handleFragmentMainChanged() {
            const e = this.fragmentMain.changed.count;
            if (e === this.fragmentMainGeneration)
                return;
            this.fragmentMainGeneration = e;
            const t = this.parseResult_ = c(this.fragmentMain.value);
            this.parseErrors_ = t.errors,
            this.processedFragmentMain_ = t.code,
            0 === t.errors.length && (this.controls.value = t.controls)
        }
        handleControlsChanged() {
            const e = this.controls.changed.count;
            if (e === this.controlsGeneration)
                return;
            this.controlsGeneration = e;
            const t = this.controls.value;
            if (void 0 === t)
                return;
            let n = !1;
            const {state_: i, unparsedJson: r} = this;
            for (const [e,r] of i) {
                void 0 !== t.get(e) || (r.trackable.changed.remove(this.changed.dispatch),
                i.delete(e),
                n = !0)
            }
            for (const [e,s] of t) {
                let t = i.get(e);
                if (void 0 !== t && JSON.stringify(t.control) !== JSON.stringify(s) && (t.trackable.changed.remove(this.changed.dispatch),
                t = void 0),
                void 0 === t && (t = {
                    control: s,
                    trackable: f(s)
                },
                t.trackable.changed.add(this.changed.dispatch),
                i.set(e, t),
                n = !0),
                void 0 !== r && r.hasOwnProperty(e)) {
                    n = !0;
                    try {
                        t.trackable.restoreState(r[e])
                    } catch (e) {}
                }
            }
            void 0 !== r && (n = !0),
            this.unparsedJson = void 0,
            n && this.changed.dispatch()
        }
        get state() {
            return this.controls.changed.count !== this.controlsGeneration && this.handleControlsChanged(),
            this.state_
        }
        restoreState(e) {
            if (void 0 === e)
                return;
            const {state: t} = this;
            if (Object(a.w)(e),
            void 0 === this.controls.value)
                return this.unparsedJson = e,
                void this.changed.dispatch();
            for (const [n,i] of t) {
                const {trackable: t} = i;
                if (t.reset(),
                e.hasOwnProperty(n))
                    try {
                        t.restoreState(e[n])
                    } catch (e) {}
            }
            this.unparsedJson = void 0
        }
        reset() {
            for (const e of this.state.values())
                e.trackable.reset();
            void 0 !== this.unparsedJson && (this.unparsedJson = void 0,
            this.changed.dispatch())
        }
        toJSON() {
            const {state: e} = this
              , {unparsedJson: t} = this;
            if (void 0 !== t)
                return t;
            const n = {};
            let i = !0;
            for (const [t,r] of e) {
                const e = r.trackable.toJSON();
                void 0 !== e && (n[t] = e,
                i = !1)
            }
            return i ? void 0 : n
        }
    }
    function g(e, t, n, i, r) {
        const s = t.uniform(u(n));
        switch (i.type) {
        case "slider":
            switch (i.valueType) {
            case "int":
            case "uint":
                e.uniform1i(s, r);
                break;
            case "float":
                e.uniform1f(s, r)
            }
            break;
        case "color":
            e.uniform3fv(s, r)
        }
    }
    function v(e, t, n, i) {
        const {state: r} = n;
        if (n.controls.value === i)
            for (const [n,i] of r)
                g(e, t, n, i.control, i.trackable.value);
        else
            for (const [n,s] of i) {
                const i = r.get(n);
                g(e, t, n, s, void 0 !== i && JSON.stringify(i.control) === JSON.stringify(s) ? i.trackable.value : s.default)
            }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return l
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    )),
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "d", (function() {
        return p
    }
    ));
    n(164);
    var i = n(29)
      , r = n(2)
      , s = n(5)
      , a = n(3)
      , o = n(26);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class l extends r.a {
        constructor(e=new o.b(o.b.VISIBLE)) {
            super(),
            this.visibility = e,
            this.element = document.createElement("div");
            const {element: t} = this;
            t.classList.add("neuroglancer-tab-content")
        }
        get visible() {
            return this.visibility.visible
        }
        disposed() {
            Object(s.c)(this.element),
            super.disposed()
        }
    }
    class c extends r.a {
        constructor() {
            super(...arguments),
            this.changed = new a.a,
            this.options = new Map,
            this.optionsChanged = new a.a,
            this.selectedValue = void 0,
            this.defaultValue = void 0,
            this.ready_ = !0
        }
        get value() {
            const {selectedValue: e} = this;
            return void 0 !== e ? e : this.defaultValue
        }
        set default(e) {
            this.defaultValue !== e && (this.defaultValue = e,
            this.changed.dispatch())
        }
        get default() {
            return this.defaultValue
        }
        set value(e) {
            void 0 !== e && this.ready_ && !this.options.has(e) && (e = void 0);
            const {selectedValue: t} = this;
            t !== e && (this.selectedValue = e,
            this.changed.dispatch())
        }
        get validValue() {
            const e = this.selectedValue;
            return void 0 !== e && this.options.has(e) ? e : this.defaultValue
        }
        add(e, t) {
            const {options: n} = this;
            if (n.has(e))
                throw new Error(`Option already defined: ${JSON.stringify(e)}.`);
            n.set(e, t),
            this.optionsChanged.dispatch(),
            void 0 === this.defaultValue && (this.default = e)
        }
        toJSON() {
            const {value: e, defaultValue: t} = this;
            if (e !== t)
                return e
        }
        reset() {
            this.value = void 0
        }
        get ready() {
            return this.ready_
        }
        set ready(e) {
            e !== this.ready_ && (this.ready_ = e,
            e && (this.value = this.value),
            this.changed.dispatch())
        }
        restoreState(e) {
            "string" != typeof e && (e = void 0),
            this.value = e
        }
    }
    class u extends r.a {
        constructor(e, t, n=new o.b(o.b.VISIBLE), r=!1) {
            super(),
            this.getter = e,
            this.selected = t,
            this.visibility = n,
            this.invalidateByDefault = r,
            this.element = document.createElement("div"),
            this.tabs = new Map,
            this.tabVisibilityChanged = new a.b,
            this.debouncedUpdateSelectedTab = this.registerCancellable(Object(i.a)(()=>this.updateSelectedTab()));
            const {element: s} = this;
            s.className = "neuroglancer-stack-view",
            this.registerDisposer(n.changed.add(this.debouncedUpdateSelectedTab)),
            this.registerDisposer(t.changed.add(this.debouncedUpdateSelectedTab)),
            this.updateSelectedTab()
        }
        get visible() {
            return this.visibility.visible
        }
        flush() {
            this.debouncedUpdateSelectedTab.flush()
        }
        invalidate(e) {
            const {tabs: t} = this
              , n = t.get(e);
            void 0 !== n && (n.dispose(),
            t.delete(e),
            e === this.displayedTab && (this.displayedTab = void 0,
            this.debouncedUpdateSelectedTab()))
        }
        hideTab(e) {
            const t = this.tabs.get(e);
            void 0 !== t && (t.visibility.value = o.b.IGNORED,
            t.element.style.display = "none"),
            this.tabVisibilityChanged.dispatch(e, !1)
        }
        showTab(e) {
            const {tabs: t} = this;
            let n = t.get(e);
            void 0 === n && (n = this.getter(e),
            this.element.appendChild(n.element),
            t.set(e, n)),
            n.element.style.display = "",
            n.visibility.value = o.b.VISIBLE,
            this.tabVisibilityChanged.dispatch(e, !0)
        }
        updateSelectedTab() {
            const {displayedTab: e} = this
              , t = this.visible ? this.selected.value : void 0;
            t !== e && (void 0 !== e && this.hideTab(e),
            this.invalidateByDefault && this.invalidateAll(),
            this.displayedTab = t,
            void 0 !== t && this.showTab(t))
        }
        invalidateAll() {
            const {tabs: e} = this;
            for (const t of e.values())
                t.dispose();
            e.clear(),
            this.debouncedUpdateSelectedTab()
        }
        disposed() {
            this.invalidateAll(),
            Object(s.c)(this.element),
            super.disposed()
        }
    }
    class d extends c {
    }
    function h(e, t) {
        const n = "neuroglancer-selected-tab-label";
        t ? e.classList.add(n) : e.classList.remove(n)
    }
    class p extends r.a {
        constructor(e, t=new o.b(o.b.VISIBLE)) {
            super(),
            this.state = e,
            this.visibility = t,
            this.element = document.createElement("div"),
            this.tabBar = document.createElement("div"),
            this.tabLabels = new Map,
            this.tabsGeneration = -1,
            this.debouncedUpdateView = this.registerCancellable(Object(i.a)(()=>this.updateTabs()));
            const {element: n, tabBar: r} = this;
            n.className = "neuroglancer-tab-view",
            r.className = "neuroglancer-tab-view-bar",
            n.appendChild(r),
            this.registerDisposer(t.changed.add(this.debouncedUpdateView));
            const s = this.stack = this.registerDisposer(new u(e=>this.state.options.get(e).getter(),this.state,this.visibility));
            n.appendChild(s.element),
            this.registerDisposer(this.state.optionsChanged.add(this.debouncedUpdateView)),
            this.registerDisposer(this.state.changed.add(()=>this.updateTabLabelStyles())),
            this.updateTabs()
        }
        get visible() {
            return this.visibility.visible
        }
        updateTabLabelStyles() {
            const e = this.state.value;
            for (const [t,n] of this.tabLabels)
                h(n, t === e)
        }
        updateTabs() {
            this.tabsGeneration !== this.state.optionsChanged.count && (this.destroyTabs(),
            this.visible && this.makeTabs())
        }
        destroyTabs() {
            -1 !== this.tabsGeneration && (this.tabLabels.clear(),
            Object(s.b)(this.tabBar),
            this.tabsGeneration = -1,
            this.stack.invalidateAll())
        }
        makeTabs() {
            const {tabBar: e, tabLabels: t} = this
              , n = Array.from(this.state.options);
            n.sort(([,{order: e=0}],[,{order: t=0}])=>e - t);
            const i = this.state.value;
            for (const [r,{label: s}] of n) {
                const n = document.createElement("div");
                n.classList.add("neuroglancer-tab-label"),
                n.textContent = s,
                h(n, r === i),
                n.addEventListener("click", ()=>{
                    this.state.value = r
                }
                ),
                t.set(r, n),
                e.appendChild(n)
            }
            this.tabsGeneration = this.state.optionsChanged.count
        }
        disposed() {
            Object(s.b)(this.tabBar),
            this.tabLabels.clear(),
            Object(s.c)(this.element),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = Symbol("objectId");
    let r = 0;
    function s(e) {
        if (e instanceof Object) {
            let t = e[i];
            return void 0 === t && (t = e[i] = r++),
            `o${t}`
        }
        return "" + JSON.stringify(e)
    }
}
, function(e, t, n) {
    "use strict";
    function i(e, t, n) {
        const i = e.length;
        for (let r = 0; r < i; ++r)
            e[r] = t[r] + n[r];
        return e
    }
    function r(e, t, n) {
        const i = e.length;
        for (let r = 0; r < i; ++r)
            e[r] = t[r] - n[r];
        return e
    }
    function s(e, t, n, i) {
        const r = e.length;
        for (let s = 0; s < r; ++s)
            e[s] = t[s] + n[s] * i;
        return e
    }
    function a(e, t, n) {
        const i = e.length;
        for (let r = 0; r < i; ++r)
            e[r] = t[r] * n;
        return e
    }
    function o(e) {
        let t = 1;
        for (const n of e)
            t *= n;
        return t
    }
    function l(e, t, n) {
        const i = e.length;
        for (let r = 0; r < i; ++r)
            e[r] = Math.min(t[r], n[r]);
        return e
    }
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "h", (function() {
        return r
    }
    )),
    n.d(t, "g", (function() {
        return s
    }
    )),
    n.d(t, "f", (function() {
        return a
    }
    )),
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "c", (function() {
        return u
    }
    ));
    const c = new Float32Array(0)
      , u = new Float64Array(0);
    Float64Array.of(1, 1, 1)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "g", (function() {
        return f
    }
    )),
    n.d(t, "f", (function() {
        return m
    }
    )),
    n.d(t, "l", (function() {
        return v
    }
    )),
    n.d(t, "a", (function() {
        return b
    }
    )),
    n.d(t, "k", (function() {
        return y
    }
    )),
    n.d(t, "m", (function() {
        return S
    }
    )),
    n.d(t, "h", (function() {
        return w
    }
    )),
    n.d(t, "e", (function() {
        return x
    }
    )),
    n.d(t, "d", (function() {
        return C
    }
    )),
    n.d(t, "b", (function() {
        return O
    }
    )),
    n.d(t, "c", (function() {
        return k
    }
    )),
    n.d(t, "j", (function() {
        return A
    }
    )),
    n.d(t, "i", (function() {
        return I
    }
    ));
    var i = n(75)
      , r = n(38)
      , s = n(110)
      , a = (n(19),
    n(1))
      , o = (n(15),
    n(43))
      , l = n(11);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const c = a.l.create();
    function u(e, t) {
        let n = 0
          , i = e.detTransform;
        const {transform: r, size: s} = e;
        for (let e = 0; e < 3; ++e) {
            let a = 0;
            for (let n = 0; n < 3; ++n)
                a += t[4 * n + 2] * r[4 * e + n];
            const o = s[e];
            n += Math.abs(a) * o,
            i *= o
        }
        return i / n
    }
    function d(e, t, n) {
        const {curPositionInChunks: i, fixedPositionWithinChunk: s} = e
          , {nonDisplayLowerClipBound: a, nonDisplayUpperClipBound: o} = e
          , {rank: l, chunkDataSize: c} = e.source.spec;
        if (!Object(r.d)(i, t, n, e.layerRank, e.fixedLayerToChunkTransform))
            return !1;
        for (let e = 0; e < l; ++e) {
            const t = i[e];
            if (t < a[e] || t >= o[e])
                return !1;
            const n = c[e]
              , r = i[e] = Math.floor(t / n);
            s[e] = t - r * n
        }
        return !0
    }
    function h(e, t) {
        let n = t.length
          , i = 0;
        if (n > 1) {
            let r = 0;
            for (let s = 0; s < n; ++s) {
                let n = t[s];
                const {chunkLayout: a} = n;
                let o = u(a, e);
                0,
                o > r && (r = o,
                i = s)
            }
        }
        return i
    }
    const p = new s.a(a.t.create(),a.l.create(),0);
    class f extends i.a {
        constructor() {
            super(...arguments),
            this.viewportNormalInGlobalCoordinates = a.t.create(),
            this.viewportNormalInCanonicalCoordinates = a.t.create(),
            this.centerDataPosition = a.t.create(),
            this.pixelSize = 0
        }
    }
    class m extends l.b {
        constructor(e) {
            super(),
            this.projectionParameters = e,
            this.visibleLayers = new Map,
            this.visibleSourcesStale = !0,
            this.registerDisposer(e.changed.add((e,t)=>{
                (function(e, t) {
                    if (e.displayDimensionRenderInfo !== t.displayDimensionRenderInfo)
                        return !0;
                    if (e.pixelSize !== t.pixelSize)
                        return !0;
                    const {viewMatrix: n} = e
                      , {viewMatrix: i} = t;
                    for (let e = 0; e < 12; ++e)
                        if (n[e] !== i[e])
                            return !0;
                    return !1
                }
                )(e, t) && this.invalidateVisibleSources(),
                this.invalidateVisibleChunks()
            }
            ))
        }
        invalidateVisibleSources() {
            this.visibleSourcesStale = !0
        }
        invalidateVisibleChunks() {}
        getNormalizedChunkLayout(e) {
            const {finiteRank: t} = e;
            if (3 === t)
                return e;
            p.finiteRank = t,
            a.t.copy(p.size, e.size);
            const n = a.l.copy(p.transform, e.transform)
              , i = a.l.copy(p.invTransform, e.invTransform);
            p.detTransform = e.detTransform;
            const {invViewMatrix: r, width: s, height: o} = this.projectionParameters.value;
            for (let e = t; e < 3; ++e) {
                const t = r[12 + e];
                let i = t
                  , a = t;
                const l = Math.abs(r[e] * s);
                i -= l,
                a += l;
                const c = Math.abs(r[e + 4] * o);
                i -= c,
                a += c;
                const u = Math.max(1, a - i);
                n[12 + e] = i,
                n[5 * e] = u
            }
            return a.l.invert(i, n),
            p
        }
        updateVisibleSources() {
            if (!this.visibleSourcesStale)
                return;
            this.visibleSourcesStale = !1;
            const e = this.projectionParameters.value.displayDimensionRenderInfo
              , {visibleLayers: t} = this;
            for (const [n,{allSources: i, visibleSources: r, displayDimensionRenderInfo: s}] of t) {
                if (r.length = 0,
                s !== e || 0 === i.length)
                    continue;
                const t = h(this.projectionParameters.value.viewMatrix, i.map(e=>e[0]))
                  , a = i[t];
                for (const e of n.filterVisibleSources(this, a))
                    r.push(e);
                r.reverse()
            }
        }
    }
    const g = 18;
    function v(e) {
        let {rank: t, upperVoxelBound: n, maxVoxelsPerChunkLog2: i=g, chunkToViewTransform: r, displayRank: s, minBlockSize: a, maxBlockSize: l} = e;
        const {lowerVoxelBound: c=new Uint32Array(t)} = e
          , u = new Float32Array(t);
        for (let e = 0; e < t; ++e) {
            let t = 0;
            for (let n = 0; n < s; ++n) {
                const i = r[e * s + n];
                t += i * i
            }
            u[e] = Math.sqrt(t)
        }
        const d = new Uint32Array(t);
        void 0 !== a ? d.set(a) : d.fill(1);
        const h = new Array(t);
        for (let e = 0; e < t; ++e) {
            let t = Number.POSITIVE_INFINITY;
            0 === u[e] ? t = d[e] : (void 0 !== n && (t = Math.pow(2, Math.floor(Math.log2(n[e] - c[e])))),
            void 0 !== l && (t = Math.min(t, l[e]))),
            h[e] = t
        }
        function p() {
            let e = 1 / 0
              , n = -1;
            for (let i = 0; i < t; ++i) {
                if (d[i] >= h[i])
                    continue;
                let t = d[i] * u[i];
                t < e && (e = t,
                n = i)
            }
            return n
        }
        i -= Math.log2(o.e(d));
        for (let e = 0; e < i; ++e) {
            let e = p();
            if (-1 === e)
                break;
            d[e] *= 2
        }
        return d
    }
    var b;
    function y(e) {
        if (void 0 !== e.chunkDataSizes)
            return e.chunkDataSizes;
        const {chunkLayoutPreference: t=b.ISOTROPIC} = e;
        switch (t) {
        case b.ISOTROPIC:
            return [v(e)];
        case b.FLAT:
            return function(e) {
                const t = []
                  , {displayRank: n, chunkToViewTransform: i, rank: r} = e;
                if (n > 3)
                    throw new Error("Unsupported view transform");
                if (n < 3)
                    return [v(e)];
                for (let s = 0; s < 3; ++s) {
                    const a = (s + 2) % 3
                      , o = new Float32Array(i);
                    for (let e = 0; e < r; ++e)
                        o[e * n + a] = 0;
                    t[s] = v(Object.assign(Object.assign({}, e), {
                        chunkToViewTransform: o
                    }))
                }
                return t
            }(e)
        }
        throw new Error(`Invalid chunk layout preference: ${t}.`)
    }
    function S(e) {
        const {rank: t, chunkDataSize: n, upperVoxelBound: i} = e
          , {lowerVoxelBound: r=new Float32Array(t)} = e
          , s = new Float32Array(t)
          , a = new Float32Array(t);
        for (let e = 0; e < t; ++e)
            s[e] = Math.floor(r[e] / n[e]),
            a[e] = Math.floor((i[e] - 1) / n[e] + 1);
        return {
            rank: t,
            chunkDataSize: n,
            lowerChunkBound: s,
            upperChunkBound: a,
            lowerVoxelBound: r,
            upperVoxelBound: i
        }
    }
    function *w(e, t, n) {
        const i = 1.1 * e.projectionParameters.value.pixelSize
          , r = n[0].effectiveVoxelSize
          , s = t.renderScaleTarget.value
          , a = e=>{
            const t = i * s;
            for (let n = 0; n < 3; ++n) {
                const i = e[n];
                if (i > t && i > 1.01 * r[n])
                    return !0
            }
            return !1
        }
          , o = (e,t)=>{
            const n = i * s;
            for (let i = 0; i < 3; ++i) {
                const r = e[i]
                  , s = t[i];
                if (Math.abs(n - r) < Math.abs(n - s) && r < 1.01 * s)
                    return !0
            }
            return !1
        }
        ;
        let l, c = n.length - 1;
        for (; ; ) {
            const e = n[c];
            if (void 0 !== l && !o(e.effectiveVoxelSize, l))
                break;
            if (yield e,
            0 === c || !a(e.effectiveVoxelSize))
                break;
            l = e.effectiveVoxelSize,
            --c
        }
    }
    !function(e) {
        e[e.ISOTROPIC = 0] = "ISOTROPIC",
        e[e.FLAT = 1] = "FLAT"
    }(b || (b = {}));
    const x = "SliceView"
      , C = "sliceview/RenderLayer"
      , O = "SliceView.addVisibleLayer"
      , k = "SliceView.removeVisibleLayer"
      , E = new Float32Array(3)
      , T = new Float32Array(3)
      , M = a.l.create()
      , D = new Float32Array(24);
    function L(e, t, n, i) {
        const r = E
          , s = T
          , {lowerChunkDisplayBound: a, upperChunkDisplayBound: o} = t;
        for (let e = 0; e < 3; ++e)
            r[e] = Math.max(r[e], a[e]),
            s[e] = Math.min(s[e], o[e]);
        const {curPositionInChunks: l, chunkDisplayDimensionIndices: c} = t;
        !function t() {
            if (!i(r[0], r[1], r[2], s[0], s[1], s[2], e))
                return;
            let a = 0
              , o = Math.max(0, s[0] - r[0])
              , u = o;
            for (let e = 1; e < 3; ++e) {
                const t = Math.max(0, s[e] - r[e]);
                u *= t,
                t > o && (o = t,
                a = e)
            }
            if (0 === u)
                return;
            if (1 === u)
                return l[c[0]] = r[0],
                l[c[1]] = r[1],
                l[c[2]] = r[2],
                void n(r);
            const d = r[a]
              , h = s[a]
              , p = Math.floor(.5 * (d + h));
            s[a] = p,
            t(),
            s[a] = h,
            r[a] = p,
            t(),
            r[a] = d
        }()
    }
    function A(e, t, n, i) {
        if (!d(n, e.globalPosition, t))
            return;
        const {size: r} = n.chunkLayout
          , s = a.l.multiply(M, e.viewProjectionMat, n.chunkLayout.transform);
        for (let e = 0; e < 3; ++e) {
            const t = r[e];
            for (let n = 0; n < 4; ++n)
                s[4 * e + n] *= t
        }
        const o = D;
        Object(a.c)(o, s);
        const l = T;
        E.fill(Number.NEGATIVE_INFINITY),
        l.fill(Number.POSITIVE_INFINITY),
        L(o, n, i, a.g)
    }
    function I(e, t, n, i) {
        if (!d(n, e.globalPosition, t))
            return;
        const {size: r} = n.chunkLayout
          , s = a.l.multiply(M, e.viewProjectionMat, n.chunkLayout.transform);
        for (let e = 0; e < 3; ++e) {
            const t = r[e];
            for (let n = 0; n < 4; ++n)
                s[4 * e + n] *= t
        }
        const o = c;
        a.l.invert(o, s);
        const l = E
          , u = T;
        for (let e = 0; e < 3; ++e) {
            const t = o[12 + e]
              , n = Math.abs(o[e])
              , i = Math.abs(o[4 + e]);
            l[e] = Math.floor(t - n - i),
            u[e] = Math.floor(t + n + i + 1)
        }
        const h = D;
        for (let e = 0; e < 3; ++e) {
            const t = s[4 * e]
              , n = s[4 * e + 1]
              , i = s[4 * e + 2];
            h[e] = t,
            h[4 + e] = -t,
            h[8 + e] = +n,
            h[12 + e] = -n,
            h[16 + e] = +i,
            h[20 + e] = -i
        }
        {
            const e = 3
              , t = s[4 * e]
              , n = s[4 * e + 1]
              , i = s[4 * e + 2];
            h[e] = 1 + t,
            h[4 + e] = 1 - t,
            h[8 + e] = 1 + n,
            h[12 + e] = 1 - n,
            h[16 + e] = i,
            h[20 + e] = -i
        }
        L(h, n, i, a.f)
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        return `${e.low},${e.high}`
    }
    function r(e, t) {
        let {visibleSegments: n, segmentEquivalences: i} = e;
        for (let e of n)
            if (i.disjointSets.isMinElement(e))
                for (let n of i.setElements(e))
                    t(n, e)
    }
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    )),
    n.d(t, "d", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return f
    }
    )),
    n.d(t, "f", (function() {
        return m
    }
    )),
    n.d(t, "b", (function() {
        return y
    }
    )),
    n.d(t, "c", (function() {
        return S
    }
    ));
    var i = n(2)
      , r = n(1)
      , s = n(42)
      , a = n(66)
      , o = n(90)
      , l = n(107);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class c extends i.a {
        constructor() {
            super(...arguments),
            this.width = Number.NaN,
            this.height = Number.NaN
        }
        hasSize(e, t) {
            return this.width === e && this.height === t
        }
        resize(e, t) {
            this.hasSize(e, t) || (this.width = e,
            this.height = t,
            this.performResize())
        }
    }
    class u extends c {
        constructor(e, t) {
            super(),
            this.gl = e,
            this.internalformat = t,
            this.renderbuffer = null,
            this.renderbuffer = e.createRenderbuffer()
        }
        performResize() {
            let {gl: e} = this;
            e.bindRenderbuffer(e.RENDERBUFFER, this.renderbuffer),
            e.renderbufferStorage(e.RENDERBUFFER, this.internalformat, this.width, this.height),
            e.bindRenderbuffer(e.RENDERBUFFER, null)
        }
        disposed() {
            this.gl.deleteRenderbuffer(this.renderbuffer)
        }
        attachToFramebuffer(e) {
            let {gl: t} = this;
            t.framebufferRenderbuffer(t.FRAMEBUFFER, e, t.RENDERBUFFER, this.renderbuffer)
        }
    }
    class d extends u {
        constructor(e, t=!1) {
            super(e, t ? e.DEPTH_STENCIL : e.DEPTH_COMPONENT16),
            this.gl = e,
            this.includeStencilBuffer = t
        }
        attachToFramebuffer() {
            let {gl: e} = this;
            super.attachToFramebuffer(this.includeStencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT)
        }
    }
    const h = class extends d {
        constructor(e) {
            super(e, !0)
        }
    }
    ;
    class p extends i.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.framebuffer = this.gl.createFramebuffer()
        }
        disposed() {
            let {gl: e} = this;
            e.deleteFramebuffer(this.framebuffer)
        }
        bind() {
            let {gl: e} = this;
            e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer)
        }
        unbind() {
            let {gl: e} = this;
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }
    }
    class f extends c {
        constructor(e, t, n, i) {
            super(),
            this.gl = e,
            this.internalFormat = t,
            this.format = n,
            this.dataType = i,
            this.texture = e.createTexture()
        }
        performResize() {
            Object(o.a)(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType)
        }
        disposed() {
            this.gl.deleteTexture(this.texture)
        }
        attachToFramebuffer(e) {
            let {gl: t} = this;
            t.framebufferTexture2D(t.FRAMEBUFFER, e, t.TEXTURE_2D, this.texture, 0)
        }
    }
    function m(e, t, n=WebGL2RenderingContext.RGBA8, i=WebGL2RenderingContext.RGBA, r=WebGL2RenderingContext.UNSIGNED_BYTE) {
        let s = new Array;
        for (let a = 0; a < t; ++a)
            s[a] = new f(e,n,i,r);
        return s
    }
    const g = new Uint8Array(4)
      , v = new Uint32Array(1)
      , b = new Float32Array(4);
    class y extends i.a {
        constructor(e, t) {
            super(),
            this.gl = e,
            this.width = Number.NaN,
            this.height = Number.NaN,
            this.fullAttachmentList = new Array,
            this.attachmentVerified = !1,
            this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
            let {framebuffer: n=new p(e), colorBuffers: i, depthBuffer: r} = t;
            this.framebuffer = this.registerDisposer(n),
            this.colorBuffers = i,
            this.depthBuffer = r,
            void 0 !== r && this.registerDisposer(r);
            let {fullAttachmentList: s} = this;
            i.forEach((t,n)=>{
                this.registerDisposer(t),
                s[n] = e.COLOR_ATTACHMENT0 + n
            }
            )
        }
        hasSize(e, t) {
            return this.width === e && this.height === t
        }
        bind(e, t) {
            this.width = e,
            this.height = t,
            this.framebuffer.bind();
            let {gl: n, depthBuffer: i} = this;
            void 0 !== i && (i.resize(e, t),
            i.attachToFramebuffer()),
            this.colorBuffers.forEach((i,r)=>{
                i.resize(e, t),
                i.attachToFramebuffer(n.COLOR_ATTACHMENT0 + r)
            }
            ),
            n.drawBuffers(this.fullAttachmentList),
            this.verifyAttachment(),
            n.viewport(0, 0, e, t)
        }
        bindSingle(e) {
            let {gl: t} = this;
            this.framebuffer.bind(),
            0 !== e && t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0),
            t.bindTexture(t.TEXTURE_2D, null),
            this.colorBuffers[e].attachToFramebuffer(t.COLOR_ATTACHMENT0),
            t.drawBuffers(this.singleAttachmentList)
        }
        unbind() {
            this.framebuffer.unbind()
        }
        readPixel(e, t, n) {
            let {gl: i} = this;
            try {
                this.bindSingle(e),
                i.readPixels(t, n, 1, 1, i.RGBA, i.UNSIGNED_BYTE, g)
            } finally {
                this.framebuffer.unbind()
            }
            return g
        }
        readPixelUint32(e, t, n) {
            let {gl: i} = this;
            try {
                this.bindSingle(e),
                i.readPixels(t, n, 1, 1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.UNSIGNED_INT, v)
            } finally {
                this.framebuffer.unbind()
            }
            return v[0]
        }
        readPixelFloat32(e, t, n) {
            let {gl: i} = this;
            try {
                this.bindSingle(e),
                i.readPixels(t, n, 1, 1, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, b)
            } finally {
                this.framebuffer.unbind()
            }
            return b[0]
        }
        readPixelFloat32IntoBuffer(e, t, n, i, r=1, s=1) {
            let {gl: a} = this;
            try {
                this.bindSingle(e),
                a.readPixels(t, n, r, s, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, i)
            } finally {
                this.framebuffer.unbind()
            }
        }
        verifyAttachment() {
            if (this.attachmentVerified)
                return;
            let {gl: e} = this
              , t = e.checkFramebufferStatus(e.FRAMEBUFFER);
            if (t !== e.FRAMEBUFFER_COMPLETE)
                throw new Error(`Framebuffer configuration not supported: ${t}`);
            this.attachmentVerified = !0
        }
    }
    class S extends i.a {
        constructor(e, t) {
            super(),
            this.gl = e,
            this.shader = t,
            this.copyVertexPositionsBuffer = Object(a.a)(this.gl),
            this.copyTexCoordsBuffer = Object(a.a)(this.gl, 0, 0, 1, 1),
            this.registerDisposer(t)
        }
        draw(...e) {
            let {gl: t, shader: n} = this;
            n.bind();
            let i = e.length;
            for (let n = 0; n < i; ++n)
                t.activeTexture(t.TEXTURE0 + n),
                t.bindTexture(t.TEXTURE_2D, e[n]);
            t.uniformMatrix4fv(n.uniform("uProjectionMatrix"), !1, r.e);
            let s = n.attribute("aVertexPosition");
            this.copyVertexPositionsBuffer.bindToVertexAttrib(s, 2);
            let a = n.attribute("aTexCoord");
            this.copyTexCoordsBuffer.bindToVertexAttrib(a, 2),
            t.drawArrays(t.TRIANGLE_FAN, 0, 4),
            t.disableVertexAttribArray(s),
            t.disableVertexAttribArray(a);
            for (let e = 0; e < i; ++e)
                t.activeTexture(t.TEXTURE0 + e),
                t.bindTexture(t.TEXTURE_2D, null)
        }
        static get(e, t=l.a, n=1) {
            return e.memoize.get(`OffscreenCopyHelper:${n}:${Object(s.a)(t)}`, ()=>new S(e,Object(l.b)(e, t, n)))
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    ));
    var i = n(8)
      , r = n(2)
      , s = n(34)
      , a = n(40);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function o(e, t) {
        return {
            defineShader(n, i) {
                const r = `prop_${i}`
                  , s = `a_${r}`;
                n.addAttribute(`${e}`, s),
                n.addVertexCode(`${e} ${r}() { return ${s}; }`),
                n.addInitializer(e=>{
                    const n = e.attribute(s)
                      , {gl: i} = e;
                    e.vertexShaderInputBinders[r] = -1 === n ? {
                        enable() {},
                        disable() {},
                        bind() {}
                    } : {
                        enable(e) {
                            i.enableVertexAttribArray(n),
                            i.vertexAttribDivisor(n, e)
                        },
                        disable() {
                            i.vertexAttribDivisor(n, 0),
                            i.disableVertexAttribArray(n)
                        },
                        bind(e, r) {
                            t(i, n, e, r)
                        }
                    }
                }
                )
            }
        }
    }
    function l(e, t, n, i) {
        return o(e, (e,r,s,a)=>{
            e.vertexAttribPointer(r, t, n, i, s, a)
        }
        )
    }
    function c(e, t, n) {
        return o(e, (e,i,r,s)=>{
            e.vertexAttribIPointer(i, t, n, r, s)
        }
        )
    }
    const u = {
        rgb: l("highp vec3", 3, WebGL2RenderingContext.UNSIGNED_BYTE, !0),
        rgba: l("highp vec4", 4, WebGL2RenderingContext.UNSIGNED_BYTE, !0),
        float32: l("highp float", 1, WebGL2RenderingContext.FLOAT, !1),
        uint32: c("highp uint", 1, WebGL2RenderingContext.UNSIGNED_INT),
        int32: c("highp int", 1, WebGL2RenderingContext.INT),
        uint16: c("highp uint", 1, WebGL2RenderingContext.UNSIGNED_SHORT),
        int16: c("highp int", 1, WebGL2RenderingContext.SHORT),
        uint8: c("highp uint", 1, WebGL2RenderingContext.UNSIGNED_BYTE),
        int8: c("highp int", 1, WebGL2RenderingContext.BYTE)
    };
    class d extends r.a {
        constructor(e, t, n, r, s, a, o) {
            super(),
            this.gl = e,
            this.annotationType = t,
            this.rank = n,
            this.properties = r,
            this.shaderControlState = s,
            this.fallbackShaderParameters = a,
            this.shaderError = o;
            const l = this.serializedGeometryBytesPerAnnotation = Object(i.k)(t).serializedBytes(n)
              , {offsets: c, serializedBytes: u} = Object(i.l)(n, r);
            this.serializedBytesPerAnnotation = u + l,
            this.propertyOffsets = c
        }
        getDependentShader(e, t) {
            return Object(s.d)(this, this.gl, {
                memoizeKey: {
                    t: "annotation",
                    targetIsSliceView: this.targetIsSliceView,
                    type: this.annotationType,
                    subType: e,
                    properties: this.properties
                },
                fallbackParameters: this.fallbackShaderParameters,
                parameters: this.shaderControlState.parseResult,
                shaderError: this.shaderError,
                defineShader: (e,n)=>{
                    const {rank: i, properties: r} = this;
                    for (const t of r) {
                        u[t.type].defineShader(e, t.identifier, i)
                    }
                    const {propertyOffsets: o} = this;
                    e.addInitializer(e=>{
                        const t = this.properties.map(t=>e.vertexShaderInputBinders[`prop_${t.identifier}`])
                          , n = t.length;
                        e.vertexShaderInputBinders.properties = {
                            enable(e) {
                                for (let i = 0; i < n; ++i)
                                    t[i].enable(e)
                            },
                            bind(e, i) {
                                for (let r = 0; r < n; ++r)
                                    t[r].bind(e, i + o[r])
                            },
                            disable() {
                                for (let e = 0; e < n; ++e)
                                    t[e].disable()
                            }
                        }
                    }
                    ),
                    e.addUniform("highp vec3", "uColor"),
                    e.addUniform("highp uint", "uSelectedIndex"),
                    e.addVarying("highp vec4", "vColor"),
                    e.addUniform("highp vec3", "uSubspaceMatrix", i),
                    e.addUniform("highp mat4", "uModelViewProjection"),
                    e.addUniform("highp float", "uModelClipBounds", 2 * i),
                    e.addUniform("highp uint", "uPickID"),
                    e.addVarying("highp uint", "vPickID", "flat"),
                    e.addVertexCode(`\nvec3 defaultColor() { return uColor; }\nhighp uint getPickBaseOffset() { return uint(gl_InstanceID) * ${this.pickIdsPerInstance}u; }\n`),
                    e.addFragmentCode("\nvoid emitAnnotation(vec4 color) {\n  emit(color, vPickID);\n}\n");
                    const l = `\nfloat getSubspaceClipCoefficient(float modelPoint[${this.rank}]) {\n  float coefficient = 1.0;\n  for (int i = 0; i < ${i}; ++i) {\n    float d = abs(modelPoint[i] - uModelClipBounds[i]) * uModelClipBounds[${i} + i];\n    coefficient *= max(0.0, 1.0 - d);\n  }\n  return coefficient;\n}\n`;
                    e.addVertexCode(l),
                    e.addFragmentCode(l),
                    e.addVertexCode(`\nvec3 projectModelVectorToSubspace(float modelPoint[${this.rank}]) {\n  vec3 result = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < ${i}; ++i) {\n    result += uSubspaceMatrix[i] * modelPoint[i];\n  }\n  return result;\n}\n\nfloat getMaxEndpointSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {\n  float coefficient = 1.0;\n  for (int i = 0; i < ${i}; ++i) {\n    float dA = abs(modelPointA[i] - uModelClipBounds[i]) * uModelClipBounds[${i} + i];\n    float dB = abs(modelPointB[i] - uModelClipBounds[i]) * uModelClipBounds[${i} + i];\n    coefficient *= max(0.0, 1.0 - min(dA, dB));\n  }\n  return coefficient;\n}\n\nfloat getMaxSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {\n  float coefficient = 1.0;\n  for (int i = 0; i < ${i}; ++i) {\n    float a = modelPointA[i];\n    float b = modelPointB[i];\n    float c = uModelClipBounds[i];\n    float x = clamp(c, min(a, b), max(a, b));\n    float d = abs(x - c) * uModelClipBounds[${i} + i];\n    coefficient *= max(0.0, 1.0 - d);\n  }\n  return coefficient;\n}\n\n`),
                    Object(a.b)(n.controls, e),
                    e.addVertexCode(`\nconst bool PROJECTION_VIEW = ${!this.targetIsSliceView};\nbool ng_discardValue;\n#define discard ng_discard()\nvoid ng_discard() {\n  ng_discardValue = true;\n}\nvoid setLineColor(vec4 startColor, vec4 endColor);\nvoid setLineWidth(float width);\n\nvoid setEndpointMarkerColor(vec4 startColor, vec4 endColor);\nvoid setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);\nvoid setEndpointMarkerSize(float startSize, float endSize);\nvoid setEndpointMarkerBorderWidth(float startSize, float endSize);\n\nvoid setPointMarkerColor(vec4 color);\nvoid setPointMarkerBorderColor(vec4 color);\nvoid setPointMarkerSize(float size);\nvoid setPointMarkerBorderWidth(float size);\n\nvoid setEllipsoidFillColor(vec4 color);\n\nvoid setBoundingBoxBorderColor(vec4 color);\nvoid setBoundingBoxBorderWidth(float size);\nvoid setBoundingBoxFillColor(vec4 color);\n\nvoid setEndpointMarkerColor(vec3 startColor, vec3 endColor) {\n  setEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));\n}\nvoid setEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {\n  setEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));\n}\nvoid setEndpointMarkerColor(vec3 color) { setEndpointMarkerColor(color, color); }\nvoid setEndpointMarkerColor(vec4 color) { setEndpointMarkerColor(color, color); }\nvoid setEndpointMarkerBorderColor(vec3 color) { setEndpointMarkerBorderColor(color, color); }\nvoid setEndpointMarkerBorderColor(vec4 color) { setEndpointMarkerBorderColor(color, color); }\nvoid setEndpointMarkerSize(float size) { setEndpointMarkerSize(size, size); }\nvoid setEndpointMarkerBorderWidth(float size) { setEndpointMarkerBorderWidth(size, size); }\nvoid setLineColor(vec4 color) { setLineColor(color, color); }\nvoid setLineColor(vec3 color) { setLineColor(vec4(color, 1.0)); }\nvoid setLineColor(vec3 startColor, vec3 endColor) { setLineColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }\nvoid setColor(vec4 color) {\n  setPointMarkerColor(color);\n  setLineColor(color);\n  setEndpointMarkerColor(color);\n  setBoundingBoxBorderColor(color);\n  setEllipsoidFillColor(vec4(color.rgb, color.a * (PROJECTION_VIEW ? 1.0 : 0.5)));\n}\nvoid setEllipsoidFillColor(vec3 color) { setEllipsoidFillColor(vec4(color, 1.0)); }\n\nvoid setBoundingBoxFillColor(vec3 color) { setBoundingBoxFillColor(vec4(color, 1.0)); }\nvoid setBoundingBoxBorderColor(vec3 color) { setBoundingBoxBorderColor(vec4(color, 1.0)); }\n\nvoid setColor(vec3 color) { setColor(vec4(color, 1.0)); }\nvoid userMain();\n`);
                    for (const [t,n] of h)
                        t !== this.annotationType && n.defineShaderNoOpSetters(e);
                    t(e),
                    e.addVertexCode("\n#define main userMain\n" + Object(s.e)(n.code) + "\n#undef main\n")
                }
            })
        }
        setPartIndex(e, ...t) {
            let n = `\nvoid setPartIndex(${t.map((e,t)=>`highp uint partIndex${t}`).join()}) {\n  highp uint pickID = uPickID;\n  highp uint pickBaseOffset = getPickBaseOffset();\n${t.map((e,t)=>`highp uint pickOffset${t} = pickBaseOffset + partIndex${t};`).join("\n")}\n`;
            return 0 === t.length && (n += "\n  highp uint pickOffset0 = pickBaseOffset;\n"),
            n += `\n  vPickID = pickID + pickOffset0;\n  highp uint selectedIndex = uSelectedIndex;\nif (selectedIndex == pickBaseOffset${t.map((e,t)=>` || selectedIndex == pickOffset${t}`).join("")}) {\n    vColor = vec4(mix(vColor.rgb, vec3(1.0, 1.0, 1.0), 0.75), vColor.a);\n  }\n}\n`,
            e.addVertexCode(n),
            `setPartIndex(${t.join()})`
        }
        get invokeUserMain() {
            return "\nng_discardValue = false;\nuserMain();\nif (ng_discardValue) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\n"
        }
        getCrossSectionFadeFactor() {
            return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)"
        }
        enable(e, t, n) {
            const {shader: i, parameters: r} = e(t.renderContext.emitter);
            if (null === i)
                return;
            i.bind();
            const {gl: s} = this
              , {renderContext: o} = t
              , {annotationLayer: l} = t;
            if (Object(a.d)(s, i, this.shaderControlState, r.controls),
            s.uniform3fv(i.uniform("uSubspaceMatrix"), t.subspaceMatrix),
            s.uniform1fv(i.uniform("uModelClipBounds"), t.modelClipBounds),
            s.uniformMatrix4fv(i.uniform("uModelViewProjection"), !1, t.modelViewProjectionMatrix),
            o.emitPickID && s.uniform1ui(i.uniform("uPickID"), t.basePickId),
            o.emitColor) {
                const e = l.state.displayState.color.value;
                s.uniform3f(i.uniform("uColor"), e[0], e[1], e[2]),
                s.uniform1ui(i.uniform("uSelectedIndex"), t.selectedIndex)
            }
            const c = i.vertexShaderInputBinders.properties;
            c.enable(1),
            s.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer),
            c.bind(this.serializedBytesPerAnnotation, t.bufferOffset + this.serializedGeometryBytesPerAnnotation),
            n(i),
            c.disable()
        }
    }
    const h = new Map;
    function p(e, t) {
        h.set(e, t)
    }
    function f(e) {
        return h.get(e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i, r = n(3);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    !function(e) {
        e[e.info = 0] = "info",
        e[e.warning = 1] = "warning",
        e[e.error = 2] = "error"
    }(i || (i = {}));
    class s {
        constructor() {
            this.changed = new r.a,
            this.messages = [],
            this.children = []
        }
        addMessage(e) {
            this.messages.push(e),
            this.changed.dispatch()
        }
        clearMessages() {
            const {messages: e} = this;
            0 !== e.length && (e.length = 0,
            this.changed.dispatch())
        }
        isEmpty() {
            return 0 === this.messages.length && !this.children.some(e=>!e.isEmpty())
        }
        addChild(e) {
            return this.children.push(e),
            e.changed.add(this.changed.dispatch),
            e.isEmpty() || this.changed.dispatch(),
            ()=>{
                const {children: t} = this;
                t.splice(t.indexOf(e), 1),
                e.changed.remove(this.changed.dispatch),
                e.isEmpty() || this.changed.dispatch()
            }
        }
        *[Symbol.iterator]() {
            yield*this.messages;
            for (const e of this.children)
                yield*e
        }
    }
}
, function(e, t, n) {
    "use strict";
    var i = n(10)
      , r = n(14)
      , s = n(63)
      , a = n(1);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function o(e, t, n, i, r, s, o) {
        const {octree: l, lodScales: c, chunkGridSpatialOrigin: u, chunkShape: d} = e
          , h = c.length - 1
          , p = t[0]
          , f = t[4]
          , m = t[8]
          , g = t[1]
          , v = t[5]
          , b = t[9]
          , y = t[3]
          , S = t[7]
          , w = t[11]
          , x = t[15]
          , C = y > 0 ? 0 : 1
          , O = S > 0 ? 0 : 1
          , k = w > 0 ? 0 : 1
          , E = n[16]
          , T = n[17]
          , M = n[18]
          , D = n[19];
        function L(e, t, n) {
            return y * e + S * t + w * n + x
        }
        const A = L(-D * E, -D * T, -D * M)
          , I = e.clipLowerBound[0]
          , P = e.clipLowerBound[1]
          , R = e.clipLowerBound[2]
          , j = e.clipUpperBound[0]
          , N = e.clipUpperBound[1]
          , V = e.clipUpperBound[2]
          , B = Math.sqrt((p * r) ** 2 + (g * s) ** 2)
          , F = Math.sqrt((f * r) ** 2 + (v * s) ** 2)
          , _ = Math.sqrt((m * r) ** 2 + (b * s) ** 2)
          , U = Math.max(B, F, _);
        !function e(t, r, s) {
            const h = 1 << t
              , p = 5 * r
              , f = l[p]
              , m = l[p + 1]
              , g = l[p + 2]
              , v = l[p + 3]
              , b = l[p + 4];
            let y = f * h * d[0] + u[0]
              , S = m * h * d[1] + u[1]
              , w = g * h * d[2] + u[2]
              , x = y + h * d[0]
              , E = S + h * d[1]
              , T = w + h * d[2];
            if (y = Math.max(y, I),
            S = Math.max(S, P),
            w = Math.max(w, R),
            x = Math.min(x, j),
            E = Math.min(E, N),
            T = Math.min(T, V),
            Object(a.g)(y, S, w, x, E, T, n)) {
                const n = Math.max(A, function(e, t, n, i, r, s) {
                    return L(e + C * (i - e), t + O * (r - t), n + k * (s - n))
                }(y, S, w, x, E, T)) / U;
                if (0 === s || n * i < s) {
                    const a = c[t];
                    if (0 !== a && o(t, r, a / n, b >>> 31),
                    t > 0 && (0 === a || n * i < a)) {
                        const n = 0 === a ? s : a
                          , i = (2147483647 & b) >>> 0;
                        for (let r = v; r < i; ++r)
                            e(t - 1, r, n)
                    }
                }
            }
        }(h, l.length / 5 - 1, 0)
    }
    function l(e, t, n, i, r, s, a, l) {
        const {lodScales: c} = e;
        let u = 0;
        for (; u + 1 < c.length && 0 !== c[u + 1]; )
            ++u;
        const d = [];
        let h = 0
          , p = 0;
        function f(e, t) {
            for (; ; ) {
                if (0 === h)
                    return;
                const n = h - 1
                  , i = u - n
                  , r = d[3 * n]
                  , s = 0 === i ? 1 : 8
                  , a = d[3 * n + 1]
                  , o = d[3 * n + 2];
                if (e === h) {
                    const e = t & s - 1;
                    return p !== e && -1 !== r && l(i, r, p, e, o),
                    void (p = e + 1)
                }
                p !== s && -1 !== r && l(i, r, p, s, o),
                p = a + 1,
                --h
            }
        }
        let m = 0;
        const {octree: g} = e;
        o(e, t, n, i, r, s, (e,t,n,i)=>{
            if (!i && !a(e, t, n))
                return void (m = Math.max(e, m));
            if (e < m)
                return;
            m = 0;
            const r = 5 * t
              , s = /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            function(e, t, n) {
                return 1 & e | t << 1 & 2 | n << 2 & 4
            }(g[r], g[r + 1], g[r + 2])
              , o = u - e;
            f(o, s);
            const l = 3 * o;
            d[l] = i ? -1 : t,
            d[l + 1] = s,
            d[l + 2] = n,
            p = 0,
            h = o + 1
        }
        ),
        f(0, 0)
    }
    function c(e, t, n) {
        return `${e}/${t}:${n}`
    }
    var u = n(67)
      , d = n(31)
      , h = n(45)
      , p = n(53)
      , f = n(42)
      , m = n(25)
      , g = n(60)
      , v = n(11);
    n.d(t, "a", (function() {
        return E
    }
    )),
    n.d(t, "b", (function() {
        return D
    }
    )),
    n.d(t, "c", (function() {
        return I
    }
    )),
    n.d(t, "d", (function() {
        return j
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var b = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    };
    const y = a.l.create()
      , S = a.j.create();
    function w(e, t) {
        t.vertexBuffer = m.a.fromData(e, t.meshData.vertexPositions, e.ARRAY_BUFFER, e.STATIC_DRAW),
        t.indexBuffer = m.a.fromData(e, t.meshData.indices, e.ELEMENT_ARRAY_BUFFER, e.STATIC_DRAW),
        t.normalBuffer = m.a.fromData(e, t.meshData.vertexNormals, e.ARRAY_BUFFER, e.STATIC_DRAW)
    }
    function x(e) {
        e.vertexBuffer.dispose(),
        e.indexBuffer.dispose(),
        e.normalBuffer.dispose()
    }
    function C(e) {
        return {
            defineShader: e=>{
                e.addAttribute("highp vec3", "aVertexPosition"),
                e.addVertexCode("highp vec3 getVertexPosition() { return aVertexPosition; }")
            }
            ,
            bind(t, n, i) {
                i.vertexBuffer.bindToVertexAttrib(n.attribute("aVertexPosition"), 3, e, !0)
            },
            endLayer: (e,t)=>{
                e.disableVertexAttribArray(t.attribute("aVertexPosition"))
            }
        }
    }
    const O = {
        [s.e.float32]: C(WebGL2RenderingContext.FLOAT),
        [s.e.uint16]: C(WebGL2RenderingContext.UNSIGNED_SHORT),
        [s.e.uint10]: {
            defineShader: e=>{
                e.addAttribute("highp uint", "aVertexPosition"),
                e.addVertexCode("\nhighp vec3 getVertexPosition() {\n  return vec3(float(aVertexPosition & 1023u),\n              float((aVertexPosition >> 10) & 1023u),\n              float((aVertexPosition >> 20) & 1023u)) / 1023.0;\n}\n")
            }
            ,
            bind(e, t, n) {
                n.vertexBuffer.bindToVertexAttribI(t.attribute("aVertexPosition"), 1, WebGL2RenderingContext.UNSIGNED_INT)
            },
            endLayer: (e,t)=>{
                e.disableVertexAttribArray(t.attribute("aVertexPosition"))
            }
        }
    };
    class k {
        constructor(e, t) {
            this.fragmentRelativeVertices = e,
            this.vertexPositionFormat = t,
            this.tempLightVec = new Float32Array(4),
            this.vertexPositionHandler = O[this.vertexPositionFormat]
        }
        defineShader(e) {
            this.vertexPositionHandler.defineShader(e),
            e.addAttribute("highp vec2", "aVertexNormal"),
            e.addVarying("highp vec4", "vColor"),
            e.addUniform("highp vec4", "uLightDirection"),
            e.addUniform("highp vec4", "uColor"),
            e.addUniform("highp mat3", "uNormalMatrix"),
            e.addUniform("highp mat4", "uModelViewProjection"),
            e.addUniform("highp uint", "uPickID"),
            this.fragmentRelativeVertices && (e.addUniform("highp vec3", "uFragmentOrigin"),
            e.addUniform("highp vec3", "uFragmentShape")),
            e.addVertexCode("\nhighp vec3 decodeNormalOctahedronSnorm8(highp vec2 e) {\n  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n  if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * vec2(v.x > 0.0 ? 1.0 : -1.0, v.y > 0.0 ? 1.0 : -1.0);\n  return normalize(v);\n}\n");
            let t = "";
            this.fragmentRelativeVertices ? t += "\nhighp vec3 vertexPosition = uFragmentOrigin + uFragmentShape * getVertexPosition();\nhighp vec3 normalMultiplier = 1.0 / uFragmentShape;\n" : t += "\nhighp vec3 vertexPosition = getVertexPosition();\nhighp vec3 normalMultiplier = vec3(1.0, 1.0, 1.0);\n",
            t += "\ngl_Position = uModelViewProjection * vec4(vertexPosition, 1.0);\nvec3 origNormal = decodeNormalOctahedronSnorm8(aVertexNormal);\nvec3 normal = normalize(uNormalMatrix * (normalMultiplier * origNormal));\nfloat lightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;\nvColor = vec4(lightingFactor * uColor.rgb, uColor.a);\n",
            e.setVertexMain(t),
            e.setFragmentMain("emit(vColor, uPickID);")
        }
        beginLayer(e, t, n) {
            let {lightDirection: i, ambientLighting: r, directionalLighting: s} = n
              , o = this.tempLightVec;
            a.t.scale(o, i, s),
            o[3] = r,
            e.uniform4fv(t.uniform("uLightDirection"), o)
        }
        setColor(e, t, n) {
            e.uniform4fv(t.uniform("uColor"), n)
        }
        setPickID(e, t, n) {
            e.uniform1ui(t.uniform("uPickID"), n)
        }
        beginModel(e, t, n, i) {
            const {projectionParameters: r} = n;
            e.uniformMatrix4fv(t.uniform("uModelViewProjection"), !1, a.l.multiply(y, r.viewProjectionMat, i)),
            Object(a.k)(S, i),
            Object(a.p)(S, S, r.displayDimensionRenderInfo.canonicalVoxelFactors),
            a.j.invert(S, S),
            a.j.transpose(S, S),
            e.uniformMatrix3fv(t.uniform("uNormalMatrix"), !1, S)
        }
        getShader(e, t) {
            return e.memoize.get(`mesh/MeshShaderManager:${Object(f.a)(t)}/` + `${this.fragmentRelativeVertices}/${this.vertexPositionFormat}`, ()=>{
                let n = new g.a(e);
                return n.require(t),
                this.defineShader(n),
                n.build()
            }
            )
        }
        drawFragmentHelper(e, t, n, i, r) {
            this.vertexPositionHandler.bind(e, t, n);
            const {meshData: s} = n;
            n.normalBuffer.bindToVertexAttrib(t.attribute("aVertexNormal"), 2, WebGL2RenderingContext.BYTE, !0),
            n.indexBuffer.bind();
            const {indices: a} = s;
            e.drawElements(s.strips ? WebGL2RenderingContext.TRIANGLE_STRIP : WebGL2RenderingContext.TRIANGLES, r - i, 2 === a.BYTES_PER_ELEMENT ? WebGL2RenderingContext.UNSIGNED_SHORT : WebGL2RenderingContext.UNSIGNED_INT, i * a.BYTES_PER_ELEMENT)
        }
        drawFragment(e, t, n) {
            const {meshData: i} = n
              , {indices: r} = i;
            this.drawFragmentHelper(e, t, n, 0, r.length)
        }
        drawMultiscaleFragment(e, t, n, i, r) {
            const s = n.meshData.subChunkOffsets[i]
              , a = n.meshData.subChunkOffsets[r];
            this.drawFragmentHelper(e, t, n, s, a)
        }
        endLayer(e, t) {
            this.vertexPositionHandler.endLayer(e, t),
            e.disableVertexAttribArray(t.attribute("aVertexNormal"))
        }
    }
    class E extends u.a {
        constructor(e, t, n) {
            super(),
            this.chunkManager = e,
            this.source = t,
            this.displayState = n,
            this.meshShaderManager = new k(!1,s.e.float32),
            this.shaders = new Map,
            Object(p.e)(n, this);
            let i = this.backend = this.registerDisposer(new p.b(e,n));
            i.RPC_TYPE_ID = s.b,
            i.initializeCounterpartWithChunkManager({
                source: t.addCounterpartRef()
            }),
            i.visibility.add(this.visibility),
            this.registerDisposer(n.renderScaleHistogram.visibility.add(this.visibility))
        }
        getShader(e) {
            let {shaders: t} = this
              , n = t.get(e);
            return void 0 === n && (n = this.registerDisposer(this.meshShaderManager.getShader(this.gl, e)),
            t.set(e, n)),
            n
        }
        get isTransparent() {
            return this.displayState.objectAlpha.value < 1
        }
        get gl() {
            return this.chunkManager.chunkQueueManager.gl
        }
        draw(e, t) {
            if (!e.emitColor && e.alreadyEmittedPickID)
                return;
            const {gl: n, displayState: r, meshShaderManager: s} = this
              , a = Math.min(1, r.objectAlpha.value);
            if (a <= 0)
                return;
            const o = Object(d.g)(r.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
            if (void 0 === o)
                return;
            const l = this.getShader(e.emitter);
            l.bind(),
            s.beginLayer(n, l, e),
            s.beginModel(n, l, e, o);
            let {pickIDs: c} = e;
            const u = this.source.chunks;
            let f = 0
              , m = 0;
            const {renderScaleHistogram: g} = this.displayState
              , v = this.source.fragmentSource.chunks;
            Object(h.a)(r, (t,o)=>{
                const d = Object(h.b)(t)
                  , g = u.get(d);
                if (++f,
                void 0 !== g) {
                    ++m,
                    e.emitColor && s.setColor(n, l, Object(p.d)(r, o, a)),
                    e.emitPickID && s.setPickID(n, l, c.registerUint64(this, t)),
                    f += g.fragmentIds.length;
                    for (const e of g.fragmentIds) {
                        const t = v.get(`${d}/${e}`);
                        void 0 !== t && t.state === i.g.GPU_MEMORY && (s.drawFragment(n, l, t),
                        ++m)
                    }
                }
            }
            ),
            e.emitColor && (g.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber),
            g.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, m, f - m)),
            s.endLayer(n, l)
        }
        isReady() {
            const {displayState: e, source: t} = this;
            let n = !0;
            const r = t.fragmentSource.chunks;
            return Object(h.a)(e, e=>{
                const s = Object(h.b)(e)
                  , a = t.chunks.get(s);
                if (void 0 !== a)
                    for (const e of a.fragmentIds) {
                        const t = r.get(`${s}/${e}`);
                        if (void 0 === t || t.state !== i.g.GPU_MEMORY)
                            return void (n = !1)
                    }
                else
                    n = !1
            }
            ),
            n
        }
    }
    class T extends r.b {
        constructor(e, t) {
            super(e),
            this.fragmentIds = t.fragmentIds
        }
    }
    class M extends r.b {
        constructor(e, t) {
            super(e),
            this.meshData = t
        }
        copyToGPU(e) {
            super.copyToGPU(e),
            w(e, this)
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e),
            x(this)
        }
    }
    class D extends r.e {
        constructor(e, t) {
            super(e, t),
            this.fragmentSource = this.registerDisposer(new L(this.chunkManager,this))
        }
        initializeCounterpart(e, t) {
            this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}),
            t.fragmentSource = this.fragmentSource.addCounterpartRef(),
            super.initializeCounterpart(e, t)
        }
        getChunk(e) {
            return new T(this,e)
        }
    }
    let L = class extends r.e {
        constructor(e, t) {
            super(e),
            this.meshSource = t
        }
        get key() {
            return this.meshSource.key
        }
        getChunk(e) {
            return new M(this,e)
        }
    }
    ;
    function A(e, t, n, r) {
        const s = e.get(c(t, n, r));
        return void 0 !== s && s.state === i.g.GPU_MEMORY
    }
    L = b([Object(v.g)(s.a)], L);
    class I extends u.a {
        constructor(e, t, n) {
            super(),
            this.chunkManager = e,
            this.source = t,
            this.displayState = n,
            this.meshShaderManager = new k(this.source.format.fragmentRelativeVertices,this.source.format.vertexPositionFormat),
            this.shaders = new Map,
            Object(p.e)(n, this);
            let i = this.backend = this.registerDisposer(new p.b(e,n));
            i.RPC_TYPE_ID = s.d,
            i.initializeCounterpartWithChunkManager({
                source: t.addCounterpartRef()
            }),
            i.visibility.add(this.visibility),
            this.registerDisposer(n.renderScaleHistogram.visibility.add(this.visibility))
        }
        getShader(e) {
            let {shaders: t} = this
              , n = t.get(e);
            return void 0 === n && (n = this.registerDisposer(this.meshShaderManager.getShader(this.gl, e)),
            t.set(e, n)),
            n
        }
        get isTransparent() {
            return this.displayState.objectAlpha.value < 1
        }
        get gl() {
            return this.chunkManager.chunkQueueManager.gl
        }
        draw(e, t) {
            if (!e.emitColor && e.alreadyEmittedPickID)
                return;
            const {gl: n, displayState: i, meshShaderManager: r} = this
              , s = Math.min(1, i.objectAlpha.value);
            if (s <= 0)
                return;
            const o = Object(d.g)(i.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
            if (void 0 === o)
                return;
            const u = this.getShader(e.emitter);
            u.bind(),
            r.beginLayer(n, u, e);
            const {renderScaleHistogram: f} = this.displayState;
            e.emitColor && f.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            let {pickIDs: m} = e;
            Object(a.k)(S, o),
            Object(a.p)(S, S, e.projectionParameters.displayDimensionRenderInfo.voxelPhysicalScales);
            const g = Math.pow(a.j.determinant(S), 1 / 3)
              , {chunks: v} = this.source
              , b = this.source.fragmentSource.chunks
              , {projectionParameters: y} = e
              , w = a.l.multiply(a.l.create(), y.viewProjectionMat, o)
              , x = Object(a.c)(new Float32Array(24), w)
              , C = this.displayState.renderScaleTarget.value
              , {fragmentRelativeVertices: O} = this.source.format;
            r.beginModel(n, u, e, o);
            let k = 0
              , E = 0;
            Object(h.a)(i, (t,a)=>{
                const o = Object(h.b)(t)
                  , d = v.get(o);
                if (++k,
                void 0 === d)
                    return;
                ++E;
                const {manifest: S} = d
                  , {octree: T, chunkShape: M, chunkGridSpatialOrigin: D, vertexOffsets: L} = S;
                e.emitColor && r.setColor(n, u, Object(p.d)(i, a, s)),
                e.emitPickID && r.setPickID(n, u, m.registerUint64(this, t)),
                l(S, w, x, C, y.width, y.height, (t,n,i)=>{
                    const r = A(b, o, t, n);
                    return e.emitColor && f.add(S.lodScales[t] * g, i, r ? 1 : 0, r ? 0 : 1),
                    r
                }
                , (e,t,i,s)=>{
                    const a = c(o, e, t)
                      , l = b.get(a)
                      , d = T[5 * t]
                      , h = T[5 * t + 1]
                      , p = T[5 * t + 2]
                      , f = 1 << e;
                    O && (n.uniform3f(u.uniform("uFragmentOrigin"), D[0] + d * M[0] * f + L[3 * e + 0], D[1] + h * M[1] * f + L[3 * e + 1], D[2] + p * M[2] * f + L[3 * e + 2]),
                    n.uniform3f(u.uniform("uFragmentShape"), M[0] * f, M[1] * f, M[2] * f)),
                    r.drawMultiscaleFragment(n, u, l, i, s)
                }
                )
            }
            ),
            f.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, E, k - E),
            r.endLayer(n, u)
        }
        isReady(e, t) {
            let {displayState: n} = this;
            if (Math.min(1, n.objectAlpha.value) <= 0)
                return !0;
            const i = Object(d.g)(n.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
            if (void 0 === i)
                return !1;
            const {chunks: r} = this.source
              , s = this.source.fragmentSource.chunks
              , {projectionParameters: o} = e
              , c = a.l.multiply(a.l.create(), o.viewProjectionMat, i)
              , u = Object(a.c)(new Float32Array(24), c)
              , p = this.displayState.renderScaleTarget.value;
            let f = !0;
            return Object(h.a)(n, e=>{
                if (!f)
                    return;
                const t = Object(h.b)(e)
                  , n = r.get(t);
                if (void 0 === n)
                    return void (f = !1);
                const {manifest: i} = n;
                l(i, c, u, p, o.width, o.height, (e,n)=>(f = f && A(s, t, e, n),
                f), ()=>{}
                )
            }
            ),
            f
        }
    }
    class P extends r.b {
        constructor(e, t) {
            super(e),
            this.manifest = t.manifest
        }
    }
    class R extends r.b {
        constructor(e, t) {
            super(e),
            this.meshData = t
        }
        copyToGPU(e) {
            super.copyToGPU(e),
            w(e, this)
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e),
            x(this)
        }
    }
    class j extends r.e {
        constructor(e, t) {
            super(e, t),
            this.fragmentSource = this.registerDisposer(new N(this.chunkManager,this)),
            this.format = t.format
        }
        static encodeOptions(e) {
            return Object.assign({
                format: e.format
            }, super.encodeOptions(e))
        }
        initializeCounterpart(e, t) {
            this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}),
            t.fragmentSource = this.fragmentSource.addCounterpartRef(),
            t.format = this.format,
            super.initializeCounterpart(e, t)
        }
        getChunk(e) {
            return new P(this,e)
        }
    }
    let N = class extends r.e {
        constructor(e, t) {
            super(e),
            this.meshSource = t
        }
        get key() {
            return this.meshSource.key
        }
        getChunk(e) {
            return new R(this,e)
        }
    }
    ;
    N = b([Object(v.g)(s.c)], N)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i = n(33);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const r = new Map;
    function s(e, t) {
        r.set(e, t)
    }
    function a(e) {
        const t = new i.b;
        for (const [n,i] of r)
            t.register(n, i(e));
        return t
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    ));
    var i = n(2)
      , r = n(13);
    n.d(t, "a", (function() {
        return r.a
    }
    ));
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends i.a {
        constructor(e, t) {
            super(),
            this.target = e,
            this.eventMap = t,
            this.registerEventListener(e, "wheel", e=>{
                this.dispatch("wheel", e)
            }
            ),
            this.registerEventListener(e, "click", e=>{
                this.dispatch(`click${e.button}`, e)
            }
            ),
            this.registerEventListener(e, "dblclick", e=>{
                this.dispatch(`dblclick${e.button}`, e)
            }
            ),
            this.registerEventListener(e, "mousedown", e=>{
                this.dispatch(`mousedown${e.button}`, e)
            }
            ),
            this.registerEventListener(e, "mouseup", e=>{
                this.dispatch(`mouseup${e.button}`, e)
            }
            )
        }
        dispatch(e, t) {
            Object(r.c)(e, t, t, this.eventMap)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "g", (function() {
        return T
    }
    )),
    n.d(t, "b", (function() {
        return D
    }
    )),
    n.d(t, "d", (function() {
        return L
    }
    )),
    n.d(t, "c", (function() {
        return A
    }
    )),
    n.d(t, "e", (function() {
        return I
    }
    )),
    n.d(t, "a", (function() {
        return P
    }
    )),
    n.d(t, "f", (function() {
        return R
    }
    ));
    var i = n(16)
      , r = n.n(i)
      , s = n(10)
      , a = n(14)
      , o = n(75)
      , l = n(38)
      , c = n(31)
      , u = n(44)
      , d = n(110)
      , h = n(65)
      , p = n(2)
      , f = n(1)
      , m = n(48)
      , g = n(42)
      , v = n(3)
      , b = n(26)
      , y = n(46)
      , S = n(60)
      , w = n(66)
      , x = n(11)
      , C = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    };
    class O extends u.f {
    }
    const k = Object(b.c)(O);
    function E(e) {
        return {
            source: e.source.addCounterpartRef(),
            effectiveVoxelSize: e.effectiveVoxelSize,
            layerRank: e.layerRank,
            nonDisplayLowerClipBound: e.nonDisplayLowerClipBound,
            nonDisplayUpperClipBound: e.nonDisplayUpperClipBound,
            lowerClipDisplayBound: e.lowerClipDisplayBound,
            upperClipDisplayBound: e.upperClipDisplayBound,
            chunkDisplayDimensionIndices: e.chunkDisplayDimensionIndices,
            lowerChunkDisplayBound: e.lowerChunkDisplayBound,
            upperChunkDisplayBound: e.upperChunkDisplayBound,
            fixedLayerToChunkTransform: e.fixedLayerToChunkTransform,
            chunkLayout: e.chunkLayout.toObject()
        }
    }
    function T(e) {
        return e.map(e=>e.map(E))
    }
    function M(e, t) {
        for (const n of t)
            for (const {source: t} of n)
                e.removeSource(t),
                t.dispose()
    }
    let D = class extends k {
        constructor(e, t, n, i) {
            super(new c.a({
                parametersConstructor: u.g,
                navigationState: n,
                update: (e,t)=>{
                    const {invViewMatrix: n, centerDataPosition: i} = e;
                    t.toMat4(n);
                    let {globalPosition: r} = e;
                    const {canonicalVoxelFactors: s, voxelPhysicalScales: a} = e.displayDimensionRenderInfo
                      , l = t.position.value
                      , c = l.length;
                    r.length !== c && (e.globalPosition = r = new Float32Array(c)),
                    r.set(l);
                    for (let e = 0; e < 3; ++e)
                        i[e] = n[12 + e];
                    const {width: u, height: d, projectionMat: h, viewportNormalInGlobalCoordinates: p, viewportNormalInCanonicalCoordinates: m} = e
                      , {relativeDepthRange: g} = t;
                    f.l.ortho(h, -u / 2, u / 2, d / 2, -d / 2, -g, g),
                    Object(o.c)(e);
                    const {viewMatrix: v} = e;
                    for (let e = 0; e < 3; ++e) {
                        const t = p[e] = v[4 * e + 2];
                        m[e] = t / s[e]
                    }
                    f.t.normalize(p, p),
                    f.t.normalize(m, m);
                    let b = 0;
                    for (let e = 0; e < 3; ++e) {
                        b += (a[e] * n[e]) ** 2
                    }
                    b = Math.sqrt(b),
                    e.pixelSize = b
                }
            })),
            this.chunkManager = e,
            this.layerManager = t,
            this.navigationState = n,
            this.wireFrame = i,
            this.gl = this.chunkManager.gl,
            this.viewChanged = new v.a,
            this.renderingStale = !0,
            this.visibleChunksStale = !0,
            this.visibleLayerList = new Array,
            this.offscreenFramebuffer = this.registerDisposer(new y.b(this.gl,{
                colorBuffers: Object(y.f)(this.gl, 1),
                depthBuffer: new y.d(this.gl)
            })),
            this.updateVisibleLayers = this.registerCancellable(r()(()=>{
                this.updateVisibleLayersNow()
            }
            , 0)),
            this.registerDisposer(n),
            this.registerDisposer(this.projectionParameters),
            this.registerDisposer(this.projectionParameters.changed.add((e,t)=>{
                e.displayDimensionRenderInfo !== t.displayDimensionRenderInfo && this.updateVisibleLayers()
            }
            ));
            const s = this.chunkManager.rpc
              , a = this.sharedProjectionParameters = this.registerDisposer(new c.d(s,this.projectionParameters));
            this.initializeCounterpart(s, {
                chunkManager: e.rpcId,
                projectionParameters: a.rpcId
            }),
            this.registerDisposer(t.layersChanged.add(()=>{
                this.updateVisibleLayers()
            }
            )),
            this.wireFrame.changed.add(this.viewChanged.dispatch),
            this.viewChanged.add(()=>{
                this.renderingStale = !0
            }
            ),
            this.registerDisposer(e.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch)),
            this.updateVisibleLayers()
        }
        flushBackendProjectionParameters() {
            this.sharedProjectionParameters.flush()
        }
        forEachVisibleChunk(e, t) {
            Object(u.i)(this.projectionParameters.value, e.renderLayer.localPosition.value, e, ()=>{
                t(e.curPositionInChunks.join())
            }
            )
        }
        isReady() {
            if (!this.navigationState.valid)
                return !1;
            this.updateVisibleLayers.flush(),
            this.updateVisibleSources();
            let e = 0
              , t = 0;
            for (const {visibleSources: n} of this.visibleLayers.values())
                for (const i of n) {
                    const {source: n} = i
                      , {chunks: r} = n;
                    this.forEachVisibleChunk(i, n=>{
                        const i = r.get(n);
                        ++t,
                        i && i.state === s.g.GPU_MEMORY && ++e
                    }
                    )
                }
            return e === t
        }
        invalidateVisibleSources() {
            super.invalidateVisibleSources(),
            this.viewChanged.dispatch()
        }
        bindVisibleRenderLayer(e, t) {
            t.push(e.localPosition.changed.add(()=>this.invalidateVisibleChunks())),
            t.push(e.redrawNeeded.add(this.viewChanged.dispatch)),
            t.push(e.transform.changed.add(this.updateVisibleLayers)),
            t.push(e.renderScaleTarget.changed.add(()=>this.invalidateVisibleSources()));
            const {renderScaleHistogram: n} = e;
            void 0 !== n && t.push(n.visibility.add(this.visibility))
        }
        updateVisibleLayersNow() {
            if (this.wasDisposed)
                return !1;
            if (!this.navigationState.valid)
                return !1;
            const e = Date.now()
              , {visibleLayers: t, visibleLayerList: n} = this
              , {displayDimensionRenderInfo: i} = this.projectionParameters.value;
            let r = this.rpc
              , s = {
                id: this.rpcId
            }
              , a = !1;
            n.length = 0;
            for (let o of this.layerManager.readyRenderLayers())
                if (o instanceof h.b) {
                    n.push(o);
                    let l = t.get(o);
                    if (void 0 === l) {
                        const n = []
                          , r = new m.a;
                        l = {
                            messages: r,
                            allSources: this.getTransformedSources(o, r),
                            transformGeneration: o.transform.changed.count,
                            visibleSources: [],
                            disposers: n,
                            lastSeenGeneration: e,
                            displayDimensionRenderInfo: i
                        },
                        n.push(o.messages.addChild(l.messages)),
                        t.set(o.addRef(), l),
                        this.bindVisibleRenderLayer(o, n)
                    } else {
                        l.lastSeenGeneration = e;
                        const t = o.transform.changed.count;
                        if (l.transformGeneration === t && l.displayDimensionRenderInfo === i)
                            continue;
                        const n = l.allSources;
                        l.allSources = this.getTransformedSources(o, l.messages),
                        M(o, n),
                        l.visibleSources.length = 0,
                        l.displayDimensionRenderInfo = i,
                        l.transformGeneration = t
                    }
                    s.layerId = o.rpcId,
                    s.sources = T(l.allSources),
                    this.flushBackendProjectionParameters(),
                    r.invoke(u.b, s),
                    a = !0
                }
            for (const [n,i] of t)
                i.lastSeenGeneration !== e && (s.layerId = n.rpcId,
                r.invoke(u.c, s),
                t.delete(n),
                M(n, i.allSources),
                Object(p.d)(i.disposers),
                n.dispose(),
                a = !0);
            return a && (this.visibleSourcesStale = !0),
            this.viewChanged.dispatch(),
            a
        }
        invalidateVisibleChunks() {
            super.invalidateVisibleChunks(),
            this.viewChanged.dispatch()
        }
        get valid() {
            return this.navigationState.valid
        }
        updateRendering() {
            const e = this.projectionParameters.value
              , {width: t, height: n} = e;
            if (!this.renderingStale || !this.valid || 0 === t || 0 === n)
                return;
            this.renderingStale = !1,
            this.updateVisibleLayers.flush(),
            this.updateVisibleSources();
            let {gl: i, offscreenFramebuffer: r} = this;
            r.bind(t, n),
            i.disable(i.SCISSOR_TEST),
            i.clearStencil(0),
            i.clearColor(0, 0, 0, 0),
            i.colorMask(!0, !0, !0, !0),
            i.clear(i.COLOR_BUFFER_BIT),
            i.enable(i.STENCIL_TEST),
            i.disable(i.DEPTH_TEST),
            i.stencilOpSeparate(i.FRONT_AND_BACK, i.KEEP, i.KEEP, i.REPLACE);
            let s = 0;
            const a = {
                sliceView: this,
                projectionParameters: e,
                wireFrame: this.wireFrame.value
            };
            for (let e of this.visibleLayerList)
                i.clear(i.STENCIL_BUFFER_BIT),
                i.stencilFuncSeparate(i.FRONT_AND_BACK, i.GREATER, 1, 1),
                e.setGLBlendMode(i, s),
                e.draw(a),
                ++s;
            i.disable(i.BLEND),
            i.disable(i.STENCIL_TEST),
            r.unbind()
        }
        disposed() {
            for (const [e,t] of this.visibleLayers)
                M(e, t.allSources),
                Object(p.d)(t.disposers),
                e.dispose();
            this.visibleLayers.clear(),
            this.visibleLayerList.length = 0
        }
        getTransformedSources(e, t) {
            const n = R(this.projectionParameters.value.displayDimensionRenderInfo, e.transform.value, t=>e.getSources(t), t, e);
            for (const t of n)
                for (const n of t)
                    e.addSource(n.source, n.chunkTransform);
            return n
        }
    }
    ;
    D = C([Object(x.g)(u.e)], D);
    class L extends a.e {
        constructor(e, t) {
            super(e, t),
            this.spec = t.spec
        }
        static encodeSpec(e) {
            return {
                chunkDataSize: Array.from(e.chunkDataSize),
                lowerVoxelBound: Array.from(e.lowerVoxelBound),
                upperVoxelBound: Array.from(e.upperVoxelBound)
            }
        }
        static encodeOptions(e) {
            const t = super.encodeOptions(e);
            return t.spec = this.encodeSpec(e.spec),
            t
        }
        initializeCounterpart(e, t) {
            t.spec = this.spec,
            super.initializeCounterpart(e, t)
        }
    }
    class A extends a.b {
        constructor(e, t) {
            super(e),
            this.chunkGridPosition = t.chunkGridPosition,
            this.state = s.g.SYSTEM_MEMORY
        }
    }
    class I extends p.a {
        constructor(e, t) {
            super(),
            this.gl = e,
            this.copyVertexPositionsBuffer = Object(w.a)(this.gl),
            this.textureCoordinateAdjustment = new Float32Array(4);
            let n = new S.a(e);
            n.addVarying("vec2", "vTexCoord"),
            n.addUniform("sampler2D", "uSampler"),
            n.addInitializer(t=>{
                e.uniform1i(t.uniform("uSampler"), 0)
            }
            ),
            n.addUniform("vec4", "uColorFactor"),
            n.addUniform("vec4", "uBackgroundColor"),
            n.addUniform("mat4", "uProjectionMatrix"),
            n.addUniform("vec4", "uTextureCoordinateAdjustment"),
            n.require(t),
            n.setFragmentMain("\nvec4 sampledColor = texture(uSampler, vTexCoord);\nif (sampledColor.a == 0.0) {\n  sampledColor = uBackgroundColor;\n}\nemit(sampledColor * uColorFactor, 0u);\n"),
            n.addAttribute("vec4", "aVertexPosition"),
            n.setVertexMain("\nvTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;\ngl_Position = uProjectionMatrix * aVertexPosition;\n"),
            this.shader = this.registerDisposer(n.build())
        }
        draw(e, t, n, i, r, s, a, o) {
            let {gl: l, shader: c, textureCoordinateAdjustment: u} = this;
            u[0] = r,
            u[1] = s,
            u[2] = a - r,
            u[3] = o - s,
            c.bind(),
            l.activeTexture(l.TEXTURE0),
            l.bindTexture(l.TEXTURE_2D, e),
            l.uniformMatrix4fv(c.uniform("uProjectionMatrix"), !1, t),
            l.uniform4fv(c.uniform("uColorFactor"), n),
            l.uniform4fv(c.uniform("uBackgroundColor"), i),
            l.uniform4fv(c.uniform("uTextureCoordinateAdjustment"), u);
            let d = c.attribute("aVertexPosition");
            this.copyVertexPositionsBuffer.bindToVertexAttrib(d, 2),
            l.drawArrays(l.TRIANGLE_FAN, 0, 4),
            l.disableVertexAttribArray(d),
            l.bindTexture(l.TEXTURE_2D, null)
        }
        static get(e, t) {
            return e.memoize.get(`sliceview/SliceViewRenderHelper:${Object(g.a)(t)}`, ()=>new I(e,t))
        }
    }
    class P {
        constructor(e) {
            this.chunkManager = e
        }
    }
    function R(e, t, n, i, r) {
        i.clearMessages();
        const s = e=>(i.addMessage({
            severity: m.b.error,
            message: e
        }),
        []);
        if (void 0 !== t.error)
            return s(t.error);
        const a = t.rank
          , o = t.unpaddedRank
          , {displayDimensionIndices: c, displayRank: u, canonicalVoxelFactors: h} = e
          , p = Object(l.f)(t, c)
          , {layerDisplayDimensionIndices: g} = p
          , v = new Float32Array(u * o)
          , {modelToRenderLayerTransform: b} = t;
        for (let e = 0; e < u; ++e) {
            const t = g[e];
            if (-1 === t)
                continue;
            const n = h[e];
            for (let i = 0; i < o; ++i)
                v[u * i + e] = b[(a + 1) * i + t] * n
        }
        const y = n({
            displayRank: u,
            multiscaleToViewTransform: v,
            modelChannelDimensionIndices: t.channelToRenderLayerDimensions
        })
          , {voxelPhysicalScales: S} = e;
        try {
            const e = e=>{
                const {chunkSource: n} = e
                  , {spec: i} = n
                  , {lowerClipBound: s=i.lowerVoxelBound, upperClipBound: a=i.upperVoxelBound} = e
                  , c = Object(l.e)(t, e.chunkToMultiscaleTransform)
                  , {chunkDataSize: h} = i
                  , {chunkChannelDimensionIndices: m} = c
                  , g = new Float32Array(o)
                  , v = new Float32Array(o);
                g.set(s),
                v.set(a);
                const b = m.length
                  , {channelDimensionBounds: y} = t;
                for (let e = 0; e < b; ++e) {
                    const n = m[e];
                    if (-1 === n)
                        continue;
                    const i = y.lowerBounds[e]
                      , r = y.upperBounds[e];
                    if (h[n] !== r || 0 !== i)
                        throw new Error("Channel dimension " + t.layerDimensionNames[t.channelToRenderLayerDimensions[e]] + ` has range [${i}, ${r}) but corresponding chunk dimension has range ` + `[0, ${h[n]})`);
                    g[n] = Number.NEGATIVE_INFINITY,
                    v[n] = Number.POSITIVE_INFINITY
                }
                const w = Object(l.c)(c, p)
                  , x = f.t.create()
                  , C = f.t.create()
                  , O = f.t.create()
                  , k = f.t.create()
                  , E = f.t.create()
                  , {numChunkDisplayDims: T, chunkDisplayDimensionIndices: M} = w
                  , {combinedGlobalLocalToChunkTransform: D, layerRank: L, combinedGlobalLocalRank: A} = c
                  , I = new Float32Array(D);
                for (let e = 0; e < T; ++e) {
                    const t = M[e];
                    for (let e = 0; e <= A; ++e)
                        I[t + e * L] = 0;
                    t < o ? (E[e] = i.chunkDataSize[t],
                    x[e] = i.lowerChunkBound[t],
                    C[e] = i.upperChunkBound[t],
                    O[e] = s[t],
                    k[e] = a[t],
                    g[t] = Number.NEGATIVE_INFINITY,
                    v[t] = Number.POSITIVE_INFINITY) : (E[e] = 1,
                    x[e] = 0,
                    C[e] = 1,
                    O[e] = 0,
                    k[e] = 1)
                }
                E.fill(1, T),
                x.fill(0, T),
                C.fill(1, T),
                O.fill(0, T),
                k.fill(1, T);
                const P = new d.a(E,w.displaySubspaceModelMatrix,T)
                  , R = P.localSpatialVectorToGlobal(f.t.create(), f.i);
                for (let e = 0; e < u; ++e)
                    R[e] *= S[e];
                return R.fill(1, u),
                {
                    layerRank: L,
                    nonDisplayLowerClipBound: g,
                    nonDisplayUpperClipBound: v,
                    renderLayer: r,
                    source: n,
                    lowerChunkDisplayBound: x,
                    upperChunkDisplayBound: C,
                    lowerClipDisplayBound: O,
                    upperClipDisplayBound: k,
                    effectiveVoxelSize: R,
                    chunkLayout: P,
                    chunkDisplayDimensionIndices: M,
                    fixedLayerToChunkTransform: I,
                    curPositionInChunks: new Float32Array(o),
                    fixedPositionWithinChunk: new Uint32Array(o),
                    chunkTransform: c,
                    chunkDisplayTransform: w
                }
            }
            ;
            return y.map(t=>t.map(t=>e(t)))
        } catch (t) {
            for (const e of y)
                for (const {chunkSource: t} of e)
                    t.dispose();
            const {globalDimensionNames: n} = e;
            return s(`Cannot render (${Array.from(e.displayDimensionIndices.filter(e=>-1 !== e), e=>n[e]).join(",")}) cross section: ${t.message}`)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "f", (function() {
        return p
    }
    )),
    n.d(t, "e", (function() {
        return f
    }
    )),
    n.d(t, "d", (function() {
        return v
    }
    )),
    n.d(t, "b", (function() {
        return y
    }
    ));
    var i = n(61)
      , r = n(85)
      , s = n(2)
      , a = n(1)
      , o = n(3)
      , l = n(21)
      , c = n(26)
      , u = n(11);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class d {
        constructor(e, t) {
            this.key = e,
            this.value = t
        }
        toString() {
            return `${this.key}${this.value}`
        }
    }
    class h extends s.a {
        constructor() {
            super(...arguments),
            this.selectedSegment = new l.a,
            this.hasSelectedSegment = !1,
            this.changed = new o.a
        }
        set(e) {
            if (null == e)
                this.hasSelectedSegment && (this.hasSelectedSegment = !1,
                this.changed.dispatch());
            else {
                let t = this.selectedSegment;
                this.hasSelectedSegment && e.low === t.low && e.high === t.high || (t.low = e.low,
                t.high = e.high,
                this.hasSelectedSegment = !0,
                this.changed.dispatch())
            }
        }
        isSelected(e) {
            return this.hasSelectedSegment && l.a.equal(e, this.selectedSegment)
        }
        bindTo(e, t) {
            let n = new l.a;
            this.registerDisposer(e.changed.add(()=>{
                let i = e.get(t);
                "number" == typeof i ? (n.low = i,
                n.high = 0,
                i = n) : i instanceof d && (i = i.value),
                this.set(i)
            }
            ))
        }
    }
    function p(e, t) {
        const n = t.redrawNeeded.dispatch;
        t.registerDisposer(e.segmentColorHash.changed.add(n)),
        t.registerDisposer(e.visibleSegments.changed.add(n)),
        t.registerDisposer(e.saturation.changed.add(n)),
        t.registerDisposer(e.highlightedSegments.changed.add(n)),
        t.registerDisposer(e.segmentEquivalences.changed.add(n)),
        t.registerDisposer(e.segmentSelectionState.changed.add(n))
    }
    function f(e, t) {
        !function(e, t) {
            p(e, t),
            t.registerDisposer(e.objectAlpha.changed.add(t.redrawNeeded.dispatch))
        }(e, t),
        t.registerDisposer(e.transform.changed.add(t.redrawNeeded.dispatch)),
        t.registerDisposer(e.renderScaleTarget.changed.add(t.redrawNeeded.dispatch))
    }
    const m = a.v.create()
      , g = new l.a;
    function v(e, t, n=1) {
        const i = m;
        if (i[3] = n,
        e.segmentStatedColors.has(t) ? (e.segmentStatedColors.get(t, g),
        i[0] = ((16711680 & g.low) >>> 16) / 255,
        i[1] = ((65280 & g.low) >>> 8) / 255,
        i[2] = (255 & g.low) / 255) : e.segmentColorHash.compute(i, t),
        e.segmentSelectionState.isSelected(t))
            for (let e = 0; e < 3; ++e)
                i[e] = .5 * i[e] + .5;
        let s = new Float32Array(3);
        Object(r.b)(s, i[0], i[1], i[2]),
        s[1] *= e.saturation.value;
        let a = new Float32Array(3);
        return Object(r.a)(a, s[0], s[1], s[2]),
        i[0] = a[0],
        i[1] = a[1],
        i[2] = a[2],
        e.highlightedSegments.has(t) && (i[0] = .2,
        i[1] = .2,
        i[2] = 2,
        i[3] = 1),
        i[0] *= n,
        i[1] *= n,
        i[2] *= n,
        i
    }
    const b = Object(c.c)(u.b);
    class y extends b {
        constructor(e, t) {
            super(),
            this.chunkManager = e,
            this.displayState = t
        }
        initializeCounterpartWithChunkManager(e) {
            let {displayState: t} = this;
            e.chunkManager = this.chunkManager.rpcId,
            e.visibleSegments = t.visibleSegments.rpcId,
            e.segmentEquivalences = t.segmentEquivalences.rpcId,
            e.transform = this.registerDisposer(i.a.makeFromExisting(this.chunkManager.rpc, this.displayState.transform)).rpcId,
            e.renderScaleTarget = this.registerDisposer(i.a.makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget)).rpcId,
            super.initializeCounterpart(this.chunkManager.rpc, e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return m
    }
    )),
    n.d(t, "a", (function() {
        return y
    }
    )),
    n.d(t, "b", (function() {
        return k
    }
    ));
    var i = n(8)
      , r = n(64)
      , s = n(47)
      , a = n(14)
      , o = n(45)
      , l = n(52)
      , c = n(35)
      , u = n(103)
      , d = n(3)
      , h = n(11)
      , p = n(15)
      , f = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    };
    function m(e) {
        let t = 0;
        const {typeToIds: n} = e;
        for (const e of i.i)
            t += Object(s.b)(e).pickIdsPerInstance * n[e].length;
        return t
    }
    class g {
        constructor(e) {
            this.bufferValid = !1,
            this.numPickIds = 0,
            this.serializedAnnotations = {
                data: e.data,
                typeToIds: e.typeToIds,
                typeToOffset: e.typeToOffset,
                typeToIdMaps: e.typeToIdMaps
            }
        }
        freeGPUMemory(e) {
            const {buffer: t} = this;
            void 0 !== t && (t.dispose(),
            this.bufferValid = !1,
            this.buffer = void 0)
        }
    }
    class v extends a.b {
        constructor(e, t) {
            super(e),
            void 0 !== t.data && (this.data = new g(t))
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e);
            const {data: t} = this;
            void 0 !== t && t.freeGPUMemory(e)
        }
        dispose() {
            this.data = void 0
        }
    }
    class b extends l.c {
        constructor(e, t) {
            super(e, t),
            void 0 !== t.data && (this.data = new g(t))
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e);
            const {data: t} = this;
            void 0 !== t && t.freeGPUMemory(e)
        }
        dispose() {
            this.data = void 0
        }
    }
    let y = class extends l.d {
        constructor(e, t) {
            super(e, t),
            this.immediateChunkUpdates = !0,
            (this.parent = t.parent).spatiallyIndexedSources.add(this);
            const {rank: n, chunkDataSize: i} = this.spec
              , r = this.multiscaleToChunkTransform = new Float32Array((n + 1) ** 2);
            p.f(r, n + 1, this.spec.chunkToMultiscaleTransform, n + 1, n + 1);
            for (let e = 0; e < n; ++e)
                for (let t = 0; t < n + 1; ++t)
                    r[(n + 1) * t + e] /= i[e]
        }
        disposed() {
            this.parent.spatiallyIndexedSources.delete(this),
            super.disposed()
        }
        initializeCounterpart(e, t) {
            t.parent = this.parent.rpcId,
            super.initializeCounterpart(e, t)
        }
        addChunk(e, t) {
            super.addChunk(e, t)
        }
        getChunk(e) {
            return new b(this,e)
        }
    }
    ;
    y = f([Object(h.g)(r.c)], y);
    let S = class extends a.e {
        constructor(e, t, n) {
            super(e, {}),
            this.parent = t,
            this.relationshipIndex = n,
            this.immediateChunkUpdates = !0
        }
        addChunk(e, t) {
            super.addChunk(e, t)
        }
        getChunk(e) {
            return new v(this,e)
        }
    }
    ;
    S = f([Object(h.g)(r.k)], S);
    class w extends a.b {
        constructor(e, t) {
            super(e),
            this.annotation = Object(i.j)(t.annotation)
        }
    }
    let x = class extends a.e {
        constructor(e, t) {
            super(e),
            this.parent = t
        }
        getChunk(e) {
            return new w(this,e)
        }
        addChunk(e, t) {
            super.addChunk(e, t);
            const {references: n} = this.parent
              , i = n.get(e);
            void 0 !== i && (i.value = t.annotation,
            i.changed.dispatch())
        }
        deleteChunk(e) {
            const {references: t} = this.parent
              , n = t.get(e);
            void 0 !== n && (n.value = void 0,
            n.changed.dispatch())
        }
    }
    ;
    function C(e, t, n) {
        const {rank: r} = n
          , s = t.type
          , {serializedAnnotations: a} = e
          , o = a.typeToIds[s]
          , l = a.typeToIdMaps[s]
          , c = Object(i.k)(s)
          , d = c.serializedBytes(r)
          , h = d + n.serializedBytes;
        let p = l.get(t.id)
          , f = 0;
        if (void 0 === p) {
            p = l.size,
            o.push(t.id),
            l.set(t.id, p);
            const e = new Uint8Array(a.data.length + h);
            f = a.typeToOffset[s] + h * p,
            e.set(a.data.subarray(0, f), 0),
            e.set(a.data.subarray(f), f + h),
            a.data = e;
            for (const e of i.i)
                e > s && (a.typeToOffset[e] += h)
        } else
            f = a.typeToOffset[s] + h * p;
        const m = new DataView(a.data.buffer,a.data.byteOffset,a.data.byteLength);
        let g = a.typeToOffset[s] + p * h;
        const v = u.a === u.b.LITTLE;
        c.serialize(m, g, v, r, t),
        g += d,
        n.serialize(m, g, v, t.properties),
        e.bufferValid = !1
    }
    function O(e, t, n, r) {
        const {serializedAnnotations: s} = e
          , a = s.typeToIdMaps[t]
          , o = a.get(n);
        if (void 0 === o)
            return !1;
        const l = s.typeToIds[t]
          , c = Object(i.k)(t)
          , {rank: u} = r
          , d = c.serializedBytes(u) + r.serializedBytes;
        l.splice(o, 1),
        a.delete(n);
        for (let e = o, t = l.length; e < t; ++e)
            a.set(l[e], e);
        const {typeToOffset: h} = s
          , p = h[t] + d * o
          , {data: f} = s
          , m = new Uint8Array(f.length - d);
        m.set(f.subarray(0, p), 0),
        m.set(f.subarray(p + d), p),
        s.data = m;
        for (const e of i.i)
            e > t && (h[e] -= d);
        return e.bufferValid = !1,
        !0
    }
    x = f([Object(h.g)(r.d)], x);
    class k extends h.b {
        constructor(e, t) {
            super(),
            this.chunkManager = e,
            this.metadataChunkSource = this.registerDisposer(new x(this.chunkManager,this)),
            this.spatiallyIndexedSources = new Set,
            this.temporary = function() {
                const e = []
                  , t = []
                  , n = [];
                for (const r of i.i)
                    e[r] = [],
                    t[r] = 0,
                    n[r] = new Map;
                return new b(void 0,{
                    data: new Uint8Array(0),
                    numPickIds: 0,
                    typeToOffset: t,
                    typeToIds: e,
                    typeToIdMaps: n
                })
            }(),
            this.references = new Map,
            this.localUpdates = new Map,
            this.numCommitsInProgress = 0,
            this.changed = new d.a,
            this.readonly = !1,
            this.rank = t.rank,
            this.properties = t.properties,
            this.annotationPropertySerializer = new i.a(this.rank,this.properties);
            const n = this.segmentFilteredSources = []
              , {relationships: r} = t;
            this.relationships = r;
            for (let t = 0, i = r.length; t < i; ++t)
                n.push(this.registerDisposer(new S(e,this,t)))
        }
        getSources(e) {
            throw new Error("not implemented")
        }
        initializeCounterpart(e, t) {
            this.metadataChunkSource.initializeCounterpart(e, {});
            for (const t of this.segmentFilteredSources)
                t.initializeCounterpart(e, {});
            t.segmentFilteredSource = this.segmentFilteredSources.map(e=>e.addCounterpartRef()),
            t.metadataChunkSource = this.metadataChunkSource.addCounterpartRef(),
            t.chunkManager = this.chunkManager.rpcId,
            super.initializeCounterpart(e, t)
        }
        add(e, t=!0) {
            e.id = Object(i.m)();
            const n = new i.b(e.id);
            return n.value = e,
            this.references.set(n.id, n),
            n.registerDisposer(()=>{
                this.references.delete(n.id)
            }
            ),
            this.applyLocalUpdate(n, !1, t, e),
            n
        }
        applyLocalUpdate(e, t, n, i) {
            const {localUpdates: r} = this
              , {id: s} = e;
            let a = this.localUpdates.get(s);
            const o = e.value;
            if (null == o)
                throw new Error("Cannot create local update from null annotation");
            if (void 0 === a ? (a = {
                type: o.type,
                reference: e.addRef(),
                existingAnnotation: t ? o : void 0,
                pendingCommit: void 0,
                commitInProgress: void 0
            },
            r.set(s, a),
            this.forEachPossibleChunk(o, e=>{
                const {data: t} = e;
                void 0 !== t && O(t, o.type, s, this.annotationPropertySerializer)
            }
            ),
            null !== i && C(this.temporary.data, i, this.annotationPropertySerializer)) : (null === i ? O(this.temporary.data, o.type, o.id, this.annotationPropertySerializer) : C(this.temporary.data, i, this.annotationPropertySerializer),
            e.value = i),
            n)
                if (void 0 !== a.commitInProgress)
                    a.pendingCommit = i;
                else {
                    if (null === i && void 0 === a.existingAnnotation)
                        return r.delete(s),
                        void a.reference.dispose();
                    this.sendCommitRequest(a, i)
                }
            this.notifyChanged(e.id, i || void 0)
        }
        sendCommitRequest(e, t) {
            this.updateCommitsInProgress(1),
            e.commitInProgress = t,
            this.rpc.invoke(r.b, {
                id: this.rpcId,
                annotationId: e.existingAnnotation && e.reference.id,
                newAnnotation: t
            })
        }
        delete(e) {
            this.applyLocalUpdate(e, !0, !0, null)
        }
        update(e, t) {
            this.applyLocalUpdate(e, !0, !1, t)
        }
        notifyChanged(e, t) {
            const n = this.references.get(e)
              , i = this.metadataChunkSource.chunks.get(e);
            void 0 !== i && (i.annotation = t || null),
            void 0 !== n && (n.value = t || null,
            n.changed.dispatch()),
            this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch()
        }
        commit(e) {
            this.applyLocalUpdate(e, !0, !0, e.value)
        }
        getReference(e) {
            let t = this.references.get(e);
            if (void 0 !== t)
                return t.addRef();
            t = new i.b(e),
            this.references.set(e, t),
            this.rpc.invoke(r.f, {
                id: this.rpcId,
                annotation: e
            }),
            t.registerDisposer(()=>{
                this.references.delete(e),
                this.rpc.invoke(r.g, {
                    id: this.rpcId,
                    annotation: e
                })
            }
            );
            const n = this.metadataChunkSource.chunks.get(e);
            return void 0 !== n && (t.value = n.annotation),
            t
        }
        forEachPossibleChunk(e, t) {
            const {relatedSegments: n} = e;
            if (void 0 !== n) {
                const e = n.length
                  , {segmentFilteredSources: i} = this;
                for (let r = 0; r < e; ++r) {
                    const e = n[r];
                    if (void 0 === e)
                        return;
                    const s = i[r];
                    for (const n of e) {
                        const e = s.chunks.get(Object(o.b)(n));
                        void 0 !== e && t(e)
                    }
                }
            }
            const {rank: r} = this
              , s = new Float32Array(r)
              , a = new Float32Array(r)
              , l = new Float32Array(r);
            for (const n of this.spatiallyIndexedSources) {
                switch (e.type) {
                case i.e.POINT:
                    p.i(s, n.multiscaleToChunkTransform, r + 1, e.point, r),
                    a.set(s);
                    break;
                case i.e.LINE:
                case i.e.AXIS_ALIGNED_BOUNDING_BOX:
                    p.i(s, n.multiscaleToChunkTransform, r + 1, e.pointA, r),
                    p.i(a, n.multiscaleToChunkTransform, r + 1, e.pointB, r);
                    break;
                case i.e.ELLIPSOID:
                    p.i(s, n.multiscaleToChunkTransform, r + 1, e.center, r),
                    p.j(a, n.multiscaleToChunkTransform, r + 1, e.radii, r);
                    for (let e = 0; e < r; ++e) {
                        const t = s[e]
                          , n = a[e];
                        s[e] = t - n,
                        a[e] = t + n
                    }
                }
                let o = 1;
                for (let e = 0; e < r; ++e) {
                    const t = s[e]
                      , n = a[e]
                      , i = Math.min(t, n)
                      , r = Math.max(t, n);
                    s[e] = Math.ceil(i - 1),
                    a[e] = Math.floor(r + 1),
                    o *= a[e] - s[e]
                }
                const {chunks: c} = n;
                for (let e = 0; e < o; ++e) {
                    let n = e;
                    for (let e = 0; e < r; ++e) {
                        const t = s[e]
                          , i = a[e] - t;
                        n = (n - (l[e] = n % i)) / i
                    }
                    const i = c.get(l.join());
                    void 0 !== i && t(i)
                }
            }
        }
        static encodeOptions(e) {
            return {}
        }
        handleSuccessfulUpdate(e, t) {
            const n = this.localUpdates.get(e);
            if (void 0 === n || void 0 === n.commitInProgress)
                throw new Error("Received invalid successful update notification");
            if (this.updateCommitsInProgress(-1),
            null !== t && n.reference.id !== t.id) {
                if (null === n.commitInProgress)
                    throw new Error("Received invalid successful update notification");
                n.reference.id = t.id,
                this.references.delete(e),
                this.references.set(t.id, n.reference),
                this.localUpdates.delete(e),
                this.localUpdates.set(t.id, n),
                null !== n.reference.value && (n.reference.value.id = t.id,
                O(this.temporary.data, n.type, e, this.annotationPropertySerializer),
                C(this.temporary.data, n.reference.value, this.annotationPropertySerializer)),
                n.reference.changed.dispatch()
            }
            n.existingAnnotation = t || void 0,
            n.commitInProgress = void 0;
            let {pendingCommit: i} = n;
            n.pendingCommit = void 0,
            null === t && (i = void 0),
            void 0 !== i ? (null !== i && (i.id = t.id),
            this.sendCommitRequest(n, i)) : this.revertLocalUpdate(n)
        }
        disposed() {
            const {commitStatus: e} = this;
            void 0 !== e && e.dispose()
        }
        updateCommitsInProgress(e) {
            if (this.numCommitsInProgress += e,
            0 === this.numCommitsInProgress)
                void 0 !== this.commitStatus && (this.commitStatus.dispose(),
                this.commitStatus = void 0);
            else if (void 0 === this.commitStatus) {
                (this.commitStatus = new c.a(!0)).setText("Commiting annotations")
            }
        }
        handleFailedUpdate(e, t) {
            const n = this.localUpdates.get(e);
            if (void 0 === n || void 0 === n.commitInProgress)
                throw new Error("Received invalid update notification");
            (new c.a).setErrorMessage(`Error commiting annotation update: ${t}`),
            this.revertLocalUpdate(n),
            this.updateCommitsInProgress(-1)
        }
        revertLocalUpdate(e) {
            O(this.temporary.data, e.type, e.reference.id, this.annotationPropertySerializer);
            const {existingAnnotation: t} = e;
            void 0 !== t && this.forEachPossibleChunk(t, e=>{
                const {data: n} = e;
                void 0 !== n && C(n, t, this.annotationPropertySerializer)
            }
            );
            const {reference: n} = e
              , {id: i} = n;
            n.value = t || null,
            n.changed.dispatch(),
            n.dispose(),
            this.localUpdates.delete(i)
        }
        *[Symbol.iterator]() {}
    }
    Object(h.e)(r.a, (function(e) {
        const t = this.get(e.id)
          , n = e.annotationId
          , r = e.error;
        if (void 0 !== r)
            t.handleFailedUpdate(n, r);
        else {
            const r = Object(i.j)(e.newAnnotation);
            t.handleSuccessfulUpdate(n, r)
        }
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(92)
      , s = n(66);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const a = r.b;
    class o extends i.a {
        constructor(e, t=1) {
            super(),
            this.linesPerInstance = t,
            this.lineOffsetsBuffer = Object(s.a)(e, 0, -1, 1, 1, t, 1),
            this.quadHelper = this.registerDisposer(new r.a(e,t))
        }
        defineShader(e) {
            e.addAttribute("highp vec2", "aLineOffset"),
            e.addUniform("highp vec3", "uLineParams"),
            e.addVarying("highp float", "vLineCoord"),
            e.addVarying("highp float", "vLineFeatherFraction"),
            e.addVertexCode("\nuint getLineEndpointIndex() { return uint(aLineOffset.x); }\nfloat getLineEndpointCoefficient() { return aLineOffset.x; }\n"),
            e.addVertexCode("\nvoid emitLine(vec4 vertexAClip, vec4 vertexBClip, float lineWidthInPixels) {\n  vec4 vertexPositionClip = mix(vertexAClip, vertexBClip, aLineOffset.x);\n  vec4 otherVertexPositionClip = mix(vertexBClip, vertexAClip, aLineOffset.x);\n\n  vec3 vertexPositionDevice = vertexPositionClip.xyz / vertexPositionClip.w;\n  vec3 otherVertexPositionDevice = otherVertexPositionClip.xyz / otherVertexPositionClip.w;\n\n  vec2 lineDirection = normalize(otherVertexPositionDevice.xy - vertexPositionDevice.xy);\n  vec2 lineNormal = vec2(lineDirection.y, -lineDirection.x);\n\n  gl_Position = vertexPositionClip;\n  float totalLineWidth = lineWidthInPixels + uLineParams.z;\n  vLineFeatherFraction = max(1e-6, uLineParams.z) / totalLineWidth;\n  gl_Position.xy += aLineOffset.y * (2.0 * aLineOffset.x - 1.0) * lineNormal * totalLineWidth * uLineParams.xy * 0.5 * gl_Position.w;\n  vLineCoord = aLineOffset.y;\n}\nvoid emitLine(mat4 projection, vec3 vertexA, vec3 vertexB, float lineWidthInPixels) {\n  emitLine(projection * vec4(vertexA, 1.0), projection * vec4(vertexB, 1.0), lineWidthInPixels);\n}\n"),
            e.addFragmentCode("\nfloat getLineAlpha() {\n  return clamp((1.0 - abs(vLineCoord)) / vLineFeatherFraction, 0.0, 1.0);\n}\n")
        }
        enable(e, t, n) {
            const i = e.attribute("aLineOffset");
            this.lineOffsetsBuffer.bindToVertexAttrib(i, 2);
            const {gl: r} = e;
            r.uniform3f(e.uniform("uLineParams"), 1 / t.width, 1 / t.height, n)
        }
        disable(e) {
            const t = e.attribute("aLineOffset");
            e.gl.disableVertexAttribArray(t)
        }
        draw(e, t) {
            this.quadHelper.draw(e, t)
        }
        enableAndDraw(e, t, n, i) {
            this.enable(e, t, n),
            this.draw(e.gl, i),
            this.disable(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    var i = n(10)
      , r = n(14)
      , s = n(67)
      , a = n(31)
      , o = n(45)
      , l = n(53);
    var c = n(65)
      , u = n(7)
      , d = n(19)
      , h = n(2)
      , p = n(1)
      , f = n(0)
      , m = n(3)
      , g = n(30)
      , v = n(91)
      , b = n(25)
      , y = n(70)
      , S = n(93)
      , w = n(34)
      , x = n(55)
      , C = n(40)
      , O = n(32);
    n.d(t, "c", (function() {
        return I
    }
    )),
    n.d(t, "b", (function() {
        return P
    }
    )),
    n.d(t, "a", (function() {
        return R
    }
    )),
    n.d(t, "e", (function() {
        return j
    }
    )),
    n.d(t, "d", (function() {
        return _
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const k = p.l.create()
      , E = []
      , T = Object(O.d)(new O.b, d.a.FLOAT32, 3);
    class M extends h.a {
        constructor(e, t) {
            super(),
            this.base = e,
            this.targetIsSliceView = t,
            this.textureAccessHelper = new O.a("vertexData"),
            this.lineShader = this.registerDisposer(new x.a(this.gl,1)),
            this.circleShader = this.registerDisposer(new y.a(this.gl,2)),
            this.edgeShaderGetter = Object(w.d)(this, this.gl, {
                memoizeKey: {
                    type: "skeleton/SkeletonShaderManager/edge",
                    vertexAttributes: this.vertexAttributes
                },
                fallbackParameters: this.base.fallbackShaderParameters,
                parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.parseResult,
                shaderError: this.base.displayState.shaderError,
                defineShader: (e,t)=>{
                    this.defineAttributeAccess(e),
                    this.lineShader.defineShader(e),
                    e.addAttribute("highp uvec2", "aVertexIndex"),
                    e.addUniform("highp float", "uLineWidth"),
                    this.defineCommonShader(e);
                    let n = "\nhighp vec3 vertexA = readAttribute0(aVertexIndex.x);\nhighp vec3 vertexB = readAttribute0(aVertexIndex.y);\nemitLine(uProjection, vertexA, vertexB, uLineWidth);\nhighp uint lineEndpointIndex = getLineEndpointIndex();\nhighp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);\n";
                    e.addFragmentCode(`\nvec4 segmentColor() {\n  return uColor;\n}\nvoid emitRGB(vec3 color) {\n  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);\n}\nvoid emitDefault() {\n  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);\n}\n`),
                    e.addFragmentCode(S.a);
                    const {vertexAttributes: i} = this
                      , r = i.length;
                    for (let t = 1; t < r; ++t) {
                        const r = i[t];
                        e.addVarying(`highp ${r.glslDataType}`, `vCustom${t}`),
                        n += `vCustom${t} = readAttribute${t}(vertexIndex);\n`,
                        e.addFragmentCode(`#define ${r.name} vCustom${t}\n`)
                    }
                    e.setVertexMain(n),
                    Object(C.b)(t.controls, e),
                    e.setFragmentMainFunction(Object(w.e)(t.code))
                }
            }),
            this.nodeShaderGetter = Object(w.d)(this, this.gl, {
                memoizeKey: {
                    type: "skeleton/SkeletonShaderManager/node",
                    vertexAttributes: this.vertexAttributes
                },
                fallbackParameters: this.base.fallbackShaderParameters,
                parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.parseResult,
                shaderError: this.base.displayState.shaderError,
                defineShader: (e,t)=>{
                    this.defineAttributeAccess(e),
                    this.circleShader.defineShader(e, this.targetIsSliceView),
                    this.defineCommonShader(e),
                    e.addUniform("highp float", "uNodeDiameter");
                    let n = "\nhighp uint vertexIndex = uint(gl_InstanceID);\nhighp vec3 vertexPosition = readAttribute0(vertexIndex);\nemitCircle(uProjection * vec4(vertexPosition, 1.0), uNodeDiameter, 0.0);\n";
                    e.addFragmentCode("\nvec4 segmentColor() {\n  return uColor;\n}\nvoid emitRGBA(vec4 color) {\n  vec4 borderColor = color;\n  emit(getCircleColor(color, borderColor), uPickID);\n}\nvoid emitRGB(vec3 color) {\n  emitRGBA(vec4(color, 1.0));\n}\nvoid emitDefault() {\n  emitRGBA(uColor);\n}\n"),
                    e.addFragmentCode(S.a);
                    const {vertexAttributes: i} = this
                      , r = i.length;
                    for (let t = 1; t < r; ++t) {
                        const r = i[t];
                        e.addVarying(`highp ${r.glslDataType}`, `vCustom${t}`),
                        n += `vCustom${t} = readAttribute${t}(vertexIndex);\n`,
                        e.addFragmentCode(`#define ${r.name} vCustom${t}\n`)
                    }
                    e.setVertexMain(n),
                    Object(C.b)(t.controls, e),
                    e.setFragmentMainFunction(Object(w.e)(t.code))
                }
            })
        }
        get vertexAttributes() {
            return this.base.vertexAttributes
        }
        defineCommonShader(e) {
            e.addUniform("highp vec4", "uColor"),
            e.addUniform("highp mat4", "uProjection"),
            e.addUniform("highp uint", "uPickID")
        }
        get gl() {
            return this.base.gl
        }
        defineAttributeAccess(e) {
            const {textureAccessHelper: t} = this;
            t.defineShader(e);
            const n = this.vertexAttributes.length;
            for (let e = E.length; e < n; ++e)
                E[e] = Symbol(`SkeletonShader.vertexAttributeTextureUnit${e}`);
            this.vertexAttributes.forEach((n,i)=>{
                e.addTextureSampler(`${Object(O.e)(n.dataType)}sampler2D`, `uVertexAttributeSampler${i}`, E[i]),
                e.addVertexCode(t.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${i}`, n.dataType, n.numComponents))
            }
            )
        }
        getCrossSectionFadeFactor() {
            return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)"
        }
        beginLayer(e, t, n, i) {
            const {viewProjectionMat: r} = n.projectionParameters;
            let s = p.l.multiply(k, r, i);
            e.uniformMatrix4fv(t.uniform("uProjection"), !1, s)
        }
        setColor(e, t, n) {
            e.uniform4fv(t.uniform("uColor"), n)
        }
        setPickID(e, t, n) {
            e.uniform1ui(t.uniform("uPickID"), n)
        }
        drawSkeleton(e, t, n, i, r) {
            const {vertexAttributes: s} = this
              , a = s.length
              , {vertexAttributeTextures: o} = i;
            for (let n = 0; n < a; ++n) {
                const i = WebGL2RenderingContext.TEXTURE0 + t.textureUnit(E[n]);
                e.activeTexture(i),
                e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, o[n])
            }
            {
                t.bind();
                const n = t.attribute("aVertexIndex");
                i.indexBuffer.bindToVertexAttribI(n, 2, WebGL2RenderingContext.UNSIGNED_INT),
                e.vertexAttribDivisor(n, 1),
                this.lineShader.enableAndDraw(t, r, this.targetIsSliceView ? 1 : 0, i.numIndices / 2),
                e.vertexAttribDivisor(n, 0),
                e.disableVertexAttribArray(n)
            }
            null !== n && (n.bind(),
            this.circleShader.draw(n, r, {
                featherWidthInPixels: this.targetIsSliceView ? 1 : 0
            }, i.numVertices))
        }
        endLayer(e, t) {
            const {vertexAttributes: n} = this
              , i = n.length;
            for (let n = 0; n < i; ++n) {
                let i = t.textureUnit(E[n]) + WebGL2RenderingContext.TEXTURE0;
                e.activeTexture(i),
                e.bindTexture(e.TEXTURE_2D, null)
            }
        }
    }
    var D;
    !function(e) {
        e[e.LINES = 0] = "LINES",
        e[e.LINES_AND_POINTS = 1] = "LINES_AND_POINTS"
    }(D || (D = {}));
    class L extends v.a {
        constructor(e, t=e) {
            super(D, e, t)
        }
    }
    class A extends u.c {
        constructor(e, t=e) {
            super(e, f.r, t)
        }
    }
    class I {
        constructor() {
            this.compound = new g.a,
            this.shader = Object(w.a)("void main() {\n  emitDefault();\n}\n"),
            this.shaderControlState = new C.a(this.shader),
            this.params2d = {
                mode: new L(D.LINES_AND_POINTS),
                lineWidth: new A(5)
            },
            this.params3d = {
                mode: new L(D.LINES),
                lineWidth: new A(2)
            };
            const {compound: e} = this;
            e.add("shader", this.shader),
            e.add("shaderControls", this.shaderControlState),
            e.add("mode2d", this.params2d.mode),
            e.add("lineWidth2d", this.params2d.lineWidth),
            e.add("mode3d", this.params3d.mode),
            e.add("lineWidth3d", this.params3d.lineWidth)
        }
        get changed() {
            return this.compound.changed
        }
        reset() {
            this.compound.reset()
        }
        restoreState(e) {
            void 0 !== e && this.compound.restoreState(e)
        }
        toJSON() {
            const e = this.compound.toJSON();
            for (const t in e)
                return e
        }
    }
    class P extends h.a {
        constructor(e, t, n) {
            super(),
            this.chunkManager = e,
            this.source = t,
            this.displayState = n,
            this.redrawNeeded = new m.a,
            this.fallbackShaderParameters = new u.e(Object(C.c)("void main() {\n  emitDefault();\n}\n")),
            Object(l.e)(n, this),
            this.displayState.shaderError.value = void 0;
            const {skeletonRenderingOptions: i} = n;
            this.registerDisposer(i.shader.changed.add(()=>{
                this.displayState.shaderError.value = void 0,
                this.redrawNeeded.dispatch()
            }
            ));
            let r = this.sharedObject = this.registerDisposer(new l.b(e,n));
            r.RPC_TYPE_ID = "skeleton/SkeletonLayer",
            r.initializeCounterpartWithChunkManager({
                source: t.addCounterpartRef()
            });
            const s = this.vertexAttributes = [V];
            for (let[e,n] of t.vertexAttributes)
                s.push({
                    name: e,
                    dataType: n.dataType,
                    numComponents: n.numComponents,
                    webglDataType: N(n.dataType),
                    glslDataType: n.numComponents > 1 ? `vec${n.numComponents}` : "float"
                })
        }
        get visibility() {
            return this.sharedObject.visibility
        }
        get gl() {
            return this.chunkManager.chunkQueueManager.gl
        }
        draw(e, t, n, r, s) {
            let c = r.lineWidth.value;
            const {gl: u, source: d, displayState: h} = this
              , p = Math.min(1, h.objectAlpha.value);
            if (p <= 0)
                return;
            const f = Object(a.g)(h.transform.value, e.projectionParameters.displayDimensionRenderInfo, s);
            if (void 0 === f)
                return;
            let m;
            m = r.mode.value === D.LINES_AND_POINTS ? Math.max(10, 2 * c) : c;
            const g = n.edgeShaderGetter(e.emitter)
              , v = n.nodeShaderGetter(e.emitter)
              , {shader: b, parameters: y} = g
              , {shader: S, parameters: w} = v;
            if (null === b || null === S)
                return;
            const {shaderControlState: x} = this.displayState.skeletonRenderingOptions;
            b.bind(),
            n.beginLayer(u, b, e, f),
            Object(C.d)(u, b, x, y.controls),
            u.uniform1f(b.uniform("uLineWidth"), c),
            S.bind(),
            n.beginLayer(u, S, e, f),
            u.uniform1f(S.uniform("uNodeDiameter"), m),
            Object(C.d)(u, S, x, w.controls);
            const O = d.chunks
              , {pickIDs: k} = e;
            Object(o.a)(h, (r,s)=>{
                const a = Object(o.b)(r)
                  , c = O.get(a);
                void 0 !== c && c.state === i.g.GPU_MEMORY && (e.emitColor && (b.bind(),
                n.setColor(u, b, Object(l.d)(h, s, p)),
                S.bind(),
                n.setColor(u, S, Object(l.d)(h, s, p))),
                e.emitPickID && (b.bind(),
                n.setPickID(u, b, k.registerUint64(t, r)),
                S.bind(),
                n.setPickID(u, S, k.registerUint64(t, r))),
                n.drawSkeleton(u, b, S, c, e.projectionParameters))
            }
            ),
            n.endLayer(u, b)
        }
        isReady() {
            const {source: e, displayState: t} = this;
            if (Math.min(1, t.objectAlpha.value) <= 0)
                return !0;
            const n = e.chunks;
            let r = !0;
            return Object(o.a)(t, e=>{
                const t = Object(o.b)(e)
                  , s = n.get(t);
                void 0 !== s && s.state === i.g.GPU_MEMORY || (r = !1)
            }
            ),
            r
        }
    }
    class R extends s.a {
        constructor(e) {
            super(),
            this.base = e,
            this.renderHelper = this.registerDisposer(new M(this.base,!1)),
            this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d,
            this.registerDisposer(e),
            this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch));
            const {renderOptions: t} = this;
            this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(e.visibility.add(this.visibility))
        }
        get gl() {
            return this.base.gl
        }
        get isTransparent() {
            return this.base.displayState.objectAlpha.value < 1
        }
        draw(e, t) {
            !e.emitColor && e.alreadyEmittedPickID || this.base.draw(e, this, this.renderHelper, this.renderOptions, t)
        }
        isReady() {
            return this.base.isReady()
        }
    }
    class j extends c.a {
        constructor(e) {
            super(),
            this.base = e,
            this.renderHelper = this.registerDisposer(new M(this.base,!0)),
            this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d,
            this.registerDisposer(e);
            const {renderOptions: t} = this;
            this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(e.visibility.add(this.visibility))
        }
        get gl() {
            return this.base.gl
        }
        draw(e, t) {
            this.base.draw(e, this, this.renderHelper, this.renderOptions, t)
        }
        isReady() {
            return this.base.isReady()
        }
    }
    function N(e) {
        switch (e) {
        case d.a.FLOAT32:
            return WebGL2RenderingContext.FLOAT;
        default:
            throw new Error(`Data type not supported by WebGL: ${d.a[e]}`)
        }
    }
    const V = {
        dataType: d.a.FLOAT32,
        numComponents: 3,
        name: "",
        webglDataType: WebGL2RenderingContext.FLOAT,
        glslDataType: "vec3"
    };
    class B extends r.b {
        constructor(e, t) {
            super(e),
            this.vertexAttributes = t.vertexAttributes;
            let n = this.indices = t.indices;
            this.numVertices = t.numVertices,
            this.vertexAttributeOffsets = t.vertexAttributeOffsets,
            this.numIndices = n.length
        }
        copyToGPU(e) {
            super.copyToGPU(e);
            const {attributeTextureFormats: t} = this.source
              , {vertexAttributes: n, vertexAttributeOffsets: i} = this
              , r = this.vertexAttributeTextures = [];
            for (let s = 0, a = i.length; s < a; ++s) {
                const o = e.createTexture();
                e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, o),
                Object(O.f)(e, t[s], n.subarray(i[s], s + 1 !== a ? i[s + 1] : n.length)),
                r[s] = o
            }
            e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null),
            this.indexBuffer = b.a.fromData(e, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW)
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e);
            const {vertexAttributeTextures: t} = this;
            for (const n of t)
                e.deleteTexture(n);
            t.length = 0,
            this.indexBuffer.dispose()
        }
    }
    const F = new Map;
    class _ extends r.e {
        constructor(e, t) {
            super(e, t)
        }
        get attributeTextureFormats() {
            let e = this.attributeTextureFormats_;
            return void 0 === e && (e = this.attributeTextureFormats_ = function(e) {
                const t = [T];
                for (const n of e.values())
                    t.push(Object(O.d)(new O.b, n.dataType, n.numComponents));
                return t
            }(this.vertexAttributes)),
            e
        }
        getChunk(e) {
            return new B(this,e)
        }
        get vertexAttributes() {
            return F
        }
    }
}
, function(e, t, n) {
    e.exports = function() {
        "use strict";
        var e = navigator.userAgent
          , t = navigator.platform
          , n = /gecko\/\d/i.test(e)
          , i = /MSIE \d/.test(e)
          , r = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e)
          , s = /Edge\/(\d+)/.exec(e)
          , a = i || r || s
          , o = a && (i ? document.documentMode || 6 : +(s || r)[1])
          , l = !s && /WebKit\//.test(e)
          , c = l && /Qt\/\d+\.\d+/.test(e)
          , u = !s && /Chrome\//.test(e)
          , d = /Opera\//.test(e)
          , h = /Apple Computer/.test(navigator.vendor)
          , p = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e)
          , f = /PhantomJS/.test(e)
          , m = !s && /AppleWebKit/.test(e) && /Mobile\/\w+/.test(e)
          , g = /Android/.test(e)
          , v = m || g || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e)
          , b = m || /Mac/.test(t)
          , y = /\bCrOS\b/.test(e)
          , S = /win/i.test(t)
          , w = d && e.match(/Version\/(\d*\.\d*)/);
        w && (w = Number(w[1])),
        w && w >= 15 && (d = !1,
        l = !0);
        var x = b && (c || d && (null == w || w < 12.11))
          , C = n || a && o >= 9;
        function O(e) {
            return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
        }
        var k, E = function(e, t) {
            var n = e.className
              , i = O(t).exec(n);
            if (i) {
                var r = n.slice(i.index + i[0].length);
                e.className = n.slice(0, i.index) + (r ? i[1] + r : "")
            }
        };
        function T(e) {
            for (var t = e.childNodes.length; t > 0; --t)
                e.removeChild(e.firstChild);
            return e
        }
        function M(e, t) {
            return T(e).appendChild(t)
        }
        function D(e, t, n, i) {
            var r = document.createElement(e);
            if (n && (r.className = n),
            i && (r.style.cssText = i),
            "string" == typeof t)
                r.appendChild(document.createTextNode(t));
            else if (t)
                for (var s = 0; s < t.length; ++s)
                    r.appendChild(t[s]);
            return r
        }
        function L(e, t, n, i) {
            var r = D(e, t, n, i);
            return r.setAttribute("role", "presentation"),
            r
        }
        function A(e, t) {
            if (3 == t.nodeType && (t = t.parentNode),
            e.contains)
                return e.contains(t);
            do {
                if (11 == t.nodeType && (t = t.host),
                t == e)
                    return !0
            } while (t = t.parentNode)
        }
        function I() {
            var e;
            try {
                e = document.activeElement
            } catch (t) {
                e = document.body || null
            }
            for (; e && e.shadowRoot && e.shadowRoot.activeElement; )
                e = e.shadowRoot.activeElement;
            return e
        }
        function P(e, t) {
            var n = e.className;
            O(t).test(n) || (e.className += (n ? " " : "") + t)
        }
        function R(e, t) {
            for (var n = e.split(" "), i = 0; i < n.length; i++)
                n[i] && !O(n[i]).test(t) && (t += " " + n[i]);
            return t
        }
        k = document.createRange ? function(e, t, n, i) {
            var r = document.createRange();
            return r.setEnd(i || e, n),
            r.setStart(e, t),
            r
        }
        : function(e, t, n) {
            var i = document.body.createTextRange();
            try {
                i.moveToElementText(e.parentNode)
            } catch (e) {
                return i
            }
            return i.collapse(!0),
            i.moveEnd("character", n),
            i.moveStart("character", t),
            i
        }
        ;
        var j = function(e) {
            e.select()
        };
        function N(e) {
            var t = Array.prototype.slice.call(arguments, 1);
            return function() {
                return e.apply(null, t)
            }
        }
        function V(e, t, n) {
            for (var i in t || (t = {}),
            e)
                !e.hasOwnProperty(i) || !1 === n && t.hasOwnProperty(i) || (t[i] = e[i]);
            return t
        }
        function B(e, t, n, i, r) {
            null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length);
            for (var s = i || 0, a = r || 0; ; ) {
                var o = e.indexOf("\t", s);
                if (o < 0 || o >= t)
                    return a + (t - s);
                a += o - s,
                a += n - a % n,
                s = o + 1
            }
        }
        m ? j = function(e) {
            e.selectionStart = 0,
            e.selectionEnd = e.value.length
        }
        : a && (j = function(e) {
            try {
                e.select()
            } catch (e) {}
        }
        );
        var F = function() {
            this.id = null,
            this.f = null,
            this.time = 0,
            this.handler = N(this.onTimeout, this)
        };
        function _(e, t) {
            for (var n = 0; n < e.length; ++n)
                if (e[n] == t)
                    return n;
            return -1
        }
        F.prototype.onTimeout = function(e) {
            e.id = 0,
            e.time <= +new Date ? e.f() : setTimeout(e.handler, e.time - +new Date)
        }
        ,
        F.prototype.set = function(e, t) {
            this.f = t;
            var n = +new Date + e;
            (!this.id || n < this.time) && (clearTimeout(this.id),
            this.id = setTimeout(this.handler, e),
            this.time = n)
        }
        ;
        var U = {
            toString: function() {
                return "CodeMirror.Pass"
            }
        }
          , z = {
            scroll: !1
        }
          , G = {
            origin: "*mouse"
        }
          , $ = {
            origin: "+move"
        };
        function W(e, t, n) {
            for (var i = 0, r = 0; ; ) {
                var s = e.indexOf("\t", i);
                -1 == s && (s = e.length);
                var a = s - i;
                if (s == e.length || r + a >= t)
                    return i + Math.min(a, t - r);
                if (r += s - i,
                i = s + 1,
                (r += n - r % n) >= t)
                    return i
            }
        }
        var H = [""];
        function J(e) {
            for (; H.length <= e; )
                H.push(q(H) + " ");
            return H[e]
        }
        function q(e) {
            return e[e.length - 1]
        }
        function Y(e, t) {
            for (var n = [], i = 0; i < e.length; i++)
                n[i] = t(e[i], i);
            return n
        }
        function X() {}
        function K(e, t) {
            var n;
            return Object.create ? n = Object.create(e) : (X.prototype = e,
            n = new X),
            t && V(t, n),
            n
        }
        var Z = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function Q(e) {
            return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || Z.test(e))
        }
        function ee(e, t) {
            return t ? !!(t.source.indexOf("\\w") > -1 && Q(e)) || t.test(e) : Q(e)
        }
        function te(e) {
            for (var t in e)
                if (e.hasOwnProperty(t) && e[t])
                    return !1;
            return !0
        }
        var ne = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function ie(e) {
            return e.charCodeAt(0) >= 768 && ne.test(e)
        }
        function re(e, t, n) {
            for (; (n < 0 ? t > 0 : t < e.length) && ie(e.charAt(t)); )
                t += n;
            return t
        }
        function se(e, t, n) {
            for (var i = t > n ? -1 : 1; ; ) {
                if (t == n)
                    return t;
                var r = (t + n) / 2
                  , s = i < 0 ? Math.ceil(r) : Math.floor(r);
                if (s == t)
                    return e(s) ? t : n;
                e(s) ? n = s : t = s + i
            }
        }
        var ae = null;
        function oe(e, t, n) {
            var i;
            ae = null;
            for (var r = 0; r < e.length; ++r) {
                var s = e[r];
                if (s.from < t && s.to > t)
                    return r;
                s.to == t && (s.from != s.to && "before" == n ? i = r : ae = r),
                s.from == t && (s.from != s.to && "before" != n ? i = r : ae = r)
            }
            return null != i ? i : ae
        }
        var le = function() {
            var e = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
              , t = /[stwN]/
              , n = /[LRr]/
              , i = /[Lb1n]/
              , r = /[1n]/;
            function s(e, t, n) {
                this.level = e,
                this.from = t,
                this.to = n
            }
            return function(a, o) {
                var l = "ltr" == o ? "L" : "R";
                if (0 == a.length || "ltr" == o && !e.test(a))
                    return !1;
                for (var c, u = a.length, d = [], h = 0; h < u; ++h)
                    d.push((c = a.charCodeAt(h)) <= 247 ? "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(c) : 1424 <= c && c <= 1524 ? "R" : 1536 <= c && c <= 1785 ? "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(c - 1536) : 1774 <= c && c <= 2220 ? "r" : 8192 <= c && c <= 8203 ? "w" : 8204 == c ? "b" : "L");
                for (var p = 0, f = l; p < u; ++p) {
                    var m = d[p];
                    "m" == m ? d[p] = f : f = m
                }
                for (var g = 0, v = l; g < u; ++g) {
                    var b = d[g];
                    "1" == b && "r" == v ? d[g] = "n" : n.test(b) && (v = b,
                    "r" == b && (d[g] = "R"))
                }
                for (var y = 1, S = d[0]; y < u - 1; ++y) {
                    var w = d[y];
                    "+" == w && "1" == S && "1" == d[y + 1] ? d[y] = "1" : "," != w || S != d[y + 1] || "1" != S && "n" != S || (d[y] = S),
                    S = w
                }
                for (var x = 0; x < u; ++x) {
                    var C = d[x];
                    if ("," == C)
                        d[x] = "N";
                    else if ("%" == C) {
                        var O = void 0;
                        for (O = x + 1; O < u && "%" == d[O]; ++O)
                            ;
                        for (var k = x && "!" == d[x - 1] || O < u && "1" == d[O] ? "1" : "N", E = x; E < O; ++E)
                            d[E] = k;
                        x = O - 1
                    }
                }
                for (var T = 0, M = l; T < u; ++T) {
                    var D = d[T];
                    "L" == M && "1" == D ? d[T] = "L" : n.test(D) && (M = D)
                }
                for (var L = 0; L < u; ++L)
                    if (t.test(d[L])) {
                        var A = void 0;
                        for (A = L + 1; A < u && t.test(d[A]); ++A)
                            ;
                        for (var I = "L" == (L ? d[L - 1] : l), P = I == ("L" == (A < u ? d[A] : l)) ? I ? "L" : "R" : l, R = L; R < A; ++R)
                            d[R] = P;
                        L = A - 1
                    }
                for (var j, N = [], V = 0; V < u; )
                    if (i.test(d[V])) {
                        var B = V;
                        for (++V; V < u && i.test(d[V]); ++V)
                            ;
                        N.push(new s(0,B,V))
                    } else {
                        var F = V
                          , _ = N.length;
                        for (++V; V < u && "L" != d[V]; ++V)
                            ;
                        for (var U = F; U < V; )
                            if (r.test(d[U])) {
                                F < U && N.splice(_, 0, new s(1,F,U));
                                var z = U;
                                for (++U; U < V && r.test(d[U]); ++U)
                                    ;
                                N.splice(_, 0, new s(2,z,U)),
                                F = U
                            } else
                                ++U;
                        F < V && N.splice(_, 0, new s(1,F,V))
                    }
                return "ltr" == o && (1 == N[0].level && (j = a.match(/^\s+/)) && (N[0].from = j[0].length,
                N.unshift(new s(0,0,j[0].length))),
                1 == q(N).level && (j = a.match(/\s+$/)) && (q(N).to -= j[0].length,
                N.push(new s(0,u - j[0].length,u)))),
                "rtl" == o ? N.reverse() : N
            }
        }();
        function ce(e, t) {
            var n = e.order;
            return null == n && (n = e.order = le(e.text, t)),
            n
        }
        var ue = []
          , de = function(e, t, n) {
            if (e.addEventListener)
                e.addEventListener(t, n, !1);
            else if (e.attachEvent)
                e.attachEvent("on" + t, n);
            else {
                var i = e._handlers || (e._handlers = {});
                i[t] = (i[t] || ue).concat(n)
            }
        };
        function he(e, t) {
            return e._handlers && e._handlers[t] || ue
        }
        function pe(e, t, n) {
            if (e.removeEventListener)
                e.removeEventListener(t, n, !1);
            else if (e.detachEvent)
                e.detachEvent("on" + t, n);
            else {
                var i = e._handlers
                  , r = i && i[t];
                if (r) {
                    var s = _(r, n);
                    s > -1 && (i[t] = r.slice(0, s).concat(r.slice(s + 1)))
                }
            }
        }
        function fe(e, t) {
            var n = he(e, t);
            if (n.length)
                for (var i = Array.prototype.slice.call(arguments, 2), r = 0; r < n.length; ++r)
                    n[r].apply(null, i)
        }
        function me(e, t, n) {
            return "string" == typeof t && (t = {
                type: t,
                preventDefault: function() {
                    this.defaultPrevented = !0
                }
            }),
            fe(e, n || t.type, e, t),
            we(t) || t.codemirrorIgnore
        }
        function ge(e) {
            var t = e._handlers && e._handlers.cursorActivity;
            if (t)
                for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), i = 0; i < t.length; ++i)
                    -1 == _(n, t[i]) && n.push(t[i])
        }
        function ve(e, t) {
            return he(e, t).length > 0
        }
        function be(e) {
            e.prototype.on = function(e, t) {
                de(this, e, t)
            }
            ,
            e.prototype.off = function(e, t) {
                pe(this, e, t)
            }
        }
        function ye(e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
        }
        function Se(e) {
            e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
        }
        function we(e) {
            return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
        }
        function xe(e) {
            ye(e),
            Se(e)
        }
        function Ce(e) {
            return e.target || e.srcElement
        }
        function Oe(e) {
            var t = e.which;
            return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)),
            b && e.ctrlKey && 1 == t && (t = 3),
            t
        }
        var ke, Ee, Te = function() {
            if (a && o < 9)
                return !1;
            var e = D("div");
            return "draggable"in e || "dragDrop"in e
        }();
        function Me(e) {
            if (null == ke) {
                var t = D("span", "");
                M(e, D("span", [t, document.createTextNode("x")])),
                0 != e.firstChild.offsetHeight && (ke = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(a && o < 8))
            }
            var n = ke ? D("span", "") : D("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
            return n.setAttribute("cm-text", ""),
            n
        }
        function De(e) {
            if (null != Ee)
                return Ee;
            var t = M(e, document.createTextNode("AA"))
              , n = k(t, 0, 1).getBoundingClientRect()
              , i = k(t, 1, 2).getBoundingClientRect();
            return T(e),
            !(!n || n.left == n.right) && (Ee = i.right - n.right < 3)
        }
        var Le, Ae = 3 != "\n\nb".split(/\n/).length ? function(e) {
            for (var t = 0, n = [], i = e.length; t <= i; ) {
                var r = e.indexOf("\n", t);
                -1 == r && (r = e.length);
                var s = e.slice(t, "\r" == e.charAt(r - 1) ? r - 1 : r)
                  , a = s.indexOf("\r");
                -1 != a ? (n.push(s.slice(0, a)),
                t += a + 1) : (n.push(s),
                t = r + 1)
            }
            return n
        }
        : function(e) {
            return e.split(/\r\n?|\n/)
        }
        , Ie = window.getSelection ? function(e) {
            try {
                return e.selectionStart != e.selectionEnd
            } catch (e) {
                return !1
            }
        }
        : function(e) {
            var t;
            try {
                t = e.ownerDocument.selection.createRange()
            } catch (e) {}
            return !(!t || t.parentElement() != e) && 0 != t.compareEndPoints("StartToEnd", t)
        }
        , Pe = "oncopy"in (Le = D("div")) || (Le.setAttribute("oncopy", "return;"),
        "function" == typeof Le.oncopy), Re = null, je = {}, Ne = {};
        function Ve(e, t) {
            arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)),
            je[e] = t
        }
        function Be(e) {
            if ("string" == typeof e && Ne.hasOwnProperty(e))
                e = Ne[e];
            else if (e && "string" == typeof e.name && Ne.hasOwnProperty(e.name)) {
                var t = Ne[e.name];
                "string" == typeof t && (t = {
                    name: t
                }),
                (e = K(t, e)).name = t.name
            } else {
                if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+xml$/.test(e))
                    return Be("application/xml");
                if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+json$/.test(e))
                    return Be("application/json")
            }
            return "string" == typeof e ? {
                name: e
            } : e || {
                name: "null"
            }
        }
        function Fe(e, t) {
            t = Be(t);
            var n = je[t.name];
            if (!n)
                return Fe(e, "text/plain");
            var i = n(e, t);
            if (_e.hasOwnProperty(t.name)) {
                var r = _e[t.name];
                for (var s in r)
                    r.hasOwnProperty(s) && (i.hasOwnProperty(s) && (i["_" + s] = i[s]),
                    i[s] = r[s])
            }
            if (i.name = t.name,
            t.helperType && (i.helperType = t.helperType),
            t.modeProps)
                for (var a in t.modeProps)
                    i[a] = t.modeProps[a];
            return i
        }
        var _e = {};
        function Ue(e, t) {
            V(t, _e.hasOwnProperty(e) ? _e[e] : _e[e] = {})
        }
        function ze(e, t) {
            if (!0 === t)
                return t;
            if (e.copyState)
                return e.copyState(t);
            var n = {};
            for (var i in t) {
                var r = t[i];
                r instanceof Array && (r = r.concat([])),
                n[i] = r
            }
            return n
        }
        function Ge(e, t) {
            for (var n; e.innerMode && (n = e.innerMode(t)) && n.mode != e; )
                t = n.state,
                e = n.mode;
            return n || {
                mode: e,
                state: t
            }
        }
        function $e(e, t, n) {
            return !e.startState || e.startState(t, n)
        }
        var We = function(e, t, n) {
            this.pos = this.start = 0,
            this.string = e,
            this.tabSize = t || 8,
            this.lastColumnPos = this.lastColumnValue = 0,
            this.lineStart = 0,
            this.lineOracle = n
        };
        function He(e, t) {
            if ((t -= e.first) < 0 || t >= e.size)
                throw new Error("There is no line " + (t + e.first) + " in the document.");
            for (var n = e; !n.lines; )
                for (var i = 0; ; ++i) {
                    var r = n.children[i]
                      , s = r.chunkSize();
                    if (t < s) {
                        n = r;
                        break
                    }
                    t -= s
                }
            return n.lines[t]
        }
        function Je(e, t, n) {
            var i = []
              , r = t.line;
            return e.iter(t.line, n.line + 1, (function(e) {
                var s = e.text;
                r == n.line && (s = s.slice(0, n.ch)),
                r == t.line && (s = s.slice(t.ch)),
                i.push(s),
                ++r
            }
            )),
            i
        }
        function qe(e, t, n) {
            var i = [];
            return e.iter(t, n, (function(e) {
                i.push(e.text)
            }
            )),
            i
        }
        function Ye(e, t) {
            var n = t - e.height;
            if (n)
                for (var i = e; i; i = i.parent)
                    i.height += n
        }
        function Xe(e) {
            if (null == e.parent)
                return null;
            for (var t = e.parent, n = _(t.lines, e), i = t.parent; i; t = i,
            i = i.parent)
                for (var r = 0; i.children[r] != t; ++r)
                    n += i.children[r].chunkSize();
            return n + t.first
        }
        function Ke(e, t) {
            var n = e.first;
            e: do {
                for (var i = 0; i < e.children.length; ++i) {
                    var r = e.children[i]
                      , s = r.height;
                    if (t < s) {
                        e = r;
                        continue e
                    }
                    t -= s,
                    n += r.chunkSize()
                }
                return n
            } while (!e.lines);for (var a = 0; a < e.lines.length; ++a) {
                var o = e.lines[a].height;
                if (t < o)
                    break;
                t -= o
            }
            return n + a
        }
        function Ze(e, t) {
            return t >= e.first && t < e.first + e.size
        }
        function Qe(e, t) {
            return String(e.lineNumberFormatter(t + e.firstLineNumber))
        }
        function et(e, t, n) {
            if (void 0 === n && (n = null),
            !(this instanceof et))
                return new et(e,t,n);
            this.line = e,
            this.ch = t,
            this.sticky = n
        }
        function tt(e, t) {
            return e.line - t.line || e.ch - t.ch
        }
        function nt(e, t) {
            return e.sticky == t.sticky && 0 == tt(e, t)
        }
        function it(e) {
            return et(e.line, e.ch)
        }
        function rt(e, t) {
            return tt(e, t) < 0 ? t : e
        }
        function st(e, t) {
            return tt(e, t) < 0 ? e : t
        }
        function at(e, t) {
            return Math.max(e.first, Math.min(t, e.first + e.size - 1))
        }
        function ot(e, t) {
            if (t.line < e.first)
                return et(e.first, 0);
            var n = e.first + e.size - 1;
            return t.line > n ? et(n, He(e, n).text.length) : function(e, t) {
                var n = e.ch;
                return null == n || n > t ? et(e.line, t) : n < 0 ? et(e.line, 0) : e
            }(t, He(e, t.line).text.length)
        }
        function lt(e, t) {
            for (var n = [], i = 0; i < t.length; i++)
                n[i] = ot(e, t[i]);
            return n
        }
        We.prototype.eol = function() {
            return this.pos >= this.string.length
        }
        ,
        We.prototype.sol = function() {
            return this.pos == this.lineStart
        }
        ,
        We.prototype.peek = function() {
            return this.string.charAt(this.pos) || void 0
        }
        ,
        We.prototype.next = function() {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++)
        }
        ,
        We.prototype.eat = function(e) {
            var t = this.string.charAt(this.pos);
            if ("string" == typeof e ? t == e : t && (e.test ? e.test(t) : e(t)))
                return ++this.pos,
                t
        }
        ,
        We.prototype.eatWhile = function(e) {
            for (var t = this.pos; this.eat(e); )
                ;
            return this.pos > t
        }
        ,
        We.prototype.eatSpace = function() {
            for (var e = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
                ++this.pos;
            return this.pos > e
        }
        ,
        We.prototype.skipToEnd = function() {
            this.pos = this.string.length
        }
        ,
        We.prototype.skipTo = function(e) {
            var t = this.string.indexOf(e, this.pos);
            if (t > -1)
                return this.pos = t,
                !0
        }
        ,
        We.prototype.backUp = function(e) {
            this.pos -= e
        }
        ,
        We.prototype.column = function() {
            return this.lastColumnPos < this.start && (this.lastColumnValue = B(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue),
            this.lastColumnPos = this.start),
            this.lastColumnValue - (this.lineStart ? B(this.string, this.lineStart, this.tabSize) : 0)
        }
        ,
        We.prototype.indentation = function() {
            return B(this.string, null, this.tabSize) - (this.lineStart ? B(this.string, this.lineStart, this.tabSize) : 0)
        }
        ,
        We.prototype.match = function(e, t, n) {
            if ("string" != typeof e) {
                var i = this.string.slice(this.pos).match(e);
                return i && i.index > 0 ? null : (i && !1 !== t && (this.pos += i[0].length),
                i)
            }
            var r = function(e) {
                return n ? e.toLowerCase() : e
            };
            if (r(this.string.substr(this.pos, e.length)) == r(e))
                return !1 !== t && (this.pos += e.length),
                !0
        }
        ,
        We.prototype.current = function() {
            return this.string.slice(this.start, this.pos)
        }
        ,
        We.prototype.hideFirstChars = function(e, t) {
            this.lineStart += e;
            try {
                return t()
            } finally {
                this.lineStart -= e
            }
        }
        ,
        We.prototype.lookAhead = function(e) {
            var t = this.lineOracle;
            return t && t.lookAhead(e)
        }
        ,
        We.prototype.baseToken = function() {
            var e = this.lineOracle;
            return e && e.baseToken(this.pos)
        }
        ;
        var ct = function(e, t) {
            this.state = e,
            this.lookAhead = t
        }
          , ut = function(e, t, n, i) {
            this.state = t,
            this.doc = e,
            this.line = n,
            this.maxLookAhead = i || 0,
            this.baseTokens = null,
            this.baseTokenPos = 1
        };
        function dt(e, t, n, i) {
            var r = [e.state.modeGen]
              , s = {};
            St(e, t.text, e.doc.mode, n, (function(e, t) {
                return r.push(e, t)
            }
            ), s, i);
            for (var a = n.state, o = function(i) {
                n.baseTokens = r;
                var o = e.state.overlays[i]
                  , l = 1
                  , c = 0;
                n.state = !0,
                St(e, t.text, o.mode, n, (function(e, t) {
                    for (var n = l; c < e; ) {
                        var i = r[l];
                        i > e && r.splice(l, 1, e, r[l + 1], i),
                        l += 2,
                        c = Math.min(e, i)
                    }
                    if (t)
                        if (o.opaque)
                            r.splice(n, l - n, e, "overlay " + t),
                            l = n + 2;
                        else
                            for (; n < l; n += 2) {
                                var s = r[n + 1];
                                r[n + 1] = (s ? s + " " : "") + "overlay " + t
                            }
                }
                ), s),
                n.state = a,
                n.baseTokens = null,
                n.baseTokenPos = 1
            }, l = 0; l < e.state.overlays.length; ++l)
                o(l);
            return {
                styles: r,
                classes: s.bgClass || s.textClass ? s : null
            }
        }
        function ht(e, t, n) {
            if (!t.styles || t.styles[0] != e.state.modeGen) {
                var i = pt(e, Xe(t))
                  , r = t.text.length > e.options.maxHighlightLength && ze(e.doc.mode, i.state)
                  , s = dt(e, t, i);
                r && (i.state = r),
                t.stateAfter = i.save(!r),
                t.styles = s.styles,
                s.classes ? t.styleClasses = s.classes : t.styleClasses && (t.styleClasses = null),
                n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier))
            }
            return t.styles
        }
        function pt(e, t, n) {
            var i = e.doc
              , r = e.display;
            if (!i.mode.startState)
                return new ut(i,!0,t);
            var s = function(e, t, n) {
                for (var i, r, s = e.doc, a = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), o = t; o > a; --o) {
                    if (o <= s.first)
                        return s.first;
                    var l = He(s, o - 1)
                      , c = l.stateAfter;
                    if (c && (!n || o + (c instanceof ct ? c.lookAhead : 0) <= s.modeFrontier))
                        return o;
                    var u = B(l.text, null, e.options.tabSize);
                    (null == r || i > u) && (r = o - 1,
                    i = u)
                }
                return r
            }(e, t, n)
              , a = s > i.first && He(i, s - 1).stateAfter
              , o = a ? ut.fromSaved(i, a, s) : new ut(i,$e(i.mode),s);
            return i.iter(s, t, (function(n) {
                ft(e, n.text, o);
                var i = o.line;
                n.stateAfter = i == t - 1 || i % 5 == 0 || i >= r.viewFrom && i < r.viewTo ? o.save() : null,
                o.nextLine()
            }
            )),
            n && (i.modeFrontier = o.line),
            o
        }
        function ft(e, t, n, i) {
            var r = e.doc.mode
              , s = new We(t,e.options.tabSize,n);
            for (s.start = s.pos = i || 0,
            "" == t && mt(r, n.state); !s.eol(); )
                gt(r, s, n.state),
                s.start = s.pos
        }
        function mt(e, t) {
            if (e.blankLine)
                return e.blankLine(t);
            if (e.innerMode) {
                var n = Ge(e, t);
                return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0
            }
        }
        function gt(e, t, n, i) {
            for (var r = 0; r < 10; r++) {
                i && (i[0] = Ge(e, n).mode);
                var s = e.token(t, n);
                if (t.pos > t.start)
                    return s
            }
            throw new Error("Mode " + e.name + " failed to advance stream.")
        }
        ut.prototype.lookAhead = function(e) {
            var t = this.doc.getLine(this.line + e);
            return null != t && e > this.maxLookAhead && (this.maxLookAhead = e),
            t
        }
        ,
        ut.prototype.baseToken = function(e) {
            if (!this.baseTokens)
                return null;
            for (; this.baseTokens[this.baseTokenPos] <= e; )
                this.baseTokenPos += 2;
            var t = this.baseTokens[this.baseTokenPos + 1];
            return {
                type: t && t.replace(/( |^)overlay .*/, ""),
                size: this.baseTokens[this.baseTokenPos] - e
            }
        }
        ,
        ut.prototype.nextLine = function() {
            this.line++,
            this.maxLookAhead > 0 && this.maxLookAhead--
        }
        ,
        ut.fromSaved = function(e, t, n) {
            return t instanceof ct ? new ut(e,ze(e.mode, t.state),n,t.lookAhead) : new ut(e,ze(e.mode, t),n)
        }
        ,
        ut.prototype.save = function(e) {
            var t = !1 !== e ? ze(this.doc.mode, this.state) : this.state;
            return this.maxLookAhead > 0 ? new ct(t,this.maxLookAhead) : t
        }
        ;
        var vt = function(e, t, n) {
            this.start = e.start,
            this.end = e.pos,
            this.string = e.current(),
            this.type = t || null,
            this.state = n
        };
        function bt(e, t, n, i) {
            var r, s, a = e.doc, o = a.mode, l = He(a, (t = ot(a, t)).line), c = pt(e, t.line, n), u = new We(l.text,e.options.tabSize,c);
            for (i && (s = []); (i || u.pos < t.ch) && !u.eol(); )
                u.start = u.pos,
                r = gt(o, u, c.state),
                i && s.push(new vt(u,r,ze(a.mode, c.state)));
            return i ? s : new vt(u,r,c.state)
        }
        function yt(e, t) {
            if (e)
                for (; ; ) {
                    var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!n)
                        break;
                    e = e.slice(0, n.index) + e.slice(n.index + n[0].length);
                    var i = n[1] ? "bgClass" : "textClass";
                    null == t[i] ? t[i] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(t[i]) || (t[i] += " " + n[2])
                }
            return e
        }
        function St(e, t, n, i, r, s, a) {
            var o = n.flattenSpans;
            null == o && (o = e.options.flattenSpans);
            var l, c = 0, u = null, d = new We(t,e.options.tabSize,i), h = e.options.addModeClass && [null];
            for ("" == t && yt(mt(n, i.state), s); !d.eol(); ) {
                if (d.pos > e.options.maxHighlightLength ? (o = !1,
                a && ft(e, t, i, d.pos),
                d.pos = t.length,
                l = null) : l = yt(gt(n, d, i.state, h), s),
                h) {
                    var p = h[0].name;
                    p && (l = "m-" + (l ? p + " " + l : p))
                }
                if (!o || u != l) {
                    for (; c < d.start; )
                        r(c = Math.min(d.start, c + 5e3), u);
                    u = l
                }
                d.start = d.pos
            }
            for (; c < d.pos; ) {
                var f = Math.min(d.pos, c + 5e3);
                r(f, u),
                c = f
            }
        }
        var wt = !1
          , xt = !1;
        function Ct(e, t, n) {
            this.marker = e,
            this.from = t,
            this.to = n
        }
        function Ot(e, t) {
            if (e)
                for (var n = 0; n < e.length; ++n) {
                    var i = e[n];
                    if (i.marker == t)
                        return i
                }
        }
        function kt(e, t) {
            for (var n, i = 0; i < e.length; ++i)
                e[i] != t && (n || (n = [])).push(e[i]);
            return n
        }
        function Et(e, t) {
            if (t.full)
                return null;
            var n = Ze(e, t.from.line) && He(e, t.from.line).markedSpans
              , i = Ze(e, t.to.line) && He(e, t.to.line).markedSpans;
            if (!n && !i)
                return null;
            var r = t.from.ch
              , s = t.to.ch
              , a = 0 == tt(t.from, t.to)
              , o = function(e, t, n) {
                var i;
                if (e)
                    for (var r = 0; r < e.length; ++r) {
                        var s = e[r]
                          , a = s.marker;
                        if (null == s.from || (a.inclusiveLeft ? s.from <= t : s.from < t) || s.from == t && "bookmark" == a.type && (!n || !s.marker.insertLeft)) {
                            var o = null == s.to || (a.inclusiveRight ? s.to >= t : s.to > t);
                            (i || (i = [])).push(new Ct(a,s.from,o ? null : s.to))
                        }
                    }
                return i
            }(n, r, a)
              , l = function(e, t, n) {
                var i;
                if (e)
                    for (var r = 0; r < e.length; ++r) {
                        var s = e[r]
                          , a = s.marker;
                        if (null == s.to || (a.inclusiveRight ? s.to >= t : s.to > t) || s.from == t && "bookmark" == a.type && (!n || s.marker.insertLeft)) {
                            var o = null == s.from || (a.inclusiveLeft ? s.from <= t : s.from < t);
                            (i || (i = [])).push(new Ct(a,o ? null : s.from - t,null == s.to ? null : s.to - t))
                        }
                    }
                return i
            }(i, s, a)
              , c = 1 == t.text.length
              , u = q(t.text).length + (c ? r : 0);
            if (o)
                for (var d = 0; d < o.length; ++d) {
                    var h = o[d];
                    if (null == h.to) {
                        var p = Ot(l, h.marker);
                        p ? c && (h.to = null == p.to ? null : p.to + u) : h.to = r
                    }
                }
            if (l)
                for (var f = 0; f < l.length; ++f) {
                    var m = l[f];
                    null != m.to && (m.to += u),
                    null == m.from ? Ot(o, m.marker) || (m.from = u,
                    c && (o || (o = [])).push(m)) : (m.from += u,
                    c && (o || (o = [])).push(m))
                }
            o && (o = Tt(o)),
            l && l != o && (l = Tt(l));
            var g = [o];
            if (!c) {
                var v, b = t.text.length - 2;
                if (b > 0 && o)
                    for (var y = 0; y < o.length; ++y)
                        null == o[y].to && (v || (v = [])).push(new Ct(o[y].marker,null,null));
                for (var S = 0; S < b; ++S)
                    g.push(v);
                g.push(l)
            }
            return g
        }
        function Tt(e) {
            for (var t = 0; t < e.length; ++t) {
                var n = e[t];
                null != n.from && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1)
            }
            return e.length ? e : null
        }
        function Mt(e) {
            var t = e.markedSpans;
            if (t) {
                for (var n = 0; n < t.length; ++n)
                    t[n].marker.detachLine(e);
                e.markedSpans = null
            }
        }
        function Dt(e, t) {
            if (t) {
                for (var n = 0; n < t.length; ++n)
                    t[n].marker.attachLine(e);
                e.markedSpans = t
            }
        }
        function Lt(e) {
            return e.inclusiveLeft ? -1 : 0
        }
        function At(e) {
            return e.inclusiveRight ? 1 : 0
        }
        function It(e, t) {
            var n = e.lines.length - t.lines.length;
            if (0 != n)
                return n;
            var i = e.find()
              , r = t.find()
              , s = tt(i.from, r.from) || Lt(e) - Lt(t);
            if (s)
                return -s;
            var a = tt(i.to, r.to) || At(e) - At(t);
            return a || t.id - e.id
        }
        function Pt(e, t) {
            var n, i = xt && e.markedSpans;
            if (i)
                for (var r = void 0, s = 0; s < i.length; ++s)
                    (r = i[s]).marker.collapsed && null == (t ? r.from : r.to) && (!n || It(n, r.marker) < 0) && (n = r.marker);
            return n
        }
        function Rt(e) {
            return Pt(e, !0)
        }
        function jt(e) {
            return Pt(e, !1)
        }
        function Nt(e, t) {
            var n, i = xt && e.markedSpans;
            if (i)
                for (var r = 0; r < i.length; ++r) {
                    var s = i[r];
                    s.marker.collapsed && (null == s.from || s.from < t) && (null == s.to || s.to > t) && (!n || It(n, s.marker) < 0) && (n = s.marker)
                }
            return n
        }
        function Vt(e, t, n, i, r) {
            var s = He(e, t)
              , a = xt && s.markedSpans;
            if (a)
                for (var o = 0; o < a.length; ++o) {
                    var l = a[o];
                    if (l.marker.collapsed) {
                        var c = l.marker.find(0)
                          , u = tt(c.from, n) || Lt(l.marker) - Lt(r)
                          , d = tt(c.to, i) || At(l.marker) - At(r);
                        if (!(u >= 0 && d <= 0 || u <= 0 && d >= 0) && (u <= 0 && (l.marker.inclusiveRight && r.inclusiveLeft ? tt(c.to, n) >= 0 : tt(c.to, n) > 0) || u >= 0 && (l.marker.inclusiveRight && r.inclusiveLeft ? tt(c.from, i) <= 0 : tt(c.from, i) < 0)))
                            return !0
                    }
                }
        }
        function Bt(e) {
            for (var t; t = Rt(e); )
                e = t.find(-1, !0).line;
            return e
        }
        function Ft(e, t) {
            var n = He(e, t)
              , i = Bt(n);
            return n == i ? t : Xe(i)
        }
        function _t(e, t) {
            if (t > e.lastLine())
                return t;
            var n, i = He(e, t);
            if (!Ut(e, i))
                return t;
            for (; n = jt(i); )
                i = n.find(1, !0).line;
            return Xe(i) + 1
        }
        function Ut(e, t) {
            var n = xt && t.markedSpans;
            if (n)
                for (var i = void 0, r = 0; r < n.length; ++r)
                    if ((i = n[r]).marker.collapsed) {
                        if (null == i.from)
                            return !0;
                        if (!i.marker.widgetNode && 0 == i.from && i.marker.inclusiveLeft && zt(e, t, i))
                            return !0
                    }
        }
        function zt(e, t, n) {
            if (null == n.to) {
                var i = n.marker.find(1, !0);
                return zt(e, i.line, Ot(i.line.markedSpans, n.marker))
            }
            if (n.marker.inclusiveRight && n.to == t.text.length)
                return !0;
            for (var r = void 0, s = 0; s < t.markedSpans.length; ++s)
                if ((r = t.markedSpans[s]).marker.collapsed && !r.marker.widgetNode && r.from == n.to && (null == r.to || r.to != n.from) && (r.marker.inclusiveLeft || n.marker.inclusiveRight) && zt(e, t, r))
                    return !0
        }
        function Gt(e) {
            for (var t = 0, n = (e = Bt(e)).parent, i = 0; i < n.lines.length; ++i) {
                var r = n.lines[i];
                if (r == e)
                    break;
                t += r.height
            }
            for (var s = n.parent; s; s = (n = s).parent)
                for (var a = 0; a < s.children.length; ++a) {
                    var o = s.children[a];
                    if (o == n)
                        break;
                    t += o.height
                }
            return t
        }
        function $t(e) {
            if (0 == e.height)
                return 0;
            for (var t, n = e.text.length, i = e; t = Rt(i); ) {
                var r = t.find(0, !0);
                i = r.from.line,
                n += r.from.ch - r.to.ch
            }
            for (i = e; t = jt(i); ) {
                var s = t.find(0, !0);
                n -= i.text.length - s.from.ch,
                n += (i = s.to.line).text.length - s.to.ch
            }
            return n
        }
        function Wt(e) {
            var t = e.display
              , n = e.doc;
            t.maxLine = He(n, n.first),
            t.maxLineLength = $t(t.maxLine),
            t.maxLineChanged = !0,
            n.iter((function(e) {
                var n = $t(e);
                n > t.maxLineLength && (t.maxLineLength = n,
                t.maxLine = e)
            }
            ))
        }
        var Ht = function(e, t, n) {
            this.text = e,
            Dt(this, t),
            this.height = n ? n(this) : 1
        };
        function Jt(e) {
            e.parent = null,
            Mt(e)
        }
        Ht.prototype.lineNo = function() {
            return Xe(this)
        }
        ,
        be(Ht);
        var qt = {}
          , Yt = {};
        function Xt(e, t) {
            if (!e || /^\s*$/.test(e))
                return null;
            var n = t.addModeClass ? Yt : qt;
            return n[e] || (n[e] = e.replace(/\S+/g, "cm-$&"))
        }
        function Kt(e, t) {
            var n = L("span", null, null, l ? "padding-right: .1px" : null)
              , i = {
                pre: L("pre", [n], "CodeMirror-line"),
                content: n,
                col: 0,
                pos: 0,
                cm: e,
                trailingSpace: !1,
                splitSpaces: e.getOption("lineWrapping")
            };
            t.measure = {};
            for (var r = 0; r <= (t.rest ? t.rest.length : 0); r++) {
                var s = r ? t.rest[r - 1] : t.line
                  , a = void 0;
                i.pos = 0,
                i.addToken = Qt,
                De(e.display.measure) && (a = ce(s, e.doc.direction)) && (i.addToken = en(i.addToken, a)),
                i.map = [],
                nn(s, i, ht(e, s, t != e.display.externalMeasured && Xe(s))),
                s.styleClasses && (s.styleClasses.bgClass && (i.bgClass = R(s.styleClasses.bgClass, i.bgClass || "")),
                s.styleClasses.textClass && (i.textClass = R(s.styleClasses.textClass, i.textClass || ""))),
                0 == i.map.length && i.map.push(0, 0, i.content.appendChild(Me(e.display.measure))),
                0 == r ? (t.measure.map = i.map,
                t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(i.map),
                (t.measure.caches || (t.measure.caches = [])).push({}))
            }
            if (l) {
                var o = i.content.lastChild;
                (/\bcm-tab\b/.test(o.className) || o.querySelector && o.querySelector(".cm-tab")) && (i.content.className = "cm-tab-wrap-hack")
            }
            return fe(e, "renderLine", e, t.line, i.pre),
            i.pre.className && (i.textClass = R(i.pre.className, i.textClass || "")),
            i
        }
        function Zt(e) {
            var t = D("span", "", "cm-invalidchar");
            return t.title = "\\u" + e.charCodeAt(0).toString(16),
            t.setAttribute("aria-label", t.title),
            t
        }
        function Qt(e, t, n, i, r, s, l) {
            if (t) {
                var c, u = e.splitSpaces ? function(e, t) {
                    if (e.length > 1 && !/  /.test(e))
                        return e;
                    for (var n = t, i = "", r = 0; r < e.length; r++) {
                        var s = e.charAt(r);
                        " " != s || !n || r != e.length - 1 && 32 != e.charCodeAt(r + 1) || (s = ""),
                        i += s,
                        n = " " == s
                    }
                    return i
                }(t, e.trailingSpace) : t, d = e.cm.state.specialChars, h = !1;
                if (d.test(t)) {
                    c = document.createDocumentFragment();
                    for (var p = 0; ; ) {
                        d.lastIndex = p;
                        var f = d.exec(t)
                          , m = f ? f.index - p : t.length - p;
                        if (m) {
                            var g = document.createTextNode(u.slice(p, p + m));
                            a && o < 9 ? c.appendChild(D("span", [g])) : c.appendChild(g),
                            e.map.push(e.pos, e.pos + m, g),
                            e.col += m,
                            e.pos += m
                        }
                        if (!f)
                            break;
                        p += m + 1;
                        var v = void 0;
                        if ("\t" == f[0]) {
                            var b = e.cm.options.tabSize
                              , y = b - e.col % b;
                            (v = c.appendChild(D("span", J(y), "cm-tab"))).setAttribute("role", "presentation"),
                            v.setAttribute("cm-text", "\t"),
                            e.col += y
                        } else
                            "\r" == f[0] || "\n" == f[0] ? ((v = c.appendChild(D("span", "\r" == f[0] ? "" : "", "cm-invalidchar"))).setAttribute("cm-text", f[0]),
                            e.col += 1) : ((v = e.cm.options.specialCharPlaceholder(f[0])).setAttribute("cm-text", f[0]),
                            a && o < 9 ? c.appendChild(D("span", [v])) : c.appendChild(v),
                            e.col += 1);
                        e.map.push(e.pos, e.pos + 1, v),
                        e.pos++
                    }
                } else
                    e.col += t.length,
                    c = document.createTextNode(u),
                    e.map.push(e.pos, e.pos + t.length, c),
                    a && o < 9 && (h = !0),
                    e.pos += t.length;
                if (e.trailingSpace = 32 == u.charCodeAt(t.length - 1),
                n || i || r || h || s) {
                    var S = n || "";
                    i && (S += i),
                    r && (S += r);
                    var w = D("span", [c], S, s);
                    if (l)
                        for (var x in l)
                            l.hasOwnProperty(x) && "style" != x && "class" != x && w.setAttribute(x, l[x]);
                    return e.content.appendChild(w)
                }
                e.content.appendChild(c)
            }
        }
        function en(e, t) {
            return function(n, i, r, s, a, o, l) {
                r = r ? r + " cm-force-border" : "cm-force-border";
                for (var c = n.pos, u = c + i.length; ; ) {
                    for (var d = void 0, h = 0; h < t.length && !((d = t[h]).to > c && d.from <= c); h++)
                        ;
                    if (d.to >= u)
                        return e(n, i, r, s, a, o, l);
                    e(n, i.slice(0, d.to - c), r, s, null, o, l),
                    s = null,
                    i = i.slice(d.to - c),
                    c = d.to
                }
            }
        }
        function tn(e, t, n, i) {
            var r = !i && n.widgetNode;
            r && e.map.push(e.pos, e.pos + t, r),
            !i && e.cm.display.input.needsContentAttribute && (r || (r = e.content.appendChild(document.createElement("span"))),
            r.setAttribute("cm-marker", n.id)),
            r && (e.cm.display.input.setUneditable(r),
            e.content.appendChild(r)),
            e.pos += t,
            e.trailingSpace = !1
        }
        function nn(e, t, n) {
            var i = e.markedSpans
              , r = e.text
              , s = 0;
            if (i)
                for (var a, o, l, c, u, d, h, p = r.length, f = 0, m = 1, g = "", v = 0; ; ) {
                    if (v == f) {
                        l = c = u = o = "",
                        h = null,
                        d = null,
                        v = 1 / 0;
                        for (var b = [], y = void 0, S = 0; S < i.length; ++S) {
                            var w = i[S]
                              , x = w.marker;
                            if ("bookmark" == x.type && w.from == f && x.widgetNode)
                                b.push(x);
                            else if (w.from <= f && (null == w.to || w.to > f || x.collapsed && w.to == f && w.from == f)) {
                                if (null != w.to && w.to != f && v > w.to && (v = w.to,
                                c = ""),
                                x.className && (l += " " + x.className),
                                x.css && (o = (o ? o + ";" : "") + x.css),
                                x.startStyle && w.from == f && (u += " " + x.startStyle),
                                x.endStyle && w.to == v && (y || (y = [])).push(x.endStyle, w.to),
                                x.title && ((h || (h = {})).title = x.title),
                                x.attributes)
                                    for (var C in x.attributes)
                                        (h || (h = {}))[C] = x.attributes[C];
                                x.collapsed && (!d || It(d.marker, x) < 0) && (d = w)
                            } else
                                w.from > f && v > w.from && (v = w.from)
                        }
                        if (y)
                            for (var O = 0; O < y.length; O += 2)
                                y[O + 1] == v && (c += " " + y[O]);
                        if (!d || d.from == f)
                            for (var k = 0; k < b.length; ++k)
                                tn(t, 0, b[k]);
                        if (d && (d.from || 0) == f) {
                            if (tn(t, (null == d.to ? p + 1 : d.to) - f, d.marker, null == d.from),
                            null == d.to)
                                return;
                            d.to == f && (d = !1)
                        }
                    }
                    if (f >= p)
                        break;
                    for (var E = Math.min(p, v); ; ) {
                        if (g) {
                            var T = f + g.length;
                            if (!d) {
                                var M = T > E ? g.slice(0, E - f) : g;
                                t.addToken(t, M, a ? a + l : l, u, f + M.length == v ? c : "", o, h)
                            }
                            if (T >= E) {
                                g = g.slice(E - f),
                                f = E;
                                break
                            }
                            f = T,
                            u = ""
                        }
                        g = r.slice(s, s = n[m++]),
                        a = Xt(n[m++], t.cm.options)
                    }
                }
            else
                for (var D = 1; D < n.length; D += 2)
                    t.addToken(t, r.slice(s, s = n[D]), Xt(n[D + 1], t.cm.options))
        }
        function rn(e, t, n) {
            this.line = t,
            this.rest = function(e) {
                for (var t, n; t = jt(e); )
                    e = t.find(1, !0).line,
                    (n || (n = [])).push(e);
                return n
            }(t),
            this.size = this.rest ? Xe(q(this.rest)) - n + 1 : 1,
            this.node = this.text = null,
            this.hidden = Ut(e, t)
        }
        function sn(e, t, n) {
            for (var i, r = [], s = t; s < n; s = i) {
                var a = new rn(e.doc,He(e.doc, s),s);
                i = s + a.size,
                r.push(a)
            }
            return r
        }
        var an = null
          , on = null;
        function ln(e, t) {
            var n = he(e, t);
            if (n.length) {
                var i, r = Array.prototype.slice.call(arguments, 2);
                an ? i = an.delayedCallbacks : on ? i = on : (i = on = [],
                setTimeout(cn, 0));
                for (var s = function(e) {
                    i.push((function() {
                        return n[e].apply(null, r)
                    }
                    ))
                }, a = 0; a < n.length; ++a)
                    s(a)
            }
        }
        function cn() {
            var e = on;
            on = null;
            for (var t = 0; t < e.length; ++t)
                e[t]()
        }
        function un(e, t, n, i) {
            for (var r = 0; r < t.changes.length; r++) {
                var s = t.changes[r];
                "text" == s ? pn(e, t) : "gutter" == s ? mn(e, t, n, i) : "class" == s ? fn(e, t) : "widget" == s && gn(e, t, i)
            }
            t.changes = null
        }
        function dn(e) {
            return e.node == e.text && (e.node = D("div", null, null, "position: relative"),
            e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text),
            e.node.appendChild(e.text),
            a && o < 8 && (e.node.style.zIndex = 2)),
            e.node
        }
        function hn(e, t) {
            var n = e.display.externalMeasured;
            return n && n.line == t.line ? (e.display.externalMeasured = null,
            t.measure = n.measure,
            n.built) : Kt(e, t)
        }
        function pn(e, t) {
            var n = t.text.className
              , i = hn(e, t);
            t.text == t.node && (t.node = i.pre),
            t.text.parentNode.replaceChild(i.pre, t.text),
            t.text = i.pre,
            i.bgClass != t.bgClass || i.textClass != t.textClass ? (t.bgClass = i.bgClass,
            t.textClass = i.textClass,
            fn(e, t)) : n && (t.text.className = n)
        }
        function fn(e, t) {
            !function(e, t) {
                var n = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
                if (n && (n += " CodeMirror-linebackground"),
                t.background)
                    n ? t.background.className = n : (t.background.parentNode.removeChild(t.background),
                    t.background = null);
                else if (n) {
                    var i = dn(t);
                    t.background = i.insertBefore(D("div", null, n), i.firstChild),
                    e.display.input.setUneditable(t.background)
                }
            }(e, t),
            t.line.wrapClass ? dn(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
            var n = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
            t.text.className = n || ""
        }
        function mn(e, t, n, i) {
            if (t.gutter && (t.node.removeChild(t.gutter),
            t.gutter = null),
            t.gutterBackground && (t.node.removeChild(t.gutterBackground),
            t.gutterBackground = null),
            t.line.gutterClass) {
                var r = dn(t);
                t.gutterBackground = D("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? i.fixedPos : -i.gutterTotalWidth) + "px; width: " + i.gutterTotalWidth + "px"),
                e.display.input.setUneditable(t.gutterBackground),
                r.insertBefore(t.gutterBackground, t.text)
            }
            var s = t.line.gutterMarkers;
            if (e.options.lineNumbers || s) {
                var a = dn(t)
                  , o = t.gutter = D("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? i.fixedPos : -i.gutterTotalWidth) + "px");
                if (e.display.input.setUneditable(o),
                a.insertBefore(o, t.text),
                t.line.gutterClass && (o.className += " " + t.line.gutterClass),
                !e.options.lineNumbers || s && s["CodeMirror-linenumbers"] || (t.lineNumber = o.appendChild(D("div", Qe(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + i.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))),
                s)
                    for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
                        var c = e.display.gutterSpecs[l].className
                          , u = s.hasOwnProperty(c) && s[c];
                        u && o.appendChild(D("div", [u], "CodeMirror-gutter-elt", "left: " + i.gutterLeft[c] + "px; width: " + i.gutterWidth[c] + "px"))
                    }
            }
        }
        function gn(e, t, n) {
            t.alignable && (t.alignable = null);
            for (var i = O("CodeMirror-linewidget"), r = t.node.firstChild, s = void 0; r; r = s)
                s = r.nextSibling,
                i.test(r.className) && t.node.removeChild(r);
            bn(e, t, n)
        }
        function vn(e, t, n, i) {
            var r = hn(e, t);
            return t.text = t.node = r.pre,
            r.bgClass && (t.bgClass = r.bgClass),
            r.textClass && (t.textClass = r.textClass),
            fn(e, t),
            mn(e, t, n, i),
            bn(e, t, i),
            t.node
        }
        function bn(e, t, n) {
            if (yn(e, t.line, t, n, !0),
            t.rest)
                for (var i = 0; i < t.rest.length; i++)
                    yn(e, t.rest[i], t, n, !1)
        }
        function yn(e, t, n, i, r) {
            if (t.widgets)
                for (var s = dn(n), a = 0, o = t.widgets; a < o.length; ++a) {
                    var l = o[a]
                      , c = D("div", [l.node], "CodeMirror-linewidget" + (l.className ? " " + l.className : ""));
                    l.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"),
                    Sn(l, c, n, i),
                    e.display.input.setUneditable(c),
                    r && l.above ? s.insertBefore(c, n.gutter || n.text) : s.appendChild(c),
                    ln(l, "redraw")
                }
        }
        function Sn(e, t, n, i) {
            if (e.noHScroll) {
                (n.alignable || (n.alignable = [])).push(t);
                var r = i.wrapperWidth;
                t.style.left = i.fixedPos + "px",
                e.coverGutter || (r -= i.gutterTotalWidth,
                t.style.paddingLeft = i.gutterTotalWidth + "px"),
                t.style.width = r + "px"
            }
            e.coverGutter && (t.style.zIndex = 5,
            t.style.position = "relative",
            e.noHScroll || (t.style.marginLeft = -i.gutterTotalWidth + "px"))
        }
        function wn(e) {
            if (null != e.height)
                return e.height;
            var t = e.doc.cm;
            if (!t)
                return 0;
            if (!A(document.body, e.node)) {
                var n = "position: relative;";
                e.coverGutter && (n += "margin-left: -" + t.display.gutters.offsetWidth + "px;"),
                e.noHScroll && (n += "width: " + t.display.wrapper.clientWidth + "px;"),
                M(t.display.measure, D("div", [e.node], null, n))
            }
            return e.height = e.node.parentNode.offsetHeight
        }
        function xn(e, t) {
            for (var n = Ce(t); n != e.wrapper; n = n.parentNode)
                if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover)
                    return !0
        }
        function Cn(e) {
            return e.lineSpace.offsetTop
        }
        function On(e) {
            return e.mover.offsetHeight - e.lineSpace.offsetHeight
        }
        function kn(e) {
            if (e.cachedPaddingH)
                return e.cachedPaddingH;
            var t = M(e.measure, D("pre", "x", "CodeMirror-line-like"))
              , n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle
              , i = {
                left: parseInt(n.paddingLeft),
                right: parseInt(n.paddingRight)
            };
            return isNaN(i.left) || isNaN(i.right) || (e.cachedPaddingH = i),
            i
        }
        function En(e) {
            return 30 - e.display.nativeBarWidth
        }
        function Tn(e) {
            return e.display.scroller.clientWidth - En(e) - e.display.barWidth
        }
        function Mn(e) {
            return e.display.scroller.clientHeight - En(e) - e.display.barHeight
        }
        function Dn(e, t, n) {
            if (e.line == t)
                return {
                    map: e.measure.map,
                    cache: e.measure.cache
                };
            for (var i = 0; i < e.rest.length; i++)
                if (e.rest[i] == t)
                    return {
                        map: e.measure.maps[i],
                        cache: e.measure.caches[i]
                    };
            for (var r = 0; r < e.rest.length; r++)
                if (Xe(e.rest[r]) > n)
                    return {
                        map: e.measure.maps[r],
                        cache: e.measure.caches[r],
                        before: !0
                    }
        }
        function Ln(e, t, n, i) {
            return Pn(e, In(e, t), n, i)
        }
        function An(e, t) {
            if (t >= e.display.viewFrom && t < e.display.viewTo)
                return e.display.view[ui(e, t)];
            var n = e.display.externalMeasured;
            return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0
        }
        function In(e, t) {
            var n = Xe(t)
              , i = An(e, n);
            i && !i.text ? i = null : i && i.changes && (un(e, i, n, si(e)),
            e.curOp.forceUpdate = !0),
            i || (i = function(e, t) {
                var n = Xe(t = Bt(t))
                  , i = e.display.externalMeasured = new rn(e.doc,t,n);
                i.lineN = n;
                var r = i.built = Kt(e, i);
                return i.text = r.pre,
                M(e.display.lineMeasure, r.pre),
                i
            }(e, t));
            var r = Dn(i, t, n);
            return {
                line: t,
                view: i,
                rect: null,
                map: r.map,
                cache: r.cache,
                before: r.before,
                hasHeights: !1
            }
        }
        function Pn(e, t, n, i, r) {
            t.before && (n = -1);
            var s, l = n + (i || "");
            return t.cache.hasOwnProperty(l) ? s = t.cache[l] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()),
            t.hasHeights || (function(e, t, n) {
                var i = e.options.lineWrapping
                  , r = i && Tn(e);
                if (!t.measure.heights || i && t.measure.width != r) {
                    var s = t.measure.heights = [];
                    if (i) {
                        t.measure.width = r;
                        for (var a = t.text.firstChild.getClientRects(), o = 0; o < a.length - 1; o++) {
                            var l = a[o]
                              , c = a[o + 1];
                            Math.abs(l.bottom - c.bottom) > 2 && s.push((l.bottom + c.top) / 2 - n.top)
                        }
                    }
                    s.push(n.bottom - n.top)
                }
            }(e, t.view, t.rect),
            t.hasHeights = !0),
            (s = function(e, t, n, i) {
                var r, s = Nn(t.map, n, i), l = s.node, c = s.start, u = s.end, d = s.collapse;
                if (3 == l.nodeType) {
                    for (var h = 0; h < 4; h++) {
                        for (; c && ie(t.line.text.charAt(s.coverStart + c)); )
                            --c;
                        for (; s.coverStart + u < s.coverEnd && ie(t.line.text.charAt(s.coverStart + u)); )
                            ++u;
                        if ((r = a && o < 9 && 0 == c && u == s.coverEnd - s.coverStart ? l.parentNode.getBoundingClientRect() : Vn(k(l, c, u).getClientRects(), i)).left || r.right || 0 == c)
                            break;
                        u = c,
                        c -= 1,
                        d = "right"
                    }
                    a && o < 11 && (r = function(e, t) {
                        if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !function(e) {
                            if (null != Re)
                                return Re;
                            var t = M(e, D("span", "x"))
                              , n = t.getBoundingClientRect()
                              , i = k(t, 0, 1).getBoundingClientRect();
                            return Re = Math.abs(n.left - i.left) > 1
                        }(e))
                            return t;
                        var n = screen.logicalXDPI / screen.deviceXDPI
                          , i = screen.logicalYDPI / screen.deviceYDPI;
                        return {
                            left: t.left * n,
                            right: t.right * n,
                            top: t.top * i,
                            bottom: t.bottom * i
                        }
                    }(e.display.measure, r))
                } else {
                    var p;
                    c > 0 && (d = i = "right"),
                    r = e.options.lineWrapping && (p = l.getClientRects()).length > 1 ? p["right" == i ? p.length - 1 : 0] : l.getBoundingClientRect()
                }
                if (a && o < 9 && !c && (!r || !r.left && !r.right)) {
                    var f = l.parentNode.getClientRects()[0];
                    r = f ? {
                        left: f.left,
                        right: f.left + ri(e.display),
                        top: f.top,
                        bottom: f.bottom
                    } : jn
                }
                for (var m = r.top - t.rect.top, g = r.bottom - t.rect.top, v = (m + g) / 2, b = t.view.measure.heights, y = 0; y < b.length - 1 && !(v < b[y]); y++)
                    ;
                var S = y ? b[y - 1] : 0
                  , w = b[y]
                  , x = {
                    left: ("right" == d ? r.right : r.left) - t.rect.left,
                    right: ("left" == d ? r.left : r.right) - t.rect.left,
                    top: S,
                    bottom: w
                };
                return r.left || r.right || (x.bogus = !0),
                e.options.singleCursorHeightPerLine || (x.rtop = m,
                x.rbottom = g),
                x
            }(e, t, n, i)).bogus || (t.cache[l] = s)),
            {
                left: s.left,
                right: s.right,
                top: r ? s.rtop : s.top,
                bottom: r ? s.rbottom : s.bottom
            }
        }
        var Rn, jn = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
        function Nn(e, t, n) {
            for (var i, r, s, a, o, l, c = 0; c < e.length; c += 3)
                if (o = e[c],
                l = e[c + 1],
                t < o ? (r = 0,
                s = 1,
                a = "left") : t < l ? s = 1 + (r = t - o) : (c == e.length - 3 || t == l && e[c + 3] > t) && (r = (s = l - o) - 1,
                t >= l && (a = "right")),
                null != r) {
                    if (i = e[c + 2],
                    o == l && n == (i.insertLeft ? "left" : "right") && (a = n),
                    "left" == n && 0 == r)
                        for (; c && e[c - 2] == e[c - 3] && e[c - 1].insertLeft; )
                            i = e[2 + (c -= 3)],
                            a = "left";
                    if ("right" == n && r == l - o)
                        for (; c < e.length - 3 && e[c + 3] == e[c + 4] && !e[c + 5].insertLeft; )
                            i = e[(c += 3) + 2],
                            a = "right";
                    break
                }
            return {
                node: i,
                start: r,
                end: s,
                collapse: a,
                coverStart: o,
                coverEnd: l
            }
        }
        function Vn(e, t) {
            var n = jn;
            if ("left" == t)
                for (var i = 0; i < e.length && (n = e[i]).left == n.right; i++)
                    ;
            else
                for (var r = e.length - 1; r >= 0 && (n = e[r]).left == n.right; r--)
                    ;
            return n
        }
        function Bn(e) {
            if (e.measure && (e.measure.cache = {},
            e.measure.heights = null,
            e.rest))
                for (var t = 0; t < e.rest.length; t++)
                    e.measure.caches[t] = {}
        }
        function Fn(e) {
            e.display.externalMeasure = null,
            T(e.display.lineMeasure);
            for (var t = 0; t < e.display.view.length; t++)
                Bn(e.display.view[t])
        }
        function _n(e) {
            Fn(e),
            e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null,
            e.options.lineWrapping || (e.display.maxLineChanged = !0),
            e.display.lineNumChars = null
        }
        function Un() {
            return u && g ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft
        }
        function zn() {
            return u && g ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop
        }
        function Gn(e) {
            var t = 0;
            if (e.widgets)
                for (var n = 0; n < e.widgets.length; ++n)
                    e.widgets[n].above && (t += wn(e.widgets[n]));
            return t
        }
        function $n(e, t, n, i, r) {
            if (!r) {
                var s = Gn(t);
                n.top += s,
                n.bottom += s
            }
            if ("line" == i)
                return n;
            i || (i = "local");
            var a = Gt(t);
            if ("local" == i ? a += Cn(e.display) : a -= e.display.viewOffset,
            "page" == i || "window" == i) {
                var o = e.display.lineSpace.getBoundingClientRect();
                a += o.top + ("window" == i ? 0 : zn());
                var l = o.left + ("window" == i ? 0 : Un());
                n.left += l,
                n.right += l
            }
            return n.top += a,
            n.bottom += a,
            n
        }
        function Wn(e, t, n) {
            if ("div" == n)
                return t;
            var i = t.left
              , r = t.top;
            if ("page" == n)
                i -= Un(),
                r -= zn();
            else if ("local" == n || !n) {
                var s = e.display.sizer.getBoundingClientRect();
                i += s.left,
                r += s.top
            }
            var a = e.display.lineSpace.getBoundingClientRect();
            return {
                left: i - a.left,
                top: r - a.top
            }
        }
        function Hn(e, t, n, i, r) {
            return i || (i = He(e.doc, t.line)),
            $n(e, i, Ln(e, i, t.ch, r), n)
        }
        function Jn(e, t, n, i, r, s) {
            function a(t, a) {
                var o = Pn(e, r, t, a ? "right" : "left", s);
                return a ? o.left = o.right : o.right = o.left,
                $n(e, i, o, n)
            }
            i = i || He(e.doc, t.line),
            r || (r = In(e, i));
            var o = ce(i, e.doc.direction)
              , l = t.ch
              , c = t.sticky;
            if (l >= i.text.length ? (l = i.text.length,
            c = "before") : l <= 0 && (l = 0,
            c = "after"),
            !o)
                return a("before" == c ? l - 1 : l, "before" == c);
            function u(e, t, n) {
                return a(n ? e - 1 : e, 1 == o[t].level != n)
            }
            var d = oe(o, l, c)
              , h = ae
              , p = u(l, d, "before" == c);
            return null != h && (p.other = u(l, h, "before" != c)),
            p
        }
        function qn(e, t) {
            var n = 0;
            t = ot(e.doc, t),
            e.options.lineWrapping || (n = ri(e.display) * t.ch);
            var i = He(e.doc, t.line)
              , r = Gt(i) + Cn(e.display);
            return {
                left: n,
                right: n,
                top: r,
                bottom: r + i.height
            }
        }
        function Yn(e, t, n, i, r) {
            var s = et(e, t, n);
            return s.xRel = r,
            i && (s.outside = i),
            s
        }
        function Xn(e, t, n) {
            var i = e.doc;
            if ((n += e.display.viewOffset) < 0)
                return Yn(i.first, 0, null, -1, -1);
            var r = Ke(i, n)
              , s = i.first + i.size - 1;
            if (r > s)
                return Yn(i.first + i.size - 1, He(i, s).text.length, null, 1, 1);
            t < 0 && (t = 0);
            for (var a = He(i, r); ; ) {
                var o = ei(e, a, r, t, n)
                  , l = Nt(a, o.ch + (o.xRel > 0 || o.outside > 0 ? 1 : 0));
                if (!l)
                    return o;
                var c = l.find(1);
                if (c.line == r)
                    return c;
                a = He(i, r = c.line)
            }
        }
        function Kn(e, t, n, i) {
            i -= Gn(t);
            var r = t.text.length
              , s = se((function(t) {
                return Pn(e, n, t - 1).bottom <= i
            }
            ), r, 0);
            return {
                begin: s,
                end: r = se((function(t) {
                    return Pn(e, n, t).top > i
                }
                ), s, r)
            }
        }
        function Zn(e, t, n, i) {
            return n || (n = In(e, t)),
            Kn(e, t, n, $n(e, t, Pn(e, n, i), "line").top)
        }
        function Qn(e, t, n, i) {
            return !(e.bottom <= n) && (e.top > n || (i ? e.left : e.right) > t)
        }
        function ei(e, t, n, i, r) {
            r -= Gt(t);
            var s = In(e, t)
              , a = Gn(t)
              , o = 0
              , l = t.text.length
              , c = !0
              , u = ce(t, e.doc.direction);
            if (u) {
                var d = (e.options.lineWrapping ? ni : ti)(e, t, n, s, u, i, r);
                o = (c = 1 != d.level) ? d.from : d.to - 1,
                l = c ? d.to : d.from - 1
            }
            var h, p, f = null, m = null, g = se((function(t) {
                var n = Pn(e, s, t);
                return n.top += a,
                n.bottom += a,
                !!Qn(n, i, r, !1) && (n.top <= r && n.left <= i && (f = t,
                m = n),
                !0)
            }
            ), o, l), v = !1;
            if (m) {
                var b = i - m.left < m.right - i
                  , y = b == c;
                g = f + (y ? 0 : 1),
                p = y ? "after" : "before",
                h = b ? m.left : m.right
            } else {
                c || g != l && g != o || g++,
                p = 0 == g ? "after" : g == t.text.length ? "before" : Pn(e, s, g - (c ? 1 : 0)).bottom + a <= r == c ? "after" : "before";
                var S = Jn(e, et(n, g, p), "line", t, s);
                h = S.left,
                v = r < S.top ? -1 : r >= S.bottom ? 1 : 0
            }
            return Yn(n, g = re(t.text, g, 1), p, v, i - h)
        }
        function ti(e, t, n, i, r, s, a) {
            var o = se((function(o) {
                var l = r[o]
                  , c = 1 != l.level;
                return Qn(Jn(e, et(n, c ? l.to : l.from, c ? "before" : "after"), "line", t, i), s, a, !0)
            }
            ), 0, r.length - 1)
              , l = r[o];
            if (o > 0) {
                var c = 1 != l.level
                  , u = Jn(e, et(n, c ? l.from : l.to, c ? "after" : "before"), "line", t, i);
                Qn(u, s, a, !0) && u.top > a && (l = r[o - 1])
            }
            return l
        }
        function ni(e, t, n, i, r, s, a) {
            var o = Kn(e, t, i, a)
              , l = o.begin
              , c = o.end;
            /\s/.test(t.text.charAt(c - 1)) && c--;
            for (var u = null, d = null, h = 0; h < r.length; h++) {
                var p = r[h];
                if (!(p.from >= c || p.to <= l)) {
                    var f = Pn(e, i, 1 != p.level ? Math.min(c, p.to) - 1 : Math.max(l, p.from)).right
                      , m = f < s ? s - f + 1e9 : f - s;
                    (!u || d > m) && (u = p,
                    d = m)
                }
            }
            return u || (u = r[r.length - 1]),
            u.from < l && (u = {
                from: l,
                to: u.to,
                level: u.level
            }),
            u.to > c && (u = {
                from: u.from,
                to: c,
                level: u.level
            }),
            u
        }
        function ii(e) {
            if (null != e.cachedTextHeight)
                return e.cachedTextHeight;
            if (null == Rn) {
                Rn = D("pre", null, "CodeMirror-line-like");
                for (var t = 0; t < 49; ++t)
                    Rn.appendChild(document.createTextNode("x")),
                    Rn.appendChild(D("br"));
                Rn.appendChild(document.createTextNode("x"))
            }
            M(e.measure, Rn);
            var n = Rn.offsetHeight / 50;
            return n > 3 && (e.cachedTextHeight = n),
            T(e.measure),
            n || 1
        }
        function ri(e) {
            if (null != e.cachedCharWidth)
                return e.cachedCharWidth;
            var t = D("span", "xxxxxxxxxx")
              , n = D("pre", [t], "CodeMirror-line-like");
            M(e.measure, n);
            var i = t.getBoundingClientRect()
              , r = (i.right - i.left) / 10;
            return r > 2 && (e.cachedCharWidth = r),
            r || 10
        }
        function si(e) {
            for (var t = e.display, n = {}, i = {}, r = t.gutters.clientLeft, s = t.gutters.firstChild, a = 0; s; s = s.nextSibling,
            ++a) {
                var o = e.display.gutterSpecs[a].className;
                n[o] = s.offsetLeft + s.clientLeft + r,
                i[o] = s.clientWidth
            }
            return {
                fixedPos: ai(t),
                gutterTotalWidth: t.gutters.offsetWidth,
                gutterLeft: n,
                gutterWidth: i,
                wrapperWidth: t.wrapper.clientWidth
            }
        }
        function ai(e) {
            return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left
        }
        function oi(e) {
            var t = ii(e.display)
              , n = e.options.lineWrapping
              , i = n && Math.max(5, e.display.scroller.clientWidth / ri(e.display) - 3);
            return function(r) {
                if (Ut(e.doc, r))
                    return 0;
                var s = 0;
                if (r.widgets)
                    for (var a = 0; a < r.widgets.length; a++)
                        r.widgets[a].height && (s += r.widgets[a].height);
                return n ? s + (Math.ceil(r.text.length / i) || 1) * t : s + t
            }
        }
        function li(e) {
            var t = e.doc
              , n = oi(e);
            t.iter((function(e) {
                var t = n(e);
                t != e.height && Ye(e, t)
            }
            ))
        }
        function ci(e, t, n, i) {
            var r = e.display;
            if (!n && "true" == Ce(t).getAttribute("cm-not-content"))
                return null;
            var s, a, o = r.lineSpace.getBoundingClientRect();
            try {
                s = t.clientX - o.left,
                a = t.clientY - o.top
            } catch (t) {
                return null
            }
            var l, c = Xn(e, s, a);
            if (i && c.xRel > 0 && (l = He(e.doc, c.line).text).length == c.ch) {
                var u = B(l, l.length, e.options.tabSize) - l.length;
                c = et(c.line, Math.max(0, Math.round((s - kn(e.display).left) / ri(e.display)) - u))
            }
            return c
        }
        function ui(e, t) {
            if (t >= e.display.viewTo)
                return null;
            if ((t -= e.display.viewFrom) < 0)
                return null;
            for (var n = e.display.view, i = 0; i < n.length; i++)
                if ((t -= n[i].size) < 0)
                    return i
        }
        function di(e, t, n, i) {
            null == t && (t = e.doc.first),
            null == n && (n = e.doc.first + e.doc.size),
            i || (i = 0);
            var r = e.display;
            if (i && n < r.viewTo && (null == r.updateLineNumbers || r.updateLineNumbers > t) && (r.updateLineNumbers = t),
            e.curOp.viewChanged = !0,
            t >= r.viewTo)
                xt && Ft(e.doc, t) < r.viewTo && pi(e);
            else if (n <= r.viewFrom)
                xt && _t(e.doc, n + i) > r.viewFrom ? pi(e) : (r.viewFrom += i,
                r.viewTo += i);
            else if (t <= r.viewFrom && n >= r.viewTo)
                pi(e);
            else if (t <= r.viewFrom) {
                var s = fi(e, n, n + i, 1);
                s ? (r.view = r.view.slice(s.index),
                r.viewFrom = s.lineN,
                r.viewTo += i) : pi(e)
            } else if (n >= r.viewTo) {
                var a = fi(e, t, t, -1);
                a ? (r.view = r.view.slice(0, a.index),
                r.viewTo = a.lineN) : pi(e)
            } else {
                var o = fi(e, t, t, -1)
                  , l = fi(e, n, n + i, 1);
                o && l ? (r.view = r.view.slice(0, o.index).concat(sn(e, o.lineN, l.lineN)).concat(r.view.slice(l.index)),
                r.viewTo += i) : pi(e)
            }
            var c = r.externalMeasured;
            c && (n < c.lineN ? c.lineN += i : t < c.lineN + c.size && (r.externalMeasured = null))
        }
        function hi(e, t, n) {
            e.curOp.viewChanged = !0;
            var i = e.display
              , r = e.display.externalMeasured;
            if (r && t >= r.lineN && t < r.lineN + r.size && (i.externalMeasured = null),
            !(t < i.viewFrom || t >= i.viewTo)) {
                var s = i.view[ui(e, t)];
                if (null != s.node) {
                    var a = s.changes || (s.changes = []);
                    -1 == _(a, n) && a.push(n)
                }
            }
        }
        function pi(e) {
            e.display.viewFrom = e.display.viewTo = e.doc.first,
            e.display.view = [],
            e.display.viewOffset = 0
        }
        function fi(e, t, n, i) {
            var r, s = ui(e, t), a = e.display.view;
            if (!xt || n == e.doc.first + e.doc.size)
                return {
                    index: s,
                    lineN: n
                };
            for (var o = e.display.viewFrom, l = 0; l < s; l++)
                o += a[l].size;
            if (o != t) {
                if (i > 0) {
                    if (s == a.length - 1)
                        return null;
                    r = o + a[s].size - t,
                    s++
                } else
                    r = o - t;
                t += r,
                n += r
            }
            for (; Ft(e.doc, n) != n; ) {
                if (s == (i < 0 ? 0 : a.length - 1))
                    return null;
                n += i * a[s - (i < 0 ? 1 : 0)].size,
                s += i
            }
            return {
                index: s,
                lineN: n
            }
        }
        function mi(e) {
            for (var t = e.display.view, n = 0, i = 0; i < t.length; i++) {
                var r = t[i];
                r.hidden || r.node && !r.changes || ++n
            }
            return n
        }
        function gi(e) {
            e.display.input.showSelection(e.display.input.prepareSelection())
        }
        function vi(e, t) {
            void 0 === t && (t = !0);
            for (var n = e.doc, i = {}, r = i.cursors = document.createDocumentFragment(), s = i.selection = document.createDocumentFragment(), a = 0; a < n.sel.ranges.length; a++)
                if (t || a != n.sel.primIndex) {
                    var o = n.sel.ranges[a];
                    if (!(o.from().line >= e.display.viewTo || o.to().line < e.display.viewFrom)) {
                        var l = o.empty();
                        (l || e.options.showCursorWhenSelecting) && bi(e, o.head, r),
                        l || Si(e, o, s)
                    }
                }
            return i
        }
        function bi(e, t, n) {
            var i = Jn(e, t, "div", null, null, !e.options.singleCursorHeightPerLine)
              , r = n.appendChild(D("div", "", "CodeMirror-cursor"));
            if (r.style.left = i.left + "px",
            r.style.top = i.top + "px",
            r.style.height = Math.max(0, i.bottom - i.top) * e.options.cursorHeight + "px",
            i.other) {
                var s = n.appendChild(D("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
                s.style.display = "",
                s.style.left = i.other.left + "px",
                s.style.top = i.other.top + "px",
                s.style.height = .85 * (i.other.bottom - i.other.top) + "px"
            }
        }
        function yi(e, t) {
            return e.top - t.top || e.left - t.left
        }
        function Si(e, t, n) {
            var i = e.display
              , r = e.doc
              , s = document.createDocumentFragment()
              , a = kn(e.display)
              , o = a.left
              , l = Math.max(i.sizerWidth, Tn(e) - i.sizer.offsetLeft) - a.right
              , c = "ltr" == r.direction;
            function u(e, t, n, i) {
                t < 0 && (t = 0),
                t = Math.round(t),
                i = Math.round(i),
                s.appendChild(D("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px;\n                             top: " + t + "px; width: " + (null == n ? l - e : n) + "px;\n                             height: " + (i - t) + "px"))
            }
            function d(t, n, i) {
                var s, a, d = He(r, t), h = d.text.length;
                function p(n, i) {
                    return Hn(e, et(t, n), "div", d, i)
                }
                function f(t, n, i) {
                    var r = Zn(e, d, null, t)
                      , s = "ltr" == n == ("after" == i) ? "left" : "right";
                    return p("after" == i ? r.begin : r.end - (/\s/.test(d.text.charAt(r.end - 1)) ? 2 : 1), s)[s]
                }
                var m = ce(d, r.direction);
                return function(e, t, n, i) {
                    if (!e)
                        return i(t, n, "ltr", 0);
                    for (var r = !1, s = 0; s < e.length; ++s) {
                        var a = e[s];
                        (a.from < n && a.to > t || t == n && a.to == t) && (i(Math.max(a.from, t), Math.min(a.to, n), 1 == a.level ? "rtl" : "ltr", s),
                        r = !0)
                    }
                    r || i(t, n, "ltr")
                }(m, n || 0, null == i ? h : i, (function(e, t, r, d) {
                    var g = "ltr" == r
                      , v = p(e, g ? "left" : "right")
                      , b = p(t - 1, g ? "right" : "left")
                      , y = null == n && 0 == e
                      , S = null == i && t == h
                      , w = 0 == d
                      , x = !m || d == m.length - 1;
                    if (b.top - v.top <= 3) {
                        var C = (c ? S : y) && x
                          , O = (c ? y : S) && w ? o : (g ? v : b).left
                          , k = C ? l : (g ? b : v).right;
                        u(O, v.top, k - O, v.bottom)
                    } else {
                        var E, T, M, D;
                        g ? (E = c && y && w ? o : v.left,
                        T = c ? l : f(e, r, "before"),
                        M = c ? o : f(t, r, "after"),
                        D = c && S && x ? l : b.right) : (E = c ? f(e, r, "before") : o,
                        T = !c && y && w ? l : v.right,
                        M = !c && S && x ? o : b.left,
                        D = c ? f(t, r, "after") : l),
                        u(E, v.top, T - E, v.bottom),
                        v.bottom < b.top && u(o, v.bottom, null, b.top),
                        u(M, b.top, D - M, b.bottom)
                    }
                    (!s || yi(v, s) < 0) && (s = v),
                    yi(b, s) < 0 && (s = b),
                    (!a || yi(v, a) < 0) && (a = v),
                    yi(b, a) < 0 && (a = b)
                }
                )),
                {
                    start: s,
                    end: a
                }
            }
            var h = t.from()
              , p = t.to();
            if (h.line == p.line)
                d(h.line, h.ch, p.ch);
            else {
                var f = He(r, h.line)
                  , m = He(r, p.line)
                  , g = Bt(f) == Bt(m)
                  , v = d(h.line, h.ch, g ? f.text.length + 1 : null).end
                  , b = d(p.line, g ? 0 : null, p.ch).start;
                g && (v.top < b.top - 2 ? (u(v.right, v.top, null, v.bottom),
                u(o, b.top, b.left, b.bottom)) : u(v.right, v.top, b.left - v.right, v.bottom)),
                v.bottom < b.top && u(o, v.bottom, null, b.top)
            }
            n.appendChild(s)
        }
        function wi(e) {
            if (e.state.focused) {
                var t = e.display;
                clearInterval(t.blinker);
                var n = !0;
                t.cursorDiv.style.visibility = "",
                e.options.cursorBlinkRate > 0 ? t.blinker = setInterval((function() {
                    return t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden"
                }
                ), e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")
            }
        }
        function xi(e) {
            e.state.focused || (e.display.input.focus(),
            Oi(e))
        }
        function Ci(e) {
            e.state.delayingBlurEvent = !0,
            setTimeout((function() {
                e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1,
                ki(e))
            }
            ), 100)
        }
        function Oi(e, t) {
            e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1),
            "nocursor" != e.options.readOnly && (e.state.focused || (fe(e, "focus", e, t),
            e.state.focused = !0,
            P(e.display.wrapper, "CodeMirror-focused"),
            e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(),
            l && setTimeout((function() {
                return e.display.input.reset(!0)
            }
            ), 20)),
            e.display.input.receivedFocus()),
            wi(e))
        }
        function ki(e, t) {
            e.state.delayingBlurEvent || (e.state.focused && (fe(e, "blur", e, t),
            e.state.focused = !1,
            E(e.display.wrapper, "CodeMirror-focused")),
            clearInterval(e.display.blinker),
            setTimeout((function() {
                e.state.focused || (e.display.shift = !1)
            }
            ), 150))
        }
        function Ei(e) {
            for (var t = e.display, n = t.lineDiv.offsetTop, i = 0; i < t.view.length; i++) {
                var r = t.view[i]
                  , s = e.options.lineWrapping
                  , l = void 0
                  , c = 0;
                if (!r.hidden) {
                    if (a && o < 8) {
                        var u = r.node.offsetTop + r.node.offsetHeight;
                        l = u - n,
                        n = u
                    } else {
                        var d = r.node.getBoundingClientRect();
                        l = d.bottom - d.top,
                        !s && r.text.firstChild && (c = r.text.firstChild.getBoundingClientRect().right - d.left - 1)
                    }
                    var h = r.line.height - l;
                    if ((h > .005 || h < -.005) && (Ye(r.line, l),
                    Ti(r.line),
                    r.rest))
                        for (var p = 0; p < r.rest.length; p++)
                            Ti(r.rest[p]);
                    if (c > e.display.sizerWidth) {
                        var f = Math.ceil(c / ri(e.display));
                        f > e.display.maxLineLength && (e.display.maxLineLength = f,
                        e.display.maxLine = r.line,
                        e.display.maxLineChanged = !0)
                    }
                }
            }
        }
        function Ti(e) {
            if (e.widgets)
                for (var t = 0; t < e.widgets.length; ++t) {
                    var n = e.widgets[t]
                      , i = n.node.parentNode;
                    i && (n.height = i.offsetHeight)
                }
        }
        function Mi(e, t, n) {
            var i = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop;
            i = Math.floor(i - Cn(e));
            var r = n && null != n.bottom ? n.bottom : i + e.wrapper.clientHeight
              , s = Ke(t, i)
              , a = Ke(t, r);
            if (n && n.ensure) {
                var o = n.ensure.from.line
                  , l = n.ensure.to.line;
                o < s ? (s = o,
                a = Ke(t, Gt(He(t, o)) + e.wrapper.clientHeight)) : Math.min(l, t.lastLine()) >= a && (s = Ke(t, Gt(He(t, l)) - e.wrapper.clientHeight),
                a = l)
            }
            return {
                from: s,
                to: Math.max(a, s + 1)
            }
        }
        function Di(e, t) {
            var n = e.display
              , i = ii(e.display);
            t.top < 0 && (t.top = 0);
            var r = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : n.scroller.scrollTop
              , s = Mn(e)
              , a = {};
            t.bottom - t.top > s && (t.bottom = t.top + s);
            var o = e.doc.height + On(n)
              , l = t.top < i
              , c = t.bottom > o - i;
            if (t.top < r)
                a.scrollTop = l ? 0 : t.top;
            else if (t.bottom > r + s) {
                var u = Math.min(t.top, (c ? o : t.bottom) - s);
                u != r && (a.scrollTop = u)
            }
            var d = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : n.scroller.scrollLeft
              , h = Tn(e) - (e.options.fixedGutter ? n.gutters.offsetWidth : 0)
              , p = t.right - t.left > h;
            return p && (t.right = t.left + h),
            t.left < 10 ? a.scrollLeft = 0 : t.left < d ? a.scrollLeft = Math.max(0, t.left - (p ? 0 : 10)) : t.right > h + d - 3 && (a.scrollLeft = t.right + (p ? 0 : 10) - h),
            a
        }
        function Li(e, t) {
            null != t && (Pi(e),
            e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + t)
        }
        function Ai(e) {
            Pi(e);
            var t = e.getCursor();
            e.curOp.scrollToPos = {
                from: t,
                to: t,
                margin: e.options.cursorScrollMargin
            }
        }
        function Ii(e, t, n) {
            null == t && null == n || Pi(e),
            null != t && (e.curOp.scrollLeft = t),
            null != n && (e.curOp.scrollTop = n)
        }
        function Pi(e) {
            var t = e.curOp.scrollToPos;
            t && (e.curOp.scrollToPos = null,
            Ri(e, qn(e, t.from), qn(e, t.to), t.margin))
        }
        function Ri(e, t, n, i) {
            var r = Di(e, {
                left: Math.min(t.left, n.left),
                top: Math.min(t.top, n.top) - i,
                right: Math.max(t.right, n.right),
                bottom: Math.max(t.bottom, n.bottom) + i
            });
            Ii(e, r.scrollLeft, r.scrollTop)
        }
        function ji(e, t) {
            Math.abs(e.doc.scrollTop - t) < 2 || (n || lr(e, {
                top: t
            }),
            Ni(e, t, !0),
            n && lr(e),
            ir(e, 100))
        }
        function Ni(e, t, n) {
            t = Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t),
            (e.display.scroller.scrollTop != t || n) && (e.doc.scrollTop = t,
            e.display.scrollbars.setScrollTop(t),
            e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t))
        }
        function Vi(e, t, n, i) {
            t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth),
            (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !i || (e.doc.scrollLeft = t,
            dr(e),
            e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t),
            e.display.scrollbars.setScrollLeft(t))
        }
        function Bi(e) {
            var t = e.display
              , n = t.gutters.offsetWidth
              , i = Math.round(e.doc.height + On(e.display));
            return {
                clientHeight: t.scroller.clientHeight,
                viewHeight: t.wrapper.clientHeight,
                scrollWidth: t.scroller.scrollWidth,
                clientWidth: t.scroller.clientWidth,
                viewWidth: t.wrapper.clientWidth,
                barLeft: e.options.fixedGutter ? n : 0,
                docHeight: i,
                scrollHeight: i + En(e) + t.barHeight,
                nativeBarWidth: t.nativeBarWidth,
                gutterWidth: n
            }
        }
        var Fi = function(e, t, n) {
            this.cm = n;
            var i = this.vert = D("div", [D("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar")
              , r = this.horiz = D("div", [D("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
            i.tabIndex = r.tabIndex = -1,
            e(i),
            e(r),
            de(i, "scroll", (function() {
                i.clientHeight && t(i.scrollTop, "vertical")
            }
            )),
            de(r, "scroll", (function() {
                r.clientWidth && t(r.scrollLeft, "horizontal")
            }
            )),
            this.checkedZeroWidth = !1,
            a && o < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
        };
        Fi.prototype.update = function(e) {
            var t = e.scrollWidth > e.clientWidth + 1
              , n = e.scrollHeight > e.clientHeight + 1
              , i = e.nativeBarWidth;
            if (n) {
                this.vert.style.display = "block",
                this.vert.style.bottom = t ? i + "px" : "0";
                var r = e.viewHeight - (t ? i : 0);
                this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + r) + "px"
            } else
                this.vert.style.display = "",
                this.vert.firstChild.style.height = "0";
            if (t) {
                this.horiz.style.display = "block",
                this.horiz.style.right = n ? i + "px" : "0",
                this.horiz.style.left = e.barLeft + "px";
                var s = e.viewWidth - e.barLeft - (n ? i : 0);
                this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + s) + "px"
            } else
                this.horiz.style.display = "",
                this.horiz.firstChild.style.width = "0";
            return !this.checkedZeroWidth && e.clientHeight > 0 && (0 == i && this.zeroWidthHack(),
            this.checkedZeroWidth = !0),
            {
                right: n ? i : 0,
                bottom: t ? i : 0
            }
        }
        ,
        Fi.prototype.setScrollLeft = function(e) {
            this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e),
            this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
        }
        ,
        Fi.prototype.setScrollTop = function(e) {
            this.vert.scrollTop != e && (this.vert.scrollTop = e),
            this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
        }
        ,
        Fi.prototype.zeroWidthHack = function() {
            var e = b && !p ? "12px" : "18px";
            this.horiz.style.height = this.vert.style.width = e,
            this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none",
            this.disableHoriz = new F,
            this.disableVert = new F
        }
        ,
        Fi.prototype.enableZeroWidthBar = function(e, t, n) {
            e.style.pointerEvents = "auto",
            t.set(1e3, (function i() {
                var r = e.getBoundingClientRect();
                ("vert" == n ? document.elementFromPoint(r.right - 1, (r.top + r.bottom) / 2) : document.elementFromPoint((r.right + r.left) / 2, r.bottom - 1)) != e ? e.style.pointerEvents = "none" : t.set(1e3, i)
            }
            ))
        }
        ,
        Fi.prototype.clear = function() {
            var e = this.horiz.parentNode;
            e.removeChild(this.horiz),
            e.removeChild(this.vert)
        }
        ;
        var _i = function() {};
        function Ui(e, t) {
            t || (t = Bi(e));
            var n = e.display.barWidth
              , i = e.display.barHeight;
            zi(e, t);
            for (var r = 0; r < 4 && n != e.display.barWidth || i != e.display.barHeight; r++)
                n != e.display.barWidth && e.options.lineWrapping && Ei(e),
                zi(e, Bi(e)),
                n = e.display.barWidth,
                i = e.display.barHeight
        }
        function zi(e, t) {
            var n = e.display
              , i = n.scrollbars.update(t);
            n.sizer.style.paddingRight = (n.barWidth = i.right) + "px",
            n.sizer.style.paddingBottom = (n.barHeight = i.bottom) + "px",
            n.heightForcer.style.borderBottom = i.bottom + "px solid transparent",
            i.right && i.bottom ? (n.scrollbarFiller.style.display = "block",
            n.scrollbarFiller.style.height = i.bottom + "px",
            n.scrollbarFiller.style.width = i.right + "px") : n.scrollbarFiller.style.display = "",
            i.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block",
            n.gutterFiller.style.height = i.bottom + "px",
            n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = ""
        }
        _i.prototype.update = function() {
            return {
                bottom: 0,
                right: 0
            }
        }
        ,
        _i.prototype.setScrollLeft = function() {}
        ,
        _i.prototype.setScrollTop = function() {}
        ,
        _i.prototype.clear = function() {}
        ;
        var Gi = {
            native: Fi,
            null: _i
        };
        function $i(e) {
            e.display.scrollbars && (e.display.scrollbars.clear(),
            e.display.scrollbars.addClass && E(e.display.wrapper, e.display.scrollbars.addClass)),
            e.display.scrollbars = new Gi[e.options.scrollbarStyle]((function(t) {
                e.display.wrapper.insertBefore(t, e.display.scrollbarFiller),
                de(t, "mousedown", (function() {
                    e.state.focused && setTimeout((function() {
                        return e.display.input.focus()
                    }
                    ), 0)
                }
                )),
                t.setAttribute("cm-not-content", "true")
            }
            ),(function(t, n) {
                "horizontal" == n ? Vi(e, t) : ji(e, t)
            }
            ),e),
            e.display.scrollbars.addClass && P(e.display.wrapper, e.display.scrollbars.addClass)
        }
        var Wi = 0;
        function Hi(e) {
            var t;
            e.curOp = {
                cm: e,
                viewChanged: !1,
                startHeight: e.doc.height,
                forceUpdate: !1,
                updateInput: 0,
                typing: !1,
                changeObjs: null,
                cursorActivityHandlers: null,
                cursorActivityCalled: 0,
                selectionChanged: !1,
                updateMaxLine: !1,
                scrollLeft: null,
                scrollTop: null,
                scrollToPos: null,
                focus: !1,
                id: ++Wi
            },
            t = e.curOp,
            an ? an.ops.push(t) : t.ownsGroup = an = {
                ops: [t],
                delayedCallbacks: []
            }
        }
        function Ji(e) {
            var t = e.curOp;
            t && function(e, t) {
                var n = e.ownsGroup;
                if (n)
                    try {
                        !function(e) {
                            var t = e.delayedCallbacks
                              , n = 0;
                            do {
                                for (; n < t.length; n++)
                                    t[n].call(null);
                                for (var i = 0; i < e.ops.length; i++) {
                                    var r = e.ops[i];
                                    if (r.cursorActivityHandlers)
                                        for (; r.cursorActivityCalled < r.cursorActivityHandlers.length; )
                                            r.cursorActivityHandlers[r.cursorActivityCalled++].call(null, r.cm)
                                }
                            } while (n < t.length)
                        }(n)
                    } finally {
                        an = null,
                        t(n)
                    }
            }(t, (function(e) {
                for (var t = 0; t < e.ops.length; t++)
                    e.ops[t].cm.curOp = null;
                !function(e) {
                    for (var t = e.ops, n = 0; n < t.length; n++)
                        qi(t[n]);
                    for (var i = 0; i < t.length; i++)
                        Yi(t[i]);
                    for (var r = 0; r < t.length; r++)
                        Xi(t[r]);
                    for (var s = 0; s < t.length; s++)
                        Ki(t[s]);
                    for (var a = 0; a < t.length; a++)
                        Zi(t[a])
                }(e)
            }
            ))
        }
        function qi(e) {
            var t = e.cm
              , n = t.display;
            !function(e) {
                var t = e.display;
                !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth,
                t.heightForcer.style.height = En(e) + "px",
                t.sizer.style.marginBottom = -t.nativeBarWidth + "px",
                t.sizer.style.borderRightWidth = En(e) + "px",
                t.scrollbarsClipped = !0)
            }(t),
            e.updateMaxLine && Wt(t),
            e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping,
            e.update = e.mustUpdate && new sr(t,e.mustUpdate && {
                top: e.scrollTop,
                ensure: e.scrollToPos
            },e.forceUpdate)
        }
        function Yi(e) {
            e.updatedDisplay = e.mustUpdate && ar(e.cm, e.update)
        }
        function Xi(e) {
            var t = e.cm
              , n = t.display;
            e.updatedDisplay && Ei(t),
            e.barMeasure = Bi(t),
            n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Ln(t, n.maxLine, n.maxLine.text.length).left + 3,
            t.display.sizerWidth = e.adjustWidthTo,
            e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + En(t) + t.display.barWidth),
            e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - Tn(t))),
            (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection())
        }
        function Ki(e) {
            var t = e.cm;
            null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px",
            e.maxScrollLeft < t.doc.scrollLeft && Vi(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0),
            t.display.maxLineChanged = !1);
            var n = e.focus && e.focus == I();
            e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n),
            (e.updatedDisplay || e.startHeight != t.doc.height) && Ui(t, e.barMeasure),
            e.updatedDisplay && ur(t, e.barMeasure),
            e.selectionChanged && wi(t),
            t.state.focused && e.updateInput && t.display.input.reset(e.typing),
            n && xi(e.cm)
        }
        function Zi(e) {
            var t = e.cm
              , n = t.display
              , i = t.doc;
            e.updatedDisplay && or(t, e.update),
            null == n.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null),
            null != e.scrollTop && Ni(t, e.scrollTop, e.forceScroll),
            null != e.scrollLeft && Vi(t, e.scrollLeft, !0, !0),
            e.scrollToPos && function(e, t) {
                if (!me(e, "scrollCursorIntoView")) {
                    var n = e.display
                      , i = n.sizer.getBoundingClientRect()
                      , r = null;
                    if (t.top + i.top < 0 ? r = !0 : t.bottom + i.top > (window.innerHeight || document.documentElement.clientHeight) && (r = !1),
                    null != r && !f) {
                        var s = D("div", "", null, "position: absolute;\n                         top: " + (t.top - n.viewOffset - Cn(e.display)) + "px;\n                         height: " + (t.bottom - t.top + En(e) + n.barHeight) + "px;\n                         left: " + t.left + "px; width: " + Math.max(2, t.right - t.left) + "px;");
                        e.display.lineSpace.appendChild(s),
                        s.scrollIntoView(r),
                        e.display.lineSpace.removeChild(s)
                    }
                }
            }(t, function(e, t, n, i) {
                var r;
                null == i && (i = 0),
                e.options.lineWrapping || t != n || (n = "before" == (t = t.ch ? et(t.line, "before" == t.sticky ? t.ch - 1 : t.ch, "after") : t).sticky ? et(t.line, t.ch + 1, "before") : t);
                for (var s = 0; s < 5; s++) {
                    var a = !1
                      , o = Jn(e, t)
                      , l = n && n != t ? Jn(e, n) : o
                      , c = Di(e, r = {
                        left: Math.min(o.left, l.left),
                        top: Math.min(o.top, l.top) - i,
                        right: Math.max(o.left, l.left),
                        bottom: Math.max(o.bottom, l.bottom) + i
                    })
                      , u = e.doc.scrollTop
                      , d = e.doc.scrollLeft;
                    if (null != c.scrollTop && (ji(e, c.scrollTop),
                    Math.abs(e.doc.scrollTop - u) > 1 && (a = !0)),
                    null != c.scrollLeft && (Vi(e, c.scrollLeft),
                    Math.abs(e.doc.scrollLeft - d) > 1 && (a = !0)),
                    !a)
                        break
                }
                return r
            }(t, ot(i, e.scrollToPos.from), ot(i, e.scrollToPos.to), e.scrollToPos.margin));
            var r = e.maybeHiddenMarkers
              , s = e.maybeUnhiddenMarkers;
            if (r)
                for (var a = 0; a < r.length; ++a)
                    r[a].lines.length || fe(r[a], "hide");
            if (s)
                for (var o = 0; o < s.length; ++o)
                    s[o].lines.length && fe(s[o], "unhide");
            n.wrapper.offsetHeight && (i.scrollTop = t.display.scroller.scrollTop),
            e.changeObjs && fe(t, "changes", t, e.changeObjs),
            e.update && e.update.finish()
        }
        function Qi(e, t) {
            if (e.curOp)
                return t();
            Hi(e);
            try {
                return t()
            } finally {
                Ji(e)
            }
        }
        function er(e, t) {
            return function() {
                if (e.curOp)
                    return t.apply(e, arguments);
                Hi(e);
                try {
                    return t.apply(e, arguments)
                } finally {
                    Ji(e)
                }
            }
        }
        function tr(e) {
            return function() {
                if (this.curOp)
                    return e.apply(this, arguments);
                Hi(this);
                try {
                    return e.apply(this, arguments)
                } finally {
                    Ji(this)
                }
            }
        }
        function nr(e) {
            return function() {
                var t = this.cm;
                if (!t || t.curOp)
                    return e.apply(this, arguments);
                Hi(t);
                try {
                    return e.apply(this, arguments)
                } finally {
                    Ji(t)
                }
            }
        }
        function ir(e, t) {
            e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, N(rr, e))
        }
        function rr(e) {
            var t = e.doc;
            if (!(t.highlightFrontier >= e.display.viewTo)) {
                var n = +new Date + e.options.workTime
                  , i = pt(e, t.highlightFrontier)
                  , r = [];
                t.iter(i.line, Math.min(t.first + t.size, e.display.viewTo + 500), (function(s) {
                    if (i.line >= e.display.viewFrom) {
                        var a = s.styles
                          , o = s.text.length > e.options.maxHighlightLength ? ze(t.mode, i.state) : null
                          , l = dt(e, s, i, !0);
                        o && (i.state = o),
                        s.styles = l.styles;
                        var c = s.styleClasses
                          , u = l.classes;
                        u ? s.styleClasses = u : c && (s.styleClasses = null);
                        for (var d = !a || a.length != s.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass), h = 0; !d && h < a.length; ++h)
                            d = a[h] != s.styles[h];
                        d && r.push(i.line),
                        s.stateAfter = i.save(),
                        i.nextLine()
                    } else
                        s.text.length <= e.options.maxHighlightLength && ft(e, s.text, i),
                        s.stateAfter = i.line % 5 == 0 ? i.save() : null,
                        i.nextLine();
                    if (+new Date > n)
                        return ir(e, e.options.workDelay),
                        !0
                }
                )),
                t.highlightFrontier = i.line,
                t.modeFrontier = Math.max(t.modeFrontier, i.line),
                r.length && Qi(e, (function() {
                    for (var t = 0; t < r.length; t++)
                        hi(e, r[t], "text")
                }
                ))
            }
        }
        var sr = function(e, t, n) {
            var i = e.display;
            this.viewport = t,
            this.visible = Mi(i, e.doc, t),
            this.editorIsHidden = !i.wrapper.offsetWidth,
            this.wrapperHeight = i.wrapper.clientHeight,
            this.wrapperWidth = i.wrapper.clientWidth,
            this.oldDisplayWidth = Tn(e),
            this.force = n,
            this.dims = si(e),
            this.events = []
        };
        function ar(e, t) {
            var n = e.display
              , i = e.doc;
            if (t.editorIsHidden)
                return pi(e),
                !1;
            if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == mi(e))
                return !1;
            hr(e) && (pi(e),
            t.dims = si(e));
            var r = i.first + i.size
              , s = Math.max(t.visible.from - e.options.viewportMargin, i.first)
              , a = Math.min(r, t.visible.to + e.options.viewportMargin);
            n.viewFrom < s && s - n.viewFrom < 20 && (s = Math.max(i.first, n.viewFrom)),
            n.viewTo > a && n.viewTo - a < 20 && (a = Math.min(r, n.viewTo)),
            xt && (s = Ft(e.doc, s),
            a = _t(e.doc, a));
            var o = s != n.viewFrom || a != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth;
            !function(e, t, n) {
                var i = e.display;
                0 == i.view.length || t >= i.viewTo || n <= i.viewFrom ? (i.view = sn(e, t, n),
                i.viewFrom = t) : (i.viewFrom > t ? i.view = sn(e, t, i.viewFrom).concat(i.view) : i.viewFrom < t && (i.view = i.view.slice(ui(e, t))),
                i.viewFrom = t,
                i.viewTo < n ? i.view = i.view.concat(sn(e, i.viewTo, n)) : i.viewTo > n && (i.view = i.view.slice(0, ui(e, n)))),
                i.viewTo = n
            }(e, s, a),
            n.viewOffset = Gt(He(e.doc, n.viewFrom)),
            e.display.mover.style.top = n.viewOffset + "px";
            var c = mi(e);
            if (!o && 0 == c && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo))
                return !1;
            var u = function(e) {
                if (e.hasFocus())
                    return null;
                var t = I();
                if (!t || !A(e.display.lineDiv, t))
                    return null;
                var n = {
                    activeElt: t
                };
                if (window.getSelection) {
                    var i = window.getSelection();
                    i.anchorNode && i.extend && A(e.display.lineDiv, i.anchorNode) && (n.anchorNode = i.anchorNode,
                    n.anchorOffset = i.anchorOffset,
                    n.focusNode = i.focusNode,
                    n.focusOffset = i.focusOffset)
                }
                return n
            }(e);
            return c > 4 && (n.lineDiv.style.display = "none"),
            function(e, t, n) {
                var i = e.display
                  , r = e.options.lineNumbers
                  , s = i.lineDiv
                  , a = s.firstChild;
                function o(t) {
                    var n = t.nextSibling;
                    return l && b && e.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t),
                    n
                }
                for (var c = i.view, u = i.viewFrom, d = 0; d < c.length; d++) {
                    var h = c[d];
                    if (h.hidden)
                        ;
                    else if (h.node && h.node.parentNode == s) {
                        for (; a != h.node; )
                            a = o(a);
                        var p = r && null != t && t <= u && h.lineNumber;
                        h.changes && (_(h.changes, "gutter") > -1 && (p = !1),
                        un(e, h, u, n)),
                        p && (T(h.lineNumber),
                        h.lineNumber.appendChild(document.createTextNode(Qe(e.options, u)))),
                        a = h.node.nextSibling
                    } else {
                        var f = vn(e, h, u, n);
                        s.insertBefore(f, a)
                    }
                    u += h.size
                }
                for (; a; )
                    a = o(a)
            }(e, n.updateLineNumbers, t.dims),
            c > 4 && (n.lineDiv.style.display = ""),
            n.renderedView = n.view,
            function(e) {
                if (e && e.activeElt && e.activeElt != I() && (e.activeElt.focus(),
                e.anchorNode && A(document.body, e.anchorNode) && A(document.body, e.focusNode))) {
                    var t = window.getSelection()
                      , n = document.createRange();
                    n.setEnd(e.anchorNode, e.anchorOffset),
                    n.collapse(!1),
                    t.removeAllRanges(),
                    t.addRange(n),
                    t.extend(e.focusNode, e.focusOffset)
                }
            }(u),
            T(n.cursorDiv),
            T(n.selectionDiv),
            n.gutters.style.height = n.sizer.style.minHeight = 0,
            o && (n.lastWrapHeight = t.wrapperHeight,
            n.lastWrapWidth = t.wrapperWidth,
            ir(e, 400)),
            n.updateLineNumbers = null,
            !0
        }
        function or(e, t) {
            for (var n = t.viewport, i = !0; (i && e.options.lineWrapping && t.oldDisplayWidth != Tn(e) || (n && null != n.top && (n = {
                top: Math.min(e.doc.height + On(e.display) - Mn(e), n.top)
            }),
            t.visible = Mi(e.display, e.doc, n),
            !(t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo))) && ar(e, t); i = !1) {
                Ei(e);
                var r = Bi(e);
                gi(e),
                Ui(e, r),
                ur(e, r),
                t.force = !1
            }
            t.signal(e, "update", e),
            e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo),
            e.display.reportedViewFrom = e.display.viewFrom,
            e.display.reportedViewTo = e.display.viewTo)
        }
        function lr(e, t) {
            var n = new sr(e,t);
            if (ar(e, n)) {
                Ei(e),
                or(e, n);
                var i = Bi(e);
                gi(e),
                Ui(e, i),
                ur(e, i),
                n.finish()
            }
        }
        function cr(e) {
            var t = e.gutters.offsetWidth;
            e.sizer.style.marginLeft = t + "px"
        }
        function ur(e, t) {
            e.display.sizer.style.minHeight = t.docHeight + "px",
            e.display.heightForcer.style.top = t.docHeight + "px",
            e.display.gutters.style.height = t.docHeight + e.display.barHeight + En(e) + "px"
        }
        function dr(e) {
            var t = e.display
              , n = t.view;
            if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
                for (var i = ai(t) - t.scroller.scrollLeft + e.doc.scrollLeft, r = t.gutters.offsetWidth, s = i + "px", a = 0; a < n.length; a++)
                    if (!n[a].hidden) {
                        e.options.fixedGutter && (n[a].gutter && (n[a].gutter.style.left = s),
                        n[a].gutterBackground && (n[a].gutterBackground.style.left = s));
                        var o = n[a].alignable;
                        if (o)
                            for (var l = 0; l < o.length; l++)
                                o[l].style.left = s
                    }
                e.options.fixedGutter && (t.gutters.style.left = i + r + "px")
            }
        }
        function hr(e) {
            if (!e.options.lineNumbers)
                return !1;
            var t = e.doc
              , n = Qe(e.options, t.first + t.size - 1)
              , i = e.display;
            if (n.length != i.lineNumChars) {
                var r = i.measure.appendChild(D("div", [D("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt"))
                  , s = r.firstChild.offsetWidth
                  , a = r.offsetWidth - s;
                return i.lineGutter.style.width = "",
                i.lineNumInnerWidth = Math.max(s, i.lineGutter.offsetWidth - a) + 1,
                i.lineNumWidth = i.lineNumInnerWidth + a,
                i.lineNumChars = i.lineNumInnerWidth ? n.length : -1,
                i.lineGutter.style.width = i.lineNumWidth + "px",
                cr(e.display),
                !0
            }
            return !1
        }
        function pr(e, t) {
            for (var n = [], i = !1, r = 0; r < e.length; r++) {
                var s = e[r]
                  , a = null;
                if ("string" != typeof s && (a = s.style,
                s = s.className),
                "CodeMirror-linenumbers" == s) {
                    if (!t)
                        continue;
                    i = !0
                }
                n.push({
                    className: s,
                    style: a
                })
            }
            return t && !i && n.push({
                className: "CodeMirror-linenumbers",
                style: null
            }),
            n
        }
        function fr(e) {
            var t = e.gutters
              , n = e.gutterSpecs;
            T(t),
            e.lineGutter = null;
            for (var i = 0; i < n.length; ++i) {
                var r = n[i]
                  , s = r.className
                  , a = r.style
                  , o = t.appendChild(D("div", null, "CodeMirror-gutter " + s));
                a && (o.style.cssText = a),
                "CodeMirror-linenumbers" == s && (e.lineGutter = o,
                o.style.width = (e.lineNumWidth || 1) + "px")
            }
            t.style.display = n.length ? "" : "none",
            cr(e)
        }
        function mr(e) {
            fr(e.display),
            di(e),
            dr(e)
        }
        function gr(e, t, i, r) {
            var s = this;
            this.input = i,
            s.scrollbarFiller = D("div", null, "CodeMirror-scrollbar-filler"),
            s.scrollbarFiller.setAttribute("cm-not-content", "true"),
            s.gutterFiller = D("div", null, "CodeMirror-gutter-filler"),
            s.gutterFiller.setAttribute("cm-not-content", "true"),
            s.lineDiv = L("div", null, "CodeMirror-code"),
            s.selectionDiv = D("div", null, null, "position: relative; z-index: 1"),
            s.cursorDiv = D("div", null, "CodeMirror-cursors"),
            s.measure = D("div", null, "CodeMirror-measure"),
            s.lineMeasure = D("div", null, "CodeMirror-measure"),
            s.lineSpace = L("div", [s.measure, s.lineMeasure, s.selectionDiv, s.cursorDiv, s.lineDiv], null, "position: relative; outline: none");
            var c = L("div", [s.lineSpace], "CodeMirror-lines");
            s.mover = D("div", [c], null, "position: relative"),
            s.sizer = D("div", [s.mover], "CodeMirror-sizer"),
            s.sizerWidth = null,
            s.heightForcer = D("div", null, null, "position: absolute; height: 30px; width: 1px;"),
            s.gutters = D("div", null, "CodeMirror-gutters"),
            s.lineGutter = null,
            s.scroller = D("div", [s.sizer, s.heightForcer, s.gutters], "CodeMirror-scroll"),
            s.scroller.setAttribute("tabIndex", "-1"),
            s.wrapper = D("div", [s.scrollbarFiller, s.gutterFiller, s.scroller], "CodeMirror"),
            a && o < 8 && (s.gutters.style.zIndex = -1,
            s.scroller.style.paddingRight = 0),
            l || n && v || (s.scroller.draggable = !0),
            e && (e.appendChild ? e.appendChild(s.wrapper) : e(s.wrapper)),
            s.viewFrom = s.viewTo = t.first,
            s.reportedViewFrom = s.reportedViewTo = t.first,
            s.view = [],
            s.renderedView = null,
            s.externalMeasured = null,
            s.viewOffset = 0,
            s.lastWrapHeight = s.lastWrapWidth = 0,
            s.updateLineNumbers = null,
            s.nativeBarWidth = s.barHeight = s.barWidth = 0,
            s.scrollbarsClipped = !1,
            s.lineNumWidth = s.lineNumInnerWidth = s.lineNumChars = null,
            s.alignWidgets = !1,
            s.cachedCharWidth = s.cachedTextHeight = s.cachedPaddingH = null,
            s.maxLine = null,
            s.maxLineLength = 0,
            s.maxLineChanged = !1,
            s.wheelDX = s.wheelDY = s.wheelStartX = s.wheelStartY = null,
            s.shift = !1,
            s.selForContextMenu = null,
            s.activeTouch = null,
            s.gutterSpecs = pr(r.gutters, r.lineNumbers),
            fr(s),
            i.init(s)
        }
        sr.prototype.signal = function(e, t) {
            ve(e, t) && this.events.push(arguments)
        }
        ,
        sr.prototype.finish = function() {
            for (var e = 0; e < this.events.length; e++)
                fe.apply(null, this.events[e])
        }
        ;
        var vr = 0
          , br = null;
        function yr(e) {
            var t = e.wheelDeltaX
              , n = e.wheelDeltaY;
            return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail),
            null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta),
            {
                x: t,
                y: n
            }
        }
        function Sr(e) {
            var t = yr(e);
            return t.x *= br,
            t.y *= br,
            t
        }
        function wr(e, t) {
            var i = yr(t)
              , r = i.x
              , s = i.y
              , a = e.display
              , o = a.scroller
              , c = o.scrollWidth > o.clientWidth
              , u = o.scrollHeight > o.clientHeight;
            if (r && c || s && u) {
                if (s && b && l)
                    e: for (var h = t.target, p = a.view; h != o; h = h.parentNode)
                        for (var f = 0; f < p.length; f++)
                            if (p[f].node == h) {
                                e.display.currentWheelTarget = h;
                                break e
                            }
                if (r && !n && !d && null != br)
                    return s && u && ji(e, Math.max(0, o.scrollTop + s * br)),
                    Vi(e, Math.max(0, o.scrollLeft + r * br)),
                    (!s || s && u) && ye(t),
                    void (a.wheelStartX = null);
                if (s && null != br) {
                    var m = s * br
                      , g = e.doc.scrollTop
                      , v = g + a.wrapper.clientHeight;
                    m < 0 ? g = Math.max(0, g + m - 50) : v = Math.min(e.doc.height, v + m + 50),
                    lr(e, {
                        top: g,
                        bottom: v
                    })
                }
                vr < 20 && (null == a.wheelStartX ? (a.wheelStartX = o.scrollLeft,
                a.wheelStartY = o.scrollTop,
                a.wheelDX = r,
                a.wheelDY = s,
                setTimeout((function() {
                    if (null != a.wheelStartX) {
                        var e = o.scrollLeft - a.wheelStartX
                          , t = o.scrollTop - a.wheelStartY
                          , n = t && a.wheelDY && t / a.wheelDY || e && a.wheelDX && e / a.wheelDX;
                        a.wheelStartX = a.wheelStartY = null,
                        n && (br = (br * vr + n) / (vr + 1),
                        ++vr)
                    }
                }
                ), 200)) : (a.wheelDX += r,
                a.wheelDY += s))
            }
        }
        a ? br = -.53 : n ? br = 15 : u ? br = -.7 : h && (br = -1 / 3);
        var xr = function(e, t) {
            this.ranges = e,
            this.primIndex = t
        };
        xr.prototype.primary = function() {
            return this.ranges[this.primIndex]
        }
        ,
        xr.prototype.equals = function(e) {
            if (e == this)
                return !0;
            if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length)
                return !1;
            for (var t = 0; t < this.ranges.length; t++) {
                var n = this.ranges[t]
                  , i = e.ranges[t];
                if (!nt(n.anchor, i.anchor) || !nt(n.head, i.head))
                    return !1
            }
            return !0
        }
        ,
        xr.prototype.deepCopy = function() {
            for (var e = [], t = 0; t < this.ranges.length; t++)
                e[t] = new Cr(it(this.ranges[t].anchor),it(this.ranges[t].head));
            return new xr(e,this.primIndex)
        }
        ,
        xr.prototype.somethingSelected = function() {
            for (var e = 0; e < this.ranges.length; e++)
                if (!this.ranges[e].empty())
                    return !0;
            return !1
        }
        ,
        xr.prototype.contains = function(e, t) {
            t || (t = e);
            for (var n = 0; n < this.ranges.length; n++) {
                var i = this.ranges[n];
                if (tt(t, i.from()) >= 0 && tt(e, i.to()) <= 0)
                    return n
            }
            return -1
        }
        ;
        var Cr = function(e, t) {
            this.anchor = e,
            this.head = t
        };
        function Or(e, t, n) {
            var i = e && e.options.selectionsMayTouch
              , r = t[n];
            t.sort((function(e, t) {
                return tt(e.from(), t.from())
            }
            )),
            n = _(t, r);
            for (var s = 1; s < t.length; s++) {
                var a = t[s]
                  , o = t[s - 1]
                  , l = tt(o.to(), a.from());
                if (i && !a.empty() ? l > 0 : l >= 0) {
                    var c = st(o.from(), a.from())
                      , u = rt(o.to(), a.to())
                      , d = o.empty() ? a.from() == a.head : o.from() == o.head;
                    s <= n && --n,
                    t.splice(--s, 2, new Cr(d ? u : c,d ? c : u))
                }
            }
            return new xr(t,n)
        }
        function kr(e, t) {
            return new xr([new Cr(e,t || e)],0)
        }
        function Er(e) {
            return e.text ? et(e.from.line + e.text.length - 1, q(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
        }
        function Tr(e, t) {
            if (tt(e, t.from) < 0)
                return e;
            if (tt(e, t.to) <= 0)
                return Er(t);
            var n = e.line + t.text.length - (t.to.line - t.from.line) - 1
              , i = e.ch;
            return e.line == t.to.line && (i += Er(t).ch - t.to.ch),
            et(n, i)
        }
        function Mr(e, t) {
            for (var n = [], i = 0; i < e.sel.ranges.length; i++) {
                var r = e.sel.ranges[i];
                n.push(new Cr(Tr(r.anchor, t),Tr(r.head, t)))
            }
            return Or(e.cm, n, e.sel.primIndex)
        }
        function Dr(e, t, n) {
            return e.line == t.line ? et(n.line, e.ch - t.ch + n.ch) : et(n.line + (e.line - t.line), e.ch)
        }
        function Lr(e) {
            e.doc.mode = Fe(e.options, e.doc.modeOption),
            Ar(e)
        }
        function Ar(e) {
            e.doc.iter((function(e) {
                e.stateAfter && (e.stateAfter = null),
                e.styles && (e.styles = null)
            }
            )),
            e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first,
            ir(e, 100),
            e.state.modeGen++,
            e.curOp && di(e)
        }
        function Ir(e, t) {
            return 0 == t.from.ch && 0 == t.to.ch && "" == q(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore)
        }
        function Pr(e, t, n, i) {
            function r(e) {
                return n ? n[e] : null
            }
            function s(e, n, r) {
                !function(e, t, n, i) {
                    e.text = t,
                    e.stateAfter && (e.stateAfter = null),
                    e.styles && (e.styles = null),
                    null != e.order && (e.order = null),
                    Mt(e),
                    Dt(e, n);
                    var r = i ? i(e) : 1;
                    r != e.height && Ye(e, r)
                }(e, n, r, i),
                ln(e, "change", e, t)
            }
            function a(e, t) {
                for (var n = [], s = e; s < t; ++s)
                    n.push(new Ht(c[s],r(s),i));
                return n
            }
            var o = t.from
              , l = t.to
              , c = t.text
              , u = He(e, o.line)
              , d = He(e, l.line)
              , h = q(c)
              , p = r(c.length - 1)
              , f = l.line - o.line;
            if (t.full)
                e.insert(0, a(0, c.length)),
                e.remove(c.length, e.size - c.length);
            else if (Ir(e, t)) {
                var m = a(0, c.length - 1);
                s(d, d.text, p),
                f && e.remove(o.line, f),
                m.length && e.insert(o.line, m)
            } else if (u == d)
                if (1 == c.length)
                    s(u, u.text.slice(0, o.ch) + h + u.text.slice(l.ch), p);
                else {
                    var g = a(1, c.length - 1);
                    g.push(new Ht(h + u.text.slice(l.ch),p,i)),
                    s(u, u.text.slice(0, o.ch) + c[0], r(0)),
                    e.insert(o.line + 1, g)
                }
            else if (1 == c.length)
                s(u, u.text.slice(0, o.ch) + c[0] + d.text.slice(l.ch), r(0)),
                e.remove(o.line + 1, f);
            else {
                s(u, u.text.slice(0, o.ch) + c[0], r(0)),
                s(d, h + d.text.slice(l.ch), p);
                var v = a(1, c.length - 1);
                f > 1 && e.remove(o.line + 1, f - 1),
                e.insert(o.line + 1, v)
            }
            ln(e, "change", e, t)
        }
        function Rr(e, t, n) {
            !function e(i, r, s) {
                if (i.linked)
                    for (var a = 0; a < i.linked.length; ++a) {
                        var o = i.linked[a];
                        if (o.doc != r) {
                            var l = s && o.sharedHist;
                            n && !l || (t(o.doc, l),
                            e(o.doc, i, l))
                        }
                    }
            }(e, null, !0)
        }
        function jr(e, t) {
            if (t.cm)
                throw new Error("This document is already in use.");
            e.doc = t,
            t.cm = e,
            li(e),
            Lr(e),
            Nr(e),
            e.options.lineWrapping || Wt(e),
            e.options.mode = t.modeOption,
            di(e)
        }
        function Nr(e) {
            ("rtl" == e.doc.direction ? P : E)(e.display.lineDiv, "CodeMirror-rtl")
        }
        function Vr(e) {
            this.done = [],
            this.undone = [],
            this.undoDepth = 1 / 0,
            this.lastModTime = this.lastSelTime = 0,
            this.lastOp = this.lastSelOp = null,
            this.lastOrigin = this.lastSelOrigin = null,
            this.generation = this.maxGeneration = e || 1
        }
        function Br(e, t) {
            var n = {
                from: it(t.from),
                to: Er(t),
                text: Je(e, t.from, t.to)
            };
            return Gr(e, n, t.from.line, t.to.line + 1),
            Rr(e, (function(e) {
                return Gr(e, n, t.from.line, t.to.line + 1)
            }
            ), !0),
            n
        }
        function Fr(e) {
            for (; e.length && q(e).ranges; )
                e.pop()
        }
        function _r(e, t, n, i) {
            var r = e.history;
            r.undone.length = 0;
            var s, a, o = +new Date;
            if ((r.lastOp == i || r.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && r.lastModTime > o - (e.cm ? e.cm.options.historyEventDelay : 500) || "*" == t.origin.charAt(0))) && (s = function(e, t) {
                return t ? (Fr(e.done),
                q(e.done)) : e.done.length && !q(e.done).ranges ? q(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(),
                q(e.done)) : void 0
            }(r, r.lastOp == i)))
                a = q(s.changes),
                0 == tt(t.from, t.to) && 0 == tt(t.from, a.to) ? a.to = Er(t) : s.changes.push(Br(e, t));
            else {
                var l = q(r.done);
                for (l && l.ranges || zr(e.sel, r.done),
                s = {
                    changes: [Br(e, t)],
                    generation: r.generation
                },
                r.done.push(s); r.done.length > r.undoDepth; )
                    r.done.shift(),
                    r.done[0].ranges || r.done.shift()
            }
            r.done.push(n),
            r.generation = ++r.maxGeneration,
            r.lastModTime = r.lastSelTime = o,
            r.lastOp = r.lastSelOp = i,
            r.lastOrigin = r.lastSelOrigin = t.origin,
            a || fe(e, "historyAdded")
        }
        function Ur(e, t, n, i) {
            var r = e.history
              , s = i && i.origin;
            n == r.lastSelOp || s && r.lastSelOrigin == s && (r.lastModTime == r.lastSelTime && r.lastOrigin == s || function(e, t, n, i) {
                var r = t.charAt(0);
                return "*" == r || "+" == r && n.ranges.length == i.ranges.length && n.somethingSelected() == i.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500)
            }(e, s, q(r.done), t)) ? r.done[r.done.length - 1] = t : zr(t, r.done),
            r.lastSelTime = +new Date,
            r.lastSelOrigin = s,
            r.lastSelOp = n,
            i && !1 !== i.clearRedo && Fr(r.undone)
        }
        function zr(e, t) {
            var n = q(t);
            n && n.ranges && n.equals(e) || t.push(e)
        }
        function Gr(e, t, n, i) {
            var r = t["spans_" + e.id]
              , s = 0;
            e.iter(Math.max(e.first, n), Math.min(e.first + e.size, i), (function(n) {
                n.markedSpans && ((r || (r = t["spans_" + e.id] = {}))[s] = n.markedSpans),
                ++s
            }
            ))
        }
        function $r(e) {
            if (!e)
                return null;
            for (var t, n = 0; n < e.length; ++n)
                e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]);
            return t ? t.length ? t : null : e
        }
        function Wr(e, t) {
            var n = function(e, t) {
                var n = t["spans_" + e.id];
                if (!n)
                    return null;
                for (var i = [], r = 0; r < t.text.length; ++r)
                    i.push($r(n[r]));
                return i
            }(e, t)
              , i = Et(e, t);
            if (!n)
                return i;
            if (!i)
                return n;
            for (var r = 0; r < n.length; ++r) {
                var s = n[r]
                  , a = i[r];
                if (s && a)
                    e: for (var o = 0; o < a.length; ++o) {
                        for (var l = a[o], c = 0; c < s.length; ++c)
                            if (s[c].marker == l.marker)
                                continue e;
                        s.push(l)
                    }
                else
                    a && (n[r] = a)
            }
            return n
        }
        function Hr(e, t, n) {
            for (var i = [], r = 0; r < e.length; ++r) {
                var s = e[r];
                if (s.ranges)
                    i.push(n ? xr.prototype.deepCopy.call(s) : s);
                else {
                    var a = s.changes
                      , o = [];
                    i.push({
                        changes: o
                    });
                    for (var l = 0; l < a.length; ++l) {
                        var c = a[l]
                          , u = void 0;
                        if (o.push({
                            from: c.from,
                            to: c.to,
                            text: c.text
                        }),
                        t)
                            for (var d in c)
                                (u = d.match(/^spans_(\d+)$/)) && _(t, Number(u[1])) > -1 && (q(o)[d] = c[d],
                                delete c[d])
                    }
                }
            }
            return i
        }
        function Jr(e, t, n, i) {
            if (i) {
                var r = e.anchor;
                if (n) {
                    var s = tt(t, r) < 0;
                    s != tt(n, r) < 0 ? (r = t,
                    t = n) : s != tt(t, n) < 0 && (t = n)
                }
                return new Cr(r,t)
            }
            return new Cr(n || t,t)
        }
        function qr(e, t, n, i, r) {
            null == r && (r = e.cm && (e.cm.display.shift || e.extend)),
            Qr(e, new xr([Jr(e.sel.primary(), t, n, r)],0), i)
        }
        function Yr(e, t, n) {
            for (var i = [], r = e.cm && (e.cm.display.shift || e.extend), s = 0; s < e.sel.ranges.length; s++)
                i[s] = Jr(e.sel.ranges[s], t[s], null, r);
            Qr(e, Or(e.cm, i, e.sel.primIndex), n)
        }
        function Xr(e, t, n, i) {
            var r = e.sel.ranges.slice(0);
            r[t] = n,
            Qr(e, Or(e.cm, r, e.sel.primIndex), i)
        }
        function Kr(e, t, n, i) {
            Qr(e, kr(t, n), i)
        }
        function Zr(e, t, n) {
            var i = e.history.done
              , r = q(i);
            r && r.ranges ? (i[i.length - 1] = t,
            es(e, t, n)) : Qr(e, t, n)
        }
        function Qr(e, t, n) {
            es(e, t, n),
            Ur(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n)
        }
        function es(e, t, n) {
            (ve(e, "beforeSelectionChange") || e.cm && ve(e.cm, "beforeSelectionChange")) && (t = function(e, t, n) {
                var i = {
                    ranges: t.ranges,
                    update: function(t) {
                        this.ranges = [];
                        for (var n = 0; n < t.length; n++)
                            this.ranges[n] = new Cr(ot(e, t[n].anchor),ot(e, t[n].head))
                    },
                    origin: n && n.origin
                };
                return fe(e, "beforeSelectionChange", e, i),
                e.cm && fe(e.cm, "beforeSelectionChange", e.cm, i),
                i.ranges != t.ranges ? Or(e.cm, i.ranges, i.ranges.length - 1) : t
            }(e, t, n));
            var i = n && n.bias || (tt(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
            ts(e, is(e, t, i, !0)),
            n && !1 === n.scroll || !e.cm || Ai(e.cm)
        }
        function ts(e, t) {
            t.equals(e.sel) || (e.sel = t,
            e.cm && (e.cm.curOp.updateInput = 1,
            e.cm.curOp.selectionChanged = !0,
            ge(e.cm)),
            ln(e, "cursorActivity", e))
        }
        function ns(e) {
            ts(e, is(e, e.sel, null, !1))
        }
        function is(e, t, n, i) {
            for (var r, s = 0; s < t.ranges.length; s++) {
                var a = t.ranges[s]
                  , o = t.ranges.length == e.sel.ranges.length && e.sel.ranges[s]
                  , l = ss(e, a.anchor, o && o.anchor, n, i)
                  , c = ss(e, a.head, o && o.head, n, i);
                (r || l != a.anchor || c != a.head) && (r || (r = t.ranges.slice(0, s)),
                r[s] = new Cr(l,c))
            }
            return r ? Or(e.cm, r, t.primIndex) : t
        }
        function rs(e, t, n, i, r) {
            var s = He(e, t.line);
            if (s.markedSpans)
                for (var a = 0; a < s.markedSpans.length; ++a) {
                    var o = s.markedSpans[a]
                      , l = o.marker
                      , c = "selectLeft"in l ? !l.selectLeft : l.inclusiveLeft
                      , u = "selectRight"in l ? !l.selectRight : l.inclusiveRight;
                    if ((null == o.from || (c ? o.from <= t.ch : o.from < t.ch)) && (null == o.to || (u ? o.to >= t.ch : o.to > t.ch))) {
                        if (r && (fe(l, "beforeCursorEnter"),
                        l.explicitlyCleared)) {
                            if (s.markedSpans) {
                                --a;
                                continue
                            }
                            break
                        }
                        if (!l.atomic)
                            continue;
                        if (n) {
                            var d = l.find(i < 0 ? 1 : -1)
                              , h = void 0;
                            if ((i < 0 ? u : c) && (d = as(e, d, -i, d && d.line == t.line ? s : null)),
                            d && d.line == t.line && (h = tt(d, n)) && (i < 0 ? h < 0 : h > 0))
                                return rs(e, d, t, i, r)
                        }
                        var p = l.find(i < 0 ? -1 : 1);
                        return (i < 0 ? c : u) && (p = as(e, p, i, p.line == t.line ? s : null)),
                        p ? rs(e, p, t, i, r) : null
                    }
                }
            return t
        }
        function ss(e, t, n, i, r) {
            var s = i || 1
              , a = rs(e, t, n, s, r) || !r && rs(e, t, n, s, !0) || rs(e, t, n, -s, r) || !r && rs(e, t, n, -s, !0);
            return a || (e.cantEdit = !0,
            et(e.first, 0))
        }
        function as(e, t, n, i) {
            return n < 0 && 0 == t.ch ? t.line > e.first ? ot(e, et(t.line - 1)) : null : n > 0 && t.ch == (i || He(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? et(t.line + 1, 0) : null : new et(t.line,t.ch + n)
        }
        function os(e) {
            e.setSelection(et(e.firstLine(), 0), et(e.lastLine()), z)
        }
        function ls(e, t, n) {
            var i = {
                canceled: !1,
                from: t.from,
                to: t.to,
                text: t.text,
                origin: t.origin,
                cancel: function() {
                    return i.canceled = !0
                }
            };
            return n && (i.update = function(t, n, r, s) {
                t && (i.from = ot(e, t)),
                n && (i.to = ot(e, n)),
                r && (i.text = r),
                void 0 !== s && (i.origin = s)
            }
            ),
            fe(e, "beforeChange", e, i),
            e.cm && fe(e.cm, "beforeChange", e.cm, i),
            i.canceled ? (e.cm && (e.cm.curOp.updateInput = 2),
            null) : {
                from: i.from,
                to: i.to,
                text: i.text,
                origin: i.origin
            }
        }
        function cs(e, t, n) {
            if (e.cm) {
                if (!e.cm.curOp)
                    return er(e.cm, cs)(e, t, n);
                if (e.cm.state.suppressEdits)
                    return
            }
            if (!(ve(e, "beforeChange") || e.cm && ve(e.cm, "beforeChange")) || (t = ls(e, t, !0))) {
                var i = wt && !n && function(e, t, n) {
                    var i = null;
                    if (e.iter(t.line, n.line + 1, (function(e) {
                        if (e.markedSpans)
                            for (var t = 0; t < e.markedSpans.length; ++t) {
                                var n = e.markedSpans[t].marker;
                                !n.readOnly || i && -1 != _(i, n) || (i || (i = [])).push(n)
                            }
                    }
                    )),
                    !i)
                        return null;
                    for (var r = [{
                        from: t,
                        to: n
                    }], s = 0; s < i.length; ++s)
                        for (var a = i[s], o = a.find(0), l = 0; l < r.length; ++l) {
                            var c = r[l];
                            if (!(tt(c.to, o.from) < 0 || tt(c.from, o.to) > 0)) {
                                var u = [l, 1]
                                  , d = tt(c.from, o.from)
                                  , h = tt(c.to, o.to);
                                (d < 0 || !a.inclusiveLeft && !d) && u.push({
                                    from: c.from,
                                    to: o.from
                                }),
                                (h > 0 || !a.inclusiveRight && !h) && u.push({
                                    from: o.to,
                                    to: c.to
                                }),
                                r.splice.apply(r, u),
                                l += u.length - 3
                            }
                        }
                    return r
                }(e, t.from, t.to);
                if (i)
                    for (var r = i.length - 1; r >= 0; --r)
                        us(e, {
                            from: i[r].from,
                            to: i[r].to,
                            text: r ? [""] : t.text,
                            origin: t.origin
                        });
                else
                    us(e, t)
            }
        }
        function us(e, t) {
            if (1 != t.text.length || "" != t.text[0] || 0 != tt(t.from, t.to)) {
                var n = Mr(e, t);
                _r(e, t, n, e.cm ? e.cm.curOp.id : NaN),
                ps(e, t, n, Et(e, t));
                var i = [];
                Rr(e, (function(e, n) {
                    n || -1 != _(i, e.history) || (vs(e.history, t),
                    i.push(e.history)),
                    ps(e, t, null, Et(e, t))
                }
                ))
            }
        }
        function ds(e, t, n) {
            var i = e.cm && e.cm.state.suppressEdits;
            if (!i || n) {
                for (var r, s = e.history, a = e.sel, o = "undo" == t ? s.done : s.undone, l = "undo" == t ? s.undone : s.done, c = 0; c < o.length && (r = o[c],
                n ? !r.ranges || r.equals(e.sel) : r.ranges); c++)
                    ;
                if (c != o.length) {
                    for (s.lastOrigin = s.lastSelOrigin = null; ; ) {
                        if (!(r = o.pop()).ranges) {
                            if (i)
                                return void o.push(r);
                            break
                        }
                        if (zr(r, l),
                        n && !r.equals(e.sel))
                            return void Qr(e, r, {
                                clearRedo: !1
                            });
                        a = r
                    }
                    var u = [];
                    zr(a, l),
                    l.push({
                        changes: u,
                        generation: s.generation
                    }),
                    s.generation = r.generation || ++s.maxGeneration;
                    for (var d = ve(e, "beforeChange") || e.cm && ve(e.cm, "beforeChange"), h = function(n) {
                        var i = r.changes[n];
                        if (i.origin = t,
                        d && !ls(e, i, !1))
                            return o.length = 0,
                            {};
                        u.push(Br(e, i));
                        var s = n ? Mr(e, i) : q(o);
                        ps(e, i, s, Wr(e, i)),
                        !n && e.cm && e.cm.scrollIntoView({
                            from: i.from,
                            to: Er(i)
                        });
                        var a = [];
                        Rr(e, (function(e, t) {
                            t || -1 != _(a, e.history) || (vs(e.history, i),
                            a.push(e.history)),
                            ps(e, i, null, Wr(e, i))
                        }
                        ))
                    }, p = r.changes.length - 1; p >= 0; --p) {
                        var f = h(p);
                        if (f)
                            return f.v
                    }
                }
            }
        }
        function hs(e, t) {
            if (0 != t && (e.first += t,
            e.sel = new xr(Y(e.sel.ranges, (function(e) {
                return new Cr(et(e.anchor.line + t, e.anchor.ch),et(e.head.line + t, e.head.ch))
            }
            )),e.sel.primIndex),
            e.cm)) {
                di(e.cm, e.first, e.first - t, t);
                for (var n = e.cm.display, i = n.viewFrom; i < n.viewTo; i++)
                    hi(e.cm, i, "gutter")
            }
        }
        function ps(e, t, n, i) {
            if (e.cm && !e.cm.curOp)
                return er(e.cm, ps)(e, t, n, i);
            if (t.to.line < e.first)
                hs(e, t.text.length - 1 - (t.to.line - t.from.line));
            else if (!(t.from.line > e.lastLine())) {
                if (t.from.line < e.first) {
                    var r = t.text.length - 1 - (e.first - t.from.line);
                    hs(e, r),
                    t = {
                        from: et(e.first, 0),
                        to: et(t.to.line + r, t.to.ch),
                        text: [q(t.text)],
                        origin: t.origin
                    }
                }
                var s = e.lastLine();
                t.to.line > s && (t = {
                    from: t.from,
                    to: et(s, He(e, s).text.length),
                    text: [t.text[0]],
                    origin: t.origin
                }),
                t.removed = Je(e, t.from, t.to),
                n || (n = Mr(e, t)),
                e.cm ? function(e, t, n) {
                    var i = e.doc
                      , r = e.display
                      , s = t.from
                      , a = t.to
                      , o = !1
                      , l = s.line;
                    e.options.lineWrapping || (l = Xe(Bt(He(i, s.line))),
                    i.iter(l, a.line + 1, (function(e) {
                        if (e == r.maxLine)
                            return o = !0,
                            !0
                    }
                    ))),
                    i.sel.contains(t.from, t.to) > -1 && ge(e),
                    Pr(i, t, n, oi(e)),
                    e.options.lineWrapping || (i.iter(l, s.line + t.text.length, (function(e) {
                        var t = $t(e);
                        t > r.maxLineLength && (r.maxLine = e,
                        r.maxLineLength = t,
                        r.maxLineChanged = !0,
                        o = !1)
                    }
                    )),
                    o && (e.curOp.updateMaxLine = !0)),
                    function(e, t) {
                        if (e.modeFrontier = Math.min(e.modeFrontier, t),
                        !(e.highlightFrontier < t - 10)) {
                            for (var n = e.first, i = t - 1; i > n; i--) {
                                var r = He(e, i).stateAfter;
                                if (r && (!(r instanceof ct) || i + r.lookAhead < t)) {
                                    n = i + 1;
                                    break
                                }
                            }
                            e.highlightFrontier = Math.min(e.highlightFrontier, n)
                        }
                    }(i, s.line),
                    ir(e, 400);
                    var c = t.text.length - (a.line - s.line) - 1;
                    t.full ? di(e) : s.line != a.line || 1 != t.text.length || Ir(e.doc, t) ? di(e, s.line, a.line + 1, c) : hi(e, s.line, "text");
                    var u = ve(e, "changes")
                      , d = ve(e, "change");
                    if (d || u) {
                        var h = {
                            from: s,
                            to: a,
                            text: t.text,
                            removed: t.removed,
                            origin: t.origin
                        };
                        d && ln(e, "change", e, h),
                        u && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(h)
                    }
                    e.display.selForContextMenu = null
                }(e.cm, t, i) : Pr(e, t, i),
                es(e, n, z),
                e.cantEdit && ss(e, et(e.firstLine(), 0)) && (e.cantEdit = !1)
            }
        }
        function fs(e, t, n, i, r) {
            var s;
            i || (i = n),
            tt(i, n) < 0 && (n = (s = [i, n])[0],
            i = s[1]),
            "string" == typeof t && (t = e.splitLines(t)),
            cs(e, {
                from: n,
                to: i,
                text: t,
                origin: r
            })
        }
        function ms(e, t, n, i) {
            n < e.line ? e.line += i : t < e.line && (e.line = t,
            e.ch = 0)
        }
        function gs(e, t, n, i) {
            for (var r = 0; r < e.length; ++r) {
                var s = e[r]
                  , a = !0;
                if (s.ranges) {
                    s.copied || ((s = e[r] = s.deepCopy()).copied = !0);
                    for (var o = 0; o < s.ranges.length; o++)
                        ms(s.ranges[o].anchor, t, n, i),
                        ms(s.ranges[o].head, t, n, i)
                } else {
                    for (var l = 0; l < s.changes.length; ++l) {
                        var c = s.changes[l];
                        if (n < c.from.line)
                            c.from = et(c.from.line + i, c.from.ch),
                            c.to = et(c.to.line + i, c.to.ch);
                        else if (t <= c.to.line) {
                            a = !1;
                            break
                        }
                    }
                    a || (e.splice(0, r + 1),
                    r = 0)
                }
            }
        }
        function vs(e, t) {
            var n = t.from.line
              , i = t.to.line
              , r = t.text.length - (i - n) - 1;
            gs(e.done, n, i, r),
            gs(e.undone, n, i, r)
        }
        function bs(e, t, n, i) {
            var r = t
              , s = t;
            return "number" == typeof t ? s = He(e, at(e, t)) : r = Xe(t),
            null == r ? null : (i(s, r) && e.cm && hi(e.cm, r, n),
            s)
        }
        function ys(e) {
            this.lines = e,
            this.parent = null;
            for (var t = 0, n = 0; n < e.length; ++n)
                e[n].parent = this,
                t += e[n].height;
            this.height = t
        }
        function Ss(e) {
            this.children = e;
            for (var t = 0, n = 0, i = 0; i < e.length; ++i) {
                var r = e[i];
                t += r.chunkSize(),
                n += r.height,
                r.parent = this
            }
            this.size = t,
            this.height = n,
            this.parent = null
        }
        Cr.prototype.from = function() {
            return st(this.anchor, this.head)
        }
        ,
        Cr.prototype.to = function() {
            return rt(this.anchor, this.head)
        }
        ,
        Cr.prototype.empty = function() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
        }
        ,
        ys.prototype = {
            chunkSize: function() {
                return this.lines.length
            },
            removeInner: function(e, t) {
                for (var n = e, i = e + t; n < i; ++n) {
                    var r = this.lines[n];
                    this.height -= r.height,
                    Jt(r),
                    ln(r, "delete")
                }
                this.lines.splice(e, t)
            },
            collapse: function(e) {
                e.push.apply(e, this.lines)
            },
            insertInner: function(e, t, n) {
                this.height += n,
                this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
                for (var i = 0; i < t.length; ++i)
                    t[i].parent = this
            },
            iterN: function(e, t, n) {
                for (var i = e + t; e < i; ++e)
                    if (n(this.lines[e]))
                        return !0
            }
        },
        Ss.prototype = {
            chunkSize: function() {
                return this.size
            },
            removeInner: function(e, t) {
                this.size -= t;
                for (var n = 0; n < this.children.length; ++n) {
                    var i = this.children[n]
                      , r = i.chunkSize();
                    if (e < r) {
                        var s = Math.min(t, r - e)
                          , a = i.height;
                        if (i.removeInner(e, s),
                        this.height -= a - i.height,
                        r == s && (this.children.splice(n--, 1),
                        i.parent = null),
                        0 == (t -= s))
                            break;
                        e = 0
                    } else
                        e -= r
                }
                if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0]instanceof ys))) {
                    var o = [];
                    this.collapse(o),
                    this.children = [new ys(o)],
                    this.children[0].parent = this
                }
            },
            collapse: function(e) {
                for (var t = 0; t < this.children.length; ++t)
                    this.children[t].collapse(e)
            },
            insertInner: function(e, t, n) {
                this.size += t.length,
                this.height += n;
                for (var i = 0; i < this.children.length; ++i) {
                    var r = this.children[i]
                      , s = r.chunkSize();
                    if (e <= s) {
                        if (r.insertInner(e, t, n),
                        r.lines && r.lines.length > 50) {
                            for (var a = r.lines.length % 25 + 25, o = a; o < r.lines.length; ) {
                                var l = new ys(r.lines.slice(o, o += 25));
                                r.height -= l.height,
                                this.children.splice(++i, 0, l),
                                l.parent = this
                            }
                            r.lines = r.lines.slice(0, a),
                            this.maybeSpill()
                        }
                        break
                    }
                    e -= s
                }
            },
            maybeSpill: function() {
                if (!(this.children.length <= 10)) {
                    var e = this;
                    do {
                        var t = new Ss(e.children.splice(e.children.length - 5, 5));
                        if (e.parent) {
                            e.size -= t.size,
                            e.height -= t.height;
                            var n = _(e.parent.children, e);
                            e.parent.children.splice(n + 1, 0, t)
                        } else {
                            var i = new Ss(e.children);
                            i.parent = e,
                            e.children = [i, t],
                            e = i
                        }
                        t.parent = e.parent
                    } while (e.children.length > 10);e.parent.maybeSpill()
                }
            },
            iterN: function(e, t, n) {
                for (var i = 0; i < this.children.length; ++i) {
                    var r = this.children[i]
                      , s = r.chunkSize();
                    if (e < s) {
                        var a = Math.min(t, s - e);
                        if (r.iterN(e, a, n))
                            return !0;
                        if (0 == (t -= a))
                            break;
                        e = 0
                    } else
                        e -= s
                }
            }
        };
        var ws = function(e, t, n) {
            if (n)
                for (var i in n)
                    n.hasOwnProperty(i) && (this[i] = n[i]);
            this.doc = e,
            this.node = t
        };
        function xs(e, t, n) {
            Gt(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Li(e, n)
        }
        ws.prototype.clear = function() {
            var e = this.doc.cm
              , t = this.line.widgets
              , n = this.line
              , i = Xe(n);
            if (null != i && t) {
                for (var r = 0; r < t.length; ++r)
                    t[r] == this && t.splice(r--, 1);
                t.length || (n.widgets = null);
                var s = wn(this);
                Ye(n, Math.max(0, n.height - s)),
                e && (Qi(e, (function() {
                    xs(e, n, -s),
                    hi(e, i, "widget")
                }
                )),
                ln(e, "lineWidgetCleared", e, this, i))
            }
        }
        ,
        ws.prototype.changed = function() {
            var e = this
              , t = this.height
              , n = this.doc.cm
              , i = this.line;
            this.height = null;
            var r = wn(this) - t;
            r && (Ut(this.doc, i) || Ye(i, i.height + r),
            n && Qi(n, (function() {
                n.curOp.forceUpdate = !0,
                xs(n, i, r),
                ln(n, "lineWidgetChanged", n, e, Xe(i))
            }
            )))
        }
        ,
        be(ws);
        var Cs = 0
          , Os = function(e, t) {
            this.lines = [],
            this.type = t,
            this.doc = e,
            this.id = ++Cs
        };
        function ks(e, t, n, i, r) {
            if (i && i.shared)
                return function(e, t, n, i, r) {
                    (i = V(i)).shared = !1;
                    var s = [ks(e, t, n, i, r)]
                      , a = s[0]
                      , o = i.widgetNode;
                    return Rr(e, (function(e) {
                        o && (i.widgetNode = o.cloneNode(!0)),
                        s.push(ks(e, ot(e, t), ot(e, n), i, r));
                        for (var l = 0; l < e.linked.length; ++l)
                            if (e.linked[l].isParent)
                                return;
                        a = q(s)
                    }
                    )),
                    new Es(s,a)
                }(e, t, n, i, r);
            if (e.cm && !e.cm.curOp)
                return er(e.cm, ks)(e, t, n, i, r);
            var s = new Os(e,r)
              , a = tt(t, n);
            if (i && V(i, s, !1),
            a > 0 || 0 == a && !1 !== s.clearWhenEmpty)
                return s;
            if (s.replacedWith && (s.collapsed = !0,
            s.widgetNode = L("span", [s.replacedWith], "CodeMirror-widget"),
            i.handleMouseEvents || s.widgetNode.setAttribute("cm-ignore-events", "true"),
            i.insertLeft && (s.widgetNode.insertLeft = !0)),
            s.collapsed) {
                if (Vt(e, t.line, t, n, s) || t.line != n.line && Vt(e, n.line, t, n, s))
                    throw new Error("Inserting collapsed marker partially overlapping an existing one");
                xt = !0
            }
            s.addToHistory && _r(e, {
                from: t,
                to: n,
                origin: "markText"
            }, e.sel, NaN);
            var o, l = t.line, c = e.cm;
            if (e.iter(l, n.line + 1, (function(e) {
                c && s.collapsed && !c.options.lineWrapping && Bt(e) == c.display.maxLine && (o = !0),
                s.collapsed && l != t.line && Ye(e, 0),
                function(e, t) {
                    e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t],
                    t.marker.attachLine(e)
                }(e, new Ct(s,l == t.line ? t.ch : null,l == n.line ? n.ch : null)),
                ++l
            }
            )),
            s.collapsed && e.iter(t.line, n.line + 1, (function(t) {
                Ut(e, t) && Ye(t, 0)
            }
            )),
            s.clearOnEnter && de(s, "beforeCursorEnter", (function() {
                return s.clear()
            }
            )),
            s.readOnly && (wt = !0,
            (e.history.done.length || e.history.undone.length) && e.clearHistory()),
            s.collapsed && (s.id = ++Cs,
            s.atomic = !0),
            c) {
                if (o && (c.curOp.updateMaxLine = !0),
                s.collapsed)
                    di(c, t.line, n.line + 1);
                else if (s.className || s.startStyle || s.endStyle || s.css || s.attributes || s.title)
                    for (var u = t.line; u <= n.line; u++)
                        hi(c, u, "text");
                s.atomic && ns(c.doc),
                ln(c, "markerAdded", c, s)
            }
            return s
        }
        Os.prototype.clear = function() {
            if (!this.explicitlyCleared) {
                var e = this.doc.cm
                  , t = e && !e.curOp;
                if (t && Hi(e),
                ve(this, "clear")) {
                    var n = this.find();
                    n && ln(this, "clear", n.from, n.to)
                }
                for (var i = null, r = null, s = 0; s < this.lines.length; ++s) {
                    var a = this.lines[s]
                      , o = Ot(a.markedSpans, this);
                    e && !this.collapsed ? hi(e, Xe(a), "text") : e && (null != o.to && (r = Xe(a)),
                    null != o.from && (i = Xe(a))),
                    a.markedSpans = kt(a.markedSpans, o),
                    null == o.from && this.collapsed && !Ut(this.doc, a) && e && Ye(a, ii(e.display))
                }
                if (e && this.collapsed && !e.options.lineWrapping)
                    for (var l = 0; l < this.lines.length; ++l) {
                        var c = Bt(this.lines[l])
                          , u = $t(c);
                        u > e.display.maxLineLength && (e.display.maxLine = c,
                        e.display.maxLineLength = u,
                        e.display.maxLineChanged = !0)
                    }
                null != i && e && this.collapsed && di(e, i, r + 1),
                this.lines.length = 0,
                this.explicitlyCleared = !0,
                this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1,
                e && ns(e.doc)),
                e && ln(e, "markerCleared", e, this, i, r),
                t && Ji(e),
                this.parent && this.parent.clear()
            }
        }
        ,
        Os.prototype.find = function(e, t) {
            var n, i;
            null == e && "bookmark" == this.type && (e = 1);
            for (var r = 0; r < this.lines.length; ++r) {
                var s = this.lines[r]
                  , a = Ot(s.markedSpans, this);
                if (null != a.from && (n = et(t ? s : Xe(s), a.from),
                -1 == e))
                    return n;
                if (null != a.to && (i = et(t ? s : Xe(s), a.to),
                1 == e))
                    return i
            }
            return n && {
                from: n,
                to: i
            }
        }
        ,
        Os.prototype.changed = function() {
            var e = this
              , t = this.find(-1, !0)
              , n = this
              , i = this.doc.cm;
            t && i && Qi(i, (function() {
                var r = t.line
                  , s = Xe(t.line)
                  , a = An(i, s);
                if (a && (Bn(a),
                i.curOp.selectionChanged = i.curOp.forceUpdate = !0),
                i.curOp.updateMaxLine = !0,
                !Ut(n.doc, r) && null != n.height) {
                    var o = n.height;
                    n.height = null;
                    var l = wn(n) - o;
                    l && Ye(r, r.height + l)
                }
                ln(i, "markerChanged", i, e)
            }
            ))
        }
        ,
        Os.prototype.attachLine = function(e) {
            if (!this.lines.length && this.doc.cm) {
                var t = this.doc.cm.curOp;
                t.maybeHiddenMarkers && -1 != _(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
            }
            this.lines.push(e)
        }
        ,
        Os.prototype.detachLine = function(e) {
            if (this.lines.splice(_(this.lines, e), 1),
            !this.lines.length && this.doc.cm) {
                var t = this.doc.cm.curOp;
                (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
            }
        }
        ,
        be(Os);
        var Es = function(e, t) {
            this.markers = e,
            this.primary = t;
            for (var n = 0; n < e.length; ++n)
                e[n].parent = this
        };
        function Ts(e) {
            return e.findMarks(et(e.first, 0), e.clipPos(et(e.lastLine())), (function(e) {
                return e.parent
            }
            ))
        }
        function Ms(e) {
            for (var t = function(t) {
                var n = e[t]
                  , i = [n.primary.doc];
                Rr(n.primary.doc, (function(e) {
                    return i.push(e)
                }
                ));
                for (var r = 0; r < n.markers.length; r++) {
                    var s = n.markers[r];
                    -1 == _(i, s.doc) && (s.parent = null,
                    n.markers.splice(r--, 1))
                }
            }, n = 0; n < e.length; n++)
                t(n)
        }
        Es.prototype.clear = function() {
            if (!this.explicitlyCleared) {
                this.explicitlyCleared = !0;
                for (var e = 0; e < this.markers.length; ++e)
                    this.markers[e].clear();
                ln(this, "clear")
            }
        }
        ,
        Es.prototype.find = function(e, t) {
            return this.primary.find(e, t)
        }
        ,
        be(Es);
        var Ds = 0
          , Ls = function(e, t, n, i, r) {
            if (!(this instanceof Ls))
                return new Ls(e,t,n,i,r);
            null == n && (n = 0),
            Ss.call(this, [new ys([new Ht("",null)])]),
            this.first = n,
            this.scrollTop = this.scrollLeft = 0,
            this.cantEdit = !1,
            this.cleanGeneration = 1,
            this.modeFrontier = this.highlightFrontier = n;
            var s = et(n, 0);
            this.sel = kr(s),
            this.history = new Vr(null),
            this.id = ++Ds,
            this.modeOption = t,
            this.lineSep = i,
            this.direction = "rtl" == r ? "rtl" : "ltr",
            this.extend = !1,
            "string" == typeof e && (e = this.splitLines(e)),
            Pr(this, {
                from: s,
                to: s,
                text: e
            }),
            Qr(this, kr(s), z)
        };
        Ls.prototype = K(Ss.prototype, {
            constructor: Ls,
            iter: function(e, t, n) {
                n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e)
            },
            insert: function(e, t) {
                for (var n = 0, i = 0; i < t.length; ++i)
                    n += t[i].height;
                this.insertInner(e - this.first, t, n)
            },
            remove: function(e, t) {
                this.removeInner(e - this.first, t)
            },
            getValue: function(e) {
                var t = qe(this, this.first, this.first + this.size);
                return !1 === e ? t : t.join(e || this.lineSeparator())
            },
            setValue: nr((function(e) {
                var t = et(this.first, 0)
                  , n = this.first + this.size - 1;
                cs(this, {
                    from: t,
                    to: et(n, He(this, n).text.length),
                    text: this.splitLines(e),
                    origin: "setValue",
                    full: !0
                }, !0),
                this.cm && Ii(this.cm, 0, 0),
                Qr(this, kr(t), z)
            }
            )),
            replaceRange: function(e, t, n, i) {
                fs(this, e, t = ot(this, t), n = n ? ot(this, n) : t, i)
            },
            getRange: function(e, t, n) {
                var i = Je(this, ot(this, e), ot(this, t));
                return !1 === n ? i : i.join(n || this.lineSeparator())
            },
            getLine: function(e) {
                var t = this.getLineHandle(e);
                return t && t.text
            },
            getLineHandle: function(e) {
                if (Ze(this, e))
                    return He(this, e)
            },
            getLineNumber: function(e) {
                return Xe(e)
            },
            getLineHandleVisualStart: function(e) {
                return "number" == typeof e && (e = He(this, e)),
                Bt(e)
            },
            lineCount: function() {
                return this.size
            },
            firstLine: function() {
                return this.first
            },
            lastLine: function() {
                return this.first + this.size - 1
            },
            clipPos: function(e) {
                return ot(this, e)
            },
            getCursor: function(e) {
                var t = this.sel.primary();
                return null == e || "head" == e ? t.head : "anchor" == e ? t.anchor : "end" == e || "to" == e || !1 === e ? t.to() : t.from()
            },
            listSelections: function() {
                return this.sel.ranges
            },
            somethingSelected: function() {
                return this.sel.somethingSelected()
            },
            setCursor: nr((function(e, t, n) {
                Kr(this, ot(this, "number" == typeof e ? et(e, t || 0) : e), null, n)
            }
            )),
            setSelection: nr((function(e, t, n) {
                Kr(this, ot(this, e), ot(this, t || e), n)
            }
            )),
            extendSelection: nr((function(e, t, n) {
                qr(this, ot(this, e), t && ot(this, t), n)
            }
            )),
            extendSelections: nr((function(e, t) {
                Yr(this, lt(this, e), t)
            }
            )),
            extendSelectionsBy: nr((function(e, t) {
                Yr(this, lt(this, Y(this.sel.ranges, e)), t)
            }
            )),
            setSelections: nr((function(e, t, n) {
                if (e.length) {
                    for (var i = [], r = 0; r < e.length; r++)
                        i[r] = new Cr(ot(this, e[r].anchor),ot(this, e[r].head));
                    null == t && (t = Math.min(e.length - 1, this.sel.primIndex)),
                    Qr(this, Or(this.cm, i, t), n)
                }
            }
            )),
            addSelection: nr((function(e, t, n) {
                var i = this.sel.ranges.slice(0);
                i.push(new Cr(ot(this, e),ot(this, t || e))),
                Qr(this, Or(this.cm, i, i.length - 1), n)
            }
            )),
            getSelection: function(e) {
                for (var t, n = this.sel.ranges, i = 0; i < n.length; i++) {
                    var r = Je(this, n[i].from(), n[i].to());
                    t = t ? t.concat(r) : r
                }
                return !1 === e ? t : t.join(e || this.lineSeparator())
            },
            getSelections: function(e) {
                for (var t = [], n = this.sel.ranges, i = 0; i < n.length; i++) {
                    var r = Je(this, n[i].from(), n[i].to());
                    !1 !== e && (r = r.join(e || this.lineSeparator())),
                    t[i] = r
                }
                return t
            },
            replaceSelection: function(e, t, n) {
                for (var i = [], r = 0; r < this.sel.ranges.length; r++)
                    i[r] = e;
                this.replaceSelections(i, t, n || "+input")
            },
            replaceSelections: nr((function(e, t, n) {
                for (var i = [], r = this.sel, s = 0; s < r.ranges.length; s++) {
                    var a = r.ranges[s];
                    i[s] = {
                        from: a.from(),
                        to: a.to(),
                        text: this.splitLines(e[s]),
                        origin: n
                    }
                }
                for (var o = t && "end" != t && function(e, t, n) {
                    for (var i = [], r = et(e.first, 0), s = r, a = 0; a < t.length; a++) {
                        var o = t[a]
                          , l = Dr(o.from, r, s)
                          , c = Dr(Er(o), r, s);
                        if (r = o.to,
                        s = c,
                        "around" == n) {
                            var u = e.sel.ranges[a]
                              , d = tt(u.head, u.anchor) < 0;
                            i[a] = new Cr(d ? c : l,d ? l : c)
                        } else
                            i[a] = new Cr(l,l)
                    }
                    return new xr(i,e.sel.primIndex)
                }(this, i, t), l = i.length - 1; l >= 0; l--)
                    cs(this, i[l]);
                o ? Zr(this, o) : this.cm && Ai(this.cm)
            }
            )),
            undo: nr((function() {
                ds(this, "undo")
            }
            )),
            redo: nr((function() {
                ds(this, "redo")
            }
            )),
            undoSelection: nr((function() {
                ds(this, "undo", !0)
            }
            )),
            redoSelection: nr((function() {
                ds(this, "redo", !0)
            }
            )),
            setExtending: function(e) {
                this.extend = e
            },
            getExtending: function() {
                return this.extend
            },
            historySize: function() {
                for (var e = this.history, t = 0, n = 0, i = 0; i < e.done.length; i++)
                    e.done[i].ranges || ++t;
                for (var r = 0; r < e.undone.length; r++)
                    e.undone[r].ranges || ++n;
                return {
                    undo: t,
                    redo: n
                }
            },
            clearHistory: function() {
                this.history = new Vr(this.history.maxGeneration)
            },
            markClean: function() {
                this.cleanGeneration = this.changeGeneration(!0)
            },
            changeGeneration: function(e) {
                return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null),
                this.history.generation
            },
            isClean: function(e) {
                return this.history.generation == (e || this.cleanGeneration)
            },
            getHistory: function() {
                return {
                    done: Hr(this.history.done),
                    undone: Hr(this.history.undone)
                }
            },
            setHistory: function(e) {
                var t = this.history = new Vr(this.history.maxGeneration);
                t.done = Hr(e.done.slice(0), null, !0),
                t.undone = Hr(e.undone.slice(0), null, !0)
            },
            setGutterMarker: nr((function(e, t, n) {
                return bs(this, e, "gutter", (function(e) {
                    var i = e.gutterMarkers || (e.gutterMarkers = {});
                    return i[t] = n,
                    !n && te(i) && (e.gutterMarkers = null),
                    !0
                }
                ))
            }
            )),
            clearGutter: nr((function(e) {
                var t = this;
                this.iter((function(n) {
                    n.gutterMarkers && n.gutterMarkers[e] && bs(t, n, "gutter", (function() {
                        return n.gutterMarkers[e] = null,
                        te(n.gutterMarkers) && (n.gutterMarkers = null),
                        !0
                    }
                    ))
                }
                ))
            }
            )),
            lineInfo: function(e) {
                var t;
                if ("number" == typeof e) {
                    if (!Ze(this, e))
                        return null;
                    if (t = e,
                    !(e = He(this, e)))
                        return null
                } else if (null == (t = Xe(e)))
                    return null;
                return {
                    line: t,
                    handle: e,
                    text: e.text,
                    gutterMarkers: e.gutterMarkers,
                    textClass: e.textClass,
                    bgClass: e.bgClass,
                    wrapClass: e.wrapClass,
                    widgets: e.widgets
                }
            },
            addLineClass: nr((function(e, t, n) {
                return bs(this, e, "gutter" == t ? "gutter" : "class", (function(e) {
                    var i = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass";
                    if (e[i]) {
                        if (O(n).test(e[i]))
                            return !1;
                        e[i] += " " + n
                    } else
                        e[i] = n;
                    return !0
                }
                ))
            }
            )),
            removeLineClass: nr((function(e, t, n) {
                return bs(this, e, "gutter" == t ? "gutter" : "class", (function(e) {
                    var i = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass"
                      , r = e[i];
                    if (!r)
                        return !1;
                    if (null == n)
                        e[i] = null;
                    else {
                        var s = r.match(O(n));
                        if (!s)
                            return !1;
                        var a = s.index + s[0].length;
                        e[i] = r.slice(0, s.index) + (s.index && a != r.length ? " " : "") + r.slice(a) || null
                    }
                    return !0
                }
                ))
            }
            )),
            addLineWidget: nr((function(e, t, n) {
                return function(e, t, n, i) {
                    var r = new ws(e,n,i)
                      , s = e.cm;
                    return s && r.noHScroll && (s.display.alignWidgets = !0),
                    bs(e, t, "widget", (function(t) {
                        var n = t.widgets || (t.widgets = []);
                        if (null == r.insertAt ? n.push(r) : n.splice(Math.min(n.length - 1, Math.max(0, r.insertAt)), 0, r),
                        r.line = t,
                        s && !Ut(e, t)) {
                            var i = Gt(t) < e.scrollTop;
                            Ye(t, t.height + wn(r)),
                            i && Li(s, r.height),
                            s.curOp.forceUpdate = !0
                        }
                        return !0
                    }
                    )),
                    s && ln(s, "lineWidgetAdded", s, r, "number" == typeof t ? t : Xe(t)),
                    r
                }(this, e, t, n)
            }
            )),
            removeLineWidget: function(e) {
                e.clear()
            },
            markText: function(e, t, n) {
                return ks(this, ot(this, e), ot(this, t), n, n && n.type || "range")
            },
            setBookmark: function(e, t) {
                var n = {
                    replacedWith: t && (null == t.nodeType ? t.widget : t),
                    insertLeft: t && t.insertLeft,
                    clearWhenEmpty: !1,
                    shared: t && t.shared,
                    handleMouseEvents: t && t.handleMouseEvents
                };
                return ks(this, e = ot(this, e), e, n, "bookmark")
            },
            findMarksAt: function(e) {
                var t = []
                  , n = He(this, (e = ot(this, e)).line).markedSpans;
                if (n)
                    for (var i = 0; i < n.length; ++i) {
                        var r = n[i];
                        (null == r.from || r.from <= e.ch) && (null == r.to || r.to >= e.ch) && t.push(r.marker.parent || r.marker)
                    }
                return t
            },
            findMarks: function(e, t, n) {
                e = ot(this, e),
                t = ot(this, t);
                var i = []
                  , r = e.line;
                return this.iter(e.line, t.line + 1, (function(s) {
                    var a = s.markedSpans;
                    if (a)
                        for (var o = 0; o < a.length; o++) {
                            var l = a[o];
                            null != l.to && r == e.line && e.ch >= l.to || null == l.from && r != e.line || null != l.from && r == t.line && l.from >= t.ch || n && !n(l.marker) || i.push(l.marker.parent || l.marker)
                        }
                    ++r
                }
                )),
                i
            },
            getAllMarks: function() {
                var e = [];
                return this.iter((function(t) {
                    var n = t.markedSpans;
                    if (n)
                        for (var i = 0; i < n.length; ++i)
                            null != n[i].from && e.push(n[i].marker)
                }
                )),
                e
            },
            posFromIndex: function(e) {
                var t, n = this.first, i = this.lineSeparator().length;
                return this.iter((function(r) {
                    var s = r.text.length + i;
                    if (s > e)
                        return t = e,
                        !0;
                    e -= s,
                    ++n
                }
                )),
                ot(this, et(n, t))
            },
            indexFromPos: function(e) {
                var t = (e = ot(this, e)).ch;
                if (e.line < this.first || e.ch < 0)
                    return 0;
                var n = this.lineSeparator().length;
                return this.iter(this.first, e.line, (function(e) {
                    t += e.text.length + n
                }
                )),
                t
            },
            copy: function(e) {
                var t = new Ls(qe(this, this.first, this.first + this.size),this.modeOption,this.first,this.lineSep,this.direction);
                return t.scrollTop = this.scrollTop,
                t.scrollLeft = this.scrollLeft,
                t.sel = this.sel,
                t.extend = !1,
                e && (t.history.undoDepth = this.history.undoDepth,
                t.setHistory(this.getHistory())),
                t
            },
            linkedDoc: function(e) {
                e || (e = {});
                var t = this.first
                  , n = this.first + this.size;
                null != e.from && e.from > t && (t = e.from),
                null != e.to && e.to < n && (n = e.to);
                var i = new Ls(qe(this, t, n),e.mode || this.modeOption,t,this.lineSep,this.direction);
                return e.sharedHist && (i.history = this.history),
                (this.linked || (this.linked = [])).push({
                    doc: i,
                    sharedHist: e.sharedHist
                }),
                i.linked = [{
                    doc: this,
                    isParent: !0,
                    sharedHist: e.sharedHist
                }],
                function(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n]
                          , r = i.find()
                          , s = e.clipPos(r.from)
                          , a = e.clipPos(r.to);
                        if (tt(s, a)) {
                            var o = ks(e, s, a, i.primary, i.primary.type);
                            i.markers.push(o),
                            o.parent = i
                        }
                    }
                }(i, Ts(this)),
                i
            },
            unlinkDoc: function(e) {
                if (e instanceof Ea && (e = e.doc),
                this.linked)
                    for (var t = 0; t < this.linked.length; ++t)
                        if (this.linked[t].doc == e) {
                            this.linked.splice(t, 1),
                            e.unlinkDoc(this),
                            Ms(Ts(this));
                            break
                        }
                if (e.history == this.history) {
                    var n = [e.id];
                    Rr(e, (function(e) {
                        return n.push(e.id)
                    }
                    ), !0),
                    e.history = new Vr(null),
                    e.history.done = Hr(this.history.done, n),
                    e.history.undone = Hr(this.history.undone, n)
                }
            },
            iterLinkedDocs: function(e) {
                Rr(this, e)
            },
            getMode: function() {
                return this.mode
            },
            getEditor: function() {
                return this.cm
            },
            splitLines: function(e) {
                return this.lineSep ? e.split(this.lineSep) : Ae(e)
            },
            lineSeparator: function() {
                return this.lineSep || "\n"
            },
            setDirection: nr((function(e) {
                var t;
                "rtl" != e && (e = "ltr"),
                e != this.direction && (this.direction = e,
                this.iter((function(e) {
                    return e.order = null
                }
                )),
                this.cm && Qi(t = this.cm, (function() {
                    Nr(t),
                    di(t)
                }
                )))
            }
            ))
        }),
        Ls.prototype.eachLine = Ls.prototype.iter;
        var As = 0;
        function Is(e) {
            var t = this;
            if (Ps(t),
            !me(t, e) && !xn(t.display, e)) {
                ye(e),
                a && (As = +new Date);
                var n = ci(t, e, !0)
                  , i = e.dataTransfer.files;
                if (n && !t.isReadOnly())
                    if (i && i.length && window.FileReader && window.File)
                        for (var r = i.length, s = Array(r), o = 0, l = function(e, i) {
                            if (!t.options.allowDropFileTypes || -1 != _(t.options.allowDropFileTypes, e.type)) {
                                var a = new FileReader;
                                a.onload = er(t, (function() {
                                    var e = a.result;
                                    if (/[\x00-\x08\x0e-\x1f]{2}/.test(e) && (e = ""),
                                    s[i] = e,
                                    ++o == r) {
                                        var l = {
                                            from: n = ot(t.doc, n),
                                            to: n,
                                            text: t.doc.splitLines(s.join(t.doc.lineSeparator())),
                                            origin: "paste"
                                        };
                                        cs(t.doc, l),
                                        Zr(t.doc, kr(n, Er(l)))
                                    }
                                }
                                )),
                                a.readAsText(e)
                            }
                        }, c = 0; c < r; ++c)
                            l(i[c], c);
                    else {
                        if (t.state.draggingText && t.doc.sel.contains(n) > -1)
                            return t.state.draggingText(e),
                            void setTimeout((function() {
                                return t.display.input.focus()
                            }
                            ), 20);
                        try {
                            var u = e.dataTransfer.getData("Text");
                            if (u) {
                                var d;
                                if (t.state.draggingText && !t.state.draggingText.copy && (d = t.listSelections()),
                                es(t.doc, kr(n, n)),
                                d)
                                    for (var h = 0; h < d.length; ++h)
                                        fs(t.doc, "", d[h].anchor, d[h].head, "drag");
                                t.replaceSelection(u, "around", "paste"),
                                t.display.input.focus()
                            }
                        } catch (e) {}
                    }
            }
        }
        function Ps(e) {
            e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor),
            e.display.dragCursor = null)
        }
        function Rs(e) {
            if (document.getElementsByClassName) {
                for (var t = document.getElementsByClassName("CodeMirror"), n = [], i = 0; i < t.length; i++) {
                    var r = t[i].CodeMirror;
                    r && n.push(r)
                }
                n.length && n[0].operation((function() {
                    for (var t = 0; t < n.length; t++)
                        e(n[t])
                }
                ))
            }
        }
        var js = !1;
        function Ns() {
            var e;
            js || (de(window, "resize", (function() {
                null == e && (e = setTimeout((function() {
                    e = null,
                    Rs(Vs)
                }
                ), 100))
            }
            )),
            de(window, "blur", (function() {
                return Rs(ki)
            }
            )),
            js = !0)
        }
        function Vs(e) {
            var t = e.display;
            t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null,
            t.scrollbarsClipped = !1,
            e.setSize()
        }
        for (var Bs = {
            3: "Pause",
            8: "Backspace",
            9: "Tab",
            13: "Enter",
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "PrintScrn",
            45: "Insert",
            46: "Delete",
            59: ";",
            61: "=",
            91: "Mod",
            92: "Mod",
            93: "Mod",
            106: "*",
            107: "=",
            109: "-",
            110: ".",
            111: "/",
            145: "ScrollLock",
            173: "-",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            63232: "Up",
            63233: "Down",
            63234: "Left",
            63235: "Right",
            63272: "Delete",
            63273: "Home",
            63275: "End",
            63276: "PageUp",
            63277: "PageDown",
            63302: "Insert"
        }, Fs = 0; Fs < 10; Fs++)
            Bs[Fs + 48] = Bs[Fs + 96] = String(Fs);
        for (var _s = 65; _s <= 90; _s++)
            Bs[_s] = String.fromCharCode(_s);
        for (var Us = 1; Us <= 12; Us++)
            Bs[Us + 111] = Bs[Us + 63235] = "F" + Us;
        var zs = {};
        function Gs(e) {
            var t, n, i, r, s = e.split(/-(?!$)/);
            e = s[s.length - 1];
            for (var a = 0; a < s.length - 1; a++) {
                var o = s[a];
                if (/^(cmd|meta|m)$/i.test(o))
                    r = !0;
                else if (/^a(lt)?$/i.test(o))
                    t = !0;
                else if (/^(c|ctrl|control)$/i.test(o))
                    n = !0;
                else {
                    if (!/^s(hift)?$/i.test(o))
                        throw new Error("Unrecognized modifier name: " + o);
                    i = !0
                }
            }
            return t && (e = "Alt-" + e),
            n && (e = "Ctrl-" + e),
            r && (e = "Cmd-" + e),
            i && (e = "Shift-" + e),
            e
        }
        function $s(e) {
            var t = {};
            for (var n in e)
                if (e.hasOwnProperty(n)) {
                    var i = e[n];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(n))
                        continue;
                    if ("..." == i) {
                        delete e[n];
                        continue
                    }
                    for (var r = Y(n.split(" "), Gs), s = 0; s < r.length; s++) {
                        var a = void 0
                          , o = void 0;
                        s == r.length - 1 ? (o = r.join(" "),
                        a = i) : (o = r.slice(0, s + 1).join(" "),
                        a = "...");
                        var l = t[o];
                        if (l) {
                            if (l != a)
                                throw new Error("Inconsistent bindings for " + o)
                        } else
                            t[o] = a
                    }
                    delete e[n]
                }
            for (var c in t)
                e[c] = t[c];
            return e
        }
        function Ws(e, t, n, i) {
            var r = (t = Ys(t)).call ? t.call(e, i) : t[e];
            if (!1 === r)
                return "nothing";
            if ("..." === r)
                return "multi";
            if (null != r && n(r))
                return "handled";
            if (t.fallthrough) {
                if ("[object Array]" != Object.prototype.toString.call(t.fallthrough))
                    return Ws(e, t.fallthrough, n, i);
                for (var s = 0; s < t.fallthrough.length; s++) {
                    var a = Ws(e, t.fallthrough[s], n, i);
                    if (a)
                        return a
                }
            }
        }
        function Hs(e) {
            var t = "string" == typeof e ? e : Bs[e.keyCode];
            return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
        }
        function Js(e, t, n) {
            var i = e;
            return t.altKey && "Alt" != i && (e = "Alt-" + e),
            (x ? t.metaKey : t.ctrlKey) && "Ctrl" != i && (e = "Ctrl-" + e),
            (x ? t.ctrlKey : t.metaKey) && "Cmd" != i && (e = "Cmd-" + e),
            !n && t.shiftKey && "Shift" != i && (e = "Shift-" + e),
            e
        }
        function qs(e, t) {
            if (d && 34 == e.keyCode && e.char)
                return !1;
            var n = Bs[e.keyCode];
            return null != n && !e.altGraphKey && (3 == e.keyCode && e.code && (n = e.code),
            Js(n, e, t))
        }
        function Ys(e) {
            return "string" == typeof e ? zs[e] : e
        }
        function Xs(e, t) {
            for (var n = e.doc.sel.ranges, i = [], r = 0; r < n.length; r++) {
                for (var s = t(n[r]); i.length && tt(s.from, q(i).to) <= 0; ) {
                    var a = i.pop();
                    if (tt(a.from, s.from) < 0) {
                        s.from = a.from;
                        break
                    }
                }
                i.push(s)
            }
            Qi(e, (function() {
                for (var t = i.length - 1; t >= 0; t--)
                    fs(e.doc, "", i[t].from, i[t].to, "+delete");
                Ai(e)
            }
            ))
        }
        function Ks(e, t, n) {
            var i = re(e.text, t + n, n);
            return i < 0 || i > e.text.length ? null : i
        }
        function Zs(e, t, n) {
            var i = Ks(e, t.ch, n);
            return null == i ? null : new et(t.line,i,n < 0 ? "after" : "before")
        }
        function Qs(e, t, n, i, r) {
            if (e) {
                var s = ce(n, t.doc.direction);
                if (s) {
                    var a, o = r < 0 ? q(s) : s[0], l = r < 0 == (1 == o.level) ? "after" : "before";
                    if (o.level > 0 || "rtl" == t.doc.direction) {
                        var c = In(t, n);
                        a = r < 0 ? n.text.length - 1 : 0;
                        var u = Pn(t, c, a).top;
                        a = se((function(e) {
                            return Pn(t, c, e).top == u
                        }
                        ), r < 0 == (1 == o.level) ? o.from : o.to - 1, a),
                        "before" == l && (a = Ks(n, a, 1))
                    } else
                        a = r < 0 ? o.to : o.from;
                    return new et(i,a,l)
                }
            }
            return new et(i,r < 0 ? n.text.length : 0,r < 0 ? "before" : "after")
        }
        zs.basic = {
            Left: "goCharLeft",
            Right: "goCharRight",
            Up: "goLineUp",
            Down: "goLineDown",
            End: "goLineEnd",
            Home: "goLineStartSmart",
            PageUp: "goPageUp",
            PageDown: "goPageDown",
            Delete: "delCharAfter",
            Backspace: "delCharBefore",
            "Shift-Backspace": "delCharBefore",
            Tab: "defaultTab",
            "Shift-Tab": "indentAuto",
            Enter: "newlineAndIndent",
            Insert: "toggleOverwrite",
            Esc: "singleSelection"
        },
        zs.pcDefault = {
            "Ctrl-A": "selectAll",
            "Ctrl-D": "deleteLine",
            "Ctrl-Z": "undo",
            "Shift-Ctrl-Z": "redo",
            "Ctrl-Y": "redo",
            "Ctrl-Home": "goDocStart",
            "Ctrl-End": "goDocEnd",
            "Ctrl-Up": "goLineUp",
            "Ctrl-Down": "goLineDown",
            "Ctrl-Left": "goGroupLeft",
            "Ctrl-Right": "goGroupRight",
            "Alt-Left": "goLineStart",
            "Alt-Right": "goLineEnd",
            "Ctrl-Backspace": "delGroupBefore",
            "Ctrl-Delete": "delGroupAfter",
            "Ctrl-S": "save",
            "Ctrl-F": "find",
            "Ctrl-G": "findNext",
            "Shift-Ctrl-G": "findPrev",
            "Shift-Ctrl-F": "replace",
            "Shift-Ctrl-R": "replaceAll",
            "Ctrl-[": "indentLess",
            "Ctrl-]": "indentMore",
            "Ctrl-U": "undoSelection",
            "Shift-Ctrl-U": "redoSelection",
            "Alt-U": "redoSelection",
            fallthrough: "basic"
        },
        zs.emacsy = {
            "Ctrl-F": "goCharRight",
            "Ctrl-B": "goCharLeft",
            "Ctrl-P": "goLineUp",
            "Ctrl-N": "goLineDown",
            "Alt-F": "goWordRight",
            "Alt-B": "goWordLeft",
            "Ctrl-A": "goLineStart",
            "Ctrl-E": "goLineEnd",
            "Ctrl-V": "goPageDown",
            "Shift-Ctrl-V": "goPageUp",
            "Ctrl-D": "delCharAfter",
            "Ctrl-H": "delCharBefore",
            "Alt-D": "delWordAfter",
            "Alt-Backspace": "delWordBefore",
            "Ctrl-K": "killLine",
            "Ctrl-T": "transposeChars",
            "Ctrl-O": "openLine"
        },
        zs.macDefault = {
            "Cmd-A": "selectAll",
            "Cmd-D": "deleteLine",
            "Cmd-Z": "undo",
            "Shift-Cmd-Z": "redo",
            "Cmd-Y": "redo",
            "Cmd-Home": "goDocStart",
            "Cmd-Up": "goDocStart",
            "Cmd-End": "goDocEnd",
            "Cmd-Down": "goDocEnd",
            "Alt-Left": "goGroupLeft",
            "Alt-Right": "goGroupRight",
            "Cmd-Left": "goLineLeft",
            "Cmd-Right": "goLineRight",
            "Alt-Backspace": "delGroupBefore",
            "Ctrl-Alt-Backspace": "delGroupAfter",
            "Alt-Delete": "delGroupAfter",
            "Cmd-S": "save",
            "Cmd-F": "find",
            "Cmd-G": "findNext",
            "Shift-Cmd-G": "findPrev",
            "Cmd-Alt-F": "replace",
            "Shift-Cmd-Alt-F": "replaceAll",
            "Cmd-[": "indentLess",
            "Cmd-]": "indentMore",
            "Cmd-Backspace": "delWrappedLineLeft",
            "Cmd-Delete": "delWrappedLineRight",
            "Cmd-U": "undoSelection",
            "Shift-Cmd-U": "redoSelection",
            "Ctrl-Up": "goDocStart",
            "Ctrl-Down": "goDocEnd",
            fallthrough: ["basic", "emacsy"]
        },
        zs.default = b ? zs.macDefault : zs.pcDefault;
        var ea = {
            selectAll: os,
            singleSelection: function(e) {
                return e.setSelection(e.getCursor("anchor"), e.getCursor("head"), z)
            },
            killLine: function(e) {
                return Xs(e, (function(t) {
                    if (t.empty()) {
                        var n = He(e.doc, t.head.line).text.length;
                        return t.head.ch == n && t.head.line < e.lastLine() ? {
                            from: t.head,
                            to: et(t.head.line + 1, 0)
                        } : {
                            from: t.head,
                            to: et(t.head.line, n)
                        }
                    }
                    return {
                        from: t.from(),
                        to: t.to()
                    }
                }
                ))
            },
            deleteLine: function(e) {
                return Xs(e, (function(t) {
                    return {
                        from: et(t.from().line, 0),
                        to: ot(e.doc, et(t.to().line + 1, 0))
                    }
                }
                ))
            },
            delLineLeft: function(e) {
                return Xs(e, (function(e) {
                    return {
                        from: et(e.from().line, 0),
                        to: e.from()
                    }
                }
                ))
            },
            delWrappedLineLeft: function(e) {
                return Xs(e, (function(t) {
                    var n = e.charCoords(t.head, "div").top + 5;
                    return {
                        from: e.coordsChar({
                            left: 0,
                            top: n
                        }, "div"),
                        to: t.from()
                    }
                }
                ))
            },
            delWrappedLineRight: function(e) {
                return Xs(e, (function(t) {
                    var n = e.charCoords(t.head, "div").top + 5
                      , i = e.coordsChar({
                        left: e.display.lineDiv.offsetWidth + 100,
                        top: n
                    }, "div");
                    return {
                        from: t.from(),
                        to: i
                    }
                }
                ))
            },
            undo: function(e) {
                return e.undo()
            },
            redo: function(e) {
                return e.redo()
            },
            undoSelection: function(e) {
                return e.undoSelection()
            },
            redoSelection: function(e) {
                return e.redoSelection()
            },
            goDocStart: function(e) {
                return e.extendSelection(et(e.firstLine(), 0))
            },
            goDocEnd: function(e) {
                return e.extendSelection(et(e.lastLine()))
            },
            goLineStart: function(e) {
                return e.extendSelectionsBy((function(t) {
                    return ta(e, t.head.line)
                }
                ), {
                    origin: "+move",
                    bias: 1
                })
            },
            goLineStartSmart: function(e) {
                return e.extendSelectionsBy((function(t) {
                    return na(e, t.head)
                }
                ), {
                    origin: "+move",
                    bias: 1
                })
            },
            goLineEnd: function(e) {
                return e.extendSelectionsBy((function(t) {
                    return function(e, t) {
                        var n = He(e.doc, t)
                          , i = function(e) {
                            for (var t; t = jt(e); )
                                e = t.find(1, !0).line;
                            return e
                        }(n);
                        return i != n && (t = Xe(i)),
                        Qs(!0, e, n, t, -1)
                    }(e, t.head.line)
                }
                ), {
                    origin: "+move",
                    bias: -1
                })
            },
            goLineRight: function(e) {
                return e.extendSelectionsBy((function(t) {
                    var n = e.cursorCoords(t.head, "div").top + 5;
                    return e.coordsChar({
                        left: e.display.lineDiv.offsetWidth + 100,
                        top: n
                    }, "div")
                }
                ), $)
            },
            goLineLeft: function(e) {
                return e.extendSelectionsBy((function(t) {
                    var n = e.cursorCoords(t.head, "div").top + 5;
                    return e.coordsChar({
                        left: 0,
                        top: n
                    }, "div")
                }
                ), $)
            },
            goLineLeftSmart: function(e) {
                return e.extendSelectionsBy((function(t) {
                    var n = e.cursorCoords(t.head, "div").top + 5
                      , i = e.coordsChar({
                        left: 0,
                        top: n
                    }, "div");
                    return i.ch < e.getLine(i.line).search(/\S/) ? na(e, t.head) : i
                }
                ), $)
            },
            goLineUp: function(e) {
                return e.moveV(-1, "line")
            },
            goLineDown: function(e) {
                return e.moveV(1, "line")
            },
            goPageUp: function(e) {
                return e.moveV(-1, "page")
            },
            goPageDown: function(e) {
                return e.moveV(1, "page")
            },
            goCharLeft: function(e) {
                return e.moveH(-1, "char")
            },
            goCharRight: function(e) {
                return e.moveH(1, "char")
            },
            goColumnLeft: function(e) {
                return e.moveH(-1, "column")
            },
            goColumnRight: function(e) {
                return e.moveH(1, "column")
            },
            goWordLeft: function(e) {
                return e.moveH(-1, "word")
            },
            goGroupRight: function(e) {
                return e.moveH(1, "group")
            },
            goGroupLeft: function(e) {
                return e.moveH(-1, "group")
            },
            goWordRight: function(e) {
                return e.moveH(1, "word")
            },
            delCharBefore: function(e) {
                return e.deleteH(-1, "char")
            },
            delCharAfter: function(e) {
                return e.deleteH(1, "char")
            },
            delWordBefore: function(e) {
                return e.deleteH(-1, "word")
            },
            delWordAfter: function(e) {
                return e.deleteH(1, "word")
            },
            delGroupBefore: function(e) {
                return e.deleteH(-1, "group")
            },
            delGroupAfter: function(e) {
                return e.deleteH(1, "group")
            },
            indentAuto: function(e) {
                return e.indentSelection("smart")
            },
            indentMore: function(e) {
                return e.indentSelection("add")
            },
            indentLess: function(e) {
                return e.indentSelection("subtract")
            },
            insertTab: function(e) {
                return e.replaceSelection("\t")
            },
            insertSoftTab: function(e) {
                for (var t = [], n = e.listSelections(), i = e.options.tabSize, r = 0; r < n.length; r++) {
                    var s = n[r].from()
                      , a = B(e.getLine(s.line), s.ch, i);
                    t.push(J(i - a % i))
                }
                e.replaceSelections(t)
            },
            defaultTab: function(e) {
                e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab")
            },
            transposeChars: function(e) {
                return Qi(e, (function() {
                    for (var t = e.listSelections(), n = [], i = 0; i < t.length; i++)
                        if (t[i].empty()) {
                            var r = t[i].head
                              , s = He(e.doc, r.line).text;
                            if (s)
                                if (r.ch == s.length && (r = new et(r.line,r.ch - 1)),
                                r.ch > 0)
                                    r = new et(r.line,r.ch + 1),
                                    e.replaceRange(s.charAt(r.ch - 1) + s.charAt(r.ch - 2), et(r.line, r.ch - 2), r, "+transpose");
                                else if (r.line > e.doc.first) {
                                    var a = He(e.doc, r.line - 1).text;
                                    a && (r = new et(r.line,1),
                                    e.replaceRange(s.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), et(r.line - 1, a.length - 1), r, "+transpose"))
                                }
                            n.push(new Cr(r,r))
                        }
                    e.setSelections(n)
                }
                ))
            },
            newlineAndIndent: function(e) {
                return Qi(e, (function() {
                    for (var t = e.listSelections(), n = t.length - 1; n >= 0; n--)
                        e.replaceRange(e.doc.lineSeparator(), t[n].anchor, t[n].head, "+input");
                    t = e.listSelections();
                    for (var i = 0; i < t.length; i++)
                        e.indentLine(t[i].from().line, null, !0);
                    Ai(e)
                }
                ))
            },
            openLine: function(e) {
                return e.replaceSelection("\n", "start")
            },
            toggleOverwrite: function(e) {
                return e.toggleOverwrite()
            }
        };
        function ta(e, t) {
            var n = He(e.doc, t)
              , i = Bt(n);
            return i != n && (t = Xe(i)),
            Qs(!0, e, i, t, 1)
        }
        function na(e, t) {
            var n = ta(e, t.line)
              , i = He(e.doc, n.line)
              , r = ce(i, e.doc.direction);
            if (!r || 0 == r[0].level) {
                var s = Math.max(0, i.text.search(/\S/))
                  , a = t.line == n.line && t.ch <= s && t.ch;
                return et(n.line, a ? 0 : s, n.sticky)
            }
            return n
        }
        function ia(e, t, n) {
            if ("string" == typeof t && !(t = ea[t]))
                return !1;
            e.display.input.ensurePolled();
            var i = e.display.shift
              , r = !1;
            try {
                e.isReadOnly() && (e.state.suppressEdits = !0),
                n && (e.display.shift = !1),
                r = t(e) != U
            } finally {
                e.display.shift = i,
                e.state.suppressEdits = !1
            }
            return r
        }
        var ra = new F;
        function sa(e, t, n, i) {
            var r = e.state.keySeq;
            if (r) {
                if (Hs(t))
                    return "handled";
                if (/\'$/.test(t) ? e.state.keySeq = null : ra.set(50, (function() {
                    e.state.keySeq == r && (e.state.keySeq = null,
                    e.display.input.reset())
                }
                )),
                aa(e, r + " " + t, n, i))
                    return !0
            }
            return aa(e, t, n, i)
        }
        function aa(e, t, n, i) {
            var r = function(e, t, n) {
                for (var i = 0; i < e.state.keyMaps.length; i++) {
                    var r = Ws(t, e.state.keyMaps[i], n, e);
                    if (r)
                        return r
                }
                return e.options.extraKeys && Ws(t, e.options.extraKeys, n, e) || Ws(t, e.options.keyMap, n, e)
            }(e, t, i);
            return "multi" == r && (e.state.keySeq = t),
            "handled" == r && ln(e, "keyHandled", e, t, n),
            "handled" != r && "multi" != r || (ye(n),
            wi(e)),
            !!r
        }
        function oa(e, t) {
            var n = qs(t, !0);
            return !!n && (t.shiftKey && !e.state.keySeq ? sa(e, "Shift-" + n, t, (function(t) {
                return ia(e, t, !0)
            }
            )) || sa(e, n, t, (function(t) {
                if ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion)
                    return ia(e, t)
            }
            )) : sa(e, n, t, (function(t) {
                return ia(e, t)
            }
            )))
        }
        var la = null;
        function ca(e) {
            var t = this;
            if (t.curOp.focus = I(),
            !me(t, e)) {
                a && o < 11 && 27 == e.keyCode && (e.returnValue = !1);
                var i = e.keyCode;
                t.display.shift = 16 == i || e.shiftKey;
                var r = oa(t, e);
                d && (la = r ? i : null,
                !r && 88 == i && !Pe && (b ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")),
                n && !b && !r && 46 == i && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"),
                18 != i || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || function(e) {
                    var t = e.display.lineDiv;
                    function n(e) {
                        18 != e.keyCode && e.altKey || (E(t, "CodeMirror-crosshair"),
                        pe(document, "keyup", n),
                        pe(document, "mouseover", n))
                    }
                    P(t, "CodeMirror-crosshair"),
                    de(document, "keyup", n),
                    de(document, "mouseover", n)
                }(t)
            }
        }
        function ua(e) {
            16 == e.keyCode && (this.doc.sel.shift = !1),
            me(this, e)
        }
        function da(e) {
            var t = this;
            if (!(xn(t.display, e) || me(t, e) || e.ctrlKey && !e.altKey || b && e.metaKey)) {
                var n = e.keyCode
                  , i = e.charCode;
                if (d && n == la)
                    return la = null,
                    void ye(e);
                if (!d || e.which && !(e.which < 10) || !oa(t, e)) {
                    var r = String.fromCharCode(null == i ? n : i);
                    "\b" != r && (function(e, t, n) {
                        return sa(e, "'" + n + "'", t, (function(t) {
                            return ia(e, t, !0)
                        }
                        ))
                    }(t, e, r) || t.display.input.onKeyPress(e))
                }
            }
        }
        var ha, pa, fa = function(e, t, n) {
            this.time = e,
            this.pos = t,
            this.button = n
        };
        function ma(e) {
            var t = this
              , n = t.display;
            if (!(me(t, e) || n.activeTouch && n.input.supportsTouch()))
                if (n.input.ensurePolled(),
                n.shift = e.shiftKey,
                xn(n, e))
                    l || (n.scroller.draggable = !1,
                    setTimeout((function() {
                        return n.scroller.draggable = !0
                    }
                    ), 100));
                else if (!ba(t, e)) {
                    var i = ci(t, e)
                      , r = Oe(e)
                      , s = i ? function(e, t) {
                        var n = +new Date;
                        return pa && pa.compare(n, e, t) ? (ha = pa = null,
                        "triple") : ha && ha.compare(n, e, t) ? (pa = new fa(n,e,t),
                        ha = null,
                        "double") : (ha = new fa(n,e,t),
                        pa = null,
                        "single")
                    }(i, r) : "single";
                    window.focus(),
                    1 == r && t.state.selectingText && t.state.selectingText(e),
                    i && function(e, t, n, i, r) {
                        var s = "Click";
                        return "double" == i ? s = "Double" + s : "triple" == i && (s = "Triple" + s),
                        sa(e, Js(s = (1 == t ? "Left" : 2 == t ? "Middle" : "Right") + s, r), r, (function(t) {
                            if ("string" == typeof t && (t = ea[t]),
                            !t)
                                return !1;
                            var i = !1;
                            try {
                                e.isReadOnly() && (e.state.suppressEdits = !0),
                                i = t(e, n) != U
                            } finally {
                                e.state.suppressEdits = !1
                            }
                            return i
                        }
                        ))
                    }(t, r, i, s, e) || (1 == r ? i ? function(e, t, n, i) {
                        a ? setTimeout(N(xi, e), 0) : e.curOp.focus = I();
                        var r, s = function(e, t, n) {
                            var i = e.getOption("configureMouse")
                              , r = i ? i(e, t, n) : {};
                            if (null == r.unit) {
                                var s = y ? n.shiftKey && n.metaKey : n.altKey;
                                r.unit = s ? "rectangle" : "single" == t ? "char" : "double" == t ? "word" : "line"
                            }
                            return (null == r.extend || e.doc.extend) && (r.extend = e.doc.extend || n.shiftKey),
                            null == r.addNew && (r.addNew = b ? n.metaKey : n.ctrlKey),
                            null == r.moveOnDrag && (r.moveOnDrag = !(b ? n.altKey : n.ctrlKey)),
                            r
                        }(e, n, i), c = e.doc.sel;
                        e.options.dragDrop && Te && !e.isReadOnly() && "single" == n && (r = c.contains(t)) > -1 && (tt((r = c.ranges[r]).from(), t) < 0 || t.xRel > 0) && (tt(r.to(), t) > 0 || t.xRel < 0) ? function(e, t, n, i) {
                            var r = e.display
                              , s = !1
                              , c = er(e, (function(t) {
                                l && (r.scroller.draggable = !1),
                                e.state.draggingText = !1,
                                pe(r.wrapper.ownerDocument, "mouseup", c),
                                pe(r.wrapper.ownerDocument, "mousemove", u),
                                pe(r.scroller, "dragstart", d),
                                pe(r.scroller, "drop", c),
                                s || (ye(t),
                                i.addNew || qr(e.doc, n, null, null, i.extend),
                                l || a && 9 == o ? setTimeout((function() {
                                    r.wrapper.ownerDocument.body.focus(),
                                    r.input.focus()
                                }
                                ), 20) : r.input.focus())
                            }
                            ))
                              , u = function(e) {
                                s = s || Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) >= 10
                            }
                              , d = function() {
                                return s = !0
                            };
                            l && (r.scroller.draggable = !0),
                            e.state.draggingText = c,
                            c.copy = !i.moveOnDrag,
                            r.scroller.dragDrop && r.scroller.dragDrop(),
                            de(r.wrapper.ownerDocument, "mouseup", c),
                            de(r.wrapper.ownerDocument, "mousemove", u),
                            de(r.scroller, "dragstart", d),
                            de(r.scroller, "drop", c),
                            Ci(e),
                            setTimeout((function() {
                                return r.input.focus()
                            }
                            ), 20)
                        }(e, i, t, s) : function(e, t, n, i) {
                            var r = e.display
                              , s = e.doc;
                            ye(t);
                            var a, o, l = s.sel, c = l.ranges;
                            if (i.addNew && !i.extend ? (o = s.sel.contains(n),
                            a = o > -1 ? c[o] : new Cr(n,n)) : (a = s.sel.primary(),
                            o = s.sel.primIndex),
                            "rectangle" == i.unit)
                                i.addNew || (a = new Cr(n,n)),
                                n = ci(e, t, !0, !0),
                                o = -1;
                            else {
                                var u = ga(e, n, i.unit);
                                a = i.extend ? Jr(a, u.anchor, u.head, i.extend) : u
                            }
                            i.addNew ? -1 == o ? (o = c.length,
                            Qr(s, Or(e, c.concat([a]), o), {
                                scroll: !1,
                                origin: "*mouse"
                            })) : c.length > 1 && c[o].empty() && "char" == i.unit && !i.extend ? (Qr(s, Or(e, c.slice(0, o).concat(c.slice(o + 1)), 0), {
                                scroll: !1,
                                origin: "*mouse"
                            }),
                            l = s.sel) : Xr(s, o, a, G) : (o = 0,
                            Qr(s, new xr([a],0), G),
                            l = s.sel);
                            var d = n;
                            function h(t) {
                                if (0 != tt(d, t))
                                    if (d = t,
                                    "rectangle" == i.unit) {
                                        for (var r = [], c = e.options.tabSize, u = B(He(s, n.line).text, n.ch, c), h = B(He(s, t.line).text, t.ch, c), p = Math.min(u, h), f = Math.max(u, h), m = Math.min(n.line, t.line), g = Math.min(e.lastLine(), Math.max(n.line, t.line)); m <= g; m++) {
                                            var v = He(s, m).text
                                              , b = W(v, p, c);
                                            p == f ? r.push(new Cr(et(m, b),et(m, b))) : v.length > b && r.push(new Cr(et(m, b),et(m, W(v, f, c))))
                                        }
                                        r.length || r.push(new Cr(n,n)),
                                        Qr(s, Or(e, l.ranges.slice(0, o).concat(r), o), {
                                            origin: "*mouse",
                                            scroll: !1
                                        }),
                                        e.scrollIntoView(t)
                                    } else {
                                        var y, S = a, w = ga(e, t, i.unit), x = S.anchor;
                                        tt(w.anchor, x) > 0 ? (y = w.head,
                                        x = st(S.from(), w.anchor)) : (y = w.anchor,
                                        x = rt(S.to(), w.head));
                                        var C = l.ranges.slice(0);
                                        C[o] = function(e, t) {
                                            var n = t.anchor
                                              , i = t.head
                                              , r = He(e.doc, n.line);
                                            if (0 == tt(n, i) && n.sticky == i.sticky)
                                                return t;
                                            var s = ce(r);
                                            if (!s)
                                                return t;
                                            var a = oe(s, n.ch, n.sticky)
                                              , o = s[a];
                                            if (o.from != n.ch && o.to != n.ch)
                                                return t;
                                            var l, c = a + (o.from == n.ch == (1 != o.level) ? 0 : 1);
                                            if (0 == c || c == s.length)
                                                return t;
                                            if (i.line != n.line)
                                                l = (i.line - n.line) * ("ltr" == e.doc.direction ? 1 : -1) > 0;
                                            else {
                                                var u = oe(s, i.ch, i.sticky)
                                                  , d = u - a || (i.ch - n.ch) * (1 == o.level ? -1 : 1);
                                                l = u == c - 1 || u == c ? d < 0 : d > 0
                                            }
                                            var h = s[c + (l ? -1 : 0)]
                                              , p = l == (1 == h.level)
                                              , f = p ? h.from : h.to
                                              , m = p ? "after" : "before";
                                            return n.ch == f && n.sticky == m ? t : new Cr(new et(n.line,f,m),i)
                                        }(e, new Cr(ot(s, x),y)),
                                        Qr(s, Or(e, C, o), G)
                                    }
                            }
                            var p = r.wrapper.getBoundingClientRect()
                              , f = 0;
                            function m(t) {
                                e.state.selectingText = !1,
                                f = 1 / 0,
                                t && (ye(t),
                                r.input.focus()),
                                pe(r.wrapper.ownerDocument, "mousemove", g),
                                pe(r.wrapper.ownerDocument, "mouseup", v),
                                s.history.lastSelOrigin = null
                            }
                            var g = er(e, (function(t) {
                                0 !== t.buttons && Oe(t) ? function t(n) {
                                    var a = ++f
                                      , o = ci(e, n, !0, "rectangle" == i.unit);
                                    if (o)
                                        if (0 != tt(o, d)) {
                                            e.curOp.focus = I(),
                                            h(o);
                                            var l = Mi(r, s);
                                            (o.line >= l.to || o.line < l.from) && setTimeout(er(e, (function() {
                                                f == a && t(n)
                                            }
                                            )), 150)
                                        } else {
                                            var c = n.clientY < p.top ? -20 : n.clientY > p.bottom ? 20 : 0;
                                            c && setTimeout(er(e, (function() {
                                                f == a && (r.scroller.scrollTop += c,
                                                t(n))
                                            }
                                            )), 50)
                                        }
                                }(t) : m(t)
                            }
                            ))
                              , v = er(e, m);
                            e.state.selectingText = v,
                            de(r.wrapper.ownerDocument, "mousemove", g),
                            de(r.wrapper.ownerDocument, "mouseup", v)
                        }(e, i, t, s)
                    }(t, i, s, e) : Ce(e) == n.scroller && ye(e) : 2 == r ? (i && qr(t.doc, i),
                    setTimeout((function() {
                        return n.input.focus()
                    }
                    ), 20)) : 3 == r && (C ? t.display.input.onContextMenu(e) : Ci(t)))
                }
        }
        function ga(e, t, n) {
            if ("char" == n)
                return new Cr(t,t);
            if ("word" == n)
                return e.findWordAt(t);
            if ("line" == n)
                return new Cr(et(t.line, 0),ot(e.doc, et(t.line + 1, 0)));
            var i = n(e, t);
            return new Cr(i.from,i.to)
        }
        function va(e, t, n, i) {
            var r, s;
            if (t.touches)
                r = t.touches[0].clientX,
                s = t.touches[0].clientY;
            else
                try {
                    r = t.clientX,
                    s = t.clientY
                } catch (t) {
                    return !1
                }
            if (r >= Math.floor(e.display.gutters.getBoundingClientRect().right))
                return !1;
            i && ye(t);
            var a = e.display
              , o = a.lineDiv.getBoundingClientRect();
            if (s > o.bottom || !ve(e, n))
                return we(t);
            s -= o.top - a.viewOffset;
            for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
                var c = a.gutters.childNodes[l];
                if (c && c.getBoundingClientRect().right >= r)
                    return fe(e, n, e, Ke(e.doc, s), e.display.gutterSpecs[l].className, t),
                    we(t)
            }
        }
        function ba(e, t) {
            return va(e, t, "gutterClick", !0)
        }
        function ya(e, t) {
            xn(e.display, t) || function(e, t) {
                return !!ve(e, "gutterContextMenu") && va(e, t, "gutterContextMenu", !1)
            }(e, t) || me(e, t, "contextmenu") || C || e.display.input.onContextMenu(t)
        }
        function Sa(e) {
            e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"),
            _n(e)
        }
        fa.prototype.compare = function(e, t, n) {
            return this.time + 400 > e && 0 == tt(t, this.pos) && n == this.button
        }
        ;
        var wa = {
            toString: function() {
                return "CodeMirror.Init"
            }
        }
          , xa = {}
          , Ca = {};
        function Oa(e, t, n) {
            if (!t != !(n && n != wa)) {
                var i = e.display.dragFunctions
                  , r = t ? de : pe;
                r(e.display.scroller, "dragstart", i.start),
                r(e.display.scroller, "dragenter", i.enter),
                r(e.display.scroller, "dragover", i.over),
                r(e.display.scroller, "dragleave", i.leave),
                r(e.display.scroller, "drop", i.drop)
            }
        }
        function ka(e) {
            e.options.lineWrapping ? (P(e.display.wrapper, "CodeMirror-wrap"),
            e.display.sizer.style.minWidth = "",
            e.display.sizerWidth = null) : (E(e.display.wrapper, "CodeMirror-wrap"),
            Wt(e)),
            li(e),
            di(e),
            _n(e),
            setTimeout((function() {
                return Ui(e)
            }
            ), 100)
        }
        function Ea(e, t) {
            var n = this;
            if (!(this instanceof Ea))
                return new Ea(e,t);
            this.options = t = t ? V(t) : {},
            V(xa, t, !1);
            var i = t.value;
            "string" == typeof i ? i = new Ls(i,t.mode,null,t.lineSeparator,t.direction) : t.mode && (i.modeOption = t.mode),
            this.doc = i;
            var r = new Ea.inputStyles[t.inputStyle](this)
              , s = this.display = new gr(e,i,r,t);
            for (var c in s.wrapper.CodeMirror = this,
            Sa(this),
            t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"),
            $i(this),
            this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: !1,
                delayingBlurEvent: !1,
                focused: !1,
                suppressEdits: !1,
                pasteIncoming: -1,
                cutIncoming: -1,
                selectingText: !1,
                draggingText: !1,
                highlight: new F,
                keySeq: null,
                specialChars: null
            },
            t.autofocus && !v && s.input.focus(),
            a && o < 11 && setTimeout((function() {
                return n.display.input.reset(!0)
            }
            ), 20),
            function(e) {
                var t = e.display;
                de(t.scroller, "mousedown", er(e, ma)),
                de(t.scroller, "dblclick", a && o < 11 ? er(e, (function(t) {
                    if (!me(e, t)) {
                        var n = ci(e, t);
                        if (n && !ba(e, t) && !xn(e.display, t)) {
                            ye(t);
                            var i = e.findWordAt(n);
                            qr(e.doc, i.anchor, i.head)
                        }
                    }
                }
                )) : function(t) {
                    return me(e, t) || ye(t)
                }
                ),
                de(t.scroller, "contextmenu", (function(t) {
                    return ya(e, t)
                }
                ));
                var n, i = {
                    end: 0
                };
                function r() {
                    t.activeTouch && (n = setTimeout((function() {
                        return t.activeTouch = null
                    }
                    ), 1e3),
                    (i = t.activeTouch).end = +new Date)
                }
                function s(e, t) {
                    if (null == t.left)
                        return !0;
                    var n = t.left - e.left
                      , i = t.top - e.top;
                    return n * n + i * i > 400
                }
                de(t.scroller, "touchstart", (function(r) {
                    if (!me(e, r) && !function(e) {
                        if (1 != e.touches.length)
                            return !1;
                        var t = e.touches[0];
                        return t.radiusX <= 1 && t.radiusY <= 1
                    }(r) && !ba(e, r)) {
                        t.input.ensurePolled(),
                        clearTimeout(n);
                        var s = +new Date;
                        t.activeTouch = {
                            start: s,
                            moved: !1,
                            prev: s - i.end <= 300 ? i : null
                        },
                        1 == r.touches.length && (t.activeTouch.left = r.touches[0].pageX,
                        t.activeTouch.top = r.touches[0].pageY)
                    }
                }
                )),
                de(t.scroller, "touchmove", (function() {
                    t.activeTouch && (t.activeTouch.moved = !0)
                }
                )),
                de(t.scroller, "touchend", (function(n) {
                    var i = t.activeTouch;
                    if (i && !xn(t, n) && null != i.left && !i.moved && new Date - i.start < 300) {
                        var a, o = e.coordsChar(t.activeTouch, "page");
                        a = !i.prev || s(i, i.prev) ? new Cr(o,o) : !i.prev.prev || s(i, i.prev.prev) ? e.findWordAt(o) : new Cr(et(o.line, 0),ot(e.doc, et(o.line + 1, 0))),
                        e.setSelection(a.anchor, a.head),
                        e.focus(),
                        ye(n)
                    }
                    r()
                }
                )),
                de(t.scroller, "touchcancel", r),
                de(t.scroller, "scroll", (function() {
                    t.scroller.clientHeight && (ji(e, t.scroller.scrollTop),
                    Vi(e, t.scroller.scrollLeft, !0),
                    fe(e, "scroll", e))
                }
                )),
                de(t.scroller, "mousewheel", (function(t) {
                    return wr(e, t)
                }
                )),
                de(t.scroller, "DOMMouseScroll", (function(t) {
                    return wr(e, t)
                }
                )),
                de(t.wrapper, "scroll", (function() {
                    return t.wrapper.scrollTop = t.wrapper.scrollLeft = 0
                }
                )),
                t.dragFunctions = {
                    enter: function(t) {
                        me(e, t) || xe(t)
                    },
                    over: function(t) {
                        me(e, t) || (function(e, t) {
                            var n = ci(e, t);
                            if (n) {
                                var i = document.createDocumentFragment();
                                bi(e, n, i),
                                e.display.dragCursor || (e.display.dragCursor = D("div", null, "CodeMirror-cursors CodeMirror-dragcursors"),
                                e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)),
                                M(e.display.dragCursor, i)
                            }
                        }(e, t),
                        xe(t))
                    },
                    start: function(t) {
                        return function(e, t) {
                            if (a && (!e.state.draggingText || +new Date - As < 100))
                                xe(t);
                            else if (!me(e, t) && !xn(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()),
                            t.dataTransfer.effectAllowed = "copyMove",
                            t.dataTransfer.setDragImage && !h)) {
                                var n = D("img", null, null, "position: fixed; left: 0; top: 0;");
                                n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                                d && (n.width = n.height = 1,
                                e.display.wrapper.appendChild(n),
                                n._top = n.offsetTop),
                                t.dataTransfer.setDragImage(n, 0, 0),
                                d && n.parentNode.removeChild(n)
                            }
                        }(e, t)
                    },
                    drop: er(e, Is),
                    leave: function(t) {
                        me(e, t) || Ps(e)
                    }
                };
                var l = t.input.getField();
                de(l, "keyup", (function(t) {
                    return ua.call(e, t)
                }
                )),
                de(l, "keydown", er(e, ca)),
                de(l, "keypress", er(e, da)),
                de(l, "focus", (function(t) {
                    return Oi(e, t)
                }
                )),
                de(l, "blur", (function(t) {
                    return ki(e, t)
                }
                ))
            }(this),
            Ns(),
            Hi(this),
            this.curOp.forceUpdate = !0,
            jr(this, i),
            t.autofocus && !v || this.hasFocus() ? setTimeout(N(Oi, this), 20) : ki(this),
            Ca)
                Ca.hasOwnProperty(c) && Ca[c](this, t[c], wa);
            hr(this),
            t.finishInit && t.finishInit(this);
            for (var u = 0; u < Ta.length; ++u)
                Ta[u](this);
            Ji(this),
            l && t.lineWrapping && "optimizelegibility" == getComputedStyle(s.lineDiv).textRendering && (s.lineDiv.style.textRendering = "auto")
        }
        Ea.defaults = xa,
        Ea.optionHandlers = Ca;
        var Ta = [];
        function Ma(e, t, n, i) {
            var r, s = e.doc;
            null == n && (n = "add"),
            "smart" == n && (s.mode.indent ? r = pt(e, t).state : n = "prev");
            var a = e.options.tabSize
              , o = He(s, t)
              , l = B(o.text, null, a);
            o.stateAfter && (o.stateAfter = null);
            var c, u = o.text.match(/^\s*/)[0];
            if (i || /\S/.test(o.text)) {
                if ("smart" == n && ((c = s.mode.indent(r, o.text.slice(u.length), o.text)) == U || c > 150)) {
                    if (!i)
                        return;
                    n = "prev"
                }
            } else
                c = 0,
                n = "not";
            "prev" == n ? c = t > s.first ? B(He(s, t - 1).text, null, a) : 0 : "add" == n ? c = l + e.options.indentUnit : "subtract" == n ? c = l - e.options.indentUnit : "number" == typeof n && (c = l + n),
            c = Math.max(0, c);
            var d = ""
              , h = 0;
            if (e.options.indentWithTabs)
                for (var p = Math.floor(c / a); p; --p)
                    h += a,
                    d += "\t";
            if (h < c && (d += J(c - h)),
            d != u)
                return fs(s, d, et(t, 0), et(t, u.length), "+input"),
                o.stateAfter = null,
                !0;
            for (var f = 0; f < s.sel.ranges.length; f++) {
                var m = s.sel.ranges[f];
                if (m.head.line == t && m.head.ch < u.length) {
                    var g = et(t, u.length);
                    Xr(s, f, new Cr(g,g));
                    break
                }
            }
        }
        Ea.defineInitHook = function(e) {
            return Ta.push(e)
        }
        ;
        var Da = null;
        function La(e) {
            Da = e
        }
        function Aa(e, t, n, i, r) {
            var s = e.doc;
            e.display.shift = !1,
            i || (i = s.sel);
            var a = +new Date - 200
              , o = "paste" == r || e.state.pasteIncoming > a
              , l = Ae(t)
              , c = null;
            if (o && i.ranges.length > 1)
                if (Da && Da.text.join("\n") == t) {
                    if (i.ranges.length % Da.text.length == 0) {
                        c = [];
                        for (var u = 0; u < Da.text.length; u++)
                            c.push(s.splitLines(Da.text[u]))
                    }
                } else
                    l.length == i.ranges.length && e.options.pasteLinesPerSelection && (c = Y(l, (function(e) {
                        return [e]
                    }
                    )));
            for (var d = e.curOp.updateInput, h = i.ranges.length - 1; h >= 0; h--) {
                var p = i.ranges[h]
                  , f = p.from()
                  , m = p.to();
                p.empty() && (n && n > 0 ? f = et(f.line, f.ch - n) : e.state.overwrite && !o ? m = et(m.line, Math.min(He(s, m.line).text.length, m.ch + q(l).length)) : o && Da && Da.lineWise && Da.text.join("\n") == t && (f = m = et(f.line, 0)));
                var g = {
                    from: f,
                    to: m,
                    text: c ? c[h % c.length] : l,
                    origin: r || (o ? "paste" : e.state.cutIncoming > a ? "cut" : "+input")
                };
                cs(e.doc, g),
                ln(e, "inputRead", e, g)
            }
            t && !o && Pa(e, t),
            Ai(e),
            e.curOp.updateInput < 2 && (e.curOp.updateInput = d),
            e.curOp.typing = !0,
            e.state.pasteIncoming = e.state.cutIncoming = -1
        }
        function Ia(e, t) {
            var n = e.clipboardData && e.clipboardData.getData("Text");
            if (n)
                return e.preventDefault(),
                t.isReadOnly() || t.options.disableInput || Qi(t, (function() {
                    return Aa(t, n, 0, null, "paste")
                }
                )),
                !0
        }
        function Pa(e, t) {
            if (e.options.electricChars && e.options.smartIndent)
                for (var n = e.doc.sel, i = n.ranges.length - 1; i >= 0; i--) {
                    var r = n.ranges[i];
                    if (!(r.head.ch > 100 || i && n.ranges[i - 1].head.line == r.head.line)) {
                        var s = e.getModeAt(r.head)
                          , a = !1;
                        if (s.electricChars) {
                            for (var o = 0; o < s.electricChars.length; o++)
                                if (t.indexOf(s.electricChars.charAt(o)) > -1) {
                                    a = Ma(e, r.head.line, "smart");
                                    break
                                }
                        } else
                            s.electricInput && s.electricInput.test(He(e.doc, r.head.line).text.slice(0, r.head.ch)) && (a = Ma(e, r.head.line, "smart"));
                        a && ln(e, "electricInput", e, r.head.line)
                    }
                }
        }
        function Ra(e) {
            for (var t = [], n = [], i = 0; i < e.doc.sel.ranges.length; i++) {
                var r = e.doc.sel.ranges[i].head.line
                  , s = {
                    anchor: et(r, 0),
                    head: et(r + 1, 0)
                };
                n.push(s),
                t.push(e.getRange(s.anchor, s.head))
            }
            return {
                text: t,
                ranges: n
            }
        }
        function ja(e, t, n, i) {
            e.setAttribute("autocorrect", n ? "" : "off"),
            e.setAttribute("autocapitalize", i ? "" : "off"),
            e.setAttribute("spellcheck", !!t)
        }
        function Na() {
            var e = D("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none")
              , t = D("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
            return l ? e.style.width = "1000px" : e.setAttribute("wrap", "off"),
            m && (e.style.border = "1px solid black"),
            ja(e),
            t
        }
        function Va(e, t, n, i, r) {
            var s = t
              , a = n
              , o = He(e, t.line);
            function l(i) {
                var s, a;
                if (null == (s = r ? function(e, t, n, i) {
                    var r = ce(t, e.doc.direction);
                    if (!r)
                        return Zs(t, n, i);
                    n.ch >= t.text.length ? (n.ch = t.text.length,
                    n.sticky = "before") : n.ch <= 0 && (n.ch = 0,
                    n.sticky = "after");
                    var s = oe(r, n.ch, n.sticky)
                      , a = r[s];
                    if ("ltr" == e.doc.direction && a.level % 2 == 0 && (i > 0 ? a.to > n.ch : a.from < n.ch))
                        return Zs(t, n, i);
                    var o, l = function(e, n) {
                        return Ks(t, e instanceof et ? e.ch : e, n)
                    }, c = function(n) {
                        return e.options.lineWrapping ? (o = o || In(e, t),
                        Zn(e, t, o, n)) : {
                            begin: 0,
                            end: t.text.length
                        }
                    }, u = c("before" == n.sticky ? l(n, -1) : n.ch);
                    if ("rtl" == e.doc.direction || 1 == a.level) {
                        var d = 1 == a.level == i < 0
                          , h = l(n, d ? 1 : -1);
                        if (null != h && (d ? h <= a.to && h <= u.end : h >= a.from && h >= u.begin)) {
                            var p = d ? "before" : "after";
                            return new et(n.line,h,p)
                        }
                    }
                    var f = function(e, t, i) {
                        for (var s = function(e, t) {
                            return t ? new et(n.line,l(e, 1),"before") : new et(n.line,e,"after")
                        }; e >= 0 && e < r.length; e += t) {
                            var a = r[e]
                              , o = t > 0 == (1 != a.level)
                              , c = o ? i.begin : l(i.end, -1);
                            if (a.from <= c && c < a.to)
                                return s(c, o);
                            if (c = o ? a.from : l(a.to, -1),
                            i.begin <= c && c < i.end)
                                return s(c, o)
                        }
                    }
                      , m = f(s + i, i, u);
                    if (m)
                        return m;
                    var g = i > 0 ? u.end : l(u.begin, -1);
                    return null == g || i > 0 && g == t.text.length || !(m = f(i > 0 ? 0 : r.length - 1, i, c(g))) ? null : m
                }(e.cm, o, t, n) : Zs(o, t, n))) {
                    if (i || (a = t.line + n) < e.first || a >= e.first + e.size || (t = new et(a,t.ch,t.sticky),
                    !(o = He(e, a))))
                        return !1;
                    t = Qs(r, e.cm, o, t.line, n)
                } else
                    t = s;
                return !0
            }
            if ("char" == i)
                l();
            else if ("column" == i)
                l(!0);
            else if ("word" == i || "group" == i)
                for (var c = null, u = "group" == i, d = e.cm && e.cm.getHelper(t, "wordChars"), h = !0; !(n < 0) || l(!h); h = !1) {
                    var p = o.text.charAt(t.ch) || "\n"
                      , f = ee(p, d) ? "w" : u && "\n" == p ? "n" : !u || /\s/.test(p) ? null : "p";
                    if (!u || h || f || (f = "s"),
                    c && c != f) {
                        n < 0 && (n = 1,
                        l(),
                        t.sticky = "after");
                        break
                    }
                    if (f && (c = f),
                    n > 0 && !l(!h))
                        break
                }
            var m = ss(e, t, s, a, !0);
            return nt(s, m) && (m.hitSide = !0),
            m
        }
        function Ba(e, t, n, i) {
            var r, s, a = e.doc, o = t.left;
            if ("page" == i) {
                var l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)
                  , c = Math.max(l - .5 * ii(e.display), 3);
                r = (n > 0 ? t.bottom : t.top) + n * c
            } else
                "line" == i && (r = n > 0 ? t.bottom + 3 : t.top - 3);
            for (; (s = Xn(e, o, r)).outside; ) {
                if (n < 0 ? r <= 0 : r >= a.height) {
                    s.hitSide = !0;
                    break
                }
                r += 5 * n
            }
            return s
        }
        var Fa = function(e) {
            this.cm = e,
            this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null,
            this.polling = new F,
            this.composing = null,
            this.gracePeriod = !1,
            this.readDOMTimeout = null
        };
        function _a(e, t) {
            var n = An(e, t.line);
            if (!n || n.hidden)
                return null;
            var i = He(e.doc, t.line)
              , r = Dn(n, i, t.line)
              , s = ce(i, e.doc.direction)
              , a = "left";
            s && (a = oe(s, t.ch) % 2 ? "right" : "left");
            var o = Nn(r.map, t.ch, a);
            return o.offset = "right" == o.collapse ? o.end : o.start,
            o
        }
        function Ua(e, t) {
            return t && (e.bad = !0),
            e
        }
        function za(e, t, n) {
            var i;
            if (t == e.display.lineDiv) {
                if (!(i = e.display.lineDiv.childNodes[n]))
                    return Ua(e.clipPos(et(e.display.viewTo - 1)), !0);
                t = null,
                n = 0
            } else
                for (i = t; ; i = i.parentNode) {
                    if (!i || i == e.display.lineDiv)
                        return null;
                    if (i.parentNode && i.parentNode == e.display.lineDiv)
                        break
                }
            for (var r = 0; r < e.display.view.length; r++) {
                var s = e.display.view[r];
                if (s.node == i)
                    return Ga(s, t, n)
            }
        }
        function Ga(e, t, n) {
            var i = e.text.firstChild
              , r = !1;
            if (!t || !A(i, t))
                return Ua(et(Xe(e.line), 0), !0);
            if (t == i && (r = !0,
            t = i.childNodes[n],
            n = 0,
            !t)) {
                var s = e.rest ? q(e.rest) : e.line;
                return Ua(et(Xe(s), s.text.length), r)
            }
            var a = 3 == t.nodeType ? t : null
              , o = t;
            for (a || 1 != t.childNodes.length || 3 != t.firstChild.nodeType || (a = t.firstChild,
            n && (n = a.nodeValue.length)); o.parentNode != i; )
                o = o.parentNode;
            var l = e.measure
              , c = l.maps;
            function u(t, n, i) {
                for (var r = -1; r < (c ? c.length : 0); r++)
                    for (var s = r < 0 ? l.map : c[r], a = 0; a < s.length; a += 3) {
                        var o = s[a + 2];
                        if (o == t || o == n) {
                            var u = Xe(r < 0 ? e.line : e.rest[r])
                              , d = s[a] + i;
                            return (i < 0 || o != t) && (d = s[a + (i ? 1 : 0)]),
                            et(u, d)
                        }
                    }
            }
            var d = u(a, o, n);
            if (d)
                return Ua(d, r);
            for (var h = o.nextSibling, p = a ? a.nodeValue.length - n : 0; h; h = h.nextSibling) {
                if (d = u(h, h.firstChild, 0))
                    return Ua(et(d.line, d.ch - p), r);
                p += h.textContent.length
            }
            for (var f = o.previousSibling, m = n; f; f = f.previousSibling) {
                if (d = u(f, f.firstChild, -1))
                    return Ua(et(d.line, d.ch + m), r);
                m += f.textContent.length
            }
        }
        Fa.prototype.init = function(e) {
            var t = this
              , n = this
              , i = n.cm
              , r = n.div = e.lineDiv;
            function s(e) {
                if (!me(i, e)) {
                    if (i.somethingSelected())
                        La({
                            lineWise: !1,
                            text: i.getSelections()
                        }),
                        "cut" == e.type && i.replaceSelection("", null, "cut");
                    else {
                        if (!i.options.lineWiseCopyCut)
                            return;
                        var t = Ra(i);
                        La({
                            lineWise: !0,
                            text: t.text
                        }),
                        "cut" == e.type && i.operation((function() {
                            i.setSelections(t.ranges, 0, z),
                            i.replaceSelection("", null, "cut")
                        }
                        ))
                    }
                    if (e.clipboardData) {
                        e.clipboardData.clearData();
                        var s = Da.text.join("\n");
                        if (e.clipboardData.setData("Text", s),
                        e.clipboardData.getData("Text") == s)
                            return void e.preventDefault()
                    }
                    var a = Na()
                      , o = a.firstChild;
                    i.display.lineSpace.insertBefore(a, i.display.lineSpace.firstChild),
                    o.value = Da.text.join("\n");
                    var l = document.activeElement;
                    j(o),
                    setTimeout((function() {
                        i.display.lineSpace.removeChild(a),
                        l.focus(),
                        l == r && n.showPrimarySelection()
                    }
                    ), 50)
                }
            }
            ja(r, i.options.spellcheck, i.options.autocorrect, i.options.autocapitalize),
            de(r, "paste", (function(e) {
                me(i, e) || Ia(e, i) || o <= 11 && setTimeout(er(i, (function() {
                    return t.updateFromDOM()
                }
                )), 20)
            }
            )),
            de(r, "compositionstart", (function(e) {
                t.composing = {
                    data: e.data,
                    done: !1
                }
            }
            )),
            de(r, "compositionupdate", (function(e) {
                t.composing || (t.composing = {
                    data: e.data,
                    done: !1
                })
            }
            )),
            de(r, "compositionend", (function(e) {
                t.composing && (e.data != t.composing.data && t.readFromDOMSoon(),
                t.composing.done = !0)
            }
            )),
            de(r, "touchstart", (function() {
                return n.forceCompositionEnd()
            }
            )),
            de(r, "input", (function() {
                t.composing || t.readFromDOMSoon()
            }
            )),
            de(r, "copy", s),
            de(r, "cut", s)
        }
        ,
        Fa.prototype.prepareSelection = function() {
            var e = vi(this.cm, !1);
            return e.focus = this.cm.state.focused,
            e
        }
        ,
        Fa.prototype.showSelection = function(e, t) {
            e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(),
            this.showMultipleSelections(e))
        }
        ,
        Fa.prototype.getSelection = function() {
            return this.cm.display.wrapper.ownerDocument.getSelection()
        }
        ,
        Fa.prototype.showPrimarySelection = function() {
            var e = this.getSelection()
              , t = this.cm
              , i = t.doc.sel.primary()
              , r = i.from()
              , s = i.to();
            if (t.display.viewTo == t.display.viewFrom || r.line >= t.display.viewTo || s.line < t.display.viewFrom)
                e.removeAllRanges();
            else {
                var a = za(t, e.anchorNode, e.anchorOffset)
                  , o = za(t, e.focusNode, e.focusOffset);
                if (!a || a.bad || !o || o.bad || 0 != tt(st(a, o), r) || 0 != tt(rt(a, o), s)) {
                    var l = t.display.view
                      , c = r.line >= t.display.viewFrom && _a(t, r) || {
                        node: l[0].measure.map[2],
                        offset: 0
                    }
                      , u = s.line < t.display.viewTo && _a(t, s);
                    if (!u) {
                        var d = l[l.length - 1].measure
                          , h = d.maps ? d.maps[d.maps.length - 1] : d.map;
                        u = {
                            node: h[h.length - 1],
                            offset: h[h.length - 2] - h[h.length - 3]
                        }
                    }
                    if (c && u) {
                        var p, f = e.rangeCount && e.getRangeAt(0);
                        try {
                            p = k(c.node, c.offset, u.offset, u.node)
                        } catch (e) {}
                        p && (!n && t.state.focused ? (e.collapse(c.node, c.offset),
                        p.collapsed || (e.removeAllRanges(),
                        e.addRange(p))) : (e.removeAllRanges(),
                        e.addRange(p)),
                        f && null == e.anchorNode ? e.addRange(f) : n && this.startGracePeriod()),
                        this.rememberSelection()
                    } else
                        e.removeAllRanges()
                }
            }
        }
        ,
        Fa.prototype.startGracePeriod = function() {
            var e = this;
            clearTimeout(this.gracePeriod),
            this.gracePeriod = setTimeout((function() {
                e.gracePeriod = !1,
                e.selectionChanged() && e.cm.operation((function() {
                    return e.cm.curOp.selectionChanged = !0
                }
                ))
            }
            ), 20)
        }
        ,
        Fa.prototype.showMultipleSelections = function(e) {
            M(this.cm.display.cursorDiv, e.cursors),
            M(this.cm.display.selectionDiv, e.selection)
        }
        ,
        Fa.prototype.rememberSelection = function() {
            var e = this.getSelection();
            this.lastAnchorNode = e.anchorNode,
            this.lastAnchorOffset = e.anchorOffset,
            this.lastFocusNode = e.focusNode,
            this.lastFocusOffset = e.focusOffset
        }
        ,
        Fa.prototype.selectionInEditor = function() {
            var e = this.getSelection();
            if (!e.rangeCount)
                return !1;
            var t = e.getRangeAt(0).commonAncestorContainer;
            return A(this.div, t)
        }
        ,
        Fa.prototype.focus = function() {
            "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0),
            this.div.focus())
        }
        ,
        Fa.prototype.blur = function() {
            this.div.blur()
        }
        ,
        Fa.prototype.getField = function() {
            return this.div
        }
        ,
        Fa.prototype.supportsTouch = function() {
            return !0
        }
        ,
        Fa.prototype.receivedFocus = function() {
            var e = this;
            this.selectionInEditor() ? this.pollSelection() : Qi(this.cm, (function() {
                return e.cm.curOp.selectionChanged = !0
            }
            )),
            this.polling.set(this.cm.options.pollInterval, (function t() {
                e.cm.state.focused && (e.pollSelection(),
                e.polling.set(e.cm.options.pollInterval, t))
            }
            ))
        }
        ,
        Fa.prototype.selectionChanged = function() {
            var e = this.getSelection();
            return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset
        }
        ,
        Fa.prototype.pollSelection = function() {
            if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                var e = this.getSelection()
                  , t = this.cm;
                if (g && u && this.cm.display.gutterSpecs.length && function(e) {
                    for (var t = e; t; t = t.parentNode)
                        if (/CodeMirror-gutter-wrapper/.test(t.className))
                            return !0;
                    return !1
                }(e.anchorNode))
                    return this.cm.triggerOnKeyDown({
                        type: "keydown",
                        keyCode: 8,
                        preventDefault: Math.abs
                    }),
                    this.blur(),
                    void this.focus();
                if (!this.composing) {
                    this.rememberSelection();
                    var n = za(t, e.anchorNode, e.anchorOffset)
                      , i = za(t, e.focusNode, e.focusOffset);
                    n && i && Qi(t, (function() {
                        Qr(t.doc, kr(n, i), z),
                        (n.bad || i.bad) && (t.curOp.selectionChanged = !0)
                    }
                    ))
                }
            }
        }
        ,
        Fa.prototype.pollContent = function() {
            null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout),
            this.readDOMTimeout = null);
            var e, t, n, i = this.cm, r = i.display, s = i.doc.sel.primary(), a = s.from(), o = s.to();
            if (0 == a.ch && a.line > i.firstLine() && (a = et(a.line - 1, He(i.doc, a.line - 1).length)),
            o.ch == He(i.doc, o.line).text.length && o.line < i.lastLine() && (o = et(o.line + 1, 0)),
            a.line < r.viewFrom || o.line > r.viewTo - 1)
                return !1;
            a.line == r.viewFrom || 0 == (e = ui(i, a.line)) ? (t = Xe(r.view[0].line),
            n = r.view[0].node) : (t = Xe(r.view[e].line),
            n = r.view[e - 1].node.nextSibling);
            var l, c, u = ui(i, o.line);
            if (u == r.view.length - 1 ? (l = r.viewTo - 1,
            c = r.lineDiv.lastChild) : (l = Xe(r.view[u + 1].line) - 1,
            c = r.view[u + 1].node.previousSibling),
            !n)
                return !1;
            for (var d = i.doc.splitLines(function(e, t, n, i, r) {
                var s = ""
                  , a = !1
                  , o = e.doc.lineSeparator()
                  , l = !1;
                function c() {
                    a && (s += o,
                    l && (s += o),
                    a = l = !1)
                }
                function u(e) {
                    e && (c(),
                    s += e)
                }
                function d(t) {
                    if (1 == t.nodeType) {
                        var n = t.getAttribute("cm-text");
                        if (n)
                            return void u(n);
                        var s, h = t.getAttribute("cm-marker");
                        if (h) {
                            var p = e.findMarks(et(i, 0), et(r + 1, 0), (g = +h,
                            function(e) {
                                return e.id == g
                            }
                            ));
                            return void (p.length && (s = p[0].find(0)) && u(Je(e.doc, s.from, s.to).join(o)))
                        }
                        if ("false" == t.getAttribute("contenteditable"))
                            return;
                        var f = /^(pre|div|p|li|table|br)$/i.test(t.nodeName);
                        if (!/^br$/i.test(t.nodeName) && 0 == t.textContent.length)
                            return;
                        f && c();
                        for (var m = 0; m < t.childNodes.length; m++)
                            d(t.childNodes[m]);
                        /^(pre|p)$/i.test(t.nodeName) && (l = !0),
                        f && (a = !0)
                    } else
                        3 == t.nodeType && u(t.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
                    var g
                }
                for (; d(t),
                t != n; )
                    t = t.nextSibling,
                    l = !1;
                return s
            }(i, n, c, t, l)), h = Je(i.doc, et(t, 0), et(l, He(i.doc, l).text.length)); d.length > 1 && h.length > 1; )
                if (q(d) == q(h))
                    d.pop(),
                    h.pop(),
                    l--;
                else {
                    if (d[0] != h[0])
                        break;
                    d.shift(),
                    h.shift(),
                    t++
                }
            for (var p = 0, f = 0, m = d[0], g = h[0], v = Math.min(m.length, g.length); p < v && m.charCodeAt(p) == g.charCodeAt(p); )
                ++p;
            for (var b = q(d), y = q(h), S = Math.min(b.length - (1 == d.length ? p : 0), y.length - (1 == h.length ? p : 0)); f < S && b.charCodeAt(b.length - f - 1) == y.charCodeAt(y.length - f - 1); )
                ++f;
            if (1 == d.length && 1 == h.length && t == a.line)
                for (; p && p > a.ch && b.charCodeAt(b.length - f - 1) == y.charCodeAt(y.length - f - 1); )
                    p--,
                    f++;
            d[d.length - 1] = b.slice(0, b.length - f).replace(/^\u200b+/, ""),
            d[0] = d[0].slice(p).replace(/\u200b+$/, "");
            var w = et(t, p)
              , x = et(l, h.length ? q(h).length - f : 0);
            return d.length > 1 || d[0] || tt(w, x) ? (fs(i.doc, d, w, x, "+input"),
            !0) : void 0
        }
        ,
        Fa.prototype.ensurePolled = function() {
            this.forceCompositionEnd()
        }
        ,
        Fa.prototype.reset = function() {
            this.forceCompositionEnd()
        }
        ,
        Fa.prototype.forceCompositionEnd = function() {
            this.composing && (clearTimeout(this.readDOMTimeout),
            this.composing = null,
            this.updateFromDOM(),
            this.div.blur(),
            this.div.focus())
        }
        ,
        Fa.prototype.readFromDOMSoon = function() {
            var e = this;
            null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout((function() {
                if (e.readDOMTimeout = null,
                e.composing) {
                    if (!e.composing.done)
                        return;
                    e.composing = null
                }
                e.updateFromDOM()
            }
            ), 80))
        }
        ,
        Fa.prototype.updateFromDOM = function() {
            var e = this;
            !this.cm.isReadOnly() && this.pollContent() || Qi(this.cm, (function() {
                return di(e.cm)
            }
            ))
        }
        ,
        Fa.prototype.setUneditable = function(e) {
            e.contentEditable = "false"
        }
        ,
        Fa.prototype.onKeyPress = function(e) {
            0 == e.charCode || this.composing || (e.preventDefault(),
            this.cm.isReadOnly() || er(this.cm, Aa)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0))
        }
        ,
        Fa.prototype.readOnlyChanged = function(e) {
            this.div.contentEditable = String("nocursor" != e)
        }
        ,
        Fa.prototype.onContextMenu = function() {}
        ,
        Fa.prototype.resetPosition = function() {}
        ,
        Fa.prototype.needsContentAttribute = !0;
        var $a = function(e) {
            this.cm = e,
            this.prevInput = "",
            this.pollingFast = !1,
            this.polling = new F,
            this.hasSelection = !1,
            this.composing = null
        };
        $a.prototype.init = function(e) {
            var t = this
              , n = this
              , i = this.cm;
            this.createField(e);
            var r = this.textarea;
            function s(e) {
                if (!me(i, e)) {
                    if (i.somethingSelected())
                        La({
                            lineWise: !1,
                            text: i.getSelections()
                        });
                    else {
                        if (!i.options.lineWiseCopyCut)
                            return;
                        var t = Ra(i);
                        La({
                            lineWise: !0,
                            text: t.text
                        }),
                        "cut" == e.type ? i.setSelections(t.ranges, null, z) : (n.prevInput = "",
                        r.value = t.text.join("\n"),
                        j(r))
                    }
                    "cut" == e.type && (i.state.cutIncoming = +new Date)
                }
            }
            e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild),
            m && (r.style.width = "0px"),
            de(r, "input", (function() {
                a && o >= 9 && t.hasSelection && (t.hasSelection = null),
                n.poll()
            }
            )),
            de(r, "paste", (function(e) {
                me(i, e) || Ia(e, i) || (i.state.pasteIncoming = +new Date,
                n.fastPoll())
            }
            )),
            de(r, "cut", s),
            de(r, "copy", s),
            de(e.scroller, "paste", (function(t) {
                if (!xn(e, t) && !me(i, t)) {
                    if (!r.dispatchEvent)
                        return i.state.pasteIncoming = +new Date,
                        void n.focus();
                    var s = new Event("paste");
                    s.clipboardData = t.clipboardData,
                    r.dispatchEvent(s)
                }
            }
            )),
            de(e.lineSpace, "selectstart", (function(t) {
                xn(e, t) || ye(t)
            }
            )),
            de(r, "compositionstart", (function() {
                var e = i.getCursor("from");
                n.composing && n.composing.range.clear(),
                n.composing = {
                    start: e,
                    range: i.markText(e, i.getCursor("to"), {
                        className: "CodeMirror-composing"
                    })
                }
            }
            )),
            de(r, "compositionend", (function() {
                n.composing && (n.poll(),
                n.composing.range.clear(),
                n.composing = null)
            }
            ))
        }
        ,
        $a.prototype.createField = function(e) {
            this.wrapper = Na(),
            this.textarea = this.wrapper.firstChild
        }
        ,
        $a.prototype.prepareSelection = function() {
            var e = this.cm
              , t = e.display
              , n = e.doc
              , i = vi(e);
            if (e.options.moveInputWithCursor) {
                var r = Jn(e, n.sel.primary().head, "div")
                  , s = t.wrapper.getBoundingClientRect()
                  , a = t.lineDiv.getBoundingClientRect();
                i.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, r.top + a.top - s.top)),
                i.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, r.left + a.left - s.left))
            }
            return i
        }
        ,
        $a.prototype.showSelection = function(e) {
            var t = this.cm.display;
            M(t.cursorDiv, e.cursors),
            M(t.selectionDiv, e.selection),
            null != e.teTop && (this.wrapper.style.top = e.teTop + "px",
            this.wrapper.style.left = e.teLeft + "px")
        }
        ,
        $a.prototype.reset = function(e) {
            if (!this.contextMenuPending && !this.composing) {
                var t = this.cm;
                if (t.somethingSelected()) {
                    this.prevInput = "";
                    var n = t.getSelection();
                    this.textarea.value = n,
                    t.state.focused && j(this.textarea),
                    a && o >= 9 && (this.hasSelection = n)
                } else
                    e || (this.prevInput = this.textarea.value = "",
                    a && o >= 9 && (this.hasSelection = null))
            }
        }
        ,
        $a.prototype.getField = function() {
            return this.textarea
        }
        ,
        $a.prototype.supportsTouch = function() {
            return !1
        }
        ,
        $a.prototype.focus = function() {
            if ("nocursor" != this.cm.options.readOnly && (!v || I() != this.textarea))
                try {
                    this.textarea.focus()
                } catch (e) {}
        }
        ,
        $a.prototype.blur = function() {
            this.textarea.blur()
        }
        ,
        $a.prototype.resetPosition = function() {
            this.wrapper.style.top = this.wrapper.style.left = 0
        }
        ,
        $a.prototype.receivedFocus = function() {
            this.slowPoll()
        }
        ,
        $a.prototype.slowPoll = function() {
            var e = this;
            this.pollingFast || this.polling.set(this.cm.options.pollInterval, (function() {
                e.poll(),
                e.cm.state.focused && e.slowPoll()
            }
            ))
        }
        ,
        $a.prototype.fastPoll = function() {
            var e = !1
              , t = this;
            t.pollingFast = !0,
            t.polling.set(20, (function n() {
                t.poll() || e ? (t.pollingFast = !1,
                t.slowPoll()) : (e = !0,
                t.polling.set(60, n))
            }
            ))
        }
        ,
        $a.prototype.poll = function() {
            var e = this
              , t = this.cm
              , n = this.textarea
              , i = this.prevInput;
            if (this.contextMenuPending || !t.state.focused || Ie(n) && !i && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq)
                return !1;
            var r = n.value;
            if (r == i && !t.somethingSelected())
                return !1;
            if (a && o >= 9 && this.hasSelection === r || b && /[\uf700-\uf7ff]/.test(r))
                return t.display.input.reset(),
                !1;
            if (t.doc.sel == t.display.selForContextMenu) {
                var s = r.charCodeAt(0);
                if (8203 != s || i || (i = ""),
                8666 == s)
                    return this.reset(),
                    this.cm.execCommand("undo")
            }
            for (var l = 0, c = Math.min(i.length, r.length); l < c && i.charCodeAt(l) == r.charCodeAt(l); )
                ++l;
            return Qi(t, (function() {
                Aa(t, r.slice(l), i.length - l, null, e.composing ? "*compose" : null),
                r.length > 1e3 || r.indexOf("\n") > -1 ? n.value = e.prevInput = "" : e.prevInput = r,
                e.composing && (e.composing.range.clear(),
                e.composing.range = t.markText(e.composing.start, t.getCursor("to"), {
                    className: "CodeMirror-composing"
                }))
            }
            )),
            !0
        }
        ,
        $a.prototype.ensurePolled = function() {
            this.pollingFast && this.poll() && (this.pollingFast = !1)
        }
        ,
        $a.prototype.onKeyPress = function() {
            a && o >= 9 && (this.hasSelection = null),
            this.fastPoll()
        }
        ,
        $a.prototype.onContextMenu = function(e) {
            var t = this
              , n = t.cm
              , i = n.display
              , r = t.textarea;
            t.contextMenuPending && t.contextMenuPending();
            var s = ci(n, e)
              , c = i.scroller.scrollTop;
            if (s && !d) {
                n.options.resetSelectionOnContextMenu && -1 == n.doc.sel.contains(s) && er(n, Qr)(n.doc, kr(s), z);
                var u, h = r.style.cssText, p = t.wrapper.style.cssText, f = t.wrapper.offsetParent.getBoundingClientRect();
                if (t.wrapper.style.cssText = "position: static",
                r.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - f.top - 5) + "px; left: " + (e.clientX - f.left - 5) + "px;\n      z-index: 1000; background: " + (a ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);",
                l && (u = window.scrollY),
                i.input.focus(),
                l && window.scrollTo(null, u),
                i.input.reset(),
                n.somethingSelected() || (r.value = t.prevInput = " "),
                t.contextMenuPending = v,
                i.selForContextMenu = n.doc.sel,
                clearTimeout(i.detectingSelectAll),
                a && o >= 9 && g(),
                C) {
                    xe(e);
                    var m = function() {
                        pe(window, "mouseup", m),
                        setTimeout(v, 20)
                    };
                    de(window, "mouseup", m)
                } else
                    setTimeout(v, 50)
            }
            function g() {
                if (null != r.selectionStart) {
                    var e = n.somethingSelected()
                      , s = "" + (e ? r.value : "");
                    r.value = "",
                    r.value = s,
                    t.prevInput = e ? "" : "",
                    r.selectionStart = 1,
                    r.selectionEnd = s.length,
                    i.selForContextMenu = n.doc.sel
                }
            }
            function v() {
                if (t.contextMenuPending == v && (t.contextMenuPending = !1,
                t.wrapper.style.cssText = p,
                r.style.cssText = h,
                a && o < 9 && i.scrollbars.setScrollTop(i.scroller.scrollTop = c),
                null != r.selectionStart)) {
                    (!a || a && o < 9) && g();
                    var e = 0
                      , s = function() {
                        i.selForContextMenu == n.doc.sel && 0 == r.selectionStart && r.selectionEnd > 0 && "" == t.prevInput ? er(n, os)(n) : e++ < 10 ? i.detectingSelectAll = setTimeout(s, 500) : (i.selForContextMenu = null,
                        i.input.reset())
                    };
                    i.detectingSelectAll = setTimeout(s, 200)
                }
            }
        }
        ,
        $a.prototype.readOnlyChanged = function(e) {
            e || this.reset(),
            this.textarea.disabled = "nocursor" == e
        }
        ,
        $a.prototype.setUneditable = function() {}
        ,
        $a.prototype.needsContentAttribute = !1,
        function(e) {
            var t = e.optionHandlers;
            function n(n, i, r, s) {
                e.defaults[n] = i,
                r && (t[n] = s ? function(e, t, n) {
                    n != wa && r(e, t, n)
                }
                : r)
            }
            e.defineOption = n,
            e.Init = wa,
            n("value", "", (function(e, t) {
                return e.setValue(t)
            }
            ), !0),
            n("mode", null, (function(e, t) {
                e.doc.modeOption = t,
                Lr(e)
            }
            ), !0),
            n("indentUnit", 2, Lr, !0),
            n("indentWithTabs", !1),
            n("smartIndent", !0),
            n("tabSize", 4, (function(e) {
                Ar(e),
                _n(e),
                di(e)
            }
            ), !0),
            n("lineSeparator", null, (function(e, t) {
                if (e.doc.lineSep = t,
                t) {
                    var n = []
                      , i = e.doc.first;
                    e.doc.iter((function(e) {
                        for (var r = 0; ; ) {
                            var s = e.text.indexOf(t, r);
                            if (-1 == s)
                                break;
                            r = s + t.length,
                            n.push(et(i, s))
                        }
                        i++
                    }
                    ));
                    for (var r = n.length - 1; r >= 0; r--)
                        fs(e.doc, t, n[r], et(n[r].line, n[r].ch + t.length))
                }
            }
            )),
            n("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, (function(e, t, n) {
                e.state.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"),"g"),
                n != wa && e.refresh()
            }
            )),
            n("specialCharPlaceholder", Zt, (function(e) {
                return e.refresh()
            }
            ), !0),
            n("electricChars", !0),
            n("inputStyle", v ? "contenteditable" : "textarea", (function() {
                throw new Error("inputStyle can not (yet) be changed in a running editor")
            }
            ), !0),
            n("spellcheck", !1, (function(e, t) {
                return e.getInputField().spellcheck = t
            }
            ), !0),
            n("autocorrect", !1, (function(e, t) {
                return e.getInputField().autocorrect = t
            }
            ), !0),
            n("autocapitalize", !1, (function(e, t) {
                return e.getInputField().autocapitalize = t
            }
            ), !0),
            n("rtlMoveVisually", !S),
            n("wholeLineUpdateBefore", !0),
            n("theme", "default", (function(e) {
                Sa(e),
                mr(e)
            }
            ), !0),
            n("keyMap", "default", (function(e, t, n) {
                var i = Ys(t)
                  , r = n != wa && Ys(n);
                r && r.detach && r.detach(e, i),
                i.attach && i.attach(e, r || null)
            }
            )),
            n("extraKeys", null),
            n("configureMouse", null),
            n("lineWrapping", !1, ka, !0),
            n("gutters", [], (function(e, t) {
                e.display.gutterSpecs = pr(t, e.options.lineNumbers),
                mr(e)
            }
            ), !0),
            n("fixedGutter", !0, (function(e, t) {
                e.display.gutters.style.left = t ? ai(e.display) + "px" : "0",
                e.refresh()
            }
            ), !0),
            n("coverGutterNextToScrollbar", !1, (function(e) {
                return Ui(e)
            }
            ), !0),
            n("scrollbarStyle", "native", (function(e) {
                $i(e),
                Ui(e),
                e.display.scrollbars.setScrollTop(e.doc.scrollTop),
                e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)
            }
            ), !0),
            n("lineNumbers", !1, (function(e, t) {
                e.display.gutterSpecs = pr(e.options.gutters, t),
                mr(e)
            }
            ), !0),
            n("firstLineNumber", 1, mr, !0),
            n("lineNumberFormatter", (function(e) {
                return e
            }
            ), mr, !0),
            n("showCursorWhenSelecting", !1, gi, !0),
            n("resetSelectionOnContextMenu", !0),
            n("lineWiseCopyCut", !0),
            n("pasteLinesPerSelection", !0),
            n("selectionsMayTouch", !1),
            n("readOnly", !1, (function(e, t) {
                "nocursor" == t && (ki(e),
                e.display.input.blur()),
                e.display.input.readOnlyChanged(t)
            }
            )),
            n("disableInput", !1, (function(e, t) {
                t || e.display.input.reset()
            }
            ), !0),
            n("dragDrop", !0, Oa),
            n("allowDropFileTypes", null),
            n("cursorBlinkRate", 530),
            n("cursorScrollMargin", 0),
            n("cursorHeight", 1, gi, !0),
            n("singleCursorHeightPerLine", !0, gi, !0),
            n("workTime", 100),
            n("workDelay", 100),
            n("flattenSpans", !0, Ar, !0),
            n("addModeClass", !1, Ar, !0),
            n("pollInterval", 100),
            n("undoDepth", 200, (function(e, t) {
                return e.doc.history.undoDepth = t
            }
            )),
            n("historyEventDelay", 1250),
            n("viewportMargin", 10, (function(e) {
                return e.refresh()
            }
            ), !0),
            n("maxHighlightLength", 1e4, Ar, !0),
            n("moveInputWithCursor", !0, (function(e, t) {
                t || e.display.input.resetPosition()
            }
            )),
            n("tabindex", null, (function(e, t) {
                return e.display.input.getField().tabIndex = t || ""
            }
            )),
            n("autofocus", null),
            n("direction", "ltr", (function(e, t) {
                return e.doc.setDirection(t)
            }
            ), !0),
            n("phrases", null)
        }(Ea),
        function(e) {
            var t = e.optionHandlers
              , n = e.helpers = {};
            e.prototype = {
                constructor: e,
                focus: function() {
                    window.focus(),
                    this.display.input.focus()
                },
                setOption: function(e, n) {
                    var i = this.options
                      , r = i[e];
                    i[e] == n && "mode" != e || (i[e] = n,
                    t.hasOwnProperty(e) && er(this, t[e])(this, n, r),
                    fe(this, "optionChange", this, e))
                },
                getOption: function(e) {
                    return this.options[e]
                },
                getDoc: function() {
                    return this.doc
                },
                addKeyMap: function(e, t) {
                    this.state.keyMaps[t ? "push" : "unshift"](Ys(e))
                },
                removeKeyMap: function(e) {
                    for (var t = this.state.keyMaps, n = 0; n < t.length; ++n)
                        if (t[n] == e || t[n].name == e)
                            return t.splice(n, 1),
                            !0
                },
                addOverlay: tr((function(t, n) {
                    var i = t.token ? t : e.getMode(this.options, t);
                    if (i.startState)
                        throw new Error("Overlays may not be stateful.");
                    !function(e, t, n) {
                        for (var i = 0, r = n(t); i < e.length && n(e[i]) <= r; )
                            i++;
                        e.splice(i, 0, t)
                    }(this.state.overlays, {
                        mode: i,
                        modeSpec: t,
                        opaque: n && n.opaque,
                        priority: n && n.priority || 0
                    }, (function(e) {
                        return e.priority
                    }
                    )),
                    this.state.modeGen++,
                    di(this)
                }
                )),
                removeOverlay: tr((function(e) {
                    for (var t = this.state.overlays, n = 0; n < t.length; ++n) {
                        var i = t[n].modeSpec;
                        if (i == e || "string" == typeof e && i.name == e)
                            return t.splice(n, 1),
                            this.state.modeGen++,
                            void di(this)
                    }
                }
                )),
                indentLine: tr((function(e, t, n) {
                    "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"),
                    Ze(this.doc, e) && Ma(this, e, t, n)
                }
                )),
                indentSelection: tr((function(e) {
                    for (var t = this.doc.sel.ranges, n = -1, i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r.empty())
                            r.head.line > n && (Ma(this, r.head.line, e, !0),
                            n = r.head.line,
                            i == this.doc.sel.primIndex && Ai(this));
                        else {
                            var s = r.from()
                              , a = r.to()
                              , o = Math.max(n, s.line);
                            n = Math.min(this.lastLine(), a.line - (a.ch ? 0 : 1)) + 1;
                            for (var l = o; l < n; ++l)
                                Ma(this, l, e);
                            var c = this.doc.sel.ranges;
                            0 == s.ch && t.length == c.length && c[i].from().ch > 0 && Xr(this.doc, i, new Cr(s,c[i].to()), z)
                        }
                    }
                }
                )),
                getTokenAt: function(e, t) {
                    return bt(this, e, t)
                },
                getLineTokens: function(e, t) {
                    return bt(this, et(e), t, !0)
                },
                getTokenTypeAt: function(e) {
                    e = ot(this.doc, e);
                    var t, n = ht(this, He(this.doc, e.line)), i = 0, r = (n.length - 1) / 2, s = e.ch;
                    if (0 == s)
                        t = n[2];
                    else
                        for (; ; ) {
                            var a = i + r >> 1;
                            if ((a ? n[2 * a - 1] : 0) >= s)
                                r = a;
                            else {
                                if (!(n[2 * a + 1] < s)) {
                                    t = n[2 * a + 2];
                                    break
                                }
                                i = a + 1
                            }
                        }
                    var o = t ? t.indexOf("overlay ") : -1;
                    return o < 0 ? t : 0 == o ? null : t.slice(0, o - 1)
                },
                getModeAt: function(t) {
                    var n = this.doc.mode;
                    return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n
                },
                getHelper: function(e, t) {
                    return this.getHelpers(e, t)[0]
                },
                getHelpers: function(e, t) {
                    var i = [];
                    if (!n.hasOwnProperty(t))
                        return i;
                    var r = n[t]
                      , s = this.getModeAt(e);
                    if ("string" == typeof s[t])
                        r[s[t]] && i.push(r[s[t]]);
                    else if (s[t])
                        for (var a = 0; a < s[t].length; a++) {
                            var o = r[s[t][a]];
                            o && i.push(o)
                        }
                    else
                        s.helperType && r[s.helperType] ? i.push(r[s.helperType]) : r[s.name] && i.push(r[s.name]);
                    for (var l = 0; l < r._global.length; l++) {
                        var c = r._global[l];
                        c.pred(s, this) && -1 == _(i, c.val) && i.push(c.val)
                    }
                    return i
                },
                getStateAfter: function(e, t) {
                    var n = this.doc;
                    return pt(this, (e = at(n, null == e ? n.first + n.size - 1 : e)) + 1, t).state
                },
                cursorCoords: function(e, t) {
                    var n = this.doc.sel.primary();
                    return Jn(this, null == e ? n.head : "object" == typeof e ? ot(this.doc, e) : e ? n.from() : n.to(), t || "page")
                },
                charCoords: function(e, t) {
                    return Hn(this, ot(this.doc, e), t || "page")
                },
                coordsChar: function(e, t) {
                    return Xn(this, (e = Wn(this, e, t || "page")).left, e.top)
                },
                lineAtHeight: function(e, t) {
                    return e = Wn(this, {
                        top: e,
                        left: 0
                    }, t || "page").top,
                    Ke(this.doc, e + this.display.viewOffset)
                },
                heightAtLine: function(e, t, n) {
                    var i, r = !1;
                    if ("number" == typeof e) {
                        var s = this.doc.first + this.doc.size - 1;
                        e < this.doc.first ? e = this.doc.first : e > s && (e = s,
                        r = !0),
                        i = He(this.doc, e)
                    } else
                        i = e;
                    return $n(this, i, {
                        top: 0,
                        left: 0
                    }, t || "page", n || r).top + (r ? this.doc.height - Gt(i) : 0)
                },
                defaultTextHeight: function() {
                    return ii(this.display)
                },
                defaultCharWidth: function() {
                    return ri(this.display)
                },
                getViewport: function() {
                    return {
                        from: this.display.viewFrom,
                        to: this.display.viewTo
                    }
                },
                addWidget: function(e, t, n, i, r) {
                    var s, a, o, l = this.display, c = (e = Jn(this, ot(this.doc, e))).bottom, u = e.left;
                    if (t.style.position = "absolute",
                    t.setAttribute("cm-ignore-events", "true"),
                    this.display.input.setUneditable(t),
                    l.sizer.appendChild(t),
                    "over" == i)
                        c = e.top;
                    else if ("above" == i || "near" == i) {
                        var d = Math.max(l.wrapper.clientHeight, this.doc.height)
                          , h = Math.max(l.sizer.clientWidth, l.lineSpace.clientWidth);
                        ("above" == i || e.bottom + t.offsetHeight > d) && e.top > t.offsetHeight ? c = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= d && (c = e.bottom),
                        u + t.offsetWidth > h && (u = h - t.offsetWidth)
                    }
                    t.style.top = c + "px",
                    t.style.left = t.style.right = "",
                    "right" == r ? (u = l.sizer.clientWidth - t.offsetWidth,
                    t.style.right = "0px") : ("left" == r ? u = 0 : "middle" == r && (u = (l.sizer.clientWidth - t.offsetWidth) / 2),
                    t.style.left = u + "px"),
                    n && (s = this,
                    a = {
                        left: u,
                        top: c,
                        right: u + t.offsetWidth,
                        bottom: c + t.offsetHeight
                    },
                    null != (o = Di(s, a)).scrollTop && ji(s, o.scrollTop),
                    null != o.scrollLeft && Vi(s, o.scrollLeft))
                },
                triggerOnKeyDown: tr(ca),
                triggerOnKeyPress: tr(da),
                triggerOnKeyUp: ua,
                triggerOnMouseDown: tr(ma),
                execCommand: function(e) {
                    if (ea.hasOwnProperty(e))
                        return ea[e].call(null, this)
                },
                triggerElectric: tr((function(e) {
                    Pa(this, e)
                }
                )),
                findPosH: function(e, t, n, i) {
                    var r = 1;
                    t < 0 && (r = -1,
                    t = -t);
                    for (var s = ot(this.doc, e), a = 0; a < t && !(s = Va(this.doc, s, r, n, i)).hitSide; ++a)
                        ;
                    return s
                },
                moveH: tr((function(e, t) {
                    var n = this;
                    this.extendSelectionsBy((function(i) {
                        return n.display.shift || n.doc.extend || i.empty() ? Va(n.doc, i.head, e, t, n.options.rtlMoveVisually) : e < 0 ? i.from() : i.to()
                    }
                    ), $)
                }
                )),
                deleteH: tr((function(e, t) {
                    var n = this.doc.sel
                      , i = this.doc;
                    n.somethingSelected() ? i.replaceSelection("", null, "+delete") : Xs(this, (function(n) {
                        var r = Va(i, n.head, e, t, !1);
                        return e < 0 ? {
                            from: r,
                            to: n.head
                        } : {
                            from: n.head,
                            to: r
                        }
                    }
                    ))
                }
                )),
                findPosV: function(e, t, n, i) {
                    var r = 1
                      , s = i;
                    t < 0 && (r = -1,
                    t = -t);
                    for (var a = ot(this.doc, e), o = 0; o < t; ++o) {
                        var l = Jn(this, a, "div");
                        if (null == s ? s = l.left : l.left = s,
                        (a = Ba(this, l, r, n)).hitSide)
                            break
                    }
                    return a
                },
                moveV: tr((function(e, t) {
                    var n = this
                      , i = this.doc
                      , r = []
                      , s = !this.display.shift && !i.extend && i.sel.somethingSelected();
                    if (i.extendSelectionsBy((function(a) {
                        if (s)
                            return e < 0 ? a.from() : a.to();
                        var o = Jn(n, a.head, "div");
                        null != a.goalColumn && (o.left = a.goalColumn),
                        r.push(o.left);
                        var l = Ba(n, o, e, t);
                        return "page" == t && a == i.sel.primary() && Li(n, Hn(n, l, "div").top - o.top),
                        l
                    }
                    ), $),
                    r.length)
                        for (var a = 0; a < i.sel.ranges.length; a++)
                            i.sel.ranges[a].goalColumn = r[a]
                }
                )),
                findWordAt: function(e) {
                    var t = He(this.doc, e.line).text
                      , n = e.ch
                      , i = e.ch;
                    if (t) {
                        var r = this.getHelper(e, "wordChars");
                        "before" != e.sticky && i != t.length || !n ? ++i : --n;
                        for (var s = t.charAt(n), a = ee(s, r) ? function(e) {
                            return ee(e, r)
                        }
                        : /\s/.test(s) ? function(e) {
                            return /\s/.test(e)
                        }
                        : function(e) {
                            return !/\s/.test(e) && !ee(e)
                        }
                        ; n > 0 && a(t.charAt(n - 1)); )
                            --n;
                        for (; i < t.length && a(t.charAt(i)); )
                            ++i
                    }
                    return new Cr(et(e.line, n),et(e.line, i))
                },
                toggleOverwrite: function(e) {
                    null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? P(this.display.cursorDiv, "CodeMirror-overwrite") : E(this.display.cursorDiv, "CodeMirror-overwrite"),
                    fe(this, "overwriteToggle", this, this.state.overwrite))
                },
                hasFocus: function() {
                    return this.display.input.getField() == I()
                },
                isReadOnly: function() {
                    return !(!this.options.readOnly && !this.doc.cantEdit)
                },
                scrollTo: tr((function(e, t) {
                    Ii(this, e, t)
                }
                )),
                getScrollInfo: function() {
                    var e = this.display.scroller;
                    return {
                        left: e.scrollLeft,
                        top: e.scrollTop,
                        height: e.scrollHeight - En(this) - this.display.barHeight,
                        width: e.scrollWidth - En(this) - this.display.barWidth,
                        clientHeight: Mn(this),
                        clientWidth: Tn(this)
                    }
                },
                scrollIntoView: tr((function(e, t) {
                    null == e ? (e = {
                        from: this.doc.sel.primary().head,
                        to: null
                    },
                    null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = {
                        from: et(e, 0),
                        to: null
                    } : null == e.from && (e = {
                        from: e,
                        to: null
                    }),
                    e.to || (e.to = e.from),
                    e.margin = t || 0,
                    null != e.from.line ? function(e, t) {
                        Pi(e),
                        e.curOp.scrollToPos = t
                    }(this, e) : Ri(this, e.from, e.to, e.margin)
                }
                )),
                setSize: tr((function(e, t) {
                    var n = this
                      , i = function(e) {
                        return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
                    };
                    null != e && (this.display.wrapper.style.width = i(e)),
                    null != t && (this.display.wrapper.style.height = i(t)),
                    this.options.lineWrapping && Fn(this);
                    var r = this.display.viewFrom;
                    this.doc.iter(r, this.display.viewTo, (function(e) {
                        if (e.widgets)
                            for (var t = 0; t < e.widgets.length; t++)
                                if (e.widgets[t].noHScroll) {
                                    hi(n, r, "widget");
                                    break
                                }
                        ++r
                    }
                    )),
                    this.curOp.forceUpdate = !0,
                    fe(this, "refresh", this)
                }
                )),
                operation: function(e) {
                    return Qi(this, e)
                },
                startOperation: function() {
                    return Hi(this)
                },
                endOperation: function() {
                    return Ji(this)
                },
                refresh: tr((function() {
                    var e = this.display.cachedTextHeight;
                    di(this),
                    this.curOp.forceUpdate = !0,
                    _n(this),
                    Ii(this, this.doc.scrollLeft, this.doc.scrollTop),
                    cr(this.display),
                    (null == e || Math.abs(e - ii(this.display)) > .5) && li(this),
                    fe(this, "refresh", this)
                }
                )),
                swapDoc: tr((function(e) {
                    var t = this.doc;
                    return t.cm = null,
                    this.state.selectingText && this.state.selectingText(),
                    jr(this, e),
                    _n(this),
                    this.display.input.reset(),
                    Ii(this, e.scrollLeft, e.scrollTop),
                    this.curOp.forceScroll = !0,
                    ln(this, "swapDoc", this, t),
                    t
                }
                )),
                phrase: function(e) {
                    var t = this.options.phrases;
                    return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e
                },
                getInputField: function() {
                    return this.display.input.getField()
                },
                getWrapperElement: function() {
                    return this.display.wrapper
                },
                getScrollerElement: function() {
                    return this.display.scroller
                },
                getGutterElement: function() {
                    return this.display.gutters
                }
            },
            be(e),
            e.registerHelper = function(t, i, r) {
                n.hasOwnProperty(t) || (n[t] = e[t] = {
                    _global: []
                }),
                n[t][i] = r
            }
            ,
            e.registerGlobalHelper = function(t, i, r, s) {
                e.registerHelper(t, i, s),
                n[t]._global.push({
                    pred: r,
                    val: s
                })
            }
        }(Ea);
        var Wa = "iter insert remove copy getEditor constructor".split(" ");
        for (var Ha in Ls.prototype)
            Ls.prototype.hasOwnProperty(Ha) && _(Wa, Ha) < 0 && (Ea.prototype[Ha] = function(e) {
                return function() {
                    return e.apply(this.doc, arguments)
                }
            }(Ls.prototype[Ha]));
        return be(Ls),
        Ea.inputStyles = {
            textarea: $a,
            contenteditable: Fa
        },
        Ea.defineMode = function(e) {
            Ea.defaults.mode || "null" == e || (Ea.defaults.mode = e),
            Ve.apply(this, arguments)
        }
        ,
        Ea.defineMIME = function(e, t) {
            Ne[e] = t
        }
        ,
        Ea.defineMode("null", (function() {
            return {
                token: function(e) {
                    return e.skipToEnd()
                }
            }
        }
        )),
        Ea.defineMIME("text/plain", "null"),
        Ea.defineExtension = function(e, t) {
            Ea.prototype[e] = t
        }
        ,
        Ea.defineDocExtension = function(e, t) {
            Ls.prototype[e] = t
        }
        ,
        Ea.fromTextArea = function(e, t) {
            if ((t = t ? V(t) : {}).value = e.value,
            !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex),
            !t.placeholder && e.placeholder && (t.placeholder = e.placeholder),
            null == t.autofocus) {
                var n = I();
                t.autofocus = n == e || null != e.getAttribute("autofocus") && n == document.body
            }
            function i() {
                e.value = o.getValue()
            }
            var r;
            if (e.form && (de(e.form, "submit", i),
            !t.leaveSubmitMethodAlone)) {
                var s = e.form;
                r = s.submit;
                try {
                    var a = s.submit = function() {
                        i(),
                        s.submit = r,
                        s.submit(),
                        s.submit = a
                    }
                } catch (e) {}
            }
            t.finishInit = function(n) {
                n.save = i,
                n.getTextArea = function() {
                    return e
                }
                ,
                n.toTextArea = function() {
                    n.toTextArea = isNaN,
                    i(),
                    e.parentNode.removeChild(n.getWrapperElement()),
                    e.style.display = "",
                    e.form && (pe(e.form, "submit", i),
                    t.leaveSubmitMethodAlone || "function" != typeof e.form.submit || (e.form.submit = r))
                }
            }
            ,
            e.style.display = "none";
            var o = Ea((function(t) {
                return e.parentNode.insertBefore(t, e.nextSibling)
            }
            ), t);
            return o
        }
        ,
        function(e) {
            e.off = pe,
            e.on = de,
            e.wheelEventPixels = Sr,
            e.Doc = Ls,
            e.splitLines = Ae,
            e.countColumn = B,
            e.findColumn = W,
            e.isWordChar = Q,
            e.Pass = U,
            e.signal = fe,
            e.Line = Ht,
            e.changeEnd = Er,
            e.scrollbarModel = Gi,
            e.Pos = et,
            e.cmpPos = tt,
            e.modes = je,
            e.mimeModes = Ne,
            e.resolveMode = Be,
            e.getMode = Fe,
            e.modeExtensions = _e,
            e.extendMode = Ue,
            e.copyState = ze,
            e.startState = $e,
            e.innerMode = Ge,
            e.commands = ea,
            e.keyMap = zs,
            e.keyName = qs,
            e.isModifierKey = Hs,
            e.lookupKey = Ws,
            e.normalizeKeyMap = $s,
            e.StringStream = We,
            e.SharedTextMarker = Es,
            e.TextMarker = Os,
            e.LineWidget = ws,
            e.e_preventDefault = ye,
            e.e_stopPropagation = Se,
            e.e_stop = xe,
            e.addClass = P,
            e.contains = A,
            e.rmClass = E,
            e.keyNames = Bs
        }(Ea),
        Ea.version = "5.50.2",
        Ea
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    ));
    var i = n(84)
      , r = n(2)
      , s = n(12);
    n(165);
    let a = 0;
    const o = s.a.fromObject({
        escape: {
            action: "close"
        }
    });
    class l extends r.a {
        constructor() {
            super(),
            this.keyMap = new s.a,
            this.keyMap.addParent(o, Number.NEGATIVE_INFINITY),
            ++a;
            let e = this.container = document.createElement("div");
            e.className = "overlay";
            let t = this.content = document.createElement("div");
            this.registerDisposer(new i.a(t)),
            t.className = "overlay-content",
            e.appendChild(t),
            document.body.appendChild(e),
            this.registerDisposer(new s.b(this.container,this.keyMap)),
            this.registerEventListener(e, "action:close", ()=>{
                this.dispose()
            }
            ),
            t.focus()
        }
        disposed() {
            --a,
            document.body.removeChild(this.container),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e=128) {
        const t = Math.ceil(e / 32)
          , n = new Uint32Array(t);
        crypto.getRandomValues(n);
        let i = "";
        for (let e = 0; e < t; ++e)
            i += ("00000000" + n[e].toString(16)).slice(-8);
        return i
    }
    function r(e) {
        let t = new Uint8Array(e.buffer,e.byteOffset,e.byteLength);
        for (let e = 0, n = t.length; e < n; e += 65536)
            crypto.getRandomValues(t.subarray(e, Math.min(n, e + 65536)));
        return e
    }
    function s() {
        const e = new Uint32Array(1);
        return crypto.getRandomValues(e),
        e[0]
    }
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    ));
    var i = n(2);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var r;
    !function(e) {
        e[e.VERTEX = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX",
        e[e.FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT"
    }(r || (r = {}));
    class s extends Error {
        constructor(e, t, n, i) {
            const s = `Error compiling ${r[e].toLowerCase()} shader: ${n}`;
            super(s),
            this.name = "ShaderCompilationError",
            this.log = n,
            this.message = s,
            this.shaderType = e,
            this.source = t,
            this.errorMessages = i
        }
    }
    class a extends Error {
        constructor(e, t, n) {
            const i = `Error linking shader: ${n}`;
            super(i),
            this.name = "ShaderLinkError",
            this.log = n,
            this.message = i,
            this.vertexSource = e,
            this.fragmentSource = t
        }
    }
    function o(e, t, n) {
        var i = e.createShader(n);
        if (e.shaderSource(i, t),
        e.compileShader(i),
        !e.getShaderParameter(i, e.COMPILE_STATUS)) {
            let r = e.getShaderInfoLog(i) || "";
            throw new s(n,t,r,function(e) {
                e = e.replace("\0", "");
                let t = [];
                for (let n of e.split("\n")) {
                    let e = n.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
                    null !== e ? t.push({
                        message: e[3].trim(),
                        file: parseInt(e[1], 10),
                        line: parseInt(e[2], 10)
                    }) : (e = n.match(/^ERROR:\s*(.+)$/),
                    null !== e ? t.push({
                        message: e[1]
                    }) : (n = n.trim(),
                    n && t.push({
                        message: n
                    })))
                }
                return t
            }(r))
        }
        return i
    }
    class l extends i.a {
        constructor(e, t, n, i, r) {
            super(),
            this.gl = e,
            this.vertexSource = t,
            this.fragmentSource = n,
            this.attributes = new Map,
            this.uniforms = new Map,
            this.vertexShaderInputBinders = {};
            let s = this.vertexShader = o(e, t, e.VERTEX_SHADER)
              , l = this.fragmentShader = o(e, n, e.FRAGMENT_SHADER)
              , c = e.createProgram();
            if (e.attachShader(c, s),
            e.attachShader(c, l),
            e.linkProgram(c),
            !e.getProgramParameter(c, e.LINK_STATUS)) {
                let i = e.getProgramInfoLog(c) || "";
                throw new a(t,n,i)
            }
            this.program = c;
            let {uniforms: u, attributes: d} = this;
            if (i)
                for (let t of i)
                    u.set(t, e.getUniformLocation(c, t));
            if (r)
                for (let t of r)
                    d.set(t, e.getAttribLocation(c, t))
        }
        uniform(e) {
            return this.uniforms.get(e)
        }
        attribute(e) {
            return this.attributes.get(e)
        }
        textureUnit(e) {
            return this.textureUnits.get(e)
        }
        bind() {
            this.gl.useProgram(this.program)
        }
        disposed() {
            let {gl: e} = this;
            e.deleteShader(this.vertexShader),
            this.vertexShader = void 0,
            e.deleteShader(this.fragmentShader),
            this.fragmentShader = void 0,
            e.deleteProgram(this.program),
            this.program = void 0,
            this.gl = void 0,
            this.attributes = void 0,
            this.uniforms = void 0
        }
    }
    class c {
        constructor() {
            this.code = "",
            this.parts = new Set
        }
        add(e) {
            if (!this.parts.has(e))
                switch (this.parts.add(e),
                typeof e) {
                case "string":
                    this.code += e;
                    break;
                case "function":
                    this.add(e());
                    break;
                default:
                    if (!Array.isArray(e))
                        throw console.log("Invalid code type", e),
                        new Error("Invalid code type");
                    for (let t of e)
                        this.add(t)
                }
        }
        toString() {
            return this.code
        }
    }
    const u = {
        sampler2D: WebGL2RenderingContext.TEXTURE_2D,
        isampler2D: WebGL2RenderingContext.TEXTURE_2D,
        usampler2D: WebGL2RenderingContext.TEXTURE_2D,
        sampler3D: WebGL2RenderingContext.TEXTURE_3D,
        isampler3D: WebGL2RenderingContext.TEXTURE_3D,
        usampler3D: WebGL2RenderingContext.TEXTURE_3D
    };
    class d {
        constructor(e) {
            this.gl = e,
            this.nextSymbolID = 0,
            this.nextTextureUnit = 0,
            this.uniformsCode = "",
            this.attributesCode = "",
            this.varyingsCodeVS = "",
            this.varyingsCodeFS = "",
            this.fragmentExtensionsSet = new Set,
            this.fragmentExtensions = "",
            this.vertexCode = new c,
            this.vertexMain = "",
            this.fragmentCode = new c,
            this.outputBufferCode = "",
            this.fragmentMain = "",
            this.required = new Set,
            this.uniforms = new Array,
            this.attributes = new Array,
            this.initializers = [],
            this.textureUnits = new Map
        }
        allocateTextureUnit(e, t=1) {
            if (this.textureUnits.has(e))
                throw new Error("Duplicate texture unit symbol: " + e);
            let n = this.nextTextureUnit;
            return this.nextTextureUnit += t,
            this.textureUnits.set(e, n),
            n
        }
        addTextureSampler(e, t, n, i) {
            let r = this.allocateTextureUnit(n, i);
            return this.addUniform(`highp ${e}`, t, i),
            this.addInitializer(e=>{
                if (i) {
                    let n = new Int32Array(i);
                    for (let e = 0; e < i; ++e)
                        n[e] = e + r;
                    e.gl.uniform1iv(e.uniform(t), n)
                } else
                    e.gl.uniform1i(e.uniform(t), r)
            }
            ),
            r
        }
        symbol(e) {
            return e + this.nextSymbolID++
        }
        addAttribute(e, t) {
            return this.attributes.push(t),
            this.attributesCode += `in ${e} ${t};\n`,
            t
        }
        addVarying(e, t, n="") {
            this.varyingsCodeVS += `${n} out ${e} ${t};\n`,
            this.varyingsCodeFS += `${n} in ${e} ${t};\n`
        }
        addOutputBuffer(e, t, n) {
            null !== n && (this.outputBufferCode += `layout(location = ${n}) `),
            this.outputBufferCode += `out ${e} ${t};\n`
        }
        addUniform(e, t, n) {
            return this.uniforms.push(t),
            this.uniformsCode += null != n ? `uniform ${e} ${t}[${n}];\n` : `uniform ${e} ${t};\n`,
            t
        }
        addFragmentExtension(e) {
            this.fragmentExtensionsSet.has(e) || (this.fragmentExtensionsSet.add(e),
            this.fragmentExtensions += `#extension ${e} : require\n`)
        }
        addVertexCode(e) {
            this.vertexCode.add(e)
        }
        addFragmentCode(e) {
            this.fragmentCode.add(e)
        }
        setVertexMain(e) {
            this.vertexMain = e
        }
        addVertexMain(e) {
            this.vertexMain = (this.vertexMain || "") + e
        }
        setFragmentMain(e) {
            this.fragmentMain = `void main() {\n${e}\n}\n`
        }
        setFragmentMainFunction(e) {
            this.fragmentMain = e
        }
        addInitializer(e) {
            this.initializers.push(e)
        }
        require(e) {
            this.required.has(e) || (this.required.add(e),
            e(this))
        }
        build() {
            let e = `#version 300 es\nprecision highp float;\nprecision highp int;\n${this.uniformsCode}\n${this.attributesCode}\n${this.varyingsCodeVS}\n${this.vertexCode}\nvoid main() {\n${this.vertexMain}\n}\n`
              , t = `#version 300 es\n${this.fragmentExtensions}\nprecision highp float;\nprecision highp int;\n${this.uniformsCode}\n${this.varyingsCodeFS}\n${this.outputBufferCode}\n${this.fragmentCode}\n${this.fragmentMain}\n`
              , n = new l(this.gl,e,t,this.uniforms,this.attributes);
            n.textureUnits = this.textureUnits;
            let {initializers: i} = this;
            if (i.length > 0) {
                n.bind();
                for (let e of i)
                    e(n)
            }
            return n
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i, r = n(7), s = n(11);
    let a = i = class extends s.c {
        constructor(e, t={}) {
            super(e, t),
            this.updatingValue_ = !1,
            void 0 !== e && (this.base = new r.e(t.value),
            this.setupChangedHandler())
        }
        initializeCounterpart(e, t={}) {
            t.value = this.value,
            super.initializeCounterpart(e, t)
        }
        setupChangedHandler() {
            this.registerDisposer(this.base.changed.add(()=>{
                if (this.updatingValue_)
                    this.updatingValue_ = !1;
                else {
                    const {rpc: e} = this;
                    null !== e && e.invoke("SharedWatchableValue.changed", {
                        id: this.rpcId,
                        value: this.value
                    })
                }
            }
            ))
        }
        static makeFromExisting(e, t) {
            let n = new i;
            return n.base = t,
            n.setupChangedHandler(),
            n.initializeCounterpart(e),
            n
        }
        static make(e, t) {
            return i.makeFromExisting(e, new r.e(t))
        }
        get value() {
            return this.base.value
        }
        set value(e) {
            this.base.value = e
        }
        get changed() {
            return this.base.changed
        }
    }
    ;
    a = i = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }([Object(s.f)("SharedWatchableValue")], a),
    Object(s.e)("SharedWatchableValue.changed", (function(e) {
        const t = this.get(e.id);
        t.updatingValue_ = !0,
        t.base.value = e.value,
        t.updatingValue_ = !1
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var i = n(7);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const r = new Float32Array(1);
    var s = n(1)
      , a = n(106);
    function o(e) {
        try {
            if ("string" != typeof e)
                throw new Error(`Expected string, but received ${JSON.stringify(e)}.`);
            const t = document.createElement("canvas").getContext("2d");
            t.fillStyle = e;
            const n = /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            function(e) {
                const t = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
                {
                    const n = e.match(t);
                    if (null !== n)
                        return [parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10), parseFloat(n[4])]
                }
                const n = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
                {
                    const t = e.match(n);
                    if (null !== t)
                        return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), 1]
                }
                throw new Error(`Invalid serialized color: ${JSON.stringify(e)}.`)
            }(t.fillStyle);
            return s.v.fromValues(n[0] / 255, n[1] / 255, n[2] / 255, n[3])
        } catch (e) {
            throw new Error(`Failed to parse color specification: ${e.message}`)
        }
    }
    function l(e) {
        return o(e).subarray(0, 3)
    }
    function c(e) {
        const t = void 0 === e[3] ? 3 : 4;
        let n = 0;
        for (let i = 0; i < t; i++)
            n = (n << 8 >>> 0) + Math.min(255, Math.max(0, Math.round(255 * e[i])));
        return n
    }
    function u(e) {
        if (void 0 === e[3] || 1 === e[3]) {
            let t = "#";
            for (let n = 0; n < 3; ++n)
                t += Object(a.c)(Math.min(255, Math.max(0, Math.round(255 * e[n]))));
            return t
        }
        {
            let t = "rgba(";
            for (let n = 0; n < 3; ++n)
                0 !== n && (t += ", "),
                t += Math.min(255, Math.max(0, Math.round(255 * e[n])));
            return t += `, ${function(e) {
                r[0] = e,
                e = r[0];
                for (let t = 1; t < 21; ++t) {
                    let n = e.toPrecision(t);
                    if (r[0] = parseFloat(n),
                    r[0] === e)
                        return n
                }
                return e.toString()
            }(e[3])})`,
            t
        }
    }
    n.d(t, "c", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    ));
    class d extends i.e {
        constructor(e) {
            super(s.t.clone(e)),
            this.defaultValue = e
        }
        toString() {
            return u(this.value)
        }
        toJSON() {
            return s.t.equals(this.value, this.defaultValue) ? void 0 : u(this.value)
        }
        reset() {
            this.value = s.t.clone(this.defaultValue)
        }
        restoreState(e) {
            if (void 0 === e)
                return void this.reset();
            const {value: t} = this
              , n = l(e);
            s.t.equals(t, n) || (this.value = n)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "d", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "e", (function() {
        return o
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = "mesh/MeshLayer"
      , r = "mesh/MultiscaleMeshLayer"
      , s = "mesh/FragmentSource"
      , a = "mesh/MultiscaleFragmentSource";
    var o;
    !function(e) {
        e[e.float32 = 0] = "float32",
        e[e.uint10 = 1] = "uint10",
        e[e.uint16 = 2] = "uint16"
    }(o || (o = {}))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "k", (function() {
        return o
    }
    )),
    n.d(t, "f", (function() {
        return l
    }
    )),
    n.d(t, "g", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    )),
    n.d(t, "j", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return p
    }
    )),
    n.d(t, "h", (function() {
        return f
    }
    )),
    n.d(t, "i", (function() {
        return m
    }
    )),
    n.d(t, "l", (function() {
        return v
    }
    ));
    var i = n(44)
      , r = n(1);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = "annotation.MetadataChunkSource"
      , a = "annotation.GeometryChunkSource"
      , o = "annotation.SubsetGeometryChunkSource"
      , l = "annotation.reference.add"
      , c = "annotation.reference.delete"
      , u = "annotation.commit"
      , d = "annotation.commit"
      , h = "annotation/SpatiallyIndexedRenderLayer"
      , p = "annotation/PerspectiveRenderLayer:updateSources"
      , f = "annotation/RenderLayer"
      , m = "annotation/RenderLayer.updateSegmentation"
      , g = r.j.create();
    function v(e, t, n, s, a, o) {
        const {displayDimensionRenderInfo: l, viewMatrix: c, projectionMat: u, width: d, height: h} = e
          , {voxelPhysicalScales: p} = l
          , f = r.j.determinant(Object(r.k)(g, c))
          , m = Object(r.m)(p)
          , v = Object(r.d)(u) / f * m;
        if (0 === s.length)
            return;
        const b = s[0];
        let y = b.chunkLayout.detTransform * m;
        const {lowerClipDisplayBound: S, upperClipDisplayBound: w} = b;
        for (let e = 0; e < 3; ++e)
            y *= w[e] - S[e];
        const x = Math.min(y, v)
          , C = d * h
          , O = C / n ** 2 / x;
        let k = 0;
        for (let n = s.length - 1; n >= 0 && k < O; --n) {
            const l = s[n]
              , c = l.source.spec
              , {chunkLayout: u} = l
              , d = Object(r.m)(u.size) * u.detTransform * m
              , {limit: h, rank: p} = c
              , {nonDisplayLowerClipBound: f, nonDisplayUpperClipBound: g} = l;
            let v = 1;
            for (let e = 0; e < p; ++e) {
                const t = g[e] - f[e];
                Number.isFinite(t) && (v /= t)
            }
            let b = !0;
            const y = k + h * v / d
              , S = Math.pow(1 / y, 1 / 3)
              , w = Math.sqrt(C / (y * x))
              , E = (O - k) * d / v
              , T = Math.min(1, E / c.limit);
            Object(i.j)(e, t, l, ()=>{
                b && (a(l, n),
                b = !1),
                o(l, n, T, S, w)
            }
            ),
            k = y
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return l
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    ));
    var i = n(27)
      , r = n(31)
      , s = n(61)
      , a = n(44)
      , o = n(11);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class l extends r.b {
        constructor(e, t, n) {
            super(),
            this.chunkManager = e,
            this.multiscaleSource = t,
            this.rpcId = null,
            this.visibleSources = new Map,
            this.visibleSourcesList_ = [];
            const {renderScaleTarget: r=Object(i.e)(1)} = n;
            this.renderScaleTarget = r,
            this.renderScaleHistogram = n.renderScaleHistogram,
            this.transform = n.transform,
            this.localPosition = n.localPosition
        }
        getSources(e) {
            return this.multiscaleSource.getSources(e)
        }
        addSource(e, t) {
            const {visibleSources: n} = this
              , i = n.get(e);
            void 0 !== i ? ++i.refCount : (n.set(e, {
                source: e,
                refCount: 1,
                chunkTransform: t
            }),
            this.visibleSourcesList_.length = 0)
        }
        removeSource(e) {
            const {visibleSources: t} = this
              , n = t.get(e);
            1 !== n.refCount ? --n.refCount : (t.delete(e),
            this.visibleSourcesList_.length = 0)
        }
        get visibleSourcesList() {
            const {visibleSources: e, visibleSourcesList_: t} = this;
            if (0 === t.length && 0 !== e.size) {
                for (const n of e.values())
                    t.push(n);
                t.sort((e,t)=>e.chunkTransform.chunkToLayerTransformDet - t.chunkTransform.chunkToLayerTransformDet)
            }
            return t
        }
        initializeCounterpart() {
            const e = this.registerDisposer(new o.b)
              , t = this.chunkManager.rpc;
            e.RPC_TYPE_ID = this.RPC_TYPE_ID,
            e.initializeCounterpart(t, {
                localPosition: this.registerDisposer(s.a.makeFromExisting(t, this.localPosition)).rpcId,
                renderScaleTarget: this.registerDisposer(s.a.makeFromExisting(t, this.renderScaleTarget)).rpcId
            }),
            this.rpcId = e.rpcId
        }
        get gl() {
            return this.chunkManager.chunkQueueManager.gl
        }
        setGLBlendMode(e, t) {
            t > 0 && (e.enable(e.BLEND),
            e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA))
        }
        filterVisibleSources(e, t) {
            return Object(a.h)(e, this, t)
        }
    }
    l.prototype.RPC_TYPE_ID = a.d;
    class c extends r.e {
        draw(e, t) {}
        isReady(e, t) {
            return !0
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i = n(6)
      , r = n(25);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function s(e=-1, t=-1, n=1, r=1, s=1, a=1) {
        return Object(i.j)(new Float32Array([e, t, e, r, n, r, n, t]), 2, s, a)
    }
    function a(e, t=-1, n=-1, i=1, a=1, o=1, l=1) {
        return Object(r.b)(e, WebGL2RenderingContext.ARRAY_BUFFER, s, t, n, i, a, o, l).value
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var i = n(31);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class r extends i.e {
        draw(e, t) {}
        isReady(e, t) {
            return !0
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    var i = n(111)
      , r = n(23)
      , s = n(20);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const a = "google-brainmaps";
    function o(e, t, n, a=r.e) {
        return Object(i.a)(t, `${e.serverUrl}${n.path}`, {
            method: n.method,
            body: n.payload
        }, "json" === n.responseType ? s.g : s.f, (e,t)=>{
            const n = new Headers(t.headers);
            return n.set("Authorization", `${e.tokenType} ${e.accessToken}`),
            Object.assign(Object.assign({}, t), {
                headers: n
            })
        }
        , e=>{
            const {status: t} = e;
            if (401 === t)
                return "refresh";
            if (504 === t || 503 === t)
                return "retry";
            throw e
        }
        , a)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return d
    }
    )),
    n.d(t, "b", (function() {
        return h
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    ));
    var i = n(6)
      , r = n(2)
      , s = n(1)
      , a = n(25)
      , o = n(55);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const l = s.t.create()
      , c = s.t.create();
    function u(e) {
        let t = 0;
        for (var n = 0; n < 3; ++n)
            e[n] < 0 && (t += 1 << n);
        return t
    }
    const d = new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]);
    function h() {
        return new Float32Array([0, 1, 2, 3, 4, 5])
    }
    function p() {
        return Object(i.j)(h(), 1, 1, o.b)
    }
    class f extends r.a {
        constructor(e) {
            super(),
            this.outputVertexIndices = Object(a.b)(e, WebGL2RenderingContext.ARRAY_BUFFER, h).value;
            let t = [0, 1, 2, 4, 5, 3, 6, 7]
              , n = [0, 1, 2, 5, 3, 4, 6, 7]
              , i = [0, 1, 1, 4, 4, 7, 4, 7, 1, 5, 0, 1, 1, 4, 4, 7, 0, 2, 2, 5, 5, 7, 5, 7, 2, 6, 0, 2, 2, 5, 5, 7, 0, 3, 3, 6, 6, 7, 6, 7, 3, 4, 0, 3, 3, 6, 6, 7]
              , r = [0, 1, 2, 3, 4, 5, 6, 7, 1, 4, 5, 0, 3, 7, 2, 6, 2, 6, 0, 5, 7, 3, 1, 4, 3, 0, 6, 4, 1, 2, 7, 5, 4, 3, 7, 1, 0, 6, 5, 2, 5, 2, 1, 7, 6, 0, 4, 3, 6, 7, 3, 2, 5, 4, 0, 1, 7, 5, 4, 6, 2, 1, 3, 0]
              , s = [];
            for (var o = 0; o < 8; ++o)
                for (var l = 0; l < i.length; ++l) {
                    const e = 8 * n[o] + i[l];
                    s.push(t[r[e]])
                }
            this.vertexIndices = new Int32Array(s)
        }
        static get(e) {
            return e.memoize.get("SliceViewShaderBuffers", ()=>new f(e))
        }
    }
    class m extends r.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.data = this.registerDisposer(f.get(e))
        }
        static get(e) {
            return e.memoize.get("BoundingBoxCrossSectionRenderHelper", ()=>new m(e))
        }
        defineShader(e) {
            e.addUniform("highp vec3", "uPlaneNormal"),
            e.addUniform("highp float", "uPlaneDistance"),
            e.addUniform("highp ivec2", "uVertexIndex", 24),
            e.addUniform("highp vec3", "uVertexBasePosition", 8),
            e.addInitializer(e=>{
                e.gl.uniform3fv(e.uniform("uVertexBasePosition"), d)
            }
            ),
            e.addVertexCode("\nvec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex) {\n  for (int e = 0; e < 4; ++e) {\n    highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];\n    highp vec3 v1 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.x] + boxLower));\n    highp vec3 v2 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.y] + boxLower));\n    highp vec3 vDir = v2 - v1;\n    highp float denom = dot(vDir, uPlaneNormal);\n    if (abs(denom) > 0.001) {\n      highp float lambda = (uPlaneDistance - dot(v1, uPlaneNormal)) / denom;\n      if ((lambda >= -0.001) && (lambda <= (1.0 + 0.001))) {\n        lambda = clamp(lambda, 0.0, 1.0);\n        highp vec3 position = v1 + lambda * vDir;\n        return position;\n      }\n    }\n  }\n  return vec3(0, 0, 0);\n}\n")
        }
        computeVertexPositionDebug(e, t, n, i, r, a, o) {
            let l = u(r)
              , c = this.data.vertexIndices.subarray(48 * l, 48 * (l + 1))
              , h = [0, 0]
              , p = [s.t.create(), s.t.create()]
              , f = s.t.create()
              , m = s.t.create()
              , g = e=>d.subarray(3 * e, 3 * e + 3);
            for (let l = 0; l < 4; ++l) {
                for (let i = 0; i < 2; ++i)
                    h[i] = c[2 * (4 * o + l) + i],
                    s.t.multiply(p[i], e, g(h[i])),
                    s.t.add(p[i], p[i], a),
                    s.t.min(p[i], p[i], n),
                    s.t.max(p[i], p[i], t);
                s.t.subtract(f, p[1], p[0]);
                let u = s.t.dot(f, r);
                if (Math.abs(u) > .001) {
                    let e = (i - s.t.dot(p[0], r)) / u;
                    if (e >= -.001 && e <= 1.001)
                        return console.log(`vertex ${o}, e = ${l}, good, lambda=${e}, denom=${u}, v0=${p[0].join()}, vDir=${f.join()}`),
                        e = Math.max(0, Math.min(1, e)),
                        s.t.scaleAndAdd(m, p[0], f, e),
                        m;
                    console.log(`vertex ${o}, e = ${l}, skipped, denom = ${u}, ` + `vDir = ${f.join()}, v0=${p[0].join()}, v1=${p[1].join()}` + `uPlaneNormal = ${Object(s.u)(r)}, ` + `lambda=${e}`)
                } else
                    console.log(`vertex ${o}, e = ${l}, skipped, deom = ${u}, ` + `vDir = ${Object(s.u)(f)}, uPlaneNormal = ${Object(s.u)(r)}, ` + `uLowerClipBound=${t.join()}, uUpperClipBound=${n.join()}, ` + `chunkSize=${e}, uVertexBasePosition(v0)=${g(h[0]).join()}, ` + `uVertexBasePosition(v1)=${g(h[1]).join()}, ` + `uTranslation=${a.join()}`)
            }
        }
        setPlane(e, t, n) {
            const {gl: i} = e;
            i.uniform3fv(e.uniform("uPlaneNormal"), t),
            i.uniform1f(e.uniform("uPlaneDistance"), n);
            const r = u(t);
            i.uniform2iv(e.uniform("uVertexIndex"), this.data.vertexIndices.subarray(48 * r, 48 * (r + 1)))
        }
        setViewportPlane(e, t, n, i, r) {
            const a = Object(s.r)(l, t, i);
            s.t.normalize(a, a);
            const o = s.t.dot(s.t.transformMat4(c, n, r), a);
            this.setPlane(e, a, o)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(92)
      , s = n(66);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const a = 4;
    class o extends i.a {
        constructor(e, t=1) {
            super(),
            this.circlesPerInstance = t,
            this.squareCornersBuffer = Object(s.a)(e, -1, -1, 1, 1, t, 1),
            this.quadHelper = this.registerDisposer(new r.a(e,t))
        }
        defineShader(e, t) {
            e.addAttribute("highp vec2", "aCircleCornerOffset"),
            e.addUniform("highp vec3", "uCircleParams"),
            e.addVarying("highp vec4", "vCircleCoord"),
            e.addVertexCode("\nvoid emitCircle(vec4 position, float diameter, float borderWidth) {\n  gl_Position = position;\n  float totalDiameter = diameter + 2.0 * (borderWidth + uCircleParams.z);\n  gl_Position.xy += aCircleCornerOffset * uCircleParams.xy * gl_Position.w * totalDiameter;\n  vCircleCoord.xy = aCircleCornerOffset;\n  vCircleCoord.z = diameter / totalDiameter;\n  vCircleCoord.w = uCircleParams.z / totalDiameter;\n}\n"),
            t ? e.addFragmentCode("\nfloat getCircleAlphaMultiplier() {\n  return 1.0 - 2.0 * abs(0.5 - gl_FragCoord.z);\n}\n") : e.addFragmentCode("\nfloat getCircleAlphaMultiplier() {\n  return 1.0;\n}\n"),
            e.addFragmentCode("\nvec4 getCircleColor(vec4 interiorColor, vec4 borderColor) {\n  float radius = length(vCircleCoord.xy);\n  if (radius > 1.0) {\n    discard;\n  }\n\n  float borderColorFraction = clamp((radius - vCircleCoord.z) / vCircleCoord.w, 0.0, 1.0);\n  float feather = clamp((1.0 - radius) / vCircleCoord.w, 0.0, 1.0);\n  vec4 color = mix(interiorColor, borderColor, borderColorFraction);\n\n  return vec4(color.rgb, color.a * feather * getCircleAlphaMultiplier());\n}\n")
        }
        draw(e, t, n, i) {
            const {gl: r} = e
              , s = e.attribute("aCircleCornerOffset");
            this.squareCornersBuffer.bindToVertexAttrib(s, 2),
            r.uniform3f(e.uniform("uCircleParams"), 1 / t.width, 1 / t.height, Math.max(1e-6, n.featherWidthInPixels)),
            this.quadHelper.draw(r, i),
            e.gl.disableVertexAttribArray(s)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "b", (function() {
        return v
    }
    )),
    n.d(t, "a", (function() {
        return b
    }
    ));
    var i = n(4)
      , r = n(33)
      , s = n(38)
      , a = n(23)
      , o = n(2)
      , l = n(0)
      , c = n(15)
      , u = n(48)
      , d = n(3);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function h(e) {
        return "boolean" == typeof e ? {
            enabled: e
        } : (Object(l.w)(e),
        {
            enabled: Object(l.B)(e, "enabled", l.n)
        })
    }
    function p(e, t) {
        return "string" == typeof e ? {
            url: e,
            transform: t,
            enableDefaultSubsources: !0,
            subsources: new Map
        } : (Object(l.w)(e),
        {
            url: Object(l.y)(e, "url", l.E),
            transform: Object(l.y)(e, "transform", i.h) || t,
            enableDefaultSubsources: Object(l.B)(e, "enableDefaultSubsources", l.n, !0),
            subsources: Object(l.B)(e, "subsources", e=>Object(l.x)(e, h), new Map)
        })
    }
    function f(e) {
        return e.enabled
    }
    function m(e) {
        const {subsources: t} = e
          , n = Object(i.j)(e.transform);
        if (void 0 === n && void 0 === t)
            return e.url;
        const r = {};
        let s = !0;
        for (const [t,n] of e.subsources) {
            const e = f(n);
            void 0 !== e && (r[t] = e,
            s = !1)
        }
        return {
            url: e.url,
            transform: n,
            subsources: s ? void 0 : r,
            enableDefaultSubsources: !0 === e.enableDefaultSubsources && void 0
        }
    }
    class g {
        constructor(e, t, n, i, r) {
            let s;
            this.loadedDataSource = e,
            this.subsourceEntry = t,
            this.subsourceSpec = n,
            this.subsourceIndex = i,
            this.activated = void 0,
            this.messages = new u.a,
            this.isActiveChanged = new d.a,
            s = void 0 === n || void 0 === n.enabled ? t.default && r : n.enabled;
            const a = e.dataSource.modelTransform.sourceRank;
            let {modelSubspaceDimensionIndices: o} = t;
            if (void 0 === o) {
                o = new Array(a);
                for (let e = 0; e < a; ++e)
                    o[e] = e
            }
            const {subsourceToModelSubspaceTransform: l=c.c(Float32Array, o.length + 1)} = t;
            this.enabled = s,
            this.subsourceToModelSubspaceTransform = l,
            this.modelSubspaceDimensionIndices = o,
            this.isActiveChanged.add(e.activatedSubsourcesChanged.dispatch)
        }
        activate(e) {
            if (this.messages.clearMessages(),
            void 0 !== this.activated)
                return;
            e(this.activated = new o.a),
            this.isActiveChanged.dispatch()
        }
        deactivate(e) {
            this.messages.clearMessages(),
            this.messages.addMessage({
                severity: u.b.error,
                message: e
            });
            const {activated: t} = this;
            void 0 !== t && (this.activated = void 0,
            t.dispose(),
            this.isActiveChanged.dispatch())
        }
        addRenderLayer(e) {
            const t = this.activated;
            t.registerDisposer(this.loadedDataSource.layer.addRenderLayer(e)),
            t.registerDisposer(this.messages.addChild(e.messages))
        }
        getRenderLayerTransform(e) {
            const t = this.activated
              , {layer: n, transform: i} = this.loadedDataSource;
            return t.registerDisposer(Object(s.g)(n.manager.root.coordinateSpace, n.localPosition.coordinateSpace, i, this, e))
        }
    }
    class v extends o.a {
        constructor(e, t, n) {
            super(),
            this.layerDataSource = e,
            this.dataSource = t,
            this.error = void 0,
            this.enabledSubsourcesChanged = new d.a,
            this.activatedSubsourcesChanged = new d.a,
            this.messages = new u.a,
            t.canChangeModelSpaceRank ? (this.transform = new i.c(Object(i.A)(Object(i.z)({
                rank: 0,
                scales: new Float64Array(0),
                units: [],
                names: []
            })),!0),
            this.transform.value = t.modelTransform) : this.transform = new i.c(t.modelTransform),
            void 0 !== n.transform && (this.transform.spec = n.transform);
            const r = n.subsources;
            this.enableDefaultSubsources = n.enableDefaultSubsources,
            this.subsources = t.subsources.map((e,t)=>new g(this,e,r.get(e.id),t,this.enableDefaultSubsources))
        }
        get enabledSubsources() {
            return this.subsources.filter(e=>e.enabled)
        }
        get layer() {
            return this.layerDataSource.layer
        }
        disposed() {
            for (const e of this.subsources) {
                const {activated: t} = e;
                void 0 !== t && (e.activated = void 0,
                t.dispose())
            }
        }
    }
    class b extends o.a {
        constructor(e, t) {
            super(),
            this.layer = e,
            this.changed = new d.a,
            this.messages = new u.a,
            this.loadState_ = void 0,
            this.specGeneration = -1,
            this.refCounted_ = void 0,
            this.registerDisposer(this.changed.add(e.dataSourcesChanged.dispatch)),
            void 0 === t ? this.spec_ = Object(r.f)() : this.spec = t
        }
        get spec() {
            const {loadState: e} = this;
            if (void 0 !== e && void 0 === e.error) {
                const t = this.changed.count;
                t !== this.specGeneration && (this.specGeneration = t,
                this.spec_ = {
                    url: this.spec.url,
                    transform: e.transform.spec,
                    enableDefaultSubsources: e.enableDefaultSubsources,
                    subsources: new Map(Array.from(e.subsources, t=>{
                        const n = e.enableDefaultSubsources && t.subsourceEntry.default;
                        return [t.subsourceEntry.id, {
                            enabled: t.enabled !== n ? t.enabled : void 0
                        }]
                    }
                    ))
                })
            }
            return this.spec_
        }
        get loadState() {
            return this.loadState_
        }
        set spec(e) {
            const {layer: t} = this;
            if (this.messages.clearMessages(),
            0 === e.url.length) {
                if (1 !== t.dataSources.length) {
                    const e = t.dataSources.indexOf(this);
                    if (-1 !== e)
                        return t.dataSources.splice(e, 1),
                        t.dataSourcesChanged.dispatch(),
                        void this.dispose()
                }
                return this.spec_ = e,
                void (void 0 !== this.refCounted_ && (this.refCounted_.dispose(),
                this.refCounted_ = void 0,
                this.loadState_ = void 0,
                this.changed.dispatch()))
            }
            const n = new o.a
              , i = n.registerDisposer(Object(o.c)(t.markLoading()));
            void 0 !== this.refCounted_ && (this.refCounted_.dispose(),
            this.loadState_ = void 0),
            this.refCounted_ = n,
            this.spec_ = e;
            const r = t.manager.chunkManager
              , s = t.manager.dataSourceProviderRegistry
              , l = new a.b;
            this.messages.addMessage({
                severity: u.b.info,
                message: "Loading data source"
            }),
            s.get({
                chunkManager: r,
                url: e.url,
                cancellationToken: l,
                globalCoordinateSpace: t.manager.root.coordinateSpace,
                transform: e.transform
            }).then(r=>{
                if (n.wasDisposed)
                    return;
                this.messages.clearMessages();
                const s = n.registerDisposer(new v(this,r,e));
                s.registerDisposer(t.addCoordinateSpace(s.transform.outputSpace)),
                s.registerDisposer(s.transform.changed.add(this.changed.dispatch)),
                this.loadState_ = s,
                s.registerDisposer(s.enabledSubsourcesChanged.add(this.changed.dispatch)),
                this.changed.dispatch(),
                i()
            }
            ).catch(e=>{
                this.wasDisposed || (this.loadState_ = {
                    error: e
                },
                this.messages.clearMessages(),
                this.messages.addMessage({
                    severity: u.b.error,
                    message: e.message
                }),
                this.changed.dispatch())
            }
            ),
            n.registerDisposer(()=>{
                l.cancel()
            }
            ),
            this.changed.dispatch()
        }
        disposed() {
            const e = this.refCounted_;
            void 0 !== e && e.dispose()
        }
        toJSON() {
            const {loadState: e} = this;
            return void 0 === e || void 0 !== e.error ? m(this.spec) : m({
                url: this.spec.url,
                transform: e.transform.spec,
                enableDefaultSubsources: e.enableDefaultSubsources,
                subsources: new Map(Array.from(e.subsources, t=>{
                    const n = e.enableDefaultSubsources && t.subsourceEntry.default;
                    return [t.subsourceEntry.id, {
                        enabled: t.enabled !== n ? t.enabled : void 0
                    }]
                }
                ))
            })
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(2)
      , r = n(5);
    n(169);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends i.a {
        constructor(e, {min: t=0, max: n=1, step: i=.01}={}) {
            super(),
            this.value = e,
            this.element = document.createElement("label"),
            this.promptElement = document.createElement("span"),
            this.inputElement = document.createElement("input"),
            this.numericInputElement = document.createElement("input");
            let {element: r, promptElement: s, inputElement: a, numericInputElement: o} = this;
            r.className = "range-slider",
            s.className = "range-prompt";
            const l = e=>{
                e.min = "" + t,
                e.max = "" + n,
                e.step = "" + i,
                e.valueAsNumber = this.value.value;
                const r = ()=>{
                    this.value.value = e.valueAsNumber
                }
                ;
                this.registerEventListener(e, "change", r),
                this.registerEventListener(e, "input", r),
                this.registerEventListener(e, "wheel", t=>{
                    let {deltaY: n} = t;
                    n > 0 ? (e.stepUp(),
                    r()) : n < 0 && (e.stepDown(),
                    r())
                }
                )
            }
            ;
            a.type = "range",
            l(a),
            o.type = "number";
            const c = Math.max(t.toString().length, n.toString().length, Math.min(n, t + i).toString().length, Math.max(t, n - i).toString().length);
            o.style.width = c + 2 + "ch",
            l(o),
            r.appendChild(s),
            r.appendChild(a),
            r.appendChild(o),
            e.changed.add(()=>{
                this.inputElement.valueAsNumber = this.value.value,
                this.numericInputElement.valueAsNumber = this.value.value
            }
            )
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    ));
    var i = n(111)
      , r = n(23);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = "boss";
    function a(e, t, n, s, a=r.e) {
        return Object(i.a)(e, t, n, s, e=>{
            const t = new Headers(n.headers);
            return t.set("Authorization", `Bearer ${e}`),
            Object.assign(Object.assign({}, n), {
                headers: t
            })
        }
        , e=>{
            const {status: t} = e;
            if (403 === t || 401 === t)
                return "refresh";
            if (504 === t)
                return "retry";
            throw e
        }
        , a)
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var i = n(11);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let r = class extends i.b {
        constructor(e, t) {
            super(),
            this.provider = e,
            this.registerDisposer(e),
            this.initializeCounterpart(t)
        }
        get(e, t) {
            return this.provider.get(e, t)
        }
    }
    ;
    r = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }([Object(i.g)("CredentialsProvider")], r),
    Object(i.d)("CredentialsProvider.get", (function(e, t) {
        return this.get(e.providerId).get(e.invalidCredentials, t).then(e=>({
            value: e
        }))
    }
    ));
    var s = n(42);
    function a() {
        return function(e) {
            return class extends e {
                constructor(...e) {
                    super(...e);
                    const t = e[1];
                    this.credentialsProvider = t.credentialsProvider.addRef()
                }
                initializeCounterpart(e, t) {
                    t.credentialsProvider = /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                    function(e, t) {
                        const n = e.memoize.get({
                            type: "getSharedCredentialsProvider",
                            credentialsProvider: Object(s.a)(t)
                        }, ()=>new r(t.addRef(),e.rpc))
                          , i = n.addCounterpartRef();
                        return n.dispose(),
                        i
                    }(this.chunkManager, this.credentialsProvider),
                    super.initializeCounterpart(e, t)
                }
                static encodeOptions(e) {
                    const t = super.encodeOptions(e);
                    return t.credentialsProvider = Object(s.a)(e.credentialsProvider),
                    t
                }
            }
        }
    }
    n.d(t, "a", (function() {
        return a
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return l
    }
    ));
    var i = n(6)
      , r = n(1)
      , s = n(43);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class a {
        constructor() {
            this.globalPosition = s.b,
            this.width = 0,
            this.height = 0,
            this.projectionMat = r.l.create(),
            this.viewMatrix = r.l.create(),
            this.invViewMatrix = r.l.create(),
            this.viewProjectionMat = r.l.create(),
            this.invViewProjectionMat = r.l.create()
        }
    }
    function o(e, t) {
        return e.displayDimensionRenderInfo === t.displayDimensionRenderInfo && e.width === t.width && e.height === t.height && Object(i.a)(e.globalPosition, t.globalPosition) && Object(i.a)(e.projectionMat, t.projectionMat) && Object(i.a)(e.viewMatrix, t.viewMatrix)
    }
    function l(e) {
        const {viewMatrix: t, viewProjectionMat: n} = e;
        r.l.invert(t, e.invViewMatrix),
        r.l.multiply(n, e.projectionMat, t),
        r.l.invert(e.invViewProjectionMat, n)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "d", (function() {
        return h
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "b", (function() {
        return b
    }
    ));
    var i = n(7)
      , r = n(2)
      , s = n(0)
      , a = n(37)
      , o = n(46)
      , l = n(90);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const c = [1.5, 2, 3, 5, 7.5, 10]
      , u = [{
        unit: "km",
        lengthInNanometers: 1e12
    }, {
        unit: "m",
        lengthInNanometers: 1e9
    }, {
        unit: "mm",
        lengthInNanometers: 1e6
    }, {
        unit: "m",
        lengthInNanometers: 1e3
    }, {
        unit: "nm",
        lengthInNanometers: 1
    }, {
        unit: "pm",
        lengthInNanometers: .001
    }];
    function d(e) {
        const t = u.length;
        let n = u[t - 1];
        for (let i = 0; i < t; ++i) {
            const t = u[i];
            if (e >= t.lengthInNanometers) {
                n = t;
                break
            }
        }
        return n
    }
    function h(e) {
        const t = u.length;
        let n = u[t - 1];
        for (let i = 0; i < t; ++i) {
            const t = u[i];
            if (e >= Math.pow(t.lengthInNanometers, 3)) {
                n = t;
                break
            }
        }
        return n
    }
    class p {
        constructor() {
            this.allowedSignificands = c,
            this.targetLengthInPixels = 0,
            this.physicalSizePerPixel = 0,
            this.prevPhysicalSizePerPixel = 0,
            this.prevTargetLengthInPixels = 0,
            this.prevPhysicalUnit = "\0"
        }
        update() {
            let {physicalSizePerPixel: e, targetLengthInPixels: t} = this;
            if (this.prevPhysicalSizePerPixel === e && this.prevTargetLengthInPixels === t && this.prevPhysicalUnit === this.physicalUnit)
                return !1;
            this.prevPhysicalSizePerPixel = e,
            this.prevTargetLengthInPixels = t,
            this.prevPhysicalUnit = this.physicalUnit;
            const n = t * e
              , i = Math.floor(Math.log10(n))
              , r = 10 ** i
              , s = n / r;
            let o = 1;
            for (let e of this.allowedSignificands) {
                if (!(Math.abs(e - s) < Math.abs(o - s)))
                    break;
                o = e
            }
            const l = o * r
              , c = Object(a.d)(l);
            return this.lengthInPixels = Math.round(l / e),
            this.physicalUnit = `${c.prefix}${this.physicalBaseUnit}`,
            this.physicalLength = o * 10 ** (i - c.exponent),
            !0
        }
    }
    class f extends r.a {
        constructor(e, t=new p) {
            super(),
            this.gl = e,
            this.dimensions = t,
            this.texture = null,
            this.width = 0,
            this.height = 0,
            this.label = "",
            this.factor = 1,
            this.priorOptions = void 0,
            this.prevLabel = ""
        }
        update(e) {
            const {dimensions: t, label: n} = this;
            let {texture: i} = this;
            if (!t.update() && null !== i && e === this.priorOptions && n == this.prevLabel)
                return;
            null === i && (i = this.texture = this.gl.createTexture());
            const {width: r, height: s} = function(e, t, n, i, r) {
                const s = document.createElement("canvas")
                  , a = s.getContext("2d")
                  , o = r.textHeightInPixels * r.scaleFactor
                  , c = `bold ${o}px ${r.fontName}`;
                a.font = c,
                a.fillStyle = "white";
                const u = `${i}${e.physicalLength} ${e.physicalUnit}`
                  , d = a.measureText(u)
                  , h = Math.max(e.lengthInPixels, d.width)
                  , p = r.barHeightInPixels * r.scaleFactor
                  , f = r.barTopMarginInPixels * r.scaleFactor
                  , m = p + f + o
                  , g = r.paddingInPixels * r.scaleFactor
                  , v = m + 2 * g
                  , b = h + 2 * g;
                return s.width = b,
                s.height = v,
                a.font = c,
                a.textAlign = "center",
                a.fillStyle = "rgba(0, 0, 0, 0.3)",
                a.fillRect(0, 0, b, v),
                a.fillStyle = "white",
                a.fillText(u, b / 2, v - g - p - f),
                a.fillRect(g, v - g - p, e.lengthInPixels, p),
                Object(l.d)(t, n, s),
                {
                    width: b,
                    height: v
                }
            }(t, this.gl, i, n, e);
            this.priorOptions = e,
            this.prevLabel = n,
            this.width = r,
            this.height = s
        }
        disposed() {
            this.gl.deleteTexture(this.texture),
            this.texture = null,
            super.disposed()
        }
    }
    class m extends r.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.scaleBarCopyHelper = this.registerDisposer(o.c.get(this.gl)),
            this.scaleBars = [];
            for (let t = 0; t < 3; ++t)
                this.scaleBars.push(this.registerDisposer(new f(e)))
        }
        draw(e, t, n, i, r) {
            const {scaleBars: s} = this
              , {displayRank: a, displayDimensionIndices: o, canonicalVoxelFactors: l, globalDimensionNames: c, displayDimensionUnits: u, displayDimensionScales: d} = t
              , {factors: h} = n
              , p = Math.min(r.maxWidthFraction * e, r.maxWidthInPixels * r.scaleFactor);
            let f = 0;
            for (let e = 0; e < a; ++e) {
                const t = o[e]
                  , n = u[e]
                  , r = h[t];
                let a, m, g;
                for (a = 0; a < f && (m = s[a],
                g = m.dimensions,
                g.physicalBaseUnit !== n || m.factor !== r); ++a)
                    ;
                a === f && (++f,
                m = s[a],
                m.label = "",
                g = m.dimensions,
                m.factor = r,
                g.physicalBaseUnit = n,
                g.targetLengthInPixels = p,
                g.physicalSizePerPixel = d[e] * i / l[e]),
                m.label += `${c[t]} `
            }
            const {gl: m, scaleBarCopyHelper: g} = this;
            let v = r.bottomPixelOffset * r.scaleFactor;
            for (let e = f - 1; e >= 0; --e) {
                const t = s[e];
                1 === f ? t.label = "" : t.label += ": ",
                t.update(r),
                m.viewport(r.leftPixelOffset * r.scaleFactor, v, t.width, t.height),
                g.draw(t.texture),
                v += t.height + r.marginPixelsBetweenScaleBars * r.scaleFactor
            }
        }
    }
    const g = Object.assign(Object.assign({}, {
        scaleFactor: 1,
        textHeightInPixels: 15,
        barHeightInPixels: 8,
        barTopMarginInPixels: 5,
        fontName: "sans-serif",
        paddingInPixels: 2
    }), {
        maxWidthInPixels: 100,
        maxWidthFraction: .25,
        leftPixelOffset: 10,
        bottomPixelOffset: 10,
        marginPixelsBetweenScaleBars: 5
    });
    function v(e) {
        const t = Object.assign({}, g);
        for (const n of ["textHeightInPixels", "barTopMarginInPixels", "barHeightInPixels", "paddingInPixels", "scaleFactor", "maxWidthInPixels", "maxWidthFraction", "leftPixelOffset", "bottomPixelOffset"])
            Object(s.y)(e, n, e=>{
                void 0 !== e && (t[n] = Object(s.s)(e))
            }
            );
        return Object(s.y)(e, "fontName", e=>{
            void 0 !== e && (t.fontName = Object(s.E)(e))
        }
        ),
        t
    }
    class b extends i.c {
        constructor() {
            super(g, v)
        }
    }
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        var n = function() {
            if ("undefined" != typeof Map)
                return Map;
            function e(e, t) {
                var n = -1;
                return e.some((function(e, i) {
                    return e[0] === t && (n = i,
                    !0)
                }
                )),
                n
            }
            return (function() {
                function t() {
                    this.__entries__ = []
                }
                return Object.defineProperty(t.prototype, "size", {
                    get: function() {
                        return this.__entries__.length
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                t.prototype.get = function(t) {
                    var n = e(this.__entries__, t)
                      , i = this.__entries__[n];
                    return i && i[1]
                }
                ,
                t.prototype.set = function(t, n) {
                    var i = e(this.__entries__, t);
                    ~i ? this.__entries__[i][1] = n : this.__entries__.push([t, n])
                }
                ,
                t.prototype.delete = function(t) {
                    var n = this.__entries__
                      , i = e(n, t);
                    ~i && n.splice(i, 1)
                }
                ,
                t.prototype.has = function(t) {
                    return !!~e(this.__entries__, t)
                }
                ,
                t.prototype.clear = function() {
                    this.__entries__.splice(0)
                }
                ,
                t.prototype.forEach = function(e, t) {
                    void 0 === t && (t = null);
                    for (var n = 0, i = this.__entries__; n < i.length; n++) {
                        var r = i[n];
                        e.call(t, r[1], r[0])
                    }
                }
                ,
                t
            }())
        }()
          , i = "undefined" != typeof window && "undefined" != typeof document && window.document === document
          , r = void 0 !== e && e.Math === Math ? e : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")()
          , s = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(r) : function(e) {
            return setTimeout((function() {
                return e(Date.now())
            }
            ), 1e3 / 60)
        }
        ;
        var a = ["top", "right", "bottom", "left", "width", "height", "size", "weight"]
          , o = "undefined" != typeof MutationObserver
          , l = function() {
            function e() {
                this.connected_ = !1,
                this.mutationEventsAdded_ = !1,
                this.mutationsObserver_ = null,
                this.observers_ = [],
                this.onTransitionEnd_ = this.onTransitionEnd_.bind(this),
                this.refresh = function(e, t) {
                    var n = !1
                      , i = !1
                      , r = 0;
                    function a() {
                        n && (n = !1,
                        e()),
                        i && l()
                    }
                    function o() {
                        s(a)
                    }
                    function l() {
                        var e = Date.now();
                        if (n) {
                            if (e - r < 2)
                                return;
                            i = !0
                        } else
                            n = !0,
                            i = !1,
                            setTimeout(o, t);
                        r = e
                    }
                    return l
                }(this.refresh.bind(this), 20)
            }
            return e.prototype.addObserver = function(e) {
                ~this.observers_.indexOf(e) || this.observers_.push(e),
                this.connected_ || this.connect_()
            }
            ,
            e.prototype.removeObserver = function(e) {
                var t = this.observers_
                  , n = t.indexOf(e);
                ~n && t.splice(n, 1),
                !t.length && this.connected_ && this.disconnect_()
            }
            ,
            e.prototype.refresh = function() {
                this.updateObservers_() && this.refresh()
            }
            ,
            e.prototype.updateObservers_ = function() {
                var e = this.observers_.filter((function(e) {
                    return e.gatherActive(),
                    e.hasActive()
                }
                ));
                return e.forEach((function(e) {
                    return e.broadcastActive()
                }
                )),
                e.length > 0
            }
            ,
            e.prototype.connect_ = function() {
                i && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_),
                window.addEventListener("resize", this.refresh),
                o ? (this.mutationsObserver_ = new MutationObserver(this.refresh),
                this.mutationsObserver_.observe(document, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                })) : (document.addEventListener("DOMSubtreeModified", this.refresh),
                this.mutationEventsAdded_ = !0),
                this.connected_ = !0)
            }
            ,
            e.prototype.disconnect_ = function() {
                i && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_),
                window.removeEventListener("resize", this.refresh),
                this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
                this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh),
                this.mutationsObserver_ = null,
                this.mutationEventsAdded_ = !1,
                this.connected_ = !1)
            }
            ,
            e.prototype.onTransitionEnd_ = function(e) {
                var t = e.propertyName
                  , n = void 0 === t ? "" : t;
                a.some((function(e) {
                    return !!~n.indexOf(e)
                }
                )) && this.refresh()
            }
            ,
            e.getInstance = function() {
                return this.instance_ || (this.instance_ = new e),
                this.instance_
            }
            ,
            e.instance_ = null,
            e
        }()
          , c = function(e, t) {
            for (var n = 0, i = Object.keys(t); n < i.length; n++) {
                var r = i[n];
                Object.defineProperty(e, r, {
                    value: t[r],
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                })
            }
            return e
        }
          , u = function(e) {
            return e && e.ownerDocument && e.ownerDocument.defaultView || r
        }
          , d = v(0, 0, 0, 0);
        function h(e) {
            return parseFloat(e) || 0
        }
        function p(e) {
            for (var t = [], n = 1; n < arguments.length; n++)
                t[n - 1] = arguments[n];
            return t.reduce((function(t, n) {
                return t + h(e["border-" + n + "-width"])
            }
            ), 0)
        }
        function f(e) {
            var t = e.clientWidth
              , n = e.clientHeight;
            if (!t && !n)
                return d;
            var i = u(e).getComputedStyle(e)
              , r = function(e) {
                for (var t = {}, n = 0, i = ["top", "right", "bottom", "left"]; n < i.length; n++) {
                    var r = i[n]
                      , s = e["padding-" + r];
                    t[r] = h(s)
                }
                return t
            }(i)
              , s = r.left + r.right
              , a = r.top + r.bottom
              , o = h(i.width)
              , l = h(i.height);
            if ("border-box" === i.boxSizing && (Math.round(o + s) !== t && (o -= p(i, "left", "right") + s),
            Math.round(l + a) !== n && (l -= p(i, "top", "bottom") + a)),
            !function(e) {
                return e === u(e).document.documentElement
            }(e)) {
                var c = Math.round(o + s) - t
                  , f = Math.round(l + a) - n;
                1 !== Math.abs(c) && (o -= c),
                1 !== Math.abs(f) && (l -= f)
            }
            return v(r.left, r.top, o, l)
        }
        var m = "undefined" != typeof SVGGraphicsElement ? function(e) {
            return e instanceof u(e).SVGGraphicsElement
        }
        : function(e) {
            return e instanceof u(e).SVGElement && "function" == typeof e.getBBox
        }
        ;
        function g(e) {
            return i ? m(e) ? function(e) {
                var t = e.getBBox();
                return v(0, 0, t.width, t.height)
            }(e) : f(e) : d
        }
        function v(e, t, n, i) {
            return {
                x: e,
                y: t,
                width: n,
                height: i
            }
        }
        var b = function() {
            function e(e) {
                this.broadcastWidth = 0,
                this.broadcastHeight = 0,
                this.contentRect_ = v(0, 0, 0, 0),
                this.target = e
            }
            return e.prototype.isActive = function() {
                var e = g(this.target);
                return this.contentRect_ = e,
                e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
            }
            ,
            e.prototype.broadcastRect = function() {
                var e = this.contentRect_;
                return this.broadcastWidth = e.width,
                this.broadcastHeight = e.height,
                e
            }
            ,
            e
        }()
          , y = function(e, t) {
            var n, i, r, s, a, o, l, u = (i = (n = t).x,
            r = n.y,
            s = n.width,
            a = n.height,
            o = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object,
            l = Object.create(o.prototype),
            c(l, {
                x: i,
                y: r,
                width: s,
                height: a,
                top: r,
                right: i + s,
                bottom: a + r,
                left: i
            }),
            l);
            c(this, {
                target: e,
                contentRect: u
            })
        }
          , S = function() {
            function e(e, t, i) {
                if (this.activeObservations_ = [],
                this.observations_ = new n,
                "function" != typeof e)
                    throw new TypeError("The callback provided as parameter 1 is not a function.");
                this.callback_ = e,
                this.controller_ = t,
                this.callbackCtx_ = i
            }
            return e.prototype.observe = function(e) {
                if (!arguments.length)
                    throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(e instanceof u(e).Element))
                        throw new TypeError('parameter 1 is not of type "Element".');
                    var t = this.observations_;
                    t.has(e) || (t.set(e, new b(e)),
                    this.controller_.addObserver(this),
                    this.controller_.refresh())
                }
            }
            ,
            e.prototype.unobserve = function(e) {
                if (!arguments.length)
                    throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(e instanceof u(e).Element))
                        throw new TypeError('parameter 1 is not of type "Element".');
                    var t = this.observations_;
                    t.has(e) && (t.delete(e),
                    t.size || this.controller_.removeObserver(this))
                }
            }
            ,
            e.prototype.disconnect = function() {
                this.clearActive(),
                this.observations_.clear(),
                this.controller_.removeObserver(this)
            }
            ,
            e.prototype.gatherActive = function() {
                var e = this;
                this.clearActive(),
                this.observations_.forEach((function(t) {
                    t.isActive() && e.activeObservations_.push(t)
                }
                ))
            }
            ,
            e.prototype.broadcastActive = function() {
                if (this.hasActive()) {
                    var e = this.callbackCtx_
                      , t = this.activeObservations_.map((function(e) {
                        return new y(e.target,e.broadcastRect())
                    }
                    ));
                    this.callback_.call(e, t, e),
                    this.clearActive()
                }
            }
            ,
            e.prototype.clearActive = function() {
                this.activeObservations_.splice(0)
            }
            ,
            e.prototype.hasActive = function() {
                return this.activeObservations_.length > 0
            }
            ,
            e
        }()
          , w = "undefined" != typeof WeakMap ? new WeakMap : new n
          , x = function e(t) {
            if (!(this instanceof e))
                throw new TypeError("Cannot call a class as a function.");
            if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
            var n = l.getInstance()
              , i = new S(t,n,this);
            w.set(this, i)
        };
        ["observe", "unobserve", "disconnect"].forEach((function(e) {
            x.prototype[e] = function() {
                var t;
                return (t = w.get(this))[e].apply(t, arguments)
            }
        }
        ));
        var C = void 0 !== r.ResizeObserver ? r.ResizeObserver : x;
        t.a = C
    }
    ).call(this, n(128))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var i = n(36);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function r(e={}) {
        return Object(i.a)(Object.assign({
            text: "?"
        }, e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i = n(136)
      , r = n.n(i)
      , s = n(36);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function a(e={}) {
        return Object(s.a)(Object.assign({
            svg: r.a
        }, e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    n(171),
    n(172),
    n(130),
    n(131);
    var i = n(57)
      , r = n.n(i)
      , s = n(16)
      , a = n.n(s)
      , o = n(2)
      , l = n(5);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    n(173)(r.a);
    class c extends o.a {
        constructor(e) {
            super(),
            this.state = e,
            this.changingValue = !1,
            this.debouncedValueUpdater = a()(()=>{
                this.changingValue = !0;
                try {
                    this.state.fragmentMain.value = this.textEditor.getValue()
                } finally {
                    this.changingValue = !1
                }
            }
            , 500),
            this.textEditor = r()(e=>{}
            , {
                value: this.state.fragmentMain.value,
                mode: "glsl",
                gutters: ["CodeMirror-lint-markers"]
            }),
            this.textEditor.on("change", ()=>{
                this.setValidState(void 0),
                this.debouncedValueUpdater()
            }
            ),
            this.registerDisposer(this.state.fragmentMain.changed.add(()=>{
                this.changingValue || this.textEditor.setValue(this.state.fragmentMain.value)
            }
            )),
            this.element.classList.add("neuroglancer-shader-code-widget"),
            this.registerDisposer(this.state.shaderError.changed.add(()=>{
                this.updateErrorState()
            }
            ));
            const {shaderControlState: t} = this.state;
            void 0 !== t && this.registerDisposer(t.parseErrors.changed.add(()=>{
                this.updateErrorState()
            }
            )),
            this.updateErrorState();
            const n = new IntersectionObserver(e=>{
                e.some(e=>e.isIntersecting) && this.textEditor.refresh()
            }
            ,{
                root: document.body
            });
            n.observe(this.element),
            this.registerDisposer(()=>n.disconnect())
        }
        get element() {
            return this.textEditor.getWrapperElement()
        }
        updateErrorState() {
            const {sourceStringNumber: e=1} = this.state
              , t = this.state.shaderError.value;
            let n;
            const {shaderControlState: i} = this.state;
            n = void 0 !== i ? i.parseErrors.value : [],
            void 0 === t && 0 === n.length ? this.setValidState(void 0) : null != t || 0 !== n.length ? (this.textEditor.setOption("lint", {
                getAnnotations: ()=>{
                    const i = [];
                    for (const e of n)
                        i.push({
                            message: e.message,
                            severity: "error",
                            from: r.a.Pos(e.line)
                        });
                    if (null != t)
                        if ("ShaderCompilationError" === t.name)
                            for (const n of t.errorMessages)
                                i.push({
                                    message: n.message,
                                    severity: "error",
                                    from: r.a.Pos(n.file === e && n.line || 0)
                                });
                        else
                            "ShaderLinkError" === t.name ? i.push({
                                message: t.log,
                                severity: "error",
                                from: r.a.Pos(0)
                            }) : i.push({
                                message: t.message,
                                severity: "error",
                                from: r.a.Pos(0)
                            });
                    return i
                }
            }),
            this.setValidState(!1)) : (this.textEditor.setOption("lint", void 0),
            this.setValidState(!0))
        }
        setValidState(e) {
            let {element: t} = this;
            t.classList.remove("invalid-input"),
            t.classList.remove("valid-input"),
            !0 === e ? t.classList.add("valid-input") : !1 === e && t.classList.add("invalid-input")
        }
        disposed() {
            this.debouncedValueUpdater.flush(),
            this.debouncedValueUpdater = void 0,
            Object(l.c)(this.element),
            this.textEditor = void 0,
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var i = n(16)
      , r = n.n(i)
      , s = n(2)
      , a = n(5)
      , o = n(113)
      , l = n(72);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class c extends s.a {
        constructor(e) {
            super(),
            this.state = e,
            this.element = document.createElement("div"),
            this.controlDisposer = void 0;
            const {controls: t} = e;
            this.registerDisposer(t.changed.add(this.registerCancellable(r()(()=>this.updateControls(), 0)))),
            this.updateControls()
        }
        updateControls() {
            void 0 !== this.controlDisposer && (this.controlDisposer.dispose(),
            Object(a.b)(this.element));
            const e = this.controlDisposer = new s.a;
            for (const [t,n] of this.state.state) {
                const {control: i} = n;
                switch (i.type) {
                case "slider":
                    {
                        const r = e.registerDisposer(new l.a(n.trackable,{
                            min: i.min,
                            max: i.max,
                            step: i.step
                        }));
                        r.promptElement.textContent = t,
                        this.element.appendChild(r.element);
                        break
                    }
                case "color":
                    {
                        const i = document.createElement("label");
                        i.textContent = t;
                        const r = e.registerDisposer(new o.a(n.trackable));
                        this.element.appendChild(i),
                        i.appendChild(r.element);
                        break
                    }
                }
            }
        }
        disposed() {
            const {controlDisposer: e} = this;
            void 0 !== e && e.dispose(),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n(166);
    var i = n(8)
      , r = n(105)
      , s = n(54)
      , a = n(47)
      , o = n(69)
      , l = n(6);
    var c = n(25)
      , u = n(70)
      , d = n(55)
      , h = n(24);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const p = Float32Array.from([0, 0, 0, 0, 0, 1, 9, 1, 0, 0, 1, 0, 1, 10, 0, 1, 0, 0, 1, 1, 11, 1, 1, 0, 1, 1, 1, 12, 0, 0, 0, 0, 1, 0, 13, 0, 0, 1, 0, 1, 1, 14, 1, 0, 0, 1, 1, 0, 15, 1, 0, 1, 1, 1, 1, 16, 0, 0, 0, 1, 0, 0, 17, 0, 0, 1, 1, 0, 1, 18, 0, 1, 0, 1, 1, 0, 19, 0, 1, 1, 1, 1, 1, 20]);
    class f extends a.a {
        defineShader(e) {
            const {rank: t} = this;
            Object(h.a)(e, "float", WebGL2RenderingContext.FLOAT, !1, "Bounds", t, 2)
        }
        enable(e, t, n) {
            super.enable(e, t, e=>{
                const i = e.vertexShaderInputBinders.Bounds;
                i.enable(1),
                this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer),
                i.bind(this.serializedBytesPerAnnotation, t.bufferOffset),
                n(e),
                i.disable()
            }
            )
        }
    }
    function m(e) {
        e.addVertexCode("\nvoid setBoundingBoxBorderWidth(float width) {}\nvoid setBoundingBoxBorderColor(vec4 color) {}\n")
    }
    function g(e) {
        e.addVertexCode("\nvoid setBoundingBoxFillColor(vec4 color) {}\n")
    }
    function v(e) {
        g(e),
        e.addVertexCode("\nfloat ng_lineWidth;\nvoid setBoundingBoxBorderWidth(float size) {\n  ng_lineWidth = size;\n}\nvoid setBoundingBoxBorderColor(vec4 color) {\n  vColor = color;\n}\n")
    }
    Object(a.c)(i.e.AXIS_ALIGNED_BOUNDING_BOX, {
        sliceViewRenderHelper: class extends f {
            constructor() {
                super(...arguments),
                this.lineShader = new d.a(this.gl,6),
                this.intersectionVertexIndexBuffer = Object(c.b)(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, o.c).value,
                this.filledIntersectionVertexIndexBuffer = Object(c.b)(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, o.b).value,
                this.boundingBoxCrossSectionHelper = this.registerDisposer(new o.a(this.gl)),
                this.faceShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/face", e=>{
                    const {rank: t} = this;
                    super.defineShader(e),
                    this.boundingBoxCrossSectionHelper.defineShader(e),
                    this.lineShader.defineShader(e),
                    e.addAttribute("highp float", "aVertexIndexFloat"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    v(e),
                    e.setVertexMain(`\nfloat modelPositionA[${t}] = getBounds0();\nfloat modelPositionB[${t}] = getBounds1();\nfor (int i = 0; i < ${t}; ++i) {\n  float a = modelPositionA[i];\n  float b = modelPositionB[i];\n  modelPositionA[i] = min(a, b);\n  modelPositionB[i] = max(a, b);\n}\nvClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);\nif (vClipCoefficient == 0.0) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nvec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA);\nvec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB);\nint vertexIndex1 = int(aVertexIndexFloat);\nint vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;\nvec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex1);\nvec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex2);\nng_lineWidth = 2.0;\n${this.invokeUserMain}\nemitLine(uModelViewProjection * vec4(vertexPosition1, 1.0),\n         uModelViewProjection * vec4(vertexPosition2, 1.0),\n         ng_lineWidth);\n${this.setPartIndex(e)};\n`),
                    e.setFragmentMain("\nemitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() * vClipCoefficient));\n")
                }
                ),
                this.fillShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/fill", e=>{
                    const {rank: t} = this;
                    super.defineShader(e),
                    this.boundingBoxCrossSectionHelper.defineShader(e),
                    e.addAttribute("highp float", "aVertexIndexFloat"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    function(e) {
                        m(e),
                        e.addVertexCode("\nvoid setBoundingBoxFillColor(vec4 color) {\n  vColor = color;\n}\n")
                    }(e),
                    e.setVertexMain(`\nfloat modelPositionA[${t}] = getBounds0();\nfloat modelPositionB[${t}] = getBounds1();\nfor (int i = 0; i < ${t}; ++i) {\n  float a = modelPositionA[i];\n  float b = modelPositionB[i];\n  modelPositionA[i] = min(a, b);\n  modelPositionB[i] = max(a, b);\n}\nvClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);\nif (vClipCoefficient == 0.0) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nvec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA);\nvec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB);\nint vertexIndex = int(aVertexIndexFloat);\nvec3 vertexPosition = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex);\ngl_Position = uModelViewProjection * vec4(vertexPosition, 1);\n${this.invokeUserMain}\n${this.setPartIndex(e)};\n`),
                    e.setFragmentMain("\nemitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));\n")
                }
                )
            }
            enableForBoundingBox(e, t, n, i) {
                super.enable(e, t, e=>{
                    const r = t.renderContext.sliceView.projectionParameters.value;
                    this.boundingBoxCrossSectionHelper.setViewportPlane(e, r.viewportNormalInGlobalCoordinates, r.centerDataPosition, t.renderSubspaceModelMatrix, t.renderSubspaceInvModelMatrix);
                    const s = e.attribute("aVertexIndexFloat");
                    n.bindToVertexAttrib(s, 1, WebGL2RenderingContext.FLOAT, !1),
                    i(e),
                    this.gl.disableVertexAttribArray(s)
                }
                )
            }
            draw(e) {
                this.shaderControlState.parseResult.value.code.match(/\bsetBoundingBoxFillColor\b/) && this.enableForBoundingBox(this.fillShaderGetter, e, this.filledIntersectionVertexIndexBuffer, ()=>{
                    this.gl.drawArraysInstanced(WebGL2RenderingContext.TRIANGLE_FAN, 0, 6, e.count)
                }
                ),
                this.enableForBoundingBox(this.faceShaderGetter, e, this.intersectionVertexIndexBuffer, t=>{
                    this.lineShader.enableAndDraw(t, e.renderContext.projectionParameters, 1, e.count)
                }
                )
            }
        }
        ,
        perspectiveViewRenderHelper: class extends f {
            constructor() {
                super(...arguments),
                this.lineShader = this.registerDisposer(new d.a(this.gl,12)),
                this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(c.a.fromData(this.gl, Object(l.j)(p, 7, 1, d.b))),
                this.edgeShaderGetter = this.getDependentShader("annotation/boundingBox/projection/border", e=>{
                    const {rank: t} = this;
                    this.defineShader(e),
                    this.lineShader.defineShader(e),
                    e.addAttribute("highp vec3", "aBoxCornerOffset1"),
                    e.addAttribute("highp vec4", "aBoxCornerOffset2"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    v(e),
                    e.setVertexMain(`\nfloat modelPositionA[${t}] = getBounds0();\nfloat modelPositionB[${t}] = getBounds1();\nvec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA);\nvec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB);\nvec3 endpointA = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset1);\nvec3 endpointB = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset2.xyz);\nvClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);\nif (vClipCoefficient == 0.0) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nng_lineWidth = 2.0;\n${this.invokeUserMain}\nemitLine(uModelViewProjection * vec4(endpointA, 1.0),\n         uModelViewProjection * vec4(endpointB, 1.0),\n         ng_lineWidth);\n${this.setPartIndex(e, "uint(aBoxCornerOffset2.w)")};\n`),
                    e.setFragmentMain("\nemitAnnotation(vec4(vColor.rgb, getLineAlpha() * vClipCoefficient));\n")
                }
                ),
                this.circleShader = this.registerDisposer(new u.a(this.gl,8)),
                this.boxCornerOffsetsBuffer = this.registerDisposer(c.a.fromData(this.gl, Object(l.j)(o.d, 3, 1, u.b))),
                this.cornerShaderGetter = this.getDependentShader("annotation/boundingBox/projection/corner", e=>{
                    const {rank: t} = this;
                    this.defineShader(e),
                    this.circleShader.defineShader(e, this.targetIsSliceView),
                    e.addAttribute("highp vec3", "aBoxCornerOffset"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    v(e),
                    e.setVertexMain(`\nfloat modelPositionA[${t}] = getBounds0();\nfloat modelPositionB[${t}] = getBounds1();\nvClipCoefficient = getMaxEndpointSubspaceClipCoefficient(modelPositionA, modelPositionB);\nif (vClipCoefficient == 0.0) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nvec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA);\nvec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB);\nvec3 vertexPosition = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset);\nemitCircle(uModelViewProjection * vec4(vertexPosition, 1.0), ng_lineWidth, 0.0);\nuint cornerIndex = uint(aBoxCornerOffset.x + aBoxCornerOffset.y * 2.0 + aBoxCornerOffset.z * 4.0);\nuint cornerPickOffset = 1u + cornerIndex;\n${this.setPartIndex(e, "cornerPickOffset")};\n`),
                    e.setFragmentMain("\nvec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 color = getCircleColor(vColor, borderColor);\ncolor.a *= vClipCoefficient;\nemitAnnotation(color);\n")
                }
                )
            }
            drawEdges(e) {
                const {gl: t} = this;
                this.enable(this.edgeShaderGetter, e, n=>{
                    const i = n.attribute("aBoxCornerOffset1")
                      , r = n.attribute("aBoxCornerOffset2");
                    this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(i, 3, WebGL2RenderingContext.FLOAT, !1, 28, 0),
                    this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(r, 4, WebGL2RenderingContext.FLOAT, !1, 28, 12),
                    this.lineShader.enableAndDraw(n, e.renderContext.projectionParameters, 1, e.count),
                    t.disableVertexAttribArray(i),
                    t.disableVertexAttribArray(r)
                }
                )
            }
            drawCorners(e) {
                const {gl: t} = this;
                this.enable(this.cornerShaderGetter, e, n=>{
                    const i = n.attribute("aBoxCornerOffset");
                    this.boxCornerOffsetsBuffer.bindToVertexAttrib(i, 3, WebGL2RenderingContext.FLOAT, !1),
                    this.circleShader.draw(n, e.renderContext.projectionParameters, {
                        featherWidthInPixels: 0
                    }, e.count),
                    t.disableVertexAttribArray(i)
                }
                )
            }
            draw(e) {
                this.drawEdges(e),
                this.drawCorners(e)
            }
        }
        ,
        defineShaderNoOpSetters(e) {
            g(e),
            m(e)
        },
        pickIdsPerInstance: 27,
        snapPosition(e, t, n, i) {
            const r = new Float32Array(t,n,6);
            i >= 1 && i < 9 && function(e, t) {
                const n = e.length;
                for (let i = 0; i < n; ++i) {
                    const r = t[i]
                      , s = t[i + n]
                      , a = e[i];
                    e[i] = Math.abs(r - a) < Math.abs(s - a) ? r : s
                }
            }(e, r)
        },
        getRepresentativePoint(e, t, n) {
            e.set(t.pointA)
        },
        updateViaRepresentativePoint(e, t, n) {
            const i = t.length
              , {pointA: r, pointB: s} = e
              , a = new Float32Array(i)
              , o = new Float32Array(i);
            for (let e = 0; e < i; ++e) {
                const n = a[e] = t[e];
                o[e] = s[e] + (n - r[e])
            }
            return Object.assign(Object.assign({}, e), {
                pointA: a,
                pointB: o
            })
        }
    });
    var b = n(1);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function y() {
        return Object(l.j)(new Uint8Array([0, 1]), 1, 1, u.b)
    }
    function S(e) {
        e.addVertexCode("\nvoid setEndpointMarkerSize(float startSize, float endSize) {}\nvoid setEndpointMarkerBorderWidth(float startSize, float endSize) {}\nvoid setEndpointMarkerColor(vec4 startColor, vec4 endColor) {}\nvoid setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}\n")
    }
    function w(e) {
        e.addVertexCode("\nvoid setLineWidth(float width) {}\nvoid setLineColor(vec4 startColor, vec4 endColor) {}\n")
    }
    class x extends a.a {
        constructor() {
            super(...arguments),
            this.lineShader = this.registerDisposer(new d.a(this.gl,1)),
            this.circleShader = this.registerDisposer(new u.a(this.gl,2)),
            this.edgeShaderGetter = this.getDependentShader("annotation/line/edge", e=>{
                const {rank: t} = this;
                this.defineShader(e),
                this.lineShader.defineShader(e),
                e.addVarying(`highp float[${t}]`, "vModelPosition"),
                e.addVertexCode("\nfloat ng_LineWidth;\n"),
                S(e),
                e.addVertexCode("\nvoid setLineWidth(float width) {\n  ng_LineWidth = width;\n}\nvoid setLineColor(vec4 startColor, vec4 endColor) {\n  vColor = mix(startColor, endColor, getLineEndpointCoefficient());\n}\n"),
                e.setVertexMain(`\nfloat modelPositionA[${t}] = getVertexPosition0();\nfloat modelPositionB[${t}] = getVertexPosition1();\nfor (int i = 0; i < ${t}; ++i) {\n  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());\n}\nng_LineWidth = 1.0;\nvColor = vec4(0.0, 0.0, 0.0, 0.0);\n${this.invokeUserMain}\nemitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),\n         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),\n         ng_LineWidth);\n${this.setPartIndex(e)};\n`),
                e.setFragmentMain(`\nfloat clipCoefficient = getSubspaceClipCoefficient(vModelPosition);\nemitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *\n                                ${this.getCrossSectionFadeFactor()} *\n                                clipCoefficient));\n`)
            }
            ),
            this.endpointIndexBuffer = this.registerDisposer(Object(c.b)(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, y)).value,
            this.endpointShaderGetter = this.getDependentShader("annotation/line/endpoint", e=>{
                const {rank: t} = this;
                this.defineShader(e),
                this.circleShader.defineShader(e, this.targetIsSliceView),
                e.addAttribute("highp uint", "aEndpointIndex"),
                e.addVarying("highp float", "vClipCoefficient"),
                e.addVarying("highp vec4", "vBorderColor"),
                w(e),
                e.addVertexCode("\nfloat ng_markerDiameter;\nfloat ng_markerBorderWidth;\nvoid setEndpointMarkerSize(float startSize, float endSize) {\n  ng_markerDiameter = mix(startSize, endSize, float(aEndpointIndex));\n}\nvoid setEndpointMarkerBorderWidth(float startSize, float endSize) {\n  ng_markerBorderWidth = mix(startSize, endSize, float(aEndpointIndex));\n}\nvoid setEndpointMarkerColor(vec4 startColor, vec4 endColor) {\n  vColor = mix(startColor, endColor, float(aEndpointIndex));\n}\nvoid setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {\n  vBorderColor = mix(startColor, endColor, float(aEndpointIndex));\n}\n"),
                e.setVertexMain(`\nfloat modelPosition[${t}] = getVertexPosition0();\nfloat modelPositionB[${t}] = getVertexPosition1();\nfor (int i = 0; i < ${t}; ++i) {\n  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(aEndpointIndex));\n}\nvClipCoefficient = getSubspaceClipCoefficient(modelPosition);\nvColor = vec4(0.0, 0.0, 0.0, 0.0);\nvBorderColor = vec4(0.0, 0.0, 0.0, 1.0);\nng_markerDiameter = 5.0;\nng_markerBorderWidth = 1.0;\n${this.invokeUserMain}\nemitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);\n${this.setPartIndex(e, "aEndpointIndex + 1u")};\n`),
                e.setFragmentMain("\nvec4 color = getCircleColor(vColor, vBorderColor);\ncolor.a *= vClipCoefficient;\nemitAnnotation(color);\n")
            }
            )
        }
        defineShader(e) {
            const {rank: t} = this;
            Object(h.a)(e, "float", WebGL2RenderingContext.FLOAT, !1, "VertexPosition", t, 2)
        }
        enable(e, t, n) {
            super.enable(e, t, e=>{
                const i = e.vertexShaderInputBinders.VertexPosition;
                i.enable(1),
                this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer),
                i.bind(this.serializedBytesPerAnnotation, t.bufferOffset),
                n(e),
                i.disable()
            }
            )
        }
        drawEdges(e) {
            this.enable(this.edgeShaderGetter, e, t=>{
                this.lineShader.enableAndDraw(t, e.renderContext.projectionParameters, 1, e.count)
            }
            )
        }
        drawEndpoints(e) {
            this.enable(this.endpointShaderGetter, e, t=>{
                const n = t.attribute("aEndpointIndex");
                this.endpointIndexBuffer.bindToVertexAttribI(n, 1, WebGL2RenderingContext.UNSIGNED_BYTE),
                this.circleShader.draw(t, e.renderContext.projectionParameters, {
                    featherWidthInPixels: .5
                }, e.count),
                t.gl.disableVertexAttribArray(n)
            }
            )
        }
        draw(e) {
            this.drawEdges(e),
            this.drawEndpoints(e)
        }
    }
    Object(a.c)(i.e.LINE, {
        sliceViewRenderHelper: x,
        perspectiveViewRenderHelper: x,
        defineShaderNoOpSetters(e) {
            S(e),
            w(e)
        },
        pickIdsPerInstance: 3,
        snapPosition(e, t, n, i) {
            const r = e.length
              , s = new Float32Array(t,n,2 * r);
            0 === i ? function(e, t) {
                const n = e.length;
                Object(b.n)(e, t.subarray(0, n), t.subarray(n), e)
            }(e, s) : function(e, t, n) {
                const i = e.length
                  , r = i * n;
                for (let n = 0; n < i; ++n)
                    e[n] = t[r + n]
            }(e, s, i - 1)
        },
        getRepresentativePoint(e, t, n) {
            e.set(0 === n || 1 === n ? t.pointA : t.pointB)
        },
        updateViaRepresentativePoint(e, t, n) {
            let i = Object.assign({}, e);
            const r = t.length;
            switch (n) {
            case 0:
                {
                    const {pointA: n, pointB: i} = e
                      , s = new Float32Array(r)
                      , a = new Float32Array(r);
                    for (let e = 0; e < r; ++e) {
                        const r = s[e] = t[e];
                        a[e] = i[e] + (r - n[e])
                    }
                    return Object.assign(Object.assign({}, e), {
                        pointA: s,
                        pointB: a
                    })
                }
            case 1:
                return Object.assign(Object.assign({}, e), {
                    pointA: new Float32Array(t)
                });
            case 2:
                return Object.assign(Object.assign({}, e), {
                    pointB: new Float32Array(t)
                })
            }
            return i
        }
    });
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class C extends a.a {
        constructor() {
            super(...arguments),
            this.circleShader = this.registerDisposer(new u.a(this.gl)),
            this.shaderGetter = this.getDependentShader("annotation/point", e=>{
                const {rank: t} = this;
                this.circleShader.defineShader(e, this.targetIsSliceView),
                Object(h.a)(e, "float", WebGL2RenderingContext.FLOAT, !1, "VertexPosition", t),
                e.addVarying("highp float", "vClipCoefficient"),
                e.addVarying("highp vec4", "vBorderColor"),
                e.addVertexCode("\nfloat ng_markerDiameter;\nfloat ng_markerBorderWidth;\nvoid setPointMarkerSize(float size) {\n  ng_markerDiameter = size;\n}\nvoid setPointMarkerBorderWidth(float size) {\n  ng_markerBorderWidth = size;\n}\nvoid setPointMarkerColor(vec4 color) {\n  vColor = color;\n}\nvoid setPointMarkerBorderColor(vec4 color) {\n  vBorderColor = color;\n}\n"),
                e.setVertexMain(`\nfloat modelPosition[${t}] = getVertexPosition0();\nvClipCoefficient = getSubspaceClipCoefficient(modelPosition);\nif (vClipCoefficient == 0.0) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nng_markerDiameter = 5.0;\nng_markerBorderWidth = 1.0;\nvBorderColor = vec4(0.0, 0.0, 0.0, 1.0);\n${this.invokeUserMain}\nemitCircle(uModelViewProjection *\n           vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);\n${this.setPartIndex(e)};\n`),
                e.setFragmentMain("\nvec4 color = getCircleColor(vColor, vBorderColor);\ncolor.a *= vClipCoefficient;\nemitAnnotation(color);\n")
            }
            )
        }
        draw(e) {
            this.enable(this.shaderGetter, e, t=>{
                const n = t.vertexShaderInputBinders.VertexPosition;
                n.enable(1),
                this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, e.buffer.buffer),
                n.bind(this.serializedBytesPerAnnotation, e.bufferOffset),
                this.circleShader.draw(t, e.renderContext.projectionParameters, {
                    featherWidthInPixels: 1
                }, e.count),
                n.disable()
            }
            )
        }
    }
    Object(a.c)(i.e.POINT, {
        sliceViewRenderHelper: C,
        perspectiveViewRenderHelper: C,
        defineShaderNoOpSetters(e) {
            e.addVertexCode("\nvoid setPointMarkerSize(float size) {}\nvoid setPointMarkerBorderWidth(float size) {}\nvoid setPointMarkerColor(vec4 color) {}\nvoid setPointMarkerBorderColor(vec4 color) {}\n")
        },
        pickIdsPerInstance: 1,
        snapPosition(e, t, n) {
            e.set(new Float32Array(t,n,e.length))
        },
        getRepresentativePoint(e, t) {
            e.set(t.point)
        },
        updateViaRepresentativePoint: (e,t)=>Object.assign(Object.assign({}, e), {
            point: new Float32Array(t)
        })
    });
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const O = "\nstruct EllipseQuadraticForm {\n  highp float A;  // x*x coefficient\n  highp float B;  // x*y coefficient\n  highp float C;  // y*y coefficient\n  highp float D;  // x coefficient\n  highp float E;  // y coefficient\n  highp float F;  // 1 coefficient\n};\n"
      , k = [O, "\nEllipseQuadraticForm computeCrossSectionEllipse(mat3 A, vec3 c) {\n  EllipseQuadraticForm p;\n  p.A = A[0][0];\n  p.B = A[0][1] + A[1][0];\n  p.C = A[1][1];\n  p.D = -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) +\n        c[2] * (A[0][2] + A[2][0]);\n  p.E = -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] +\n        c[2] * (A[1][2] + A[2][1]);\n  p.F = c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -\n        c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -\n        c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0;\n  return p;\n}\n"];
    const E = [O, "\nstruct CenterOrientEllipse {\n  vec2 k;   // center\n  vec2 u1;  // minor axis direction\n  vec2 u2;  // major axis direction\n  float a;  // semimajor axis\n  float b;  // semiminor axis\n  bool valid; // indicates if the ellipse is valid\n};\n", "\nCenterOrientEllipse computeCenterOrientEllipse(EllipseQuadraticForm p) {\n  CenterOrientEllipse r;\n  float a11 = p.A;\n  float a12 = p.B / 2.0;\n  float a22 = p.C;\n  float b1 = p.D;\n  float b2 = p.E;\n  float c = p.F;\n  float kdenom = 2.0 * (a12 * a12 - a11 * a22);\n  float k1 = r.k.x = (a22 * b1 - a12 * b2) / kdenom;\n  float k2 = r.k.y = (a11 * b2 - a12 * b1) / kdenom;\n  float mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);\n  float m11 = mu * a11;\n  float m12 = mu * a12;\n  float m22 = mu * a22;\n  float lambdaTerm1 = m11 + m22;\n  float lambdaTerm2 = sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);\n  float lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);\n  float lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);\n  r.a = 1.0 / sqrt(lambda1);\n  r.b = 1.0 / sqrt(lambda2);\n  r.valid = lambda1 > 0.0 && lambda2 > 0.0;\n  if (abs(m11 - m22) < 1e-6 && abs(m12) < 1e-6) {\n    r.u1 = vec2(1.0, 0.0);\n  } else if (m11 >= m22) {\n    r.u1 = normalize(vec2(lambda1 - m22, m12));\n  } else {\n    r.u1 = normalize(vec2(m12, lambda1 - m11));\n  }\n  r.u2 = vec2(-r.u1.y, r.u1.x);\n  return r;\n}\n"];
    var T = n(92)
      , M = n(2);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function D(e, t) {
        const n = new Float32Array((e + 1) * (t + 1) * 3);
        let i = 0;
        for (let r = 0; r <= e; ++r) {
            const s = r * Math.PI / e
              , a = Math.sin(s)
              , o = Math.cos(s);
            for (let e = 0; e <= t; ++e) {
                const r = 2 * e * Math.PI / t
                  , s = Math.sin(r)
                  , l = Math.cos(r);
                n[i++] = l * a,
                n[i++] = o,
                n[i++] = s * a
            }
        }
        return n
    }
    function L(e, t) {
        const n = new Uint16Array(e * t * 6);
        let i = 0;
        for (let r = 0; r < e; r++)
            for (let e = 0; e < t; e++) {
                const s = r * (t + 1) + e
                  , a = s + t + 1;
                n[i++] = s,
                n[i++] = a,
                n[i++] = s + 1,
                n[i++] = a,
                n[i++] = a + 1,
                n[i++] = s + 1
            }
        return n
    }
    class A extends M.a {
        constructor(e, t, n) {
            super(),
            this.vertexBuffer = this.registerDisposer(Object(c.b)(e, WebGL2RenderingContext.ARRAY_BUFFER, D, t, n)).value,
            this.indexBuffer = this.registerDisposer(Object(c.b)(e, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, L, t, n)).value,
            this.numIndices = t * n * 6
        }
        defineShader(e) {
            e.addAttribute("highp vec3", "aSphereVertex"),
            e.addVarying("highp float", "vLightingFactor"),
            e.addVertexCode("\nvoid emitSphere(mat4 projectionMatrix, mat4 normalTransformMatrix, vec3 centerPosition, vec3 radii, vec4 lightDirection) {\n  vec3 vertexPosition = aSphereVertex * radii + centerPosition;\n  gl_Position = projectionMatrix * vec4(vertexPosition, 1.0);\n  vec3 normal = normalize((normalTransformMatrix * vec4(aSphereVertex / max(radii, 1e-6), 0.0)).xyz);\n  vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;\n}\n")
        }
        draw(e, t) {
            const n = e.attribute("aSphereVertex");
            this.vertexBuffer.bindToVertexAttrib(n, 3, WebGL2RenderingContext.FLOAT, !1),
            this.indexBuffer.bind(),
            e.gl.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, this.numIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0, t),
            e.gl.disableVertexAttribArray(n)
        }
    }
    var I = n(66);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const P = b.l.create();
    class R extends a.a {
        defineShader(e) {
            const {rank: t} = this;
            Object(h.a)(e, "float", WebGL2RenderingContext.FLOAT, !1, "CenterAndRadii", t, 2),
            e.addVertexCode(`\nstruct SubspaceParams {\n  highp vec3 subspaceCenter;\n  highp vec3 subspaceRadii;\n  highp float clipCoefficient;\n  bool cull;\n};\nSubspaceParams getSubspaceParams() {\n  SubspaceParams params;\n  highp float modelCenter[${t}] = getCenterAndRadii0();\n  highp float modelRadii[${t}] = getCenterAndRadii1();\n  float radiusAdjustment = 1.0;\n  float clipCoefficient = 1.0;\n  for (int i = 0; i < ${t}; ++i) {\n    float r = modelRadii[i];\n    float c = modelCenter[i];\n    float x = uModelClipBounds[i];\n    float clipRadius = uModelClipBounds[i + ${t}];\n    if (r != 0.0 && clipRadius != 0.0) {\n      float d = c - x;\n      d = d * d;\n      radiusAdjustment -= d / (r * r);\n    }\n    float e = abs(x - clamp(x, c - r, c + r)) * clipRadius;\n    clipCoefficient *= max(0.0, 1.0 - e);\n  }\n  radiusAdjustment = sqrt(max(0.0, radiusAdjustment));\n  params.subspaceCenter = projectModelVectorToSubspace(modelCenter);\n  params.subspaceRadii = projectModelVectorToSubspace(modelRadii) * radiusAdjustment;\n  params.clipCoefficient = clipCoefficient;\n  params.cull = clipCoefficient == 0.0 || radiusAdjustment == 0.0;\n  return params;\n}\nvoid setEllipsoidFillColor(vec4 color) {\n  vColor = color;\n}\n`)
        }
        enable(e, t, n) {
            super.enable(e, t, e=>{
                const i = e.vertexShaderInputBinders.CenterAndRadii;
                i.enable(1),
                this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer),
                i.bind(this.serializedBytesPerAnnotation, t.bufferOffset),
                n(e),
                i.disable()
            }
            )
        }
    }
    Object(a.c)(i.e.ELLIPSOID, {
        sliceViewRenderHelper: class extends R {
            constructor() {
                super(...arguments),
                this.quadRenderHelper = this.registerDisposer(new T.a(this.gl,1)),
                this.squareCornersBuffer = Object(I.a)(this.gl, -1, -1, 1, 1, 1, 1),
                this.shaderGetter = this.getDependentShader("annotation/ellipsoid/crossSection", e=>{
                    this.defineShader(e),
                    e.addUniform("highp mat4", "uViewportToObject"),
                    e.addUniform("highp mat4", "uObjectToViewport"),
                    e.addUniform("highp mat4", "uViewportToDevice"),
                    e.addAttribute("highp vec2", "aCornerOffset"),
                    e.addVarying("highp vec2", "vCircleCoord"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    e.addVertexCode(k),
                    e.addVertexCode(E),
                    e.setVertexMain(`\nSubspaceParams params = getSubspaceParams();\nif (params.cull) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nvClipCoefficient = params.clipCoefficient;\nmat3 Aobject = mat3(0.0);\nfor (int i = 0; i < 3; ++i) {\n  float r = max(params.subspaceRadii[i], 1e-3);\n  Aobject[i][i] = 1.0 / (r * r);\n}\nmat3 RviewportToObject = mat3(uViewportToObject);\nmat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;\nvec3 cViewport = (uObjectToViewport * vec4(params.subspaceCenter, 1.0)).xyz;\nEllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);\nvec2 u1, u2;\nfloat a, b;\nCenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);\nvec2 viewportCorner = centerOrient.k +\n  centerOrient.u1 * aCornerOffset.x * centerOrient.a +\n  centerOrient.u2 * aCornerOffset.y * centerOrient.b;\nif (centerOrient.valid) {\n  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);\n} else {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n}\nvCircleCoord = aCornerOffset;\n${this.invokeUserMain}\n${this.setPartIndex(e)};\n`),
                    e.setFragmentMain("\nif (dot(vCircleCoord, vCircleCoord) > 1.0) {\n  discard;\n}\nemitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));\n")
                }
                )
            }
            draw(e) {
                this.enable(this.shaderGetter, e, t=>{
                    const {gl: n} = t
                      , i = t.attribute("aCornerOffset");
                    this.squareCornersBuffer.bindToVertexAttrib(i, 2);
                    const r = e.renderContext.sliceView.projectionParameters.value
                      , s = b.l.multiply(P, e.renderSubspaceInvModelMatrix, r.invViewMatrix);
                    n.uniformMatrix4fv(t.uniform("uViewportToObject"), !1, s),
                    n.uniformMatrix4fv(t.uniform("uViewportToDevice"), !1, r.projectionMat);
                    const a = P;
                    b.l.invert(a, s),
                    n.uniformMatrix4fv(t.uniform("uObjectToViewport"), !1, a),
                    this.quadRenderHelper.draw(n, e.count),
                    t.gl.disableVertexAttribArray(i)
                }
                )
            }
        }
        ,
        perspectiveViewRenderHelper: class extends R {
            constructor() {
                super(...arguments),
                this.sphereRenderHelper = this.registerDisposer(new A(this.gl,10,10)),
                this.shaderGetter = this.getDependentShader("annotation/ellipsoid/projection", e=>{
                    this.defineShader(e),
                    this.sphereRenderHelper.defineShader(e),
                    e.addUniform("highp vec4", "uLightDirection"),
                    e.addUniform("highp mat4", "uNormalTransform"),
                    e.addVarying("highp float", "vClipCoefficient"),
                    e.setVertexMain(`\nSubspaceParams params = getSubspaceParams();\nif (params.cull) {\n  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);\n  return;\n}\nvClipCoefficient = params.clipCoefficient;\n${this.invokeUserMain}\nemitSphere(uModelViewProjection, uNormalTransform, params.subspaceCenter, params.subspaceRadii, uLightDirection);\n${this.setPartIndex(e)};\n`),
                    e.setFragmentMain("\nemitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a * vClipCoefficient));\n")
                }
                ),
                this.tempLightVec = new Float32Array(4)
            }
            draw(e) {
                this.enable(this.shaderGetter, e, t=>{
                    const {gl: n} = t;
                    let i = this.tempLightVec
                      , {lightDirection: r, ambientLighting: s, directionalLighting: a} = e.renderContext;
                    b.t.scale(i, r, a),
                    i[3] = s,
                    n.uniform4fv(t.uniform("uLightDirection"), i),
                    n.uniformMatrix4fv(t.uniform("uNormalTransform"), !1, b.l.transpose(b.l.create(), e.renderSubspaceInvModelMatrix)),
                    this.sphereRenderHelper.draw(t, e.count)
                }
                )
            }
        }
        ,
        defineShaderNoOpSetters(e) {
            e.addVertexCode("\nvoid setEllipsoidFillColor(vec4 color) {}\n")
        },
        pickIdsPerInstance: 1,
        snapPosition: ()=>{}
        ,
        getRepresentativePoint(e, t) {
            e.set(t.center)
        },
        updateViaRepresentativePoint: (e,t)=>Object.assign(Object.assign({}, e), {
            center: new Float32Array(t)
        })
    });
    var j = n(64)
      , N = n(10)
      , V = n(67)
      , B = n(38)
      , F = n(45)
      , _ = n(61)
      , U = n(52)
      , z = n(65);
    /**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const G = b.l.create()
      , $ = b.t.create();
    function W(e) {
        e.addUniform("highp vec3", "uTranslation"),
        e.addUniform("highp mat4", "uProjectionMatrix"),
        e.addUniform("highp vec3", "uChunkDataSize"),
        e.addUniform("highp vec3", "uLowerClipBound"),
        e.addUniform("highp vec3", "uUpperClipBound"),
        e.setFragmentMain("\nemit(vec4(1.0, 1.0, 1.0, getLineAlpha()), 0u);\n")
    }
    const H = Float32Array.from([0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1]);
    class J extends M.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.lineShader = this.registerDisposer(new d.a(this.gl,12)),
            this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(c.a.fromData(this.gl, Object(l.j)(H, 6, 1, d.b)))
        }
        static get(e) {
            return e.memoize.get("sliceView.ProjectionWireFrameRenderHelper", ()=>new J(e))
        }
        defineShader(e) {
            W(e),
            this.lineShader.defineShader(e),
            e.addAttribute("highp vec3", "aBoxCornerOffset1"),
            e.addAttribute("highp vec3", "aBoxCornerOffset2"),
            e.setVertexMain("\nvec3 cornerA = max(uLowerClipBound, min(uUpperClipBound, uTranslation));\nvec3 cornerB = max(uLowerClipBound, min(uUpperClipBound, uTranslation + uChunkDataSize));\nvec3 vertexPosition1 = mix(cornerA, cornerB, aBoxCornerOffset1);\nvec3 vertexPosition2 = mix(cornerA, cornerB, aBoxCornerOffset2);\nemitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),\n         uProjectionMatrix * vec4(vertexPosition2, 1.0),\n         2.0);\n")
        }
        enable(e, t) {
            const n = e.attribute("aBoxCornerOffset1")
              , i = e.attribute("aBoxCornerOffset2");
            this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(n, 3, WebGL2RenderingContext.FLOAT, !1, 24, 0),
            this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(i, 3, WebGL2RenderingContext.FLOAT, !1, 24, 12),
            this.lineShader.enable(e, t, 1)
        }
        draw(e, t, n) {
            const {gl: i} = this
              , r = G
              , {chunkLayout: s} = t;
            b.l.multiply(r, n.viewProjectionMat, s.transform),
            i.uniformMatrix4fv(e.uniform("uProjectionMatrix"), !1, r),
            i.uniform3fv(e.uniform("uChunkDataSize"), s.size),
            i.uniform3fv(e.uniform("uLowerClipBound"), t.lowerClipDisplayBound),
            i.uniform3fv(e.uniform("uUpperClipBound"), t.upperClipDisplayBound);
            const a = s.size
              , {curPositionInChunks: o, chunkDisplayDimensionIndices: l} = t
              , c = $;
            for (let e = 0; e < 3; ++e) {
                const t = l[e];
                c[e] = (-1 === t ? 0 : o[t]) * a[e]
            }
            i.uniform3fv(e.uniform("uTranslation"), c),
            this.lineShader.draw(i, 1)
        }
        disable(e) {
            const {gl: t} = e;
            t.disableVertexAttribArray(e.attribute("aBoxCornerOffset1")),
            t.disableVertexAttribArray(e.attribute("aBoxCornerOffset2"))
        }
    }
    class q extends o.a {
        constructor() {
            super(...arguments),
            this.lineShader = new d.a(this.gl,6),
            this.intersectionVertexIndexBuffer = Object(c.b)(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, o.c).value
        }
        static get(e) {
            return e.memoize.get("sliceView.WireFrameRenderHelper", ()=>new q(e))
        }
        defineShader(e) {
            super.defineShader(e),
            W(e),
            e.addAttribute("highp float", "aVertexIndexFloat"),
            this.lineShader.defineShader(e),
            e.setVertexMain("\nint vertexIndex1 = int(aVertexIndexFloat);\nint vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;\nvec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);\nvec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);\nemitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),\n         uProjectionMatrix * vec4(vertexPosition2, 1.0),\n         2.0);\n")
        }
        enable(e, t) {
            this.intersectionVertexIndexBuffer.bindToVertexAttrib(e.attribute("aVertexIndexFloat"), 1),
            this.lineShader.enable(e, t, 1)
        }
        draw(e, t, n) {
            const {gl: i} = this
              , r = G
              , {chunkLayout: s} = t;
            b.l.multiply(r, n.viewProjectionMat, s.transform),
            i.uniformMatrix4fv(e.uniform("uProjectionMatrix"), !1, r),
            i.uniform3fv(e.uniform("uChunkDataSize"), s.size),
            i.uniform3fv(e.uniform("uLowerClipBound"), t.lowerClipDisplayBound),
            i.uniform3fv(e.uniform("uUpperClipBound"), t.upperClipDisplayBound);
            const a = s.size
              , {curPositionInChunks: o, chunkDisplayDimensionIndices: l} = t
              , c = $;
            for (let e = 0; e < 3; ++e) {
                const t = l[e];
                c[e] = (-1 === t ? 0 : o[t]) * a[e]
            }
            i.uniform3fv(e.uniform("uTranslation"), c),
            this.setViewportPlane(e, n.viewportNormalInGlobalCoordinates, n.centerDataPosition, s.transform, s.invTransform),
            this.lineShader.draw(i, 1)
        }
        disable(e) {
            this.gl.disableVertexAttribArray(e.attribute("aVertexIndexFloat"))
        }
    }
    var Y = n(7)
      , X = n(48)
      , K = n(3)
      , Z = n(26)
      , Q = n(34)
      , ee = n(11)
      , te = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    };
    const ne = b.l.create();
    let ie = class extends (Object(Z.c)(ee.b)) {
        constructor(e, t, n) {
            super(),
            this.chunkManager = e,
            this.source = t,
            this.segmentationStates = n,
            this.initializeCounterpart(this.chunkManager.rpc, {
                chunkManager: this.chunkManager.rpcId,
                source: t.rpcId,
                segmentationStates: this.serializeDisplayState()
            });
            this.registerDisposer(n.changed.add(()=>{
                const e = {
                    id: this.rpcId,
                    segmentationStates: this.serializeDisplayState()
                };
                this.rpc.invoke(j.i, e)
            }
            ))
        }
        serializeDisplayState() {
            const {value: e} = this.segmentationStates;
            if (void 0 !== e)
                return e.map(e=>null == e ? e : {
                    segmentEquivalences: e.segmentEquivalences.rpcId,
                    visibleSegments: e.visibleSegments.rpcId
                })
        }
    }
    ;
    ie = te([Object(ee.g)(j.h)], ie);
    class re extends M.a {
        constructor(e, t) {
            super(),
            this.chunkManager = e,
            this.state = t,
            this.numPickIds = 0,
            this.generation = -1,
            this.redrawNeeded = new K.a,
            this.serializedAnnotations = void 0,
            this.handleChangeAffectingBuffer = ()=>{
                this.generation = -1,
                this.redrawNeeded.dispatch()
            }
            ,
            this.segmentationStates = this.registerDisposer(Object(Y.g)(e=>{
                const {displayState: t, source: n} = this.state
                  , {relationshipStates: i} = t;
                return t.displayUnfiltered.value ? void 0 : n.relationships.map(e=>{
                    const t = i.get(e);
                    return t.showMatches.value ? t.segmentationState.value : void 0
                }
                )
            }
            , [this.state.displayState.relationshipStates], (e,t)=>void 0 === e || void 0 === t ? e === t : Object(l.a)(e, t))),
            this.registerDisposer(t),
            this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer)),
            this.registerDisposer(Object(Y.j)((e,t)=>{
                if (this.handleChangeAffectingBuffer(),
                void 0 !== t)
                    for (const n of t)
                        null != n && (e.registerDisposer(n.visibleSegments.changed.add(()=>this.handleChangeAffectingBuffer())),
                        e.registerDisposer(n.segmentEquivalences.changed.add(()=>this.handleChangeAffectingBuffer())))
            }
            , this.segmentationStates)),
            this.source instanceof i.d || (this.sharedObject = this.registerDisposer(new ie(e,this.source,this.segmentationStates)));
            const {displayState: n} = this.state;
            this.registerDisposer(n.color.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(n.shader.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(n.shaderControls.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch))
        }
        get source() {
            return this.state.source
        }
        get transform() {
            return this.state.transform
        }
        get hoverState() {
            return this.state.displayState.hoverState
        }
        get visibility() {
            const {sharedObject: e} = this;
            if (void 0 !== e)
                return e.visibility
        }
        get gl() {
            return this.chunkManager.gl
        }
        updateBuffer() {
            const {source: e} = this;
            if (e instanceof i.d) {
                const t = e.changed.count;
                if (this.generation !== t) {
                    let {buffer: n} = this;
                    void 0 === n && (n = this.buffer = this.registerDisposer(new c.a(this.chunkManager.gl))),
                    this.generation = t;
                    const r = this.serializedAnnotations = function(e, t) {
                        const n = new i.c(e.annotationPropertySerializer);
                        for (const i of e)
                            (void 0 === t || t(i)) && n.add(i);
                        return n.serialize()
                    }(e, function(e) {
                        if (void 0 !== e)
                            return t=>{
                                const {relatedSegments: n} = t;
                                if (void 0 === n)
                                    return !1;
                                for (let t = 0, i = n.length; t < i; ++t) {
                                    const i = e[t];
                                    if (null == i)
                                        continue;
                                    const {visibleSegments: r, segmentEquivalences: s} = i;
                                    for (const e of n[t])
                                        if (r.has(s.get(e)))
                                            return !0
                                }
                                return !1
                            }
                    }(this.segmentationStates.value));
                    n.setData(this.serializedAnnotations.data),
                    this.numPickIds = Object(s.c)(r)
                }
            }
        }
    }
    function se(e) {
        const {chunkTransform: t} = e
          , {unpaddedRank: n} = t.modelTransform
          , i = new Float32Array(2 * n)
          , r = new Float32Array(3 * n);
        r.fill(0),
        i.fill(1, n);
        const {numChunkDisplayDims: s, chunkDisplayDimensionIndices: a} = e;
        for (let e = 0; e < s; ++e) {
            const t = a[e];
            i[n + t] = 0,
            r[3 * t + e] = 1
        }
        return {
            modelClipBounds: i,
            renderSubspaceTransform: r
        }
    }
    function ae(e, t, n) {
        n.clearMessages();
        const i = e=>{
            n.addMessage({
                severity: X.b.error,
                message: e
            })
        }
        ;
        if (void 0 !== e.error)
            return i(e.error);
        const r = Object(B.f)(e.modelTransform, t.displayDimensionIndices);
        let s;
        try {
            s = Object(B.c)(e, r)
        } catch (e) {
            return i(e.message)
        }
        const {modelClipBounds: a, renderSubspaceTransform: o} = se(s);
        return {
            chunkTransform: e,
            chunkDisplayTransform: s,
            modelClipBounds: a,
            renderSubspaceTransform: o
        }
    }
    function oe(e, t) {
        return class extends e {
            constructor(e, t) {
                super(),
                this.base = e,
                this.renderScaleHistogram = t,
                this.curRank = -1,
                this.renderHelpers = [],
                this.isAnnotation = !0;
                const n = e.visibility;
                void 0 !== n && this.registerDisposer(n.add(this.visibility)),
                this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility)),
                this.registerDisposer(()=>{
                    for (const e of this.renderHelpers)
                        e.dispose()
                }
                ),
                this.role = e.state.role,
                this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch)),
                this.handleRankChanged()
            }
            handleRankChanged() {
                const {rank: e} = this.base.source;
                if (e === this.curRank)
                    return;
                this.curRank = e,
                this.tempChunkPosition = new Float32Array(e);
                const {renderHelpers: n, gl: r} = this;
                for (const e of n)
                    e.dispose();
                const {properties: s} = this.base.source
                  , {displayState: o} = this.base.state;
                for (const l of i.i) {
                    const i = Object(a.b)(l)
                      , c = i[t]
                      , u = n[l] = new c(r,l,e,s,o.shaderControls,o.fallbackShaderControls,o.shaderError);
                    u.pickIdsPerInstance = i.pickIdsPerInstance,
                    u.targetIsSliceView = "sliceViewRenderHelper" === t
                }
            }
            attach(e) {
                super.attach(e),
                this.handleRankChanged();
                const {chunkTransform: t} = this
                  , n = e.view.displayDimensionRenderInfo.value;
                e.state = {
                    chunkTransform: t,
                    displayDimensionRenderInfo: n,
                    chunkRenderParameters: ae(t, n, e.messages)
                }
            }
            updateAttachmentState(e) {
                const t = e.state;
                this.handleRankChanged();
                const {chunkTransform: n} = this
                  , i = e.view.displayDimensionRenderInfo.value;
                return void 0 !== t && t.chunkTransform === n && t.displayDimensionRenderInfo === i ? t.chunkRenderParameters : (t.chunkTransform = n,
                t.displayDimensionRenderInfo = i,
                t.chunkRenderParameters = ae(n, i, e.messages))
            }
            get chunkTransform() {
                return this.base.state.chunkTransform.value
            }
            updateModelClipBounds(e, t) {
                const {modelClipBounds: n} = t
                  , i = this.curRank
                  , {chunkTransform: r} = t;
                Object(B.d)(n.subarray(0, i), e.projectionParameters.globalPosition, this.base.state.localPosition.value, r.layerRank, r.combinedGlobalLocalToChunkTransform)
            }
            get gl() {
                return this.base.chunkManager.gl
            }
            drawGeometryChunkData(e, t, n, i=1) {
                if (!e.bufferValid) {
                    let {buffer: t} = e;
                    void 0 === t && (t = e.buffer = new c.a(this.gl));
                    const {serializedAnnotations: n} = e;
                    t.setData(n.data),
                    e.numPickIds = Object(s.c)(n),
                    e.bufferValid = !0
                }
                this.drawGeometry(e, t, n, i)
            }
            drawGeometry(e, t, n, r=1) {
                const {base: s} = this
                  , {chunkDisplayTransform: o} = n
                  , {serializedAnnotations: l} = e
                  , {typeToIdMaps: c, typeToOffset: u} = l;
                let d = 0;
                t.emitPickID && (d = t.pickIDs.register(this, e.numPickIds, 0, 0, e));
                const h = s.hoverState.value
                  , p = b.l.multiply(ne, t.projectionParameters.viewProjectionMat, o.displaySubspaceModelMatrix)
                  , f = {
                    annotationLayer: s,
                    renderContext: t,
                    selectedIndex: 0,
                    basePickId: d,
                    buffer: e.buffer,
                    bufferOffset: 0,
                    count: 0,
                    modelViewProjectionMatrix: p,
                    modelClipBounds: n.modelClipBounds,
                    subspaceMatrix: n.renderSubspaceTransform,
                    renderSubspaceModelMatrix: o.displaySubspaceModelMatrix,
                    renderSubspaceInvModelMatrix: o.displaySubspaceInvModelMatrix
                };
                for (const e of i.i) {
                    const t = c[e];
                    let n = t.size;
                    if (n > 0) {
                        const i = Object(a.b)(e);
                        let s = 4294967295;
                        if (void 0 !== h) {
                            const e = t.get(h.id);
                            void 0 !== e && (s = e * i.pickIdsPerInstance)
                        }
                        n = Math.round(n * r),
                        f.count = n,
                        f.bufferOffset = u[e],
                        f.selectedIndex = s,
                        this.renderHelpers[e].draw(f),
                        f.basePickId += n * i.pickIdsPerInstance
                    }
                }
            }
            updateMouseState(e, t, n, r) {
                const s = r
                  , {serializedAnnotations: o} = s
                  , {typeToIds: l, typeToOffset: c} = o
                  , u = this.curRank
                  , d = this.chunkTransform;
                if (void 0 === d.error)
                    for (const t of i.i) {
                        const r = l[t]
                          , s = Object(a.b)(t)
                          , h = Object(i.k)(t)
                          , {pickIdsPerInstance: p} = s;
                        if (n < r.length * p) {
                            const i = Math.floor(n / p)
                              , a = r[i]
                              , l = n % p;
                            e.pickedAnnotationId = a,
                            e.pickedAnnotationLayer = this.base.state,
                            e.pickedOffset = l,
                            e.pickedAnnotationBuffer = o.data.buffer,
                            e.pickedAnnotationBufferOffset = o.data.byteOffset + c[t] + i * (h.serializedBytes(u) + this.base.source.annotationPropertySerializer.serializedBytes);
                            const f = this.tempChunkPosition
                              , {chunkToLayerTransform: m, combinedGlobalLocalToChunkTransform: g, layerRank: v} = d
                              , {globalToRenderLayerDimensions: b} = d.modelTransform
                              , {position: y} = e;
                            if (!Object(B.d)(f, y, this.base.state.localPosition.value, v, g))
                                return;
                            s.snapPosition(f, e.pickedAnnotationBuffer, e.pickedAnnotationBufferOffset, l);
                            const S = b.length;
                            for (let e = 0; e < S; ++e) {
                                const t = b[e];
                                if (-1 === t)
                                    continue;
                                let n = m[(u + 1) * u + t];
                                for (let e = 0; e < u; ++e)
                                    n += f[e] * m[e * (v + 1) + t];
                                Number.isFinite(n) && (y[e] = n)
                            }
                            return
                        }
                        n -= r.length * p
                    }
            }
            transformPickedValue(e, t) {}
            isReady() {
                const {base: e} = this
                  , {source: t} = e;
                if (!(t instanceof s.b))
                    return !0;
                const {value: n} = this.base.segmentationStates;
                if (void 0 === n)
                    return !0;
                for (let e = 0, i = n.length; e < i; ++e) {
                    const i = n[e];
                    if (null === i)
                        return !1;
                    if (void 0 === i)
                        continue;
                    const r = t.segmentFilteredSources[e].chunks;
                    let s = !1;
                    if (Object(F.a)(i, e=>{
                        const t = Object(F.b)(e);
                        r.has(t) || (s = !0)
                    }
                    ),
                    s)
                        return !1
                }
                return !0
            }
        }
    }
    const le = e=>class extends e {
        draw(e, t) {
            const n = this.updateAttachmentState(t);
            if (0 === this.curRank || void 0 === n)
                return;
            this.updateModelClipBounds(e, n);
            const {source: r} = this.base;
            if (r instanceof i.d) {
                const {base: t} = this;
                t.updateBuffer(),
                this.drawGeometry(t, e, n)
            } else {
                const {renderScaleHistogram: t} = this;
                t.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber),
                this.drawGeometryChunkData(r.temporary.data, e, n);
                const {value: i} = this.base.segmentationStates;
                let s = 0
                  , a = 0;
                if (void 0 !== i)
                    for (let t = 0, o = i.length; t < o; ++t) {
                        const o = i[t];
                        if (null == o)
                            continue;
                        const l = r.segmentFilteredSources[t].chunks;
                        Object(F.a)(o, t=>{
                            const i = Object(F.b)(t)
                              , r = l.get(i);
                            if (void 0 !== r && r.state === N.g.GPU_MEMORY) {
                                const {data: t} = r;
                                if (void 0 === t)
                                    return;
                                this.drawGeometryChunkData(t, e, n),
                                ++s
                            } else
                                ++a
                        }
                        )
                    }
                t.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, s, a)
            }
        }
    }
      , ce = oe(V.a, "perspectiveViewRenderHelper");
    class ue extends (le(ce)) {
    }
    const de = e=>class extends e {
        constructor(e) {
            super(e.annotationLayer, e.renderScaleHistogram),
            this.wireFrameRenderHelper = this.registerDisposer(this instanceof z.a ? q.get(this.gl) : J.get(this.gl)),
            this.wireFrameShaderGetter = Object(Q.d)(this, this.gl, {
                memoizeKey: `annotation/wireFrameShader:${this instanceof z.a}`,
                parameters: Object(Y.f)(void 0),
                defineShader: e=>{
                    this.wireFrameRenderHelper.defineShader(e)
                }
            }),
            this.renderScaleTarget = e.renderScaleTarget,
            this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
            const t = this.registerDisposer(new ee.b)
              , n = this.base.chunkManager.rpc;
            t.RPC_TYPE_ID = j.j,
            t.initializeCounterpart(n, {
                chunkManager: this.base.chunkManager.rpcId,
                localPosition: this.registerDisposer(_.a.makeFromExisting(n, this.base.state.localPosition)).rpcId,
                renderScaleTarget: this.registerDisposer(_.a.makeFromExisting(n, this.renderScaleTarget)).rpcId
            }),
            this.backend = t
        }
        attach(e) {
            super.attach(e),
            e.state.sources = e.registerDisposer(Object(Y.j)((t,n,i)=>{
                const r = Object(U.f)(i, n, e=>this.base.state.source.getSources(e), e.messages, this);
                for (const e of r)
                    for (const n of e)
                        t.registerDisposer(n.source),
                        Object.assign(n, se(n.chunkDisplayTransform));
                return e.view.flushBackendProjectionParameters(),
                this.backend.rpc.invoke(j.e, {
                    layer: this.backend.rpcId,
                    view: e.view.rpcId,
                    sources: Object(U.g)(r)
                }),
                this.redrawNeeded.dispatch(),
                r
            }
            , this.base.state.transform, e.view.displayDimensionRenderInfo))
        }
        draw(e, t) {
            const n = this.updateAttachmentState(t);
            if (0 === this.curRank || void 0 === n)
                return;
            const i = t.state.sources.value;
            if (0 === i.length)
                return;
            this.updateModelClipBounds(e, n);
            const {renderScaleHistogram: r} = this;
            r.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            const {projectionParameters: s} = e;
            let a;
            if (e.wireFrame) {
                const {shader: t} = this.wireFrameShaderGetter(e.emitter);
                if (null === t)
                    return;
                t.bind(),
                this.wireFrameRenderHelper.enable(t, s),
                a = t
            }
            Object(j.l)(s, this.base.state.localPosition.value, this.renderScaleTarget.value, i[0], ()=>{}
            , (t,i,o,l,c)=>{
                const u = t.source.chunks.get(t.curPositionInChunks.join());
                let d;
                if (void 0 === u || u.state !== N.g.GPU_MEMORY)
                    d = 0;
                else {
                    const {data: i} = u;
                    if (void 0 === i)
                        return;
                    void 0 !== a ? this.wireFrameRenderHelper.draw(a, t, s) : this.drawGeometryChunkData(i, e, n, o),
                    d = 1
                }
                r.add(l, c, d, 1 - d)
            }
            )
        }
    }
      , he = de(ce)
      , pe = de(oe(z.a, "sliceViewRenderHelper"))
      , fe = le(oe(z.a, "sliceViewRenderHelper"));
    var me = n(27)
      , ge = n(31)
      , ve = n(17)
      , be = n(88)
      , ye = n(29)
      , Se = n(5)
      , we = n(0)
      , xe = n(15)
      , Ce = n(37);
    n(76);
    var Oe = n(21)
      , ke = n(43)
      , Ee = n(101)
      , Te = n(113)
      , Me = n(109)
      , De = n(36)
      , Le = n(41)
      , Ae = n(114);
    n.d(t, "b", (function() {
        return Ne
    }
    )),
    n.d(t, "a", (function() {
        return Xe
    }
    ));
    class Ie extends M.a {
        constructor(e, t, n) {
            super(),
            this.reference = e,
            this.annotationLayer = t,
            this.relationshipIndex = n,
            this.element = document.createElement("span"),
            this.containerElement = document.createElement("div"),
            this.debouncedUpdateView = this.registerCancellable(Object(ye.a)(()=>this.updateView())),
            this.segmentationState = this.annotationLayer.displayState.relationshipStates.get(this.annotationLayer.source.relationships[this.relationshipIndex]).segmentationState;
            const {element: i, containerElement: r} = this;
            if (i.className = "neuroglancer-annotation-segment-list",
            !t.source.readonly) {
                const e = this.registerDisposer(new Ae.a);
                e.element.style.display = "inline-block",
                e.element.title = "Associate segments",
                i.appendChild(e.element),
                this.registerDisposer(e.valuesEntered.add(e=>{
                    const t = this.reference.value;
                    if (null == t)
                        return;
                    let {relatedSegments: n} = t;
                    n = void 0 === n ? this.annotationLayer.source.relationships.map(()=>[]) : n.slice();
                    const i = n[this.relationshipIndex];
                    n[this.relationshipIndex] = [...i, ...e];
                    const r = Object.assign(Object.assign({}, t), {
                        relatedSegments: n
                    });
                    this.annotationLayer.source.update(this.reference, r),
                    this.annotationLayer.source.commit(this.reference)
                }
                ))
            }
            r.style.display = "contents",
            i.appendChild(r),
            this.registerDisposer(Object(Y.j)((e,t)=>{
                null != t && (e.registerDisposer(t.visibleSegments.changed.add(this.debouncedUpdateView)),
                e.registerDisposer(t.segmentColorHash.changed.add(this.debouncedUpdateView)),
                e.registerDisposer(t.segmentSelectionState.changed.add(this.debouncedUpdateView))),
                this.debouncedUpdateView()
            }
            , this.segmentationState)),
            this.registerDisposer(e.changed.add(this.debouncedUpdateView)),
            this.updateView()
        }
        updateView() {
            const {value: e} = this.segmentationState
              , {containerElement: t} = this;
            Object(Se.b)(t),
            this.element.style.display = "none";
            const n = this.reference.value;
            if (null == n)
                return;
            const {relatedSegments: i} = n
              , r = i && i[this.relationshipIndex];
            if (this.element.style.display = "",
            void 0 === r || 0 === r.length)
                return;
            const s = e ? e.segmentColorHash : void 0;
            r.forEach((i,r)=>{
                0 !== r && t.appendChild(document.createTextNode(" "));
                const a = document.createElement("span");
                a.title = "Double click to toggle segment visibility, control+click to disassociate segment from annotation.",
                a.className = "neuroglancer-annotation-segment-item",
                a.textContent = i.toString(),
                null != e && (a.style.backgroundColor = s.computeCssColor(i),
                a.addEventListener("mouseenter", ()=>{
                    e.segmentSelectionState.set(i)
                }
                ),
                a.addEventListener("mouseleave", ()=>{
                    e.segmentSelectionState.set(null)
                }
                ),
                a.addEventListener("dblclick", t=>{
                    t.ctrlKey || (e.visibleSegments.has(i) ? e.visibleSegments.delete(i) : e.visibleSegments.add(i))
                }
                )),
                a.addEventListener("click", e=>{
                    if (!e.ctrlKey)
                        return;
                    let {relatedSegments: t} = n;
                    t = void 0 === t ? this.annotationLayer.source.relationships.map(()=>[]) : t.slice();
                    const r = t[this.relationshipIndex].filter(e=>!Oe.a.equal(i, e));
                    t[this.relationshipIndex] = r;
                    const s = Object.assign(Object.assign({}, n), {
                        relatedSegments: t
                    });
                    this.annotationLayer.source.update(this.reference, s),
                    this.annotationLayer.source.commit(this.reference)
                }
                ),
                t.appendChild(a)
            }
            )
        }
    }
    class Pe extends M.a {
        constructor() {
            super(...arguments),
            this.changed = new K.a,
            this.isLoadingChanged = new K.a,
            this.states = [],
            this.relationships = [],
            this.loadingCount = 0
        }
        get value() {
            return this.states
        }
        get isLoading() {
            return 0 !== this.loadingCount
        }
        markLoading() {
            return this.loadingCount++,
            ()=>{
                0 == --this.loadingCount && this.isLoadingChanged.dispatch()
            }
        }
        sort() {
            this.states.sort((e,t)=>{
                let n = e.sourceIndex - t.sourceIndex;
                return 0 !== n ? n : e.subsourceIndex - t.subsourceIndex
            }
            )
        }
        updateRelationships() {
            const e = new Set;
            for (const t of this.states)
                for (const n of t.source.relationships)
                    e.add(n);
            this.relationships = Array.from(e)
        }
        add(e) {
            return this.states.push(e),
            this.sort(),
            this.updateRelationships(),
            this.changed.dispatch(),
            ()=>{
                const t = this.states.indexOf(e);
                this.states.splice(t, 1),
                this.updateRelationships(),
                this.changed.dispatch()
            }
        }
    }
    class Re extends M.a {
        constructor(e) {
            super(),
            this.annotationStates = e,
            this.value_ = void 0,
            this.changed = new K.a,
            this.annotationLayer_ = void 0,
            this.reference_ = void 0,
            this.referenceChanged = ()=>{
                this.validate(),
                this.changed.dispatch()
            }
            ,
            this.validate = ()=>{
                const e = this.value_;
                if (void 0 === e)
                    return;
                const {annotationLayer_: t} = this
                  , {annotationStates: n} = this;
                if (void 0 !== t) {
                    if (!n.states.includes(t))
                        return this.unbindReference(),
                        void (n.isLoading || (this.value_ = void 0,
                        this.changed.dispatch()));
                    const i = this.reference_;
                    let r = !1;
                    i.id !== e.id && (e.id = i.id,
                    r = !0);
                    const {dataSource: s} = t;
                    return s.layer.dataSources[e.sourceIndex] !== s && (e.sourceIndex = t.sourceIndex,
                    r = !0),
                    void (r && this.changed.dispatch())
                }
                const i = n.states.find(t=>t.sourceIndex === e.sourceIndex && (void 0 === e.subsource || t.subsourceId === e.subsource));
                void 0 !== i ? (this.annotationLayer_ = i,
                (this.reference_ = i.source.getReference(e.id)).changed.add(this.referenceChanged),
                i.source.changed.add(this.validate),
                i.dataSource.layer.dataSourcesChanged.add(this.validate),
                this.changed.dispatch()) : n.isLoading || (this.value_ = void 0,
                this.changed.dispatch())
            }
            ,
            this.registerDisposer(e.isLoadingChanged.add(this.validate))
        }
        get reference() {
            return this.reference_
        }
        get selectedAnnotationLayer() {
            return this.annotationLayer_
        }
        get value() {
            return this.validate(),
            this.value_
        }
        get validValue() {
            return this.validate(),
            this.annotationLayer_ && this.value_
        }
        set value(e) {
            if (this.value_ === e)
                return;
            if (this.value_ = e,
            void 0 === e)
                return this.unbindReference(),
                void this.changed.dispatch();
            const t = this.reference_;
            if (void 0 !== t) {
                const n = this.annotationLayer_;
                (void 0 === e || t.id !== e.id || n.sourceIndex !== e.sourceIndex || void 0 !== n.subsourceId && n.subsourceId !== e.subsource) && this.unbindReference()
            }
            this.validate(),
            this.changed.dispatch()
        }
        disposed() {
            this.unbindReference(),
            super.disposed()
        }
        unbindReference() {
            const e = this.reference_;
            if (void 0 !== e) {
                e.changed.remove(this.referenceChanged);
                const t = this.annotationLayer_;
                t.source.changed.remove(this.validate),
                t.dataSource.layer.dataSourcesChanged.remove(this.validate),
                this.reference_ = void 0,
                this.annotationLayer_ = void 0
            }
        }
        toJSON() {
            const e = this.value_;
            if (void 0 === e)
                return;
            let t = e.partIndex;
            0 === t && (t = void 0);
            let n = e.sourceIndex;
            return 0 === n && (n = void 0),
            {
                id: e.id,
                partIndex: t,
                source: n,
                subsource: e.subsource
            }
        }
        reset() {
            this.value = void 0
        }
        restoreState(e) {
            void 0 !== e ? "string" != typeof e ? (Object(we.w)(e),
            this.value = {
                id: Object(we.y)(e, "id", we.E),
                partIndex: Object(we.B)(e, "partIndex", we.u),
                sourceIndex: Object(we.B)(e, "source", we.u, 0),
                subsource: Object(we.B)(e, "subsource", we.E)
            }) : this.value = {
                id: e,
                partIndex: 0,
                sourceIndex: 0
            } : this.value = void 0
        }
    }
    function je(e, t, n) {
        const i = t.layerRank
          , r = new Float32Array(i)
          , s = new Float32Array(i);
        s.set(e),
        xe.i(r, t.chunkToLayerTransform, i + 1, s, i);
        const a = /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function(e) {
            let t = "(";
            for (let n = 0, i = e.length; n < i; ++n)
                0 !== n && (t += ", "),
                t += Math.floor(e[n]).toString();
            return t += ")",
            t
        }(r);
        if (void 0 !== n) {
            const e = document.createElement("span");
            return e.className = "neuroglancer-voxel-coordinates-link",
            e.textContent = a,
            e.title = `Center view on coordinates ${a}.`,
            e.addEventListener("click", ()=>{
                n(r)
            }
            ),
            e
        }
        return document.createTextNode(a)
    }
    function Ne(e, t, n, r) {
        const s = e=>je(e, n, r);
        switch (t.type) {
        case i.e.AXIS_ALIGNED_BOUNDING_BOX:
        case i.e.LINE:
            e.appendChild(s(t.pointA)),
            e.appendChild(document.createTextNode("")),
            e.appendChild(s(t.pointB));
            break;
        case i.e.POINT:
            e.appendChild(s(t.point));
            break;
        case i.e.ELLIPSOID:
            e.appendChild(s(t.center));
            const r = n.layerRank
              , a = new Float32Array(r);
            xe.j(a, n.chunkToLayerTransform, r + 1, t.radii, r),
            e.appendChild(document.createTextNode("" + function(e) {
                let t = "";
                for (let n = 0, i = e.length; n < i; ++n)
                    0 !== n && (t += "  "),
                    t += Math.round(Math.abs(e[n]));
                return t
            }(a)))
        }
    }
    function Ve(e, t, n) {
        const {globalPosition: i} = e.manager.root
          , {localPosition: r} = e
          , {modelTransform: s} = t;
        Object(l.f)(i.value, n, s.globalToRenderLayerDimensions),
        Object(l.f)(r.value, n, s.localToRenderLayerDimensions),
        r.changed.dispatch(),
        i.changed.dispatch()
    }
    class Be extends Le.b {
        constructor(e, t, n) {
            super(),
            this.layer = e,
            this.state = t,
            this.displayState = n,
            this.previousSelectedId = void 0,
            this.previousSelectedAnnotationLayerState = void 0,
            this.previousHoverId = void 0,
            this.previousHoverAnnotationLayerState = void 0,
            this.listContainer = document.createElement("div"),
            this.updated = !1,
            this.mutableControls = document.createElement("div"),
            this.headerRow = document.createElement("div"),
            this.attachedAnnotationStates = new Map,
            this.forceUpdateView = ()=>{
                this.updated = !1,
                this.updateView()
            }
            ,
            this.globalDimensionIndices = [],
            this.localDimensionIndices = [],
            this.curCoordinateSpaceGeneration = -1,
            this.prevCoordinateSpaceGeneration = -1,
            this.element.classList.add("neuroglancer-annotation-layer-view"),
            this.listContainer.classList.add("neuroglancer-annotation-list"),
            this.registerDisposer(t),
            this.registerDisposer(this.visibility.changed.add(()=>this.updateView())),
            this.registerDisposer(t.annotationStates.changed.add(()=>this.updateAttachedAnnotationLayerStates())),
            this.headerRow.classList.add("neuroglancer-annotation-list-header");
            const r = document.createElement("div");
            r.className = "neuroglancer-annotation-toolbox",
            e.initializeAnnotationLayerViewTab(this);
            const s = this.registerDisposer(new Te.a(this.displayState.color));
            s.element.title = "Change annotation display color",
            this.registerDisposer(new ve.a(Object(Y.h)(e=>null !== e.match(/\bdefaultColor\b/), n.shaderControls.processedFragmentMain),s.element)),
            r.appendChild(s.element);
            const {mutableControls: a} = this
              , o = Object(De.a)({
                text: Object(i.k)(i.e.POINT).icon,
                title: "Annotate point",
                onClick: ()=>{
                    this.layer.tool.value = new Ge(this.layer,{})
                }
            });
            a.appendChild(o);
            const l = Object(De.a)({
                text: Object(i.k)(i.e.AXIS_ALIGNED_BOUNDING_BOX).icon,
                title: "Annotate bounding box",
                onClick: ()=>{
                    this.layer.tool.value = new Je(this.layer,{})
                }
            });
            a.appendChild(l);
            const c = Object(De.a)({
                text: Object(i.k)(i.e.LINE).icon,
                title: "Annotate line",
                onClick: ()=>{
                    this.layer.tool.value = new qe(this.layer,{})
                }
            });
            a.appendChild(c);
            const u = Object(De.a)({
                text: Object(i.k)(i.e.ELLIPSOID).icon,
                title: "Annotate ellipsoid",
                onClick: ()=>{
                    this.layer.tool.value = new Ye(this.layer,{})
                }
            });
            a.appendChild(u),
            r.appendChild(a),
            this.element.appendChild(r),
            this.element.appendChild(this.listContainer),
            this.listContainer.addEventListener("mouseleave", ()=>{
                this.displayState.hoverState.value = void 0
            }
            ),
            this.registerDisposer(this.displayState.hoverState.changed.add(()=>this.updateHoverView())),
            this.registerDisposer(this.state.changed.add(()=>this.updateSelectionView())),
            this.registerDisposer(this.layer.localCoordinateSpace.changed.add(()=>{
                this.updateCoordinateSpace(),
                this.updateView()
            }
            )),
            this.registerDisposer(this.layer.manager.root.coordinateSpace.changed.add(()=>{
                this.updateCoordinateSpace(),
                this.updateView()
            }
            )),
            this.updateCoordinateSpace(),
            this.updateAttachedAnnotationLayerStates()
        }
        get annotationStates() {
            return this.state.annotationStates
        }
        updateAttachedAnnotationLayerStates() {
            const e = this.annotationStates.states
              , {attachedAnnotationStates: t} = this
              , n = new Map;
            for (const [n,i] of t)
                e.includes(n) || (t.delete(n),
                i.listElements.clear(),
                i.refCounted.dispose());
            for (const r of e) {
                const e = t.get(r);
                if (void 0 !== e) {
                    n.set(r, e);
                    continue
                }
                const s = r.source
                  , a = new M.a;
                s instanceof i.d && (a.registerDisposer(s.childAdded.add(e=>this.addAnnotationElement(e, r))),
                a.registerDisposer(s.childUpdated.add(e=>this.updateAnnotationElement(e, r))),
                a.registerDisposer(s.childDeleted.add(e=>this.deleteAnnotationElement(e, r)))),
                a.registerDisposer(r.transform.changed.add(this.forceUpdateView));
                const o = document.createElement("div");
                o.classList.add("neuroglancer-annotation-sublist"),
                n.set(r, {
                    refCounted: a,
                    listElements: new Map,
                    sublistContainer: o
                })
            }
            this.attachedAnnotationStates = n,
            t.clear(),
            this.updateCoordinateSpace(),
            this.forceUpdateView()
        }
        updateCoordinateSpace() {
            const e = this.layer.localCoordinateSpace.value
              , t = this.layer.manager.root.coordinateSpace.value
              , n = []
              , i = [];
            for (let e = 0, i = t.rank; e < i; ++e)
                this.annotationStates.states.some(t=>{
                    const n = t.transform.value;
                    return void 0 === n.error && -1 !== n.globalToRenderLayerDimensions[e]
                }
                ) && n.push(e);
            for (let t = 0, n = e.rank; t < n; ++t)
                this.annotationStates.states.some(e=>{
                    const n = e.transform.value;
                    return void 0 === n.error && -1 !== n.localToRenderLayerDimensions[t]
                }
                ) && i.push(t);
            Object(l.a)(n, this.globalDimensionIndices) && Object(l.a)(i, this.localDimensionIndices) || (this.localDimensionIndices = i,
            this.globalDimensionIndices = n,
            ++this.curCoordinateSpaceGeneration)
        }
        clearSelectionClass() {
            const {previousSelectedAnnotationLayerState: e, previousSelectedId: t} = this;
            if (void 0 !== e) {
                this.previousSelectedAnnotationLayerState = void 0,
                this.previousSelectedId = void 0;
                const n = this.attachedAnnotationStates.get(e);
                if (void 0 === n)
                    return;
                const i = n.listElements.get(t);
                void 0 !== i && i.classList.remove("neuroglancer-annotation-selected")
            }
        }
        clearHoverClass() {
            const {previousHoverId: e, previousHoverAnnotationLayerState: t} = this;
            if (void 0 !== t) {
                this.previousHoverAnnotationLayerState = void 0,
                this.previousHoverId = void 0;
                const n = this.attachedAnnotationStates.get(t);
                if (void 0 === n)
                    return;
                const i = n.listElements.get(e);
                void 0 !== i && i.classList.remove("neuroglancer-annotation-hover")
            }
        }
        updateSelectionView() {
            const e = this.state.value;
            let t, n;
            void 0 !== e && (t = e.id,
            n = this.state.selectedAnnotationLayer);
            const {previousSelectedId: i, previousSelectedAnnotationLayerState: r} = this;
            if (t === i && r === n)
                return;
            if (this.clearSelectionClass(),
            this.previousSelectedId = t,
            this.previousSelectedAnnotationLayerState = n,
            void 0 === t)
                return;
            const s = this.attachedAnnotationStates.get(n);
            if (void 0 === s)
                return;
            const a = s.listElements.get(t);
            void 0 !== a && (a.classList.add("neuroglancer-annotation-selected"),
            a.scrollIntoView())
        }
        updateHoverView() {
            const e = this.displayState.hoverState.value;
            let t, n;
            void 0 !== e && (t = e.id,
            n = e.annotationLayerState);
            const {previousHoverId: i, previousHoverAnnotationLayerState: r} = this;
            if (t === i && n === r)
                return;
            if (this.clearHoverClass(),
            this.previousHoverId = t,
            this.previousHoverAnnotationLayerState = n,
            void 0 === t)
                return;
            const s = this.attachedAnnotationStates.get(n);
            if (void 0 === s)
                return;
            const a = s.listElements.get(t);
            void 0 !== a && a.classList.add("neuroglancer-annotation-hover")
        }
        updateView() {
            if (!this.visible)
                return;
            if (this.curCoordinateSpaceGeneration !== this.prevCoordinateSpaceGeneration) {
                this.updated = !1;
                const {headerRow: e} = this
                  , t = document.createElement("div");
                t.style.gridColumn = "symbol";
                const n = document.createElement("div");
                n.style.gridColumn = "delete",
                Object(Se.b)(e),
                e.appendChild(t);
                let i = 0;
                const r = (t,n)=>{
                    const r = document.createElement("div");
                    r.classList.add("neuroglancer-annotations-view-dimension");
                    const s = document.createElement("span");
                    s.classList.add("neuroglancer-annotations-view-dimension-name"),
                    s.textContent = t.names[n];
                    const a = document.createElement("scale");
                    a.classList.add("neuroglancer-annotations-view-dimension-scale"),
                    a.textContent = Object(Ce.b)(t.scales[n], t.units[n], {
                        precision: 2
                    }),
                    r.appendChild(s),
                    r.appendChild(a),
                    r.style.gridColumn = `dim ${i + 1}`,
                    ++i,
                    e.appendChild(r)
                }
                  , s = this.layer.manager.root.coordinateSpace.value;
                for (const e of this.globalDimensionIndices)
                    r(s, e);
                const a = this.layer.localCoordinateSpace.value;
                for (const e of this.localDimensionIndices)
                    r(a, e);
                e.appendChild(n),
                this.listContainer.style.gridTemplateColumns = `[symbol] min-content repeat(${i}, [dim] min-content) [delete] min-content`,
                this.prevCoordinateSpaceGeneration = this.curCoordinateSpaceGeneration
            }
            if (this.updated)
                return;
            let e = !1;
            const t = this;
            Object(Se.d)(this.listContainer, function*() {
                yield t.headerRow;
                for (const [n,{sublistContainer: i, listElements: r}] of t.attachedAnnotationStates)
                    if (n.source.readonly || (e = !0),
                    Object(Se.b)(i),
                    r.clear(),
                    void 0 === n.chunkTransform.value.error) {
                        for (const e of n.source)
                            i.appendChild(t.makeAnnotationListElement(e, n));
                        yield i
                    }
            }()),
            this.mutableControls.style.display = e ? "contents" : "none",
            this.resetOnUpdate()
        }
        addAnnotationElement(e, t) {
            if (!this.visible)
                return void (this.updated = !1);
            if (!this.updated)
                return void this.updateView();
            const n = this.attachedAnnotationStates.get(t);
            void 0 !== n && n.sublistContainer.appendChild(this.makeAnnotationListElement(e, t)),
            this.resetOnUpdate()
        }
        updateAnnotationElement(e, t) {
            if (!this.visible)
                return void (this.updated = !1);
            if (!this.updated)
                return void this.updateView();
            const n = this.attachedAnnotationStates.get(t);
            if (void 0 !== n) {
                const {listElements: i} = n
                  , r = i.get(e.id);
                if (void 0 !== r) {
                    const s = this.makeAnnotationListElement(e, t);
                    n.sublistContainer.replaceChild(s, r),
                    i.set(e.id, s)
                }
            }
            this.resetOnUpdate()
        }
        deleteAnnotationElement(e, t) {
            if (!this.visible)
                return void (this.updated = !1);
            if (!this.updated)
                return void this.updateView();
            const n = this.attachedAnnotationStates.get(t);
            if (void 0 !== n) {
                let t = n.listElements.get(e);
                void 0 !== t && (Object(Se.c)(t),
                n.listElements.delete(e))
            }
            this.resetOnUpdate()
        }
        resetOnUpdate() {
            this.clearHoverClass(),
            this.clearSelectionClass(),
            this.updated = !0,
            this.updateHoverView(),
            this.updateSelectionView()
        }
        makeAnnotationListElement(e, t) {
            const n = t.chunkTransform.value
              , r = document.createElement("div");
            r.classList.add("neuroglancer-annotation-list-entry"),
            r.title = "Click to select, right click to recenter view.";
            const s = document.createElement("div");
            let a;
            s.className = "neuroglancer-annotation-icon",
            s.textContent = Object(i.k)(e.type).icon,
            s.classList.add("neuroglancer-annotation-list-entry-highlight"),
            r.appendChild(s);
            let o = 0;
            const {layerRank: l} = n
              , c = new Float32Array(l)
              , u = (i,s=!1)=>{
                ++o;
                const u = document.createElement("div");
                u.className = "neuroglancer-annotation-position",
                r.appendChild(u),
                c.set(i);
                const d = new Float32Array(l);
                (s ? xe.j : xe.i)(d, n.chunkToLayerTransform, l + 1, c, l);
                let h = 0;
                const p = (e,t)=>{
                    for (const n of e) {
                        const e = t[n];
                        if (-1 !== e) {
                            const t = Math.floor(d[e])
                              , n = document.createElement("div");
                            n.textContent = t.toString(),
                            n.classList.add("neuroglancer-annotation-coordinate"),
                            n.classList.add("neuroglancer-annotation-list-entry-highlight"),
                            n.style.gridColumn = `dim ${h + 1}`,
                            u.appendChild(n)
                        }
                        ++h
                    }
                }
                ;
                p(this.globalDimensionIndices, n.modelTransform.globalToRenderLayerDimensions),
                p(this.localDimensionIndices, n.modelTransform.localToRenderLayerDimensions),
                t.source.readonly || void 0 === a && (a = Object(Me.a)({
                    title: "Delete annotation",
                    onClick: ()=>{
                        const n = t.source.getReference(e.id);
                        try {
                            t.source.delete(n)
                        } finally {
                            n.dispose()
                        }
                    }
                }),
                a.classList.add("neuroglancer-annotation-list-entry-delete"),
                r.appendChild(a))
            }
            ;
            switch (e.type) {
            case i.e.POINT:
                u(e.point);
                break;
            case i.e.AXIS_ALIGNED_BOUNDING_BOX:
            case i.e.LINE:
                u(e.pointA),
                u(e.pointB);
                break;
            case i.e.ELLIPSOID:
                u(e.center),
                u(e.radii, !0)
            }
            if (e.description) {
                ++o;
                const t = document.createElement("div");
                t.classList.add("neuroglancer-annotation-description"),
                t.classList.add("neuroglancer-annotation-list-entry-highlight"),
                t.textContent = e.description,
                r.appendChild(t)
            }
            return s.style.gridRow = `span ${o}`,
            void 0 !== a && (a.style.gridRow = `span ${o}`),
            this.attachedAnnotationStates.get(t).listElements.set(e.id, r),
            r.addEventListener("mouseenter", ()=>{
                this.displayState.hoverState.value = {
                    id: e.id,
                    partIndex: 0,
                    annotationLayerState: t
                }
            }
            ),
            r.addEventListener("click", ()=>{
                this.state.value = {
                    id: e.id,
                    partIndex: 0,
                    sourceIndex: t.sourceIndex,
                    subsource: t.subsourceId
                }
            }
            ),
            r.addEventListener("mouseup", t=>{
                if (2 === t.button) {
                    const {layerRank: t} = n
                      , r = new Float32Array(t)
                      , s = new Float32Array(t);
                    !function(e, t) {
                        switch (t.type) {
                        case i.e.AXIS_ALIGNED_BOUNDING_BOX:
                        case i.e.LINE:
                            ke.a(e, t.pointA, t.pointB),
                            ke.f(e, e, .5);
                            break;
                        case i.e.POINT:
                            e.set(t.point);
                            break;
                        case i.e.ELLIPSOID:
                            e.set(t.center)
                        }
                    }(r, e),
                    xe.i(s, n.chunkToLayerTransform, t + 1, r, t),
                    Ve(this.layer, n, s)
                }
            }
            ),
            r
        }
    }
    class Fe extends Le.b {
        constructor(e, t, n) {
            super(),
            this.state = e,
            this.displayState = t,
            this.setLayerPosition = n,
            this.valid = !1,
            this.mouseEntered = !1,
            this.viewDisposer = void 0,
            this.element.classList.add("neuroglancer-annotation-details"),
            this.registerDisposer(e),
            this.registerDisposer(this.state.changed.add(()=>{
                this.valid = !1,
                this.updateView()
            }
            )),
            this.registerDisposer(this.visibility.changed.add(()=>this.updateView())),
            this.state.changed.add(()=>{
                this.valid = !1,
                this.updateView()
            }
            ),
            this.element.addEventListener("mouseenter", ()=>{
                this.mouseEntered = !0;
                const e = this.state.value
                  , t = this.state.selectedAnnotationLayer;
                this.displayState.hoverState.value = void 0 !== t && void 0 !== e ? {
                    id: e.id,
                    partIndex: e.partIndex || 0,
                    annotationLayerState: t
                } : void 0
            }
            ),
            this.element.addEventListener("mouseleave", ()=>{
                this.mouseEntered = !1,
                this.displayState.hoverState.value = void 0
            }
            ),
            this.updateView()
        }
        disposed() {
            const {viewDisposer: e} = this;
            void 0 !== e && (e.dispose(),
            this.viewDisposer = void 0),
            super.disposed()
        }
        updateView() {
            if (!this.visible)
                return void (this.element.style.display = "none");
            if (this.element.style.display = "",
            this.valid)
                return;
            const {element: e} = this;
            Object(Se.b)(e),
            this.valid = !0;
            const {reference: t} = this.state;
            if (void 0 === t)
                return;
            const n = this.state.value
              , r = t.value;
            if (null == r)
                return;
            const s = this.state.selectedAnnotationLayer;
            this.mouseEntered && (this.displayState.hoverState.value = {
                id: n.id,
                partIndex: n.partIndex || 0,
                annotationLayerState: s
            });
            const a = Object(i.k)(r.type)
              , o = document.createElement("div");
            o.className = "neuroglancer-annotation-details-title";
            const l = document.createElement("div");
            l.className = "neuroglancer-annotation-details-icon",
            l.textContent = a.icon;
            const c = document.createElement("div");
            c.className = "neuroglancer-annotation-details-title-text",
            c.textContent = `${a.description}`,
            o.appendChild(l),
            o.appendChild(c),
            s.source.readonly || o.appendChild(Object(Me.a)({
                title: "Delete annotation",
                onClick: ()=>{
                    const e = s.source.getReference(n.id);
                    try {
                        s.source.delete(e)
                    } finally {
                        e.dispose()
                    }
                }
            }));
            const u = Object(Ee.a)();
            u.title = "Hide annotation details",
            u.addEventListener("click", ()=>{
                this.state.value = void 0
            }
            ),
            o.appendChild(u),
            e.appendChild(o);
            const d = s.chunkTransform.value;
            if (void 0 === d.error) {
                const t = document.createElement("div");
                t.className = "neuroglancer-annotation-details-position",
                Ne(t, r, d, e=>this.setLayerPosition(e, s)),
                e.appendChild(t)
            }
            let {viewDisposer: h} = this;
            void 0 !== h && h.dispose(),
            h = this.viewDisposer = new M.a;
            const {relationships: p, properties: f} = s.source;
            for (let n = 0, i = p.length; n < i; ++n) {
                const i = h.registerDisposer(new Ie(t,s,n))
                  , r = document.createElement("label")
                  , a = document.createElement("span");
                a.classList.add("neuroglancer-annotation-relationship-label"),
                a.textContent = p[n],
                r.appendChild(a),
                r.appendChild(i.element),
                e.appendChild(r)
            }
            for (let t = 0, n = f.length; t < n; ++t) {
                const n = f[t]
                  , i = document.createElement("label")
                  , s = document.createElement("span");
                s.classList.add("neuroglancer-annotation-property-label"),
                s.textContent = n.identifier,
                i.appendChild(s);
                const {description: a} = n;
                void 0 !== a && (i.title = a);
                const o = r.properties[t]
                  , l = document.createElement("span");
                l.classList.add("neuroglancer-annotation-property-value"),
                l.textContent = o.toString(),
                i.appendChild(l),
                e.appendChild(i)
            }
            if (!s.source.readonly || r.description) {
                const n = document.createElement("textarea");
                n.value = r.description || "",
                n.rows = 3,
                n.className = "neuroglancer-annotation-details-description",
                n.placeholder = "Description",
                s.source.readonly ? n.readOnly = !0 : n.addEventListener("change", ()=>{
                    const e = n.value;
                    s.source.update(t, Object.assign(Object.assign({}, r), {
                        description: e || void 0
                    })),
                    s.source.commit(t)
                }
                ),
                e.appendChild(n)
            }
        }
    }
    class _e extends Le.b {
        constructor(e, t) {
            super(),
            this.layer = e,
            this.state = t,
            this.layerView = this.registerDisposer(new Be(this.layer,this.state.addRef(),this.layer.annotationDisplayState)),
            this.detailsTab = this.registerDisposer(new Fe(this.state,this.layer.annotationDisplayState,(e,t)=>Ve(this.layer, t.chunkTransform.value, e))),
            this.registerDisposer(t);
            const {element: n} = this;
            n.classList.add("neuroglancer-annotations-tab"),
            n.appendChild(this.layerView.element),
            n.appendChild(this.detailsTab.element);
            const i = ()=>{
                this.detailsTab.visibility.value = void 0 !== this.state.validValue && this.visible ? Z.b.VISIBLE : Z.b.IGNORED
            }
            ;
            this.registerDisposer(this.state.changed.add(i)),
            this.registerDisposer(this.visibility.changed.add(i))
        }
    }
    function Ue(e) {
        let t = [];
        const {relationships: n} = e.source
          , {relationshipStates: i} = e.displayState;
        for (let e = 0, r = n.length; e < r; ++e) {
            const r = i.get(n[e]).segmentationState.value;
            null != r && r.segmentSelectionState.hasSelectedSegment ? t[e] = [r.segmentSelectionState.selectedSegment.clone()] : t[e] = []
        }
        return t
    }
    class ze extends be.a {
        constructor(e, t) {
            super(),
            this.layer = e,
            this.annotationDescription = Object(we.y)(t, "description", we.C)
        }
        get annotationLayer() {
            for (const e of this.layer.annotationStates.states)
                if (!e.source.readonly)
                    return e
        }
    }
    class Ge extends ze {
        constructor(e, t) {
            super(e, t)
        }
        trigger(e) {
            const {annotationLayer: t} = this;
            if (void 0 !== t && e.active) {
                const n = $e(e, t);
                if (void 0 === n)
                    return;
                const r = {
                    id: "",
                    description: "",
                    relatedSegments: Ue(t),
                    point: n,
                    type: i.e.POINT,
                    properties: t.source.properties.map(e=>e.default)
                }
                  , s = t.source.add(r, !0);
                this.layer.selectedAnnotation.value = {
                    id: s.id,
                    sourceIndex: t.sourceIndex,
                    subsource: t.subsourceId
                },
                s.dispose()
            }
        }
        get description() {
            return "annotate point"
        }
        toJSON() {
            return "annotatePoint"
        }
    }
    function $e(e, t) {
        const n = t.chunkTransform.value;
        if (void 0 !== n.error)
            return;
        const i = new Float32Array(n.modelTransform.unpaddedRank);
        return Object(B.d)(i, e.position, t.localPosition.value, n.layerRank, n.combinedGlobalLocalToChunkTransform) ? i : void 0
    }
    class We extends ze {
        trigger(e) {
            const {annotationLayer: t} = this;
            if (void 0 !== t && e.active) {
                const n = ()=>{
                    const n = this.inProgressAnnotation
                      , r = n.reference
                      , s = this.getUpdatedAnnotation(r.value, e, t);
                    JSON.stringify(Object(i.h)(s, t.source)) !== JSON.stringify(Object(i.h)(r.value, t.source)) && (n.annotationLayer.source.update(r, s),
                    this.layer.selectedAnnotation.value = {
                        id: r.id,
                        sourceIndex: t.sourceIndex,
                        subsource: t.subsourceId
                    })
                }
                ;
                if (void 0 === this.inProgressAnnotation) {
                    const i = t.source.add(this.getInitialAnnotation(e, t), !1);
                    this.layer.selectedAnnotation.value = {
                        id: i.id,
                        sourceIndex: t.sourceIndex,
                        subsource: t.subsourceId
                    };
                    const r = e.changed.add(n)
                      , s = ()=>{
                        r(),
                        i.dispose()
                    }
                    ;
                    this.inProgressAnnotation = {
                        annotationLayer: t,
                        reference: i,
                        disposer: s
                    }
                } else
                    n(),
                    this.inProgressAnnotation.annotationLayer.source.commit(this.inProgressAnnotation.reference),
                    this.inProgressAnnotation.disposer(),
                    this.inProgressAnnotation = void 0
            }
        }
        disposed() {
            this.deactivate(),
            super.disposed()
        }
        deactivate() {
            void 0 !== this.inProgressAnnotation && (this.inProgressAnnotation.annotationLayer.source.delete(this.inProgressAnnotation.reference),
            this.inProgressAnnotation.disposer(),
            this.inProgressAnnotation = void 0)
        }
    }
    class He extends We {
        getInitialAnnotation(e, t) {
            const n = $e(e, t);
            return {
                id: "",
                type: this.annotationType,
                description: "",
                pointA: n,
                pointB: n,
                properties: t.source.properties.map(e=>e.default)
            }
        }
        getUpdatedAnnotation(e, t, n) {
            const i = $e(t, n);
            return void 0 === i ? e : Object.assign(Object.assign({}, e), {
                pointB: i
            })
        }
    }
    class Je extends He {
        get description() {
            return "annotate bounding box"
        }
        toJSON() {
            return "annotateBoundingBox"
        }
    }
    Je.prototype.annotationType = i.e.AXIS_ALIGNED_BOUNDING_BOX;
    class qe extends He {
        get description() {
            return "annotate line"
        }
        getInitialAnnotation(e, t) {
            const n = super.getInitialAnnotation(e, t);
            return this.initialRelationships = n.relatedSegments = Ue(t),
            n
        }
        getUpdatedAnnotation(e, t, n) {
            const i = super.getUpdatedAnnotation(e, t, n)
              , r = this.initialRelationships
              , s = Ue(n);
            return i.relatedSegments = void 0 === r ? s : Array.from(s, (e,t)=>{
                const n = r[t];
                return e = e.filter(e=>-1 === n.findIndex(t=>Oe.a.equal(e, t))),
                [...n, ...e]
            }
            ),
            i
        }
        toJSON() {
            return "annotateLine"
        }
    }
    qe.prototype.annotationType = i.e.LINE;
    class Ye extends We {
        getInitialAnnotation(e, t) {
            const n = $e(e, t);
            return {
                type: i.e.ELLIPSOID,
                id: "",
                description: "",
                segments: Ue(t),
                center: n,
                radii: b.t.fromValues(0, 0, 0),
                properties: t.source.properties.map(e=>e.default)
            }
        }
        getUpdatedAnnotation(e, t, n) {
            const i = $e(t, n);
            if (void 0 === i)
                return e;
            const r = e.center
              , s = r.length;
            for (let e = 0; e < s; ++e)
                i[e] = Math.abs(r[e] - i[e]);
            return Object.assign(Object.assign({}, e), {
                radii: i
            })
        }
        get description() {
            return "annotate ellipsoid"
        }
        toJSON() {
            return "annotateSphere"
        }
    }
    Object(be.b)("annotatePoint", (e,t)=>new Ge(e,t)),
    Object(be.b)("annotateBoundingBox", (e,t)=>new Je(e,t)),
    Object(be.b)("annotateLine", (e,t)=>new qe(e,t)),
    Object(be.b)("annotateSphere", (e,t)=>new Ye(e,t));
    function Xe(e) {
        return class extends e {
            constructor(...e) {
                let t;
                super(...e),
                this.annotationStates = this.registerDisposer(new Pe),
                this.annotationDisplayState = new r.a,
                this.selectedAnnotation = this.registerDisposer(new Re(this.annotationStates)),
                this.annotationCrossSectionRenderScaleHistogram = new me.a,
                this.annotationCrossSectionRenderScaleTarget = Object(me.e)(8),
                this.annotationProjectionRenderScaleHistogram = new me.a,
                this.annotationProjectionRenderScaleTarget = Object(me.e)(8),
                this.selectedAnnotation.changed.add(this.specificationChanged.dispatch),
                this.annotationDisplayState.color.changed.add(this.specificationChanged.dispatch),
                this.annotationDisplayState.shader.changed.add(this.specificationChanged.dispatch),
                this.annotationDisplayState.shaderControls.changed.add(this.specificationChanged.dispatch),
                this.tabs.add("annotations", {
                    label: "Annotations",
                    order: 10,
                    getter: ()=>new _e(this,this.selectedAnnotation.addRef())
                });
                const n = ()=>{
                    const e = this.isReady;
                    e && void 0 !== t ? (t(),
                    t = void 0) : e || void 0 !== t || (t = this.annotationStates.markLoading())
                }
                ;
                this.readyStateChanged.add(n),
                n();
                const {mouseState: i} = this.manager.layerSelectedValues;
                this.registerDisposer(i.changed.add(()=>{
                    if (i.active) {
                        const {pickedAnnotationLayer: e} = i;
                        if (void 0 !== e && this.annotationStates.states.includes(e)) {
                            const t = this.annotationDisplayState.hoverState.value;
                            return void (void 0 !== t && t.id === i.pickedAnnotationId && t.partIndex === i.pickedOffset && t.annotationLayerState === e || (this.annotationDisplayState.hoverState.value = {
                                id: i.pickedAnnotationId,
                                partIndex: i.pickedOffset,
                                annotationLayerState: e
                            }))
                        }
                    }
                    this.annotationDisplayState.hoverState.value = void 0
                }
                ))
            }
            initializeAnnotationLayerViewTab(e) {}
            restoreState(e) {
                super.restoreState(e),
                this.selectedAnnotation.restoreState(e.selectedAnnotation),
                this.annotationDisplayState.color.restoreState(e.annotationColor),
                this.annotationDisplayState.shader.restoreState(e.shader),
                this.annotationDisplayState.shaderControls.restoreState(e.shaderControls)
            }
            addLocalAnnotations(e, t, n) {
                const {subsourceEntry: i} = e
                  , s = new r.b({
                    localPosition: this.localPosition,
                    transform: e.getRenderLayerTransform(),
                    source: t,
                    displayState: this.annotationDisplayState,
                    dataSource: e.loadedDataSource.layerDataSource,
                    subsourceIndex: e.subsourceIndex,
                    subsourceId: i.id,
                    role: n
                });
                this.addAnnotationLayerState(s, e)
            }
            addStaticAnnotations(e) {
                const {subsourceEntry: t} = e
                  , {staticAnnotations: n} = t.subsource;
                return void 0 !== n && (e.activate(()=>{
                    this.addLocalAnnotations(e, n, ge.c.DEFAULT_ANNOTATION)
                }
                ),
                !0)
            }
            addAnnotationLayerState(e, t) {
                const n = t.activated;
                n.registerDisposer(this.annotationStates.add(e));
                const i = new re(this.manager.chunkManager,e.addRef());
                if (i.source instanceof s.b) {
                    const e = new pe({
                        annotationLayer: i.addRef(),
                        renderScaleTarget: this.annotationCrossSectionRenderScaleTarget,
                        renderScaleHistogram: this.annotationCrossSectionRenderScaleHistogram
                    });
                    n.registerDisposer(t.messages.addChild(e.messages));
                    const r = new he({
                        annotationLayer: i.addRef(),
                        renderScaleTarget: this.annotationProjectionRenderScaleTarget,
                        renderScaleHistogram: this.annotationProjectionRenderScaleHistogram
                    });
                    n.registerDisposer(t.messages.addChild(r.messages)),
                    n.registerDisposer(Object(Y.j)((t,n)=>{
                        n && (t.registerDisposer(this.addRenderLayer(e.addRef())),
                        t.registerDisposer(this.addRenderLayer(r.addRef())))
                    }
                    , this.annotationDisplayState.displayUnfiltered))
                }
                {
                    const e = new fe(i,this.annotationCrossSectionRenderScaleHistogram);
                    n.registerDisposer(this.addRenderLayer(e)),
                    n.registerDisposer(t.messages.addChild(e.messages))
                }
                {
                    const e = new ue(i.addRef(),this.annotationProjectionRenderScaleHistogram);
                    n.registerDisposer(this.addRenderLayer(e)),
                    n.registerDisposer(t.messages.addChild(e.messages))
                }
            }
            toJSON() {
                const e = super.toJSON();
                return e.selectedAnnotation = this.selectedAnnotation.toJSON(),
                e.annotationColor = this.annotationDisplayState.color.toJSON(),
                e.shader = this.annotationDisplayState.shader.toJSON(),
                e.shaderControls = this.annotationDisplayState.shaderControls.toJSON(),
                e
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    var i = n(20);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    async function r(e, t, n, r) {
        if (!n.startsWith("/"))
            throw null;
        const s = await async function(e, t, n, r) {
            const s = await Object(i.b)(`${e}?prefix=${encodeURIComponent(t)}` + `&delimiter=${encodeURIComponent(n)}`, {}, e=>e.text(), r)
              , a = (new DOMParser).parseFromString(s, "application/xml")
              , o = a.evaluate('//*[name()="CommonPrefixes"]/*[name()="Prefix"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null)
              , l = [];
            for (let e = 0, t = o.snapshotLength; e < t; ++e)
                l.push(o.snapshotItem(e).textContent || "");
            const c = a.evaluate('//*[name()="Contents"]/*[name()="Key"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
            for (let e = 0, t = c.snapshotLength; e < t; ++e)
                l.push(c.snapshotItem(e).textContent || "");
            return l
        }(t, n.substring(1), "/", r);
        let a = n.lastIndexOf("/");
        return {
            offset: a + e.length + 1,
            completions: s.map(e=>({
                value: e.substring(a)
            }))
        }
    }
    async function s(e, t) {
        const n = e.match(/^([a-z]+:\/\/.*\/)([^\/?#]*)$/);
        if (null === n)
            throw null;
        const r = await /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        async function(e, t) {
            const {text: n, contentType: r} = await Object(i.b)(e, {
                headers: {
                    accept: "text/html"
                }
            }, async e=>({
                text: await e.text(),
                contentType: e.headers.get("content-type")
            }), t);
            if ("text/html" !== r)
                return [];
            const s = (new DOMParser).parseFromString(n, r)
              , a = s.evaluate("//a/@href", s, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null)
              , o = [];
            for (let t = 0, n = a.snapshotLength; t < n; ++t) {
                const n = a.snapshotItem(t).textContent;
                n && o.push(new URL(n,e).toString())
            }
            return o
        }(n[1], t)
          , s = n[1].length
          , a = [];
        for (const t of r)
            t.startsWith(e) && a.push({
                value: t.substring(s)
            });
        return {
            offset: s,
            completions: a
        }
    }
    async function a(e, t) {
        let n;
        try {
            n = Object(i.e)(e)
        } catch (e) {
            throw null
        }
        const {protocol: a, host: o, path: l} = n;
        if ("gs" === a && l.length > 0)
            return await r(`${a}://${o}`, `https://storage.googleapis.com/${o}`, l, t);
        const c = e.match(/^((?:http|https):\/\/(?:storage\.googleapis\.com\/[^\/]+|[^\/]+\.storage\.googleapis\.com))(\/.*)$/);
        if (null !== c)
            return await r(c[1], c[1], c[2], t);
        if (("http" === a || "https" === a) && l.length > 0)
            return await s(e, t);
        throw null
    }
    n.d(t, "a", (function() {
        return a
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var i = n(16)
      , r = n.n(i)
      , s = n(2)
      , a = n(5)
      , o = class {
        static insertAfter(e, t) {
            let n = e.next0;
            t.next0 = n,
            t.prev0 = e,
            e.next0 = t,
            n.prev0 = t
        }
        static insertBefore(e, t) {
            let n = e.prev0;
            t.prev0 = n,
            t.next0 = e,
            e.prev0 = t,
            n.next0 = t
        }
        static front(e) {
            let t = e.next0;
            return t === e ? null : t
        }
        static back(e) {
            let t = e.prev0;
            return t === e ? null : t
        }
        static pop(e) {
            let t = e.next0
              , n = e.prev0;
            return t.prev0 = n,
            n.next0 = t,
            e.next0 = null,
            e.prev0 = null,
            e
        }
        static*iterator(e) {
            for (let t = e.next0; t !== e; t = t.next0)
                yield t
        }
        static*reverseIterator(e) {
            for (let t = e.prev0; t !== e; t = t.prev0)
                yield t
        }
        static initializeHead(e) {
            e.next0 = e.prev0 = e
        }
    }
    ;
    n.d(t, "a", (function() {
        return u
    }
    ));
    const l = new /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class {
        constructor() {
            o.initializeHead(this)
        }
    }
      , c = r()(()=>{
        const {activeElement: e} = document;
        if (null === e || e === document.body) {
            const e = o.front(l);
            null !== e && e.element.focus()
        }
    }
    );
    window.addEventListener("focus", ()=>{
        c()
    }
    , !0),
    window.addEventListener("blur", ()=>{
        c()
    }
    , !0);
    class u extends s.a {
        constructor(e) {
            super(),
            this.element = e,
            this.prev0 = null,
            this.next0 = null,
            this.lastFocusedElement = null,
            this.scheduleUpdateFocus = this.registerCancellable(r()(()=>{
                const {activeElement: e} = document
                  , {element: t} = this;
                t.contains(e) || Object(a.a)(e) || (null == e || e !== this.lastFocusedElement && !e.contains(t) || this.element.focus(),
                this.lastFocusedElement = null)
            }
            , 0)),
            e.tabIndex = -1,
            this.registerEventListener(e, "pointerdown", t=>{
                t.target === e && (this.lastFocusedElement = null,
                e.focus())
            }
            ),
            this.registerEventListener(e, "mouseenter", ()=>{
                this.lastFocusedElement = document.activeElement,
                this.scheduleUpdateFocus()
            }
            ),
            this.registerEventListener(e, "mouseleave", ()=>{
                this.scheduleUpdateFocus.cancel()
            }
            ),
            o.insertBefore(l, this),
            this.registerEventListener(e, "focus", ()=>{
                o.pop(this),
                o.insertAfter(l, this)
            }
            ),
            c()
        }
        disposed() {
            o.pop(this),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e, t, n, i) {
        t *= 6;
        let r = Math.floor(t)
          , s = t - r
          , a = i * (1 - n)
          , o = i * (1 - n * s)
          , l = i * (1 - n * (1 - s));
        switch (r % 6) {
        case 0:
            e[0] = i,
            e[1] = l,
            e[2] = a;
            break;
        case 1:
            e[0] = o,
            e[1] = i,
            e[2] = a;
            break;
        case 2:
            e[0] = a,
            e[1] = i,
            e[2] = l;
            break;
        case 3:
            e[0] = a,
            e[1] = o,
            e[2] = i;
            break;
        case 4:
            e[0] = l,
            e[1] = a,
            e[2] = i;
            break;
        case 5:
            e[0] = i,
            e[1] = a,
            e[2] = o
        }
        return e
    }
    function r(e, t, n, i) {
        const r = Math.max(Math.max(t, n), i)
          , s = Math.min(Math.min(t, n), i);
        if (e[2] = r,
        s === r)
            e[0] = 0,
            e[1] = 0;
        else {
            const a = r - s;
            e[1] = a / r,
            e[0] = t === r ? (n - i) / a : n === r ? 2 + (i - t) / a : 4 + (t - n) / a,
            e[0] /= 6,
            e[0] < 0 && (e[0] += 1),
            e[0] > 1 && (e[0] -= 1)
        }
        return e
    }
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    ));
    var i = n(23)
      , r = n(2)
      , s = n(98);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class a extends r.a {
    }
    function o(e) {
        let t = 0;
        return function(e) {
            let t, n, r;
            return (s,a)=>void 0 === n || void 0 !== t && void 0 !== s && t.generation === s.generation ? (t = void 0,
            r = new i.c,
            n = e(s, r).then(e=>(t = e,
            r = void 0,
            e), e=>{
                throw r.isCanceled && (r = void 0,
                n = void 0),
                e
            }
            ),
            n) : (void 0 === t && r.addConsumer(a),
            n)
        }((n,i)=>e(i).then(e=>({
            generation: ++t,
            credentials: e
        })))
    }
    class l {
        constructor() {
            this.providers = new Map
        }
        register(e, t) {
            this.providers.set(e, t)
        }
        getCredentialsProvider(e, t) {
            const n = this.providers.get(e);
            if (void 0 === n)
                throw new Error(`No registered credentials provider: ${JSON.stringify(e)}`);
            return n(t)
        }
    }
    class c extends r.a {
        constructor(e) {
            super(),
            this.base = e,
            this.memoize = new s.b
        }
        getCredentialsProvider(e, t) {
            return this.memoize.get({
                key: e,
                parameters: t
            }, ()=>this.registerDisposer(this.base.getCredentialsProvider(e, t).addRef()))
        }
    }
    class u extends c {
        constructor() {
            super(new l)
        }
        register(e, t) {
            this.base.register(e, t)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return y
    }
    ));
    n(170);
    var i = n(16)
      , r = n.n(i)
      , s = n(115)
      , a = n.n(s)
      , o = n(27)
      , l = n(7)
      , c = n(62)
      , u = n(85)
      , d = n(2)
      , h = n(13)
      , p = n(1)
      , f = n(51)
      , m = n(116)
      , g = n(37)
      , v = n(77);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const b = h.a.fromObject({
        mousedown0: {
            action: "set"
        },
        wheel: {
            action: "adjust-via-wheel"
        },
        dblclick0: {
            action: "reset"
        }
    });
    class y extends d.a {
        constructor(e, t) {
            super(),
            this.histogram = e,
            this.target = t,
            this.label = document.createElement("div"),
            this.element = document.createElement("div"),
            this.canvas = document.createElement("canvas"),
            this.legend = document.createElement("div"),
            this.legendRenderScale = document.createElement("div"),
            this.legendSpatialScale = document.createElement("div"),
            this.legendChunks = document.createElement("div"),
            this.ctx = this.canvas.getContext("2d"),
            this.hoverTarget = new l.e(void 0),
            this.throttledUpdateView = this.registerCancellable(a()(()=>this.debouncedUpdateView(), 200, {
                leading: !0,
                trailing: !0
            })),
            this.debouncedUpdateView = this.registerCancellable(r()(()=>this.updateView(), 0));
            const {canvas: n, label: i, element: s, legend: c, legendRenderScale: u, legendSpatialScale: d, legendChunks: p} = this;
            i.className = "neuroglancer-render-scale-widget-prompt",
            s.className = "neuroglancer-render-scale-widget",
            s.title = b.describe(),
            c.className = "neuroglancer-render-scale-widget-legend",
            s.appendChild(i),
            s.appendChild(n),
            s.appendChild(c),
            u.title = "Target resolution of data in screen pixels",
            p.title = "Number of chunks rendered",
            c.appendChild(u),
            c.appendChild(p),
            c.appendChild(d),
            this.registerDisposer(e.changed.add(this.throttledUpdateView)),
            this.registerDisposer(e.visibility.changed.add(this.debouncedUpdateView)),
            this.registerDisposer(t.changed.add(this.debouncedUpdateView)),
            this.registerDisposer(new f.b(n,b)),
            this.registerDisposer(t.changed.add(this.debouncedUpdateView)),
            this.registerDisposer(this.hoverTarget.changed.add(this.debouncedUpdateView));
            const m = e=>{
                const t = e.offsetX / n.width * o.d;
                return Object(o.b)(t)
            }
            ;
            this.registerEventListener(n, "pointermove", e=>{
                this.hoverTarget.value = [m(e), e.offsetY]
            }
            ),
            this.registerEventListener(n, "pointerleave", ()=>{
                this.hoverTarget.value = void 0
            }
            ),
            this.registerDisposer(Object(h.d)(n, "set", e=>{
                this.target.value = m(e.detail)
            }
            )),
            this.registerDisposer(Object(h.d)(n, "adjust-via-wheel", e=>{
                const t = e.detail
                  , {deltaY: n} = t;
                0 !== n && (this.hoverTarget.value = void 0,
                this.target.value *= 2 ** Math.sign(n),
                t.preventDefault())
            }
            )),
            this.registerDisposer(Object(h.d)(n, "reset", e=>{
                this.hoverTarget.value = void 0,
                this.target.reset(),
                e.preventDefault()
            }
            ));
            const g = new v.a(()=>this.debouncedUpdateView());
            g.observe(n),
            this.registerDisposer(()=>g.disconnect()),
            this.updateView()
        }
        updateView() {
            const {ctx: e} = this
              , {canvas: t} = this
              , n = t.width = t.offsetWidth
              , i = t.height = t.offsetHeight
              , r = this.target.value
              , s = this.hoverTarget.value;
            {
                const {legendRenderScale: e} = this
                  , t = function(e) {
                    if (e < 1 || e > 1024) {
                        const t = 0 | Math.log2(e)
                          , n = e / 2 ** t;
                        return `${Object(m.a)(n, 1)}p${t}`
                    }
                    return Math.round(e) + ""
                }(void 0 === s ? r : s[0]);
                e.textContent = t + " px"
            }
            function a(e) {
                return e * n / o.d
            }
            e.clearRect(0, 0, n, i);
            const {histogram: l} = this
              , {value: d, spatialScales: h} = l;
            l.visibility.visible || d.fill(0);
            const f = Array.from(h.keys());
            f.sort();
            const v = p.t.create();
            let b = 1;
            const y = h.size;
            let S = 0
              , w = 0;
            for (let e = 0; e < o.d; ++e) {
                let t = 0;
                for (let n = 0; n < y; ++n) {
                    const i = n * o.d * 2 + e
                      , r = d[i]
                      , s = d[i + o.d];
                    S += r,
                    w += s,
                    t += r + s
                }
                b = Math.max(t, b)
            }
            const x = i / Math.log(1 + b);
            function C(e) {
                return i - Math.log(1 + e) * x
            }
            let O = void 0;
            if (void 0 !== s) {
                const e = Math.floor(Object(o.c)(s[0]));
                if (e >= 0 && e < o.d) {
                    let t = 0;
                    const n = s[1];
                    for (let i = y - 1; i >= 0; --i) {
                        const r = f[i]
                          , s = 2 * h.get(r) * o.d + e
                          , a = d[s] + d[s + o.d];
                        if (0 === a)
                            continue;
                        const l = Math.round(C(t));
                        if (t += a,
                        Math.round(C(t)) <= n && n <= l) {
                            O = r;
                            break
                        }
                    }
                }
            }
            if (void 0 !== O) {
                S = 0,
                w = 0;
                const e = 2 * h.get(O) * o.d;
                for (let t = 0; t < o.d; ++t) {
                    const n = e + t;
                    S += d[n],
                    w += d[n + o.d]
                }
                Number.isFinite(O) ? this.legendSpatialScale.textContent = Object(g.b)(O, "m", {
                    precision: 2,
                    elide1: !1
                }) : this.legendSpatialScale.textContent = "unknown"
            } else
                this.legendSpatialScale.textContent = "";
            this.legendChunks.textContent = `${S}/${S + w}`;
            const k = f.map(e=>{
                const t = e === O ? .5 : 1;
                let n;
                n = Number.isFinite(e) ? (.1 * Math.log2(e) % 1 + 1) % 1 : 0,
                Object(u.a)(v, n, t, 1);
                const i = Object(c.d)(v);
                return Object(u.a)(v, n, t, .5),
                [i, Object(c.d)(v)]
            }
            );
            for (let t = 0; t < o.d; ++t) {
                let n = 0;
                for (let i = y - 1; i >= 0; --i) {
                    const r = f[i]
                      , s = h.get(r) * o.d * 2 + t
                      , l = d[s]
                      , c = d[s + o.d]
                      , u = l + c;
                    if (0 === u)
                        continue;
                    const p = Math.round(a(t))
                      , m = Math.round(a(t + 1))
                      , g = Math.round(C(n));
                    n += u;
                    const v = Math.round(C(n))
                      , b = (l * v + c * g) / u;
                    e.fillStyle = k[i][1],
                    e.fillRect(p, v, m - p, b - v),
                    e.fillStyle = k[i][0],
                    e.fillRect(p, b, m - p, g - b)
                }
            }
            {
                const t = r;
                e.fillStyle = "#fff";
                const n = a(Object(o.c)(t))
                  , s = 1;
                e.fillRect(Math.floor(n), 0, s, i)
            }
            if (void 0 !== s) {
                const t = s[0];
                e.fillStyle = "#888";
                const n = a(Object(o.c)(t))
                  , r = 1;
                e.fillRect(Math.floor(n), 0, r, i)
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return l
    }
    ));
    var i = n(2)
      , r = n(0);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends i.a {
        setActive(e) {}
        deactivate() {}
    }
    function a(e, t) {
        if (void 0 === t)
            return;
        "string" == typeof t && (t = {
            type: t
        }),
        Object(r.w)(t);
        const n = Object(r.y)(t, "type", r.E)
          , i = o.get(n);
        if (void 0 === i)
            throw new Error(`Invalid tool type: ${JSON.stringify(t)}.`);
        return i(e, t)
    }
    const o = new Map;
    function l(e, t) {
        o.set(e, t)
    }
}
, function(e, t, n) {}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE)
    }
    function r(e) {
        e.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_R, WebGL2RenderingContext.CLAMP_TO_EDGE)
    }
    function s(e, t, n, r, s=WebGL2RenderingContext.RGBA8, a=WebGL2RenderingContext.RGBA, o=WebGL2RenderingContext.UNSIGNED_BYTE) {
        e.activeTexture(WebGL2RenderingContext.TEXTURE0 + e.tempTextureUnit),
        e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, t),
        i(e),
        e.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, s, n, r, 0, a, o, null),
        e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null)
    }
    function a(e, t, n) {
        e.activeTexture(WebGL2RenderingContext.TEXTURE0 + e.tempTextureUnit),
        e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, t),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE),
        e.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE),
        e.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 1),
        e.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 4),
        e.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, n),
        e.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 0),
        e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null)
    }
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return a
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(0)
      , r = n(3);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s {
        constructor(e, t, n=t) {
            this.enumType = e,
            this.value_ = t,
            this.defaultValue = n,
            this.changed = new r.a
        }
        set value(e) {
            this.value_ !== e && (this.value_ = e,
            this.changed.dispatch())
        }
        get value() {
            return this.value_
        }
        reset() {
            this.value = this.defaultValue
        }
        restoreState(e) {
            this.value = Object(i.o)(e, this.enumType)
        }
        toJSON() {
            return this.enumType[this.value_].toLowerCase()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(25);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const s = 4;
    function a(e) {
        const t = new Uint16Array(6 * e);
        for (let n = 0; n < e; ++n) {
            const e = n * s;
            let i = 6 * n;
            t[i] = e,
            t[i + 1] = e + 1,
            t[i + 2] = e + 2,
            t[i + 3] = e + 2,
            t[i + 4] = e + 3,
            t[i + 5] = e
        }
        return t
    }
    class o extends i.a {
        constructor(e, t) {
            super(),
            this.quadsPerInstance = t,
            1 !== t && (this.quadIndexBuffer = this.registerDisposer(Object(r.b)(e, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, a, t)).value)
        }
        draw(e, t) {
            1 === this.quadsPerInstance ? e.drawArraysInstanced(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4, t) : (this.quadIndexBuffer.bind(),
            e.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, 6 * this.quadsPerInstance, WebGL2RenderingContext.UNSIGNED_SHORT, 0, t))
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = "vec3 colormapJet(float x) {\n  vec3 result;\n  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);\n  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);\n  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);\n  return clamp(result, 0.0, 1.0);\n}\nvec3 colormapCubehelix(float x) {\n  float xclamp = clamp(x, 0.0, 1.0);\n  float angle = 2.0 * 3.1415926 * (4.0 / 3.0 + xclamp);\n  float amp = xclamp * (1.0 - xclamp) / 2.0;\n  vec3 result;\n  float cosangle = cos(angle);\n  float sinangle = sin(angle);\n  result.r = -0.14861 * cosangle + 1.78277 * sinangle;\n  result.g = -0.29227 * cosangle + -0.90649 * sinangle;\n  result.b = 1.97294 * cosangle;\n  result = clamp(xclamp + amp * result, 0.0, 1.0);\n  return result;\n}\n"
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="plusIconTitle"><path d="M20 12L4 12M12 4L12 20"></path></svg>'
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(7)
      , r = n(0);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function s(e=.5) {
        return new i.c(e,r.t)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var i = n(29)
      , r = n(2)
      , s = n(5)
      , a = n(26);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o extends r.a {
        constructor(e, t, n=new a.b(a.b.VISIBLE)) {
            super(),
            this.model = e,
            this.render = t,
            this.visibility = n,
            this.element = document.createElement("div"),
            this.generation = -1,
            this.currentViewDisposer = void 0,
            this.element.style.display = "contents";
            const r = this.registerCancellable(Object(i.a)(()=>this.updateView()));
            this.registerDisposer(e.changed.add(r)),
            this.registerDisposer(n.changed.add(()=>{
                this.visible && r()
            }
            )),
            this.updateView()
        }
        get visible() {
            return this.visibility.visible
        }
        updateView() {
            if (!this.visible)
                return;
            const {model: e} = this;
            if (e.changed.count === this.generation)
                return;
            this.disposeCurrentView();
            const t = this.currentViewDisposer = new r.a;
            this.render(e.value, this.element, t)
        }
        disposeCurrentView() {
            let {currentViewDisposer: e} = this;
            void 0 !== e && e.dispose(),
            Object(s.b)(this.element)
        }
        disposed() {
            this.disposeCurrentView(),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    var i = n(10)
      , r = n(14)
      , s = n(67)
      , a = n(31);
    class o extends class {
    }
    {
    }
    o.RPC_ID = "single_mesh/SingleMeshSource";
    var l = n(7)
      , c = n(19)
      , u = n(1)
      , d = n(26)
      , h = n(93)
      , p = n(34)
      , f = n(2)
      , m = n(25)
      , g = n(24);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class v extends f.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.buffer = this.registerDisposer(new m.a(e))
        }
        resize(e) {
            let t;
            if (e < 256) {
                let n = t = new Uint8Array(e);
                for (let t = 0; t < e; ++t)
                    n[t] = t;
                this.webglType = WebGL2RenderingContext.UNSIGNED_BYTE
            } else if (e < 65536) {
                const n = t = new Uint16Array(e);
                for (let t = 0; t < e; ++t)
                    n[t] = t;
                this.webglType = WebGL2RenderingContext.UNSIGNED_SHORT
            } else {
                const n = t = new Uint32Array(e);
                for (let t = 0; t < e; ++t)
                    n[t] = t;
                this.webglType = WebGL2RenderingContext.UNSIGNED_INT
            }
            this.buffer.setData(t),
            this.length = e
        }
        ensure(e) {
            return (void 0 === this.length || this.length < e) && this.resize(e),
            this
        }
        bindToVertexAttrib(e) {
            this.buffer.bindToVertexAttribI(e, 1, this.webglType)
        }
        bind(e, t=0) {
            const n = e.attribute("aIndexRaw");
            n >= 0 && (this.bindToVertexAttrib(n),
            0 !== t && this.gl.vertexAttribDivisor(n, t))
        }
    }
    function b(e) {
        e.addAttribute("highp uint", "aIndexRaw"),
        e.addVertexCode(g.i),
        e.addVertexCode("\nuint getPrimitiveIndex() {\n  return aIndexRaw;\n}\n")
    }
    class y {
        constructor(e) {
            this.name = e
        }
        defineShader(e) {
            e.addAttribute("highp uint", this.name)
        }
        bind(e, t) {
            const n = t.attribute(this.name);
            e.bindToVertexAttribI(n, 1, WebGL2RenderingContext.UNSIGNED_INT)
        }
        disable(e) {
            e.gl.disableVertexAttribArray(e.attribute(this.name))
        }
    }
    var S = n(40)
      , w = n(32)
      , x = n(11);
    n.d(t, "a", (function() {
        return C
    }
    )),
    n.d(t, "c", (function() {
        return O
    }
    )),
    n.d(t, "e", (function() {
        return M
    }
    )),
    n.d(t, "b", (function() {
        return j
    }
    )),
    n.d(t, "d", (function() {
        return N
    }
    ));
    class C {
        constructor() {
            this.shaderError = Object(p.b)(),
            this.fragmentMain = Object(p.a)("void main() {\n  emitGray();\n}\n"),
            this.shaderControlState = new S.a(this.fragmentMain)
        }
    }
    function O(e) {
        return Object(g.b)(e.dataType, e.numComponents)
    }
    const k = []
      , E = Object(w.d)(new w.b, c.a.FLOAT32, 3)
      , T = E;
    function M(e) {
        const t = new Set;
        let n = [];
        for (let i of e) {
            let e = i.split(/[^a-zA-Z0-9]+/).filter(e=>e).join("_")
              , r = ""
              , s = 0;
            for (; t.has(e + r); )
                r = "" + ++s;
            n.push(e + r)
        }
        return n
    }
    class D {
        constructor(e, t) {
            this.attributeNames = e,
            this.attributeInfo = t,
            this.tempLightVec = new Float32Array(4),
            this.textureAccessHelper = new w.a("vertexData"),
            this.indexBufferHelper = new y("vertexIndex")
        }
        defineAttributeAccess(e, t) {
            let {textureAccessHelper: n} = this;
            n.defineShader(e);
            const {attributeNames: i} = this;
            let r = 2 + i.length;
            for (let e = k.length; e < r; ++e)
                k[e] = Symbol(`SingleMeshShaderManager.vertexAttributeTextureUnit${e}`);
            r = 0,
            e.addTextureSampler("sampler2D", "uVertexAttributeSampler0", k[r++]),
            e.addTextureSampler("sampler2D", "uVertexAttributeSampler1", k[r++]),
            e.addVertexCode(n.getAccessor("readVertexPosition", "uVertexAttributeSampler0", c.a.FLOAT32, 3)),
            e.addVertexCode(n.getAccessor("readVertexNormal", "uVertexAttributeSampler1", c.a.FLOAT32, 3));
            let s = `\nvec3 vertexPosition = readVertexPosition(${t});\nvec3 vertexNormal = readVertexNormal(${t});\n`;
            this.attributeInfo.forEach((a,o)=>{
                e.addTextureSampler(`${Object(w.e)(a.dataType)}sampler2D`, `uVertexAttributeSampler${r}`, k[r]);
                const l = O(a);
                e.addVarying(`highp ${l}`, `vCustom${o}`),
                e.addFragmentCode(`\n#define ${i[o]} vCustom${o}\n`),
                e.addVertexCode(n.getAccessor(`readAttribute${o}`, `uVertexAttributeSampler${r}`, a.dataType, a.numComponents)),
                s += `vCustom${o} = readAttribute${o}(${t});\n`,
                ++r
            }
            ),
            e.addVertexMain(s)
        }
        defineShader(e) {
            e.require(b),
            this.indexBufferHelper.defineShader(e),
            e.addVarying("highp float", "vLightingFactor"),
            e.addUniform("highp vec4", "uLightDirection"),
            e.addUniform("highp vec4", "uColor"),
            e.addUniform("highp mat4", "uModelMatrix"),
            e.addUniform("highp mat4", "uProjection"),
            e.addUniform("highp uint", "uPickID"),
            e.addVarying("highp uint", "vPickID", "flat"),
            e.addVertexMain("\nuint triangleIndex = getPrimitiveIndex() / 3u;\nvPickID = uPickID + triangleIndex;\n"),
            e.addFragmentCode("\nvoid emitPremultipliedRGBA(vec4 color) {\n  emit(vec4(color.rgb * vLightingFactor, color.a), vPickID);\n}\nvoid emitRGBA(vec4 color) {\n  color = clamp(color, 0.0, 1.0);\n  color.xyz *= color.a;\n  emitPremultipliedRGBA(color);\n}\nvoid emitRGB(vec3 color) {\n  emitRGBA(vec4(color, 1.0));\n}\nvoid emitGray() {\n  emitRGB(vec3(1.0, 1.0, 1.0));\n}\n"),
            e.addFragmentCode(h.a),
            this.defineAttributeAccess(e, "vertexIndex"),
            e.addVertexMain("\ngl_Position = uProjection * (uModelMatrix * vec4(vertexPosition, 1.0));\nvec3 normal = normalize((uModelMatrix * vec4(vertexNormal, 0.0)).xyz);\nvLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;\n")
        }
        beginLayer(e, t, n) {
            const {lightDirection: i, ambientLighting: r, directionalLighting: s, projectionParameters: a} = n
              , {viewProjectionMat: o} = a;
            e.uniformMatrix4fv(t.uniform("uProjection"), !1, o);
            let l = this.tempLightVec;
            u.t.scale(l, i, s),
            l[3] = r,
            e.uniform4fv(t.uniform("uLightDirection"), l)
        }
        setPickID(e, t, n) {
            e.uniform1ui(t.uniform("uPickID"), n)
        }
        beginObject(e, t, n) {
            e.uniformMatrix4fv(t.uniform("uModelMatrix"), !1, n)
        }
        bindVertexData(e, t, n) {
            let i = 0;
            const r = n=>{
                const r = WebGL2RenderingContext.TEXTURE0 + t.textureUnit(k[i]);
                e.activeTexture(r),
                e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, n),
                ++i
            }
            ;
            r(n.vertexTexture),
            r(n.normalTexture);
            const {attributeNames: s} = this;
            n.vertexAttributeTextures.forEach((e,t)=>{
                void 0 !== s[t] && r(e)
            }
            )
        }
        disableVertexData(e, t) {
            let n = 2
              , i = this.attributeInfo.length
              , {attributeNames: r} = this;
            for (let e = 0; e < i; ++e)
                void 0 !== r[e] && ++n;
            for (let i = 0; i < n; ++i) {
                let n = t.textureUnit(k[i]) + WebGL2RenderingContext.TEXTURE0;
                e.activeTexture(n),
                e.bindTexture(e.TEXTURE_2D, null)
            }
        }
        drawFragment(e, t, n, i) {
            i.ensure(n.numIndices).bind(t),
            this.bindVertexData(e, t, n.vertexData),
            this.indexBufferHelper.bind(n.indexBuffer, t),
            e.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, n.numIndices)
        }
        endLayer(e, t) {
            !function(e, t, n=!1) {
                const i = t.attribute("aIndexRaw");
                i >= 0 && (n && e.vertexAttribDivisor(i, 0),
                e.disableVertexAttribArray(i))
            }(e, t),
            this.indexBufferHelper.disable(t),
            this.disableVertexData(e, t)
        }
    }
    class L {
        copyToGPU(e, t) {
            const n = (t,n)=>{
                let i = e.createTexture();
                return e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, i),
                Object(w.f)(e, n, t),
                i
            }
            ;
            this.vertexTexture = n(this.vertexPositions, E),
            this.normalTexture = n(this.vertexNormals, T),
            this.vertexAttributeTextures = this.vertexAttributes.map((e,i)=>n(e, t[i])),
            e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null)
        }
        freeGPUMemory(e) {
            e.deleteTexture(this.vertexTexture),
            e.deleteTexture(this.normalTexture);
            let {vertexAttributeTextures: t} = this;
            for (const n of t)
                e.deleteTexture(n);
            t.length = 0
        }
    }
    class A extends r.b {
        constructor(e, t) {
            super(e);
            const n = this.vertexData = new L;
            n.vertexPositions = t.vertexPositions,
            n.vertexNormals = t.vertexNormals,
            n.vertexAttributes = t.vertexAttributes;
            let i = this.indices = t.indices;
            this.numIndices = i.length
        }
        copyToGPU(e) {
            super.copyToGPU(e),
            this.vertexData.copyToGPU(e, this.source.attributeTextureFormats),
            this.indexBuffer = function(e, t) {
                return m.a.fromData(e, t, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW)
            }(e, this.indices)
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e),
            this.vertexData.freeGPUMemory(e),
            this.indexBuffer.dispose()
        }
    }
    class I extends (Object(r.f)(r.e, o)) {
        constructor() {
            super(...arguments),
            this.attributeTextureFormats = this.info.vertexAttributes.map(e=>Object(w.d)(new w.b, e.dataType, e.numComponents))
        }
        get info() {
            return this.parameters.info
        }
        getChunk(e) {
            return new A(this,e)
        }
    }
    const P = Object(d.c)(x.b);
    class R extends P {
    }
    class j extends s.a {
        constructor(e, t, n) {
            var i;
            super(),
            this.source = e,
            this.displayState = t,
            this.transform = n,
            this.shaderManager = new D(M(this.source.info.vertexAttributes.map(e=>e.name)),this.source.info.vertexAttributes),
            this.shaders = new Map,
            this.sharedObject = this.registerDisposer(new R),
            this.shaderGetter = Object(p.d)(this, this.gl, {
                memoizeKey: {
                    t: "single_mesh/RenderLayer",
                    attributes: this.source.info.vertexAttributes
                },
                fallbackParameters: new l.e(Object(S.c)("void main() {\n  emitGray();\n}\n")),
                parameters: this.displayState.shaderControlState.parseResult,
                encodeParameters: e=>e.source,
                shaderError: this.displayState.shaderError,
                defineShader: (e,t)=>{
                    if (0 !== t.errors.length)
                        throw new Error("Invalid UI control specification");
                    Object(S.b)(t.controls, e),
                    this.shaderManager.defineShader(e),
                    e.setFragmentMainFunction(Object(p.e)(t.code))
                }
            }),
            this.countingBuffer = this.registerDisposer((i = this.gl).memoize.get("IndexBuffer", ()=>new v(i))),
            this.registerDisposer(t.shaderControlState.parseResult.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(t.shaderControlState.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(n.changed.add(this.redrawNeeded.dispatch));
            const {sharedObject: r} = this;
            r.visibility.add(this.visibility),
            r.RPC_TYPE_ID = "single_mesh/SingleMeshLayer",
            r.initializeCounterpart(e.chunkManager.rpc, {
                chunkManager: e.chunkManager.rpcId,
                source: e.addCounterpartRef()
            })
        }
        disposeShaders() {
            let {shaders: e} = this;
            for (let t of e.values())
                null !== t && t.dispose();
            e.clear()
        }
        disposed() {
            this.disposeShaders(),
            super.disposed()
        }
        get isTransparent() {
            return null !== this.displayState.fragmentMain.value.match(/emitRGBA|emitPremultipliedRGBA/)
        }
        get gl() {
            return this.source.gl
        }
        draw(e, t) {
            if (!e.emitColor && e.alreadyEmittedPickID)
                return;
            const n = Object(a.g)(this.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
            if (void 0 === n)
                return;
            let r = this.source.chunks.get("");
            if (void 0 === r || r.state !== i.g.GPU_MEMORY)
                return;
            const s = this.shaderGetter(e.emitter)
              , {shader: o, parameters: l} = s;
            if (null === o)
                return;
            const {gl: c} = this
              , u = this.shaderManager;
            o.bind(),
            u.beginLayer(c, o, e),
            Object(S.d)(c, o, this.displayState.shaderControlState, l.controls);
            let {pickIDs: d} = e;
            u.beginObject(c, o, n),
            e.emitPickID && u.setPickID(c, o, d.register(this, r.numIndices / 3)),
            u.drawFragment(c, o, r, this.countingBuffer),
            u.endLayer(c, o)
        }
        transformPickedValue(e, t) {
            let n = this.source.chunks.get("");
            if (void 0 === n)
                return;
            let i = 3 * t
              , {indices: r} = n;
            if (i >= r.length)
                return;
            let s = r[i]
              , a = [];
            const {attributeNames: o} = this.shaderManager;
            return n.vertexData.vertexAttributes.forEach((e,t)=>{
                const n = o[t];
                void 0 !== n && a.push(`${n}=${e[s].toPrecision(6)}`)
            }
            ),
            a.join(", ")
        }
    }
    function N(e, t) {
        return function(e, t) {
            return e.memoize.getUncounted({
                type: "single_mesh:getMeshInfo",
                parameters: t
            }, ()=>e.rpc.promiseInvoke("single_mesh/getSingleMeshInfo", {
                chunkManager: e.addCounterpartRef(),
                parameters: t
            }))
        }(e, t).then(n=>e.getChunkSource(I, {
            parameters: Object.assign(Object.assign({}, t), {
                info: n
            })
        }))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    ));
    var i = n(2)
      , r = n(0);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s {
        constructor() {
            this.map = new Map
        }
        get(e, t) {
            let {map: n} = this
              , i = n.get(e);
            return void 0 === i ? (i = t(),
            i.registerDisposer(()=>{
                n.delete(e)
            }
            ),
            n.set(e, i)) : i.addRef(),
            i
        }
    }
    class a extends s {
        get(e, t) {
            return "string" != typeof e && (e = Object(r.h)(e)),
            super.get(e, t)
        }
        getUncounted(e, t) {
            return this.get(e, ()=>new i.b(t())).value
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = new (n(86).a)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(2)
      , r = n(3);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends i.a {
        constructor(e, t) {
            if (super(),
            this.register = e,
            this.changed = new r.a,
            this.disposerMap = new Map,
            void 0 === t)
                this.map = new Map;
            else {
                const n = this.map = new Map(t)
                  , {disposerMap: r} = this;
                for (const [t,s] of n) {
                    const n = new i.a;
                    r.set(t, n),
                    e(n, s, t)
                }
            }
        }
        get value() {
            return this.map
        }
        set(e, t) {
            const {map: n, disposerMap: r} = this;
            let s = r.get(e);
            return void 0 !== s && s.dispose(),
            s = new i.a,
            r.set(e, s),
            n.set(e, t),
            this.register(s, t, e),
            this.changed.dispatch(),
            this
        }
        delete(e) {
            const {map: t, disposerMap: n} = this
              , i = n.get(e);
            return void 0 !== i && (i.dispose(),
            n.delete(e),
            t.delete(e),
            this.changed.dispatch(),
            !0)
        }
        get(e) {
            return this.map.get(e)
        }
        has(e) {
            return this.map.has(e)
        }
        get size() {
            return this.map.size
        }
        [Symbol.iterator]() {
            return this.map[Symbol.iterator]()
        }
        clear() {
            const {map: e, disposerMap: t} = this;
            if (e.size > 0) {
                for (const e of t.values())
                    e.dispose();
                e.clear(),
                t.clear(),
                this.changed.dispatch()
            }
        }
        values() {
            return this.map.values()
        }
        keys() {
            return this.map.keys()
        }
        disposed() {
            const {map: e, disposerMap: t} = this;
            for (const e of t.values())
                e.dispose();
            e.clear(),
            t.clear(),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i = n(134)
      , r = n.n(i)
      , s = n(36);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function a(e={}) {
        return Object(s.a)(Object.assign({
            svg: r.a
        }, e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var i = n(2);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class r extends i.a {
        constructor(e) {
            super(),
            this.model = e,
            this.element = document.createElement("select"),
            this.valueIndexMap = new Map;
            const {element: t, valueIndexMap: n} = this;
            let i = 0;
            for (const r of Object.keys(e.enumType))
                if (isNaN(Number(r))) {
                    const s = document.createElement("option");
                    s.textContent = s.value = r.toLowerCase(),
                    t.appendChild(s),
                    n.set(e.enumType[r], i),
                    ++i
                }
            this.registerDisposer(e.changed.add(()=>this.updateView())),
            this.registerEventListener(t, "change", ()=>this.updateModel()),
            this.registerEventListener(t, "wheel", e=>{
                let {deltaY: n} = e;
                n > 0 ? (t.selectedIndex = (t.options.length + t.selectedIndex - 1) % t.options.length,
                this.updateModel()) : n < 0 && (t.selectedIndex = (t.options.length + t.selectedIndex + 1) % t.options.length,
                this.updateModel())
            }
            ),
            this.updateView()
        }
        updateView() {
            const {element: e} = this;
            e.selectedIndex = this.valueIndexMap.get(this.model.value)
        }
        updateModel() {
            this.model.restoreState(this.element.value)
        }
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var i;
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return r
    }
    )),
    function(e) {
        e[e.LITTLE = 0] = "LITTLE",
        e[e.BIG = 1] = "BIG"
    }(i || (i = {}));
    const r = function() {
        const e = Uint16Array.of(4386);
        return 17 === new Uint8Array(e.buffer)[0] ? i.BIG : i.LITTLE
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "d", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    ));
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const i = "rendered_view.addLayer"
      , r = "rendered_view.removeLayer"
      , s = "SharedProjectionParameters"
      , a = "SharedProjectionParameters.changed"
}
, function(e, t, n) {
    "use strict";
    var i = n(38)
      , r = n(31)
      , s = n(17)
      , a = n(7)
      , o = n(62)
      , l = n(2);
    var c = n(1)
      , u = n(100)
      , d = n(34)
      , h = n(40);
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "b", (function() {
        return g
    }
    ));
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class p extends a.e {
    }
    class f extends u.a {
        constructor() {
            super((e,{showMatches: t, segmentationState: n})=>{
                e.registerDisposer(t.changed.add(this.changed.dispatch)),
                e.registerDisposer(n.changed.add(this.changed.dispatch)),
                e.registerDisposer(Object(a.j)((e,t)=>{
                    if (null == t)
                        return;
                    const {visibleSegments: n} = t;
                    let i = 0 === n.size;
                    e.registerDisposer(t.visibleSegments.changed.add(()=>{
                        const e = 0 === n.size;
                        e !== i && (i = e,
                        this.changed.dispatch())
                    }
                    ))
                }
                , n))
            }
            )
        }
        get(e) {
            let t = super.get(e);
            return void 0 === t && (t = {
                segmentationState: new a.e(void 0),
                showMatches: new s.b(!1)
            },
            super.set(e, t)),
            t
        }
    }
    class m extends l.a {
        constructor() {
            super(...arguments),
            this.shader = Object(d.a)("\nvoid main() {\n  setColor(defaultColor());\n}\n"),
            this.shaderControls = new h.a(this.shader),
            this.fallbackShaderControls = new a.e(Object(h.c)("\nvoid main() {\n  setColor(defaultColor());\n}\n")),
            this.shaderError = Object(d.b)(),
            this.color = new o.a(c.t.fromValues(1, 1, 0)),
            this.relationshipStates = this.registerDisposer(new f),
            this.ignoreNullSegmentFilter = new s.b(!0),
            this.displayUnfiltered = Object(a.h)((e,t)=>{
                for (const n of e.values())
                    if (n.showMatches.value) {
                        if (!t)
                            return !1;
                        const e = n.segmentationState.value;
                        if (null != e && e.visibleSegments.size > 0)
                            return !1
                    }
                return !0
            }
            , this.relationshipStates, this.ignoreNullSegmentFilter),
            this.hoverState = new p(void 0)
        }
    }
    class g extends l.a {
        constructor(e) {
            super();
            const {transform: t, localPosition: n, source: s, role: o=r.c.ANNOTATION} = e;
            this.transform = t,
            this.localPosition = n,
            this.source = this.registerDisposer(s),
            this.role = o,
            this.displayState = e.displayState,
            this.chunkTransform = this.registerDisposer(Object(a.h)(e=>/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            function(e) {
                try {
                    return e()
                } catch (e) {
                    return {
                        error: e.message
                    }
                }
            }(()=>Object(i.e)(function(e) {
                if (void 0 !== e.error)
                    throw new Error(e.error);
                return e
            }(e))), this.transform)),
            this.dataSource = e.dataSource,
            this.subsourceId = e.subsourceId,
            this.subsourceIndex = e.subsourceIndex
        }
        get sourceIndex() {
            const {dataSource: e} = this;
            return e.layer.dataSources.indexOf(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e) {
        return ("0" + e.toString(16)).slice(-2)
    }
    function r(e) {
        return Array.prototype.map.call(e, i).join("")
    }
    function s(e) {
        if (!/^(?:[0-9a-fA-F]{2})*$/.test(e))
            throw new Error("Invalid hex-encoded string");
        const t = e.length / 2
          , n = new Uint8Array(t);
        for (let i = 0; i < t; ++i)
            n[i] = parseInt(e.substr(2 * i, 2), 16);
        return n
    }
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    ));
    var i = n(42)
      , r = n(60);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function s(e) {
        e.addOutputBuffer("vec4", "v4f_fragColor", null),
        e.setFragmentMain("v4f_fragColor = getValue0();")
    }
    function a(e, t=s, n=1) {
        return e.memoize.get(`elementWiseTextureShader:${n}:${Object(i.a)(t)}`, ()=>{
            let i = new r.a(e);
            i.addVarying("vec2", "vTexCoord"),
            i.addUniform("sampler2D", "uSampler", n),
            i.addInitializer(t=>{
                let i = [];
                for (let e = 0; e < n; ++e)
                    i[e] = e;
                e.uniform1iv(t.uniform("uSampler"), i)
            }
            );
            for (let e = 0; e < n; ++e)
                i.addFragmentCode(`\nvec4 getValue${e}() {\n  return texture(uSampler[${e}], vTexCoord);\n}\n`);
            return i.addUniform("mat4", "uProjectionMatrix"),
            i.require(t),
            i.addAttribute("vec4", "aVertexPosition"),
            i.addAttribute("vec2", "aTexCoord"),
            i.setVertexMain("vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;"),
            i.build()
        }
        )
    }
    function o(e) {
        return e.memoize.get("trivialColorShader", ()=>{
            let t = new r.a(e);
            return t.addVarying("vec4", "vColor"),
            t.addOutputBuffer("vec4", "v4f_fragColor", null),
            t.setFragmentMain("v4f_fragColor = vColor;"),
            t.addAttribute("vec4", "aVertexPosition"),
            t.addAttribute("vec4", "aColor"),
            t.addUniform("mat4", "uProjectionMatrix"),
            t.setVertexMain("vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;"),
            t.build()
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e, t) {
        return e < t ? -1 : e > t ? 1 : 0
    }
    n.d(t, "a", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var i = n(135)
      , r = n.n(i)
      , s = n(36);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function a(e={}) {
        const t = Object(s.a)(Object.assign({
            svg: r.a
        }, e));
        return t.firstElementChild.style.fill = "white",
        t
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(1)
      , r = n(15);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s {
        constructor(e, t, n) {
            this.size = i.t.clone(e),
            this.transform = i.l.clone(t),
            this.finiteRank = n;
            const s = i.l.create()
              , a = r.f(s, 4, t, 4, 4);
            if (0 === a)
                throw new Error("Transform is singular");
            this.invTransform = s,
            this.detTransform = a
        }
        toObject() {
            return {
                size: this.size,
                transform: this.transform,
                finiteRank: this.finiteRank
            }
        }
        static fromObject(e) {
            return new s(e.size,e.transform,e.finiteRank)
        }
        globalToLocalSpatial(e, t) {
            return i.t.transformMat4(e, t, this.invTransform)
        }
        localSpatialVectorToGlobal(e, t) {
            return Object(i.q)(e, t, this.transform)
        }
        globalToLocalNormal(e, t) {
            return Object(i.r)(e, t, this.transform)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(23)
      , r = n(20);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    async function s(e, t, n, s, a, o, l=i.e) {
        let c;
        e: for (; ; ) {
            c = await e.get(c, l);
            t: for (; ; )
                try {
                    return await Object(r.b)(t, a(c.credentials, n), s, l)
                } catch (e) {
                    if (e instanceof r.a) {
                        if ("refresh" === o(e))
                            continue e;
                        continue t
                    }
                    throw e
                }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return v
    }
    ));
    var i = n(10)
      , r = n(4)
      , s = n(38)
      , a = n(69)
      , o = n(65)
      , l = n(7)
      , c = n(1)
      , u = n(42)
      , d = n(25)
      , h = n(34)
      , p = n(55)
      , f = n(24);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const m = c.l.create();
    class g extends a.a {
        constructor() {
            super(...arguments),
            this.lineShader = new p.a(this.gl,6),
            this.intersectionVertexIndexBuffer = Object(d.b)(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, a.c).value
        }
        static get(e) {
            return e.memoize.get("volume.VolumeSliceVertexComputationManager", ()=>new g(e))
        }
        defineVolumeShader(e, t) {
            if (super.defineShader(e),
            e.addAttribute("highp float", "aVertexIndexFloat"),
            e.addUniform("highp vec3", "uTranslation"),
            e.addUniform("highp mat4", "uProjectionMatrix"),
            e.addUniform("highp vec3", "uChunkDataSize"),
            e.addUniform("highp vec3", "uLowerClipBound"),
            e.addUniform("highp vec3", "uUpperClipBound"),
            t)
                return this.lineShader.defineShader(e),
                e.setVertexMain("\nint vertexIndex1 = int(aVertexIndexFloat);\nint vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;\nvec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);\nvec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);\nemitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),\n         uProjectionMatrix * vec4(vertexPosition2, 1.0),\n         2.0);\n"),
                void e.setFragmentMain("\nemit(vec4(1.0, 1.0, 1.0, getLineAlpha()));\n");
            e.addVarying("highp vec3", "vChunkPosition"),
            e.setVertexMain("\nvec3 position = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, int(aVertexIndexFloat));\ngl_Position = uProjectionMatrix * vec4(position, 1.0);\nvChunkPosition = (position - uTranslation) +\n    0.001 * abs(uPlaneNormal);\n"),
            e.addFragmentCode("\nhighp ivec3 getPositionWithinChunk () {\n  return ivec3(min(vChunkPosition, uChunkDataSize - 1.0));\n}\n")
        }
        computeVerticesDebug(e, t, n, i, r, s, a) {
            let o = c.t.create()
              , l = c.t.create()
              , u = c.t.fromValues(Math.abs(r[0]), Math.abs(r[1]), Math.abs(r[2]))
              , d = c.t.create();
            for (let h = 0; h < 6; ++h) {
                const p = this.computeVertexPositionDebug(e, t, n, i, r, s, h);
                if (void 0 === p)
                    return void console.log("no intersection found");
                c.t.transformMat4(o, p, a);
                const f = 0 !== h && c.t.equals(o, d);
                c.t.copy(d, o),
                c.t.sub(l, p, s),
                c.t.scaleAndAdd(l, l, u, .001),
                console.log(`${f ? "SKIPPED" : "OUTPUT"} vertex ${h}, ` + `at ${o}, vChunkPosition = ${l}, ` + `uTranslation=${s.join()}, position=${p.join()}`)
            }
        }
        beginSlice(e, t, n, i) {
            const r = t.attribute("aVertexIndexFloat");
            (i ? this.intersectionVertexIndexBuffer : this.data.outputVertexIndices).bindToVertexAttrib(r, 1),
            i && this.lineShader.enable(t, n, 1)
        }
        endSlice(e, t, n) {
            let i = t.attribute("aVertexIndexFloat");
            e.disableVertexAttribArray(i),
            n && this.lineShader.disable(t)
        }
        beginSource(e, t, n, i, r, s) {
            const a = n.projectionParameters.value
              , {centerDataPosition: o} = a;
            this.setViewportPlane(t, a.viewportNormalInGlobalCoordinates, o, s.transform, s.invTransform),
            e.uniformMatrix4fv(t.uniform("uProjectionMatrix"), !1, c.l.multiply(m, i, s.transform)),
            e.uniform3fv(t.uniform("uLowerClipBound"), r.lowerClipDisplayBound),
            e.uniform3fv(t.uniform("uUpperClipBound"), r.upperClipDisplayBound)
        }
        setupChunkDataSize(e, t, n) {
            e.uniform3fv(t.uniform("uChunkDataSize"), n)
        }
        drawChunk(e, t, n, i) {
            e.uniform3fv(t.uniform("uTranslation"), n),
            i ? this.lineShader.draw(t.gl, 1) : e.drawArrays(e.TRIANGLE_FAN, 0, 6)
        }
    }
    class v extends o.b {
        constructor(e, t) {
            const {shaderError: n=Object(h.b)(), shaderParameters: i} = t;
            super(e.chunkManager, e, t);
            const {gl: s} = this;
            this.shaderParameters = i;
            const {channelCoordinateSpace: a} = t;
            this.channelCoordinateSpace = void 0 === a ? Object(l.f)(r.l) : a,
            this.registerDisposer(i.changed.add(this.redrawNeeded.dispatch));
            const o = this.registerDisposer(Object(l.g)(e=>e.rank, [this.channelCoordinateSpace]));
            this.shaderGetter = Object(h.c)(this, s, {
                memoizeKey: `volume/RenderLayer:${Object(u.a)(this.constructor)}`,
                fallbackParameters: t.fallbackShaderParameters,
                parameters: i,
                encodeParameters: t.encodeShaderParameters,
                shaderError: n,
                extraParameters: o,
                defineShader: (e,t,n,i)=>{
                    this.vertexComputationManager.defineVolumeShader(e, null === t),
                    e.addOutputBuffer("vec4", "v4f_fragData0", 0),
                    e.addFragmentCode("\nvoid emit(vec4 color) {\n  v4f_fragData0 = color;\n}\n"),
                    null !== t && (t.defineShader(e, i),
                    i <= 1 && e.addFragmentCode(`\n${Object(f.b)(this.dataType)} getDataValue() { return getDataValue(0); }\n`),
                    this.defineShader(e, n))
                }
                ,
                getContextKey: e=>null === e ? null : e.shaderKey
            }),
            this.vertexComputationManager = g.get(s),
            this.tempChunkPosition = new Float32Array(e.rank),
            this.initializeCounterpart()
        }
        get dataType() {
            return this.multiscaleSource.dataType
        }
        getValueAt(e) {
            let {tempChunkPosition: t} = this;
            for (const {source: n, chunkTransform: i} of this.visibleSourcesList) {
                if (!Object(s.d)(t, e, this.localPosition.value, i.layerRank, i.combinedGlobalLocalToChunkTransform))
                    continue;
                const r = n.getValueAt(t);
                if (null != r)
                    return r
            }
            return null
        }
        beginChunkFormat(e, t, n) {
            const {gl: i} = this
              , r = this.shaderGetter(t)
              , {shader: s, parameters: a, fallback: o} = r;
            return null !== s && (s.bind(),
            this.vertexComputationManager.beginSlice(i, s, n, null === t),
            null !== t && (this.initializeShader(e, s, a, o),
            t.beginDrawing(i, s))),
            r
        }
        endSlice(e, t, n) {}
        draw(e) {
            const {sliceView: t} = e
              , n = t.visibleLayers.get(this)
              , {visibleSources: r} = n;
            if (0 === r.length)
                return;
            const {projectionParameters: s, wireFrame: a} = e
              , {gl: o} = this
              , l = c.t.create()
              , {renderScaleHistogram: u, vertexComputationManager: d} = this;
            let h;
            void 0 !== u && u.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            let p, f = null;
            const m = c.t.create()
              , g = ()=>{
                null !== f && (null !== p && p.endDrawing(o, f),
                this.vertexComputationManager.endSlice(o, f, a),
                this.endSlice(t, f, h.parameters))
            }
            ;
            let v = !0;
            for (const e of r) {
                const n = t.getNormalizedChunkLayout(e.chunkLayout)
                  , {chunkTransform: {chunkChannelDimensionIndices: r}} = e
                  , c = e.source
                  , {fixedPositionWithinChunk: w, chunkDisplayDimensionIndices: x} = e;
                for (const e of x)
                    w[e] = 0;
                const C = a ? null : c.chunkFormat;
                if (C !== p && (p = C,
                g(),
                h = this.beginChunkFormat(t, C, s),
                f = h.shader),
                null === f)
                    continue;
                const O = c.chunks;
                m.fill(1);
                let k, E = n.size;
                const T = c.spec.rank;
                d.beginSource(o, f, t, s.viewProjectionMat, e, n),
                null !== C && C.beginSource(o, f),
                v = !0;
                let M = 0
                  , D = 0;
                if (t.forEachVisibleChunk(e, e=>{
                    let t = O.get(e);
                    if (t && t.state === i.g.GPU_MEMORY) {
                        let e = t.chunkDataSize;
                        if (e !== k) {
                            k = e;
                            for (let e = 0; e < 3; ++e) {
                                const t = x[e];
                                m[e] = -1 === t || t >= T ? 1 : k[t]
                            }
                            d.setupChunkDataSize(o, f, m)
                        }
                        const {chunkGridPosition: n} = t;
                        for (let e = 0; e < 3; ++e) {
                            const t = x[e];
                            l[e] = -1 === t || t >= T ? 0 : E[e] * n[t]
                        }
                        null !== C && C.bindChunk(o, f, t, w, x, r, v),
                        v = !1,
                        d.drawChunk(o, f, l, a),
                        ++M
                    } else
                        ++D
                }
                ),
                (0 !== M || 0 !== D) && void 0 !== u) {
                    const {effectiveVoxelSize: t} = e
                      , n = (b = t[0],
                    y = t[1],
                    S = t[2],
                    b > y ? S > b ? b : y > S ? y : S : S > y ? y : b > S ? b : S);
                    u.add(n, n / s.pixelSize, M, D)
                }
            }
            var b, y, S;
            g()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var i = n(2)
      , r = n(5);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class s extends i.a {
        constructor(e) {
            super(),
            this.model = e,
            this.element = document.createElement("input");
            const {element: t} = this;
            t.classList.add("neuroglancer-color-widget"),
            t.type = "color",
            t.addEventListener("change", ()=>this.updateModel()),
            this.registerDisposer(e.changed.add(()=>this.updateView())),
            this.updateView()
        }
        updateView() {
            this.element.value = this.model.toString()
        }
        updateModel() {
            this.model.restoreState(this.element.value)
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var i = n(2)
      , r = n(5)
      , s = n(3)
      , a = n(21);
    n(89),
    n(167);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o extends i.a {
        constructor() {
            super(),
            this.element = document.createElement("form"),
            this.label = document.createElement("label"),
            this.input = document.createElement("input"),
            this.valuesEntered = new s.b;
            let {element: e, label: t, input: n} = this;
            e.className = "uint64-entry neuroglancer-noselect",
            e.appendChild(t),
            t.appendChild(n),
            this.registerEventListener(e, "submit", e=>{
                e.preventDefault();
                const t = this.validateInput();
                void 0 !== t && (this.input.value = "",
                this.input.classList.remove("valid-input", "invalid-input"),
                this.valuesEntered.dispatch(t))
            }
            ),
            this.registerEventListener(e, "input", ()=>{
                "" !== this.input.value ? this.validateInput() ? this.input.classList.remove("invalid-input") : this.input.classList.add("invalid-input") : this.input.classList.remove("valid-input", "invalid-input")
            }
            )
        }
        validateInput() {
            let e = this.input.value;
            e = e.replace(/[\s,\(\)\[\]\{\};]+/g, " "),
            e = e.trim();
            const t = e.split(" ");
            if (0 === t.length)
                return;
            const n = [];
            for (const e of t) {
                const t = new a.a;
                if (!t.tryParseString(e))
                    return;
                n.push(t)
            }
            return n
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
}
, function(e, t, n) {
    var i = n(16)
      , r = n(119);
    e.exports = function(e, t, n) {
        var s = !0
          , a = !0;
        if ("function" != typeof e)
            throw new TypeError("Expected a function");
        return r(n) && (s = "leading"in n ? !!n.leading : s,
        a = "trailing"in n ? !!n.trailing : a),
        i(e, t, {
            leading: s,
            maxWait: t,
            trailing: a
        })
    }
}
, function(e, t, n) {
    "use strict";
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function i(e, t) {
        let n = "";
        for (let i = 0; i <= t && (n = e.toFixed(i),
        parseFloat(n) !== e); ++i)
            ;
        return n
    }
    n.d(t, "a", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    n(89),
    n(174);
    var i = n(22)
      , r = n(71)
      , s = n(49)
      , a = n(58)
      , o = n(27);
    function l(e, t) {
        return t >>>= 0,
        e >>>= 0,
        t = ((t = Math.imul(t, 3432918353) >>> 0) << 15 | t >>> 17) >>> 0,
        e = 5 * (e = ((e = (e ^ (t = Math.imul(t, 461845907) >>> 0)) >>> 0) << 13 | e >>> 19) >>> 0) + 3864292196 >>> 0
    }
    var c = n(59)
      , u = n(21);
    let d = 0
      , h = 0
      , p = 0
      , f = 0;
    class m {
        constructor(e=m.generateHashSeeds(3)) {
            this.hashSeeds = e,
            this.loadFactor = .9,
            this.size = 0,
            this.emptyLow = 4294967295,
            this.emptyHigh = 4294967295,
            this.maxRehashAttempts = 5,
            this.maxAttempts = 5,
            this.generation = 0,
            this.mungedEmptyKey = -1;
            let t = 8;
            for (; t < 2 * e.length; )
                t *= 2;
            this.allocate(t)
        }
        updateHashFunctions(e) {
            this.hashSeeds = m.generateHashSeeds(e),
            this.mungedEmptyKey = -1
        }
        tableWithMungedEmptyKey(e) {
            const t = this.hashSeeds.length
              , n = new Array(t);
            for (let e = 0; e < t; ++e)
                n[e] = this.getHash(e, this.emptyLow, this.emptyHigh);
            let {mungedEmptyKey: i} = this;
            if (-1 === i)
                e: for (; ; ) {
                    i = 16777216 * Math.random() >>> 0;
                    for (let e = 0; e < t; ++e) {
                        let r = this.getHash(e, i, i);
                        for (let e = 0; e < t; ++e)
                            if (n[e] === r)
                                continue e
                    }
                    this.mungedEmptyKey = i;
                    break
                }
            let {table: r, emptyLow: s, emptyHigh: a} = this;
            for (let e = 0; e < t; ++e) {
                let t = n[e];
                r[t] === s && r[t + 1] === a && (r[t] = i,
                r[t + 1] = i)
            }
            try {
                e(r)
            } finally {
                for (let e = 0; e < t; ++e) {
                    let t = n[e];
                    r[t] === i && r[t + 1] === i && (r[t] = s,
                    r[t + 1] = a)
                }
            }
        }
        static generateHashSeeds(e=3) {
            return Object(c.c)(new Uint32Array(e))
        }
        getHash(e, t, n) {
            let i = this.hashSeeds[e];
            return i = l(i, t),
            i = l(i, n),
            this.entryStride * (i & this.tableSize - 1)
        }
        *keys(e=new u.a) {
            let {emptyLow: t, emptyHigh: n, entryStride: i} = this
              , {table: r} = this;
            for (let s = 0, a = r.length; s < a; s += i) {
                let i = r[s]
                  , a = r[s + 1];
                i === t && a === n || (e.low = i,
                e.high = a,
                yield e)
            }
        }
        indexOfPair(e, t) {
            let {table: n, emptyLow: i, emptyHigh: r} = this;
            if (e === i && t === r)
                return -1;
            for (let i = 0, r = this.hashSeeds.length; i < r; ++i) {
                let r = this.getHash(i, e, t);
                if (n[r] === e && n[r + 1] === t)
                    return r
            }
            return -1
        }
        indexOf(e) {
            return this.indexOfPair(e.low, e.high)
        }
        chooseAnotherEmptyKey() {
            let e, t, {emptyLow: n, emptyHigh: i, table: r, entryStride: s} = this;
            for (; e = 4294967296 * Math.random() >>> 0,
            t = 4294967296 * Math.random() >>> 0,
            e === n && t === i || this.hasPair(e, t); )
                ;
            this.emptyLow = e,
            this.emptyHigh = t;
            for (let a = 0, o = r.length; a < o; a += s)
                r[a] === n && r[a + 1] === i && (r[a] = e,
                r[a + 1] = t)
        }
        has(e) {
            return -1 !== this.indexOf(e)
        }
        hasPair(e, t) {
            return -1 !== this.indexOfPair(e, t)
        }
        delete(e) {
            let t = this.indexOf(e);
            if (-1 !== t) {
                let {table: e} = this;
                return e[t] = this.emptyLow,
                e[t + 1] = this.emptyHigh,
                ++this.generation,
                this.size--,
                !0
            }
            return !1
        }
        clearTable() {
            let {table: e, entryStride: t, emptyLow: n, emptyHigh: i} = this
              , r = e.length;
            for (let s = 0; s < r; s += t)
                e[s] = n,
                e[s + 1] = i
        }
        clear() {
            return 0 !== this.size && (this.size = 0,
            ++this.generation,
            this.clearTable(),
            !0)
        }
        swapPending(e, t) {
            let n = d
              , i = h;
            this.storePending(e, t),
            e[t] = n,
            e[t + 1] = i
        }
        storePending(e, t) {
            d = e[t],
            h = e[t + 1]
        }
        backupPending() {
            p = d,
            f = h
        }
        restorePending() {
            d = p,
            h = f
        }
        tryToInsert() {
            let e = 0
              , {emptyLow: t, emptyHigh: n, maxAttempts: i, table: r} = this
              , s = this.hashSeeds.length
              , a = Math.floor(Math.random() * s);
            for (; ; ) {
                let o = this.getHash(a, d, h);
                if (this.swapPending(r, o),
                d === t && h === n)
                    return !0;
                if (++e === i)
                    break;
                a = (a + Math.floor(Math.random() * (s - 1)) + 1) % s
            }
            return !1
        }
        allocate(e) {
            this.tableSize = e;
            let {entryStride: t} = this;
            this.table = new Uint32Array(e * t),
            this.maxAttempts = e,
            this.clearTable(),
            this.capacity = e * this.loadFactor,
            this.mungedEmptyKey = -1
        }
        rehash(e, t) {
            this.allocate(t),
            this.updateHashFunctions(this.hashSeeds.length);
            let {emptyLow: n, emptyHigh: i, entryStride: r} = this;
            for (let t = 0, s = e.length; t < s; t += r) {
                let r = e[t]
                  , s = e[t + 1];
                if ((r !== n || s !== i) && (this.storePending(e, t),
                !this.tryToInsert()))
                    return !1
            }
            return !0
        }
        grow(e) {
            let t = this.table
              , {tableSize: n} = this;
            for (; n < e; )
                n *= 2;
            for (; ; ) {
                for (let e = 0; e < this.maxRehashAttempts; ++e)
                    if (this.rehash(t, n))
                        return void 0;
                n *= 2
            }
        }
        insertInternal() {
            for (++this.generation,
            d === this.emptyLow && h === this.emptyHigh && this.chooseAnotherEmptyKey(),
            ++this.size > this.capacity && (this.backupPending(),
            this.grow(2 * this.tableSize),
            this.restorePending()); !this.tryToInsert(); )
                this.backupPending(),
                this.grow(this.tableSize),
                this.restorePending()
        }
    }
    class g extends m {
        add(e) {
            let {low: t, high: n} = e;
            return !this.hasPair(t, n) && (d = t,
            h = n,
            this.insertInternal(),
            !0)
        }
        [Symbol.iterator]() {
            return this.keys()
        }
    }
    g.prototype.entryStride = 2;
    let v = 0
      , b = 0
      , y = 0
      , S = 0;
    class w extends m {
        set(e, t) {
            let {low: n, high: i} = e;
            return !this.hasPair(n, i) && (d = n,
            h = i,
            v = t.low,
            b = t.high,
            this.insertInternal(),
            !0)
        }
        get(e, t) {
            let n = this.indexOf(e);
            if (-1 === n)
                return !1;
            let {table: i} = this;
            return t.low = i[n + 2],
            t.high = i[n + 3],
            !0
        }
        swapPending(e, t) {
            let n = v
              , i = b;
            super.swapPending(e, t),
            e[t + 2] = n,
            e[t + 3] = i
        }
        storePending(e, t) {
            super.storePending(e, t),
            v = e[t + 2],
            b = e[t + 3]
        }
        backupPending() {
            super.backupPending(),
            y = v,
            S = b
        }
        restorePending() {
            super.restorePending(),
            v = y,
            b = S
        }
        [Symbol.iterator]() {
            return this.entries()
        }
        *entries(e=[new u.a, new u.a]) {
            let {emptyLow: t, emptyHigh: n, entryStride: i} = this
              , {table: r} = this
              , [s,a] = e;
            for (let o = 0, l = r.length; o < l; o += i) {
                let i = r[o]
                  , l = r[o + 1];
                i === t && l === n || (s.low = i,
                s.high = l,
                a.low = r[o + 2],
                a.high = r[o + 3],
                yield e)
            }
        }
    }
    w.prototype.entryStride = 4;
    var x = n(19)
      , C = n(2)
      , O = n(24)
      , k = n(32);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const E = [O.j, "\nhighp uint hashCombine(highp uint state, highp uint value) {\n  value *= 0xcc9e2d51u;\n  value = (value << 15u) | (value >> 17u);\n  value *= 0x1b873593u;\n  state ^= value;\n  state = (state << 13u) | (state >> 19u);\n  state = (state * 5u) + 0xe6546b64u;\n  return state;\n}\nhighp uint hashCombine(highp uint state, uint64_t x) {\n  state = hashCombine(state, x.value[0]);\n  return hashCombine(state, x.value[1]);\n}\n"]
      , T = Object(k.d)(new k.b, x.a.UINT64, 1);
    class M extends C.a {
        constructor(e, t) {
            super(),
            this.gl = e,
            this.hashTable = t,
            this.generation = -1,
            this.texture = null,
            this.texture = e.createTexture()
        }
        copyToGPU() {
            let {hashTable: e} = this
              , {generation: t} = e;
            if (this.generation === t)
                return;
            const {gl: n, texture: i} = this;
            this.generation = t,
            n.activeTexture(WebGL2RenderingContext.TEXTURE0 + n.tempTextureUnit),
            n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, i),
            e.tableWithMungedEmptyKey(e=>{
                Object(k.f)(this.gl, T, e)
            }
            ),
            n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null)
        }
        disposed() {
            let {gl: e} = this;
            e.deleteTexture(this.texture),
            this.texture = null,
            this.gl = void 0,
            this.hashTable = void 0,
            super.disposed()
        }
        static get(e, t) {
            return e.memoize.get(t, ()=>new this(e,t))
        }
    }
    class D {
        constructor(e, t=3) {
            this.prefix = e,
            this.numAlternatives = t,
            this.textureUnitSymbol = Symbol.for(`gpuhashtable:${this.prefix}`),
            this.accessHelper = new k.a(`gpuhashtable_${this.prefix}`),
            this.samplerName = this.prefix + "_sampler",
            this.hashSeedsName = this.prefix + "_seeds",
            this.hashKeyMask = this.prefix + "_keyMask",
            this.readTable = this.prefix + "_readTable"
        }
        defineShader(e) {
            let {hashSeedsName: t, samplerName: n, numAlternatives: i, hashKeyMask: r} = this;
            e.addUniform("highp uint", t, i),
            e.addUniform("highp uint", r),
            e.addTextureSampler("usampler2D", n, this.textureUnitSymbol),
            e.addFragmentCode(E),
            e.addFragmentCode(O.j),
            e.addFragmentCode(O.c),
            this.accessHelper.defineShader(e),
            e.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, x.a.UINT64, 1));
            let s = "";
            s += `\nbool ${this.hasFunctionName}(uint64_t x) {\n`;
            for (let e = 0; e < i; ++e)
                s += `\n  {\n    uint h = hashCombine(${t}[${e}], x) & ${r};\n    uint64_t key = ${this.readTable}(h);\n    if (equals(key, x)) {\n      return true;\n    }\n  }\n`;
            s += "\n  return false;\n}\n",
            e.addFragmentCode(s)
        }
        get hasFunctionName() {
            return `${this.prefix}_has`
        }
        enable(e, t, n) {
            n.copyToGPU();
            const i = t.textureUnit(this.textureUnitSymbol);
            e.activeTexture(WebGL2RenderingContext.TEXTURE0 + i),
            e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, n.texture),
            e.uniform1ui(t.uniform(this.hashKeyMask), n.hashTable.tableSize - 1),
            e.uniform1uiv(t.uniform(this.hashSeedsName), n.hashTable.hashSeeds)
        }
        disable(e, t) {
            const n = t.textureUnit(this.textureUnitSymbol);
            e.activeTexture(WebGL2RenderingContext.TEXTURE0 + n),
            e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null)
        }
    }
    class L extends D {
        defineShader(e) {
            super.defineShader(e);
            let {numAlternatives: t, hashSeedsName: n, hashKeyMask: i} = this
              , r = `\nbool ${this.getFunctionName}(uint64_t x, out uint64_t value) {\n`;
            for (let e = 0; e < t; ++e)
                r += `\n  {\n    uint h = hashCombine(${n}[${e}], x) & ${i};\n    uint64_t key = ${this.readTable}(h * 2u);\n    if (equals(key, x)) {\n      value = ${this.readTable}(h * 2u + 1u);\n      return true;\n    }\n  }\n`;
            r += "\n  return false;\n}\n",
            e.addFragmentCode(r)
        }
        get getFunctionName() {
            return `${this.prefix}_get`
        }
    }
    var A = n(85)
      , I = n(3);
    class P {
        constructor(e) {
            this.prefix = e,
            this.seedName = this.prefix + "_seed"
        }
        defineShader(e) {
            const {seedName: t} = this;
            e.addUniform("highp uint", t),
            e.addFragmentCode(O.j),
            e.addFragmentCode(E),
            e.addFragmentCode(O.f);
            let n = `\nvec3 ${this.prefix}(uint64_t x) {\n  uint h = hashCombine(${t}, x);\n  vec2 v;\n`;
            for (let e = 0; e < 2; ++e)
                n += `\n  v[${e}] = float(h & 0xFFu) / 255.0;\n  h >>= 8u;\n`;
            n += "\n  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);\n  return hsvToRgb(hsv);\n}\n",
            e.addFragmentCode(n)
        }
        enable(e, t, n) {
            e.uniform1ui(t.uniform(this.seedName), n.hashSeed)
        }
    }
    let R = new Float32Array(3);
    class j {
        constructor(e=Object(c.b)()) {
            this.hashSeed = e,
            this.changed = new I.a
        }
        static getDefault() {
            return new j(0)
        }
        compute(e, t) {
            let n = l(this.hashSeed, t.low);
            n = l(n, t.high);
            const i = (255 & n) / 255
              , r = (n >> 8 & 255) / 255;
            return Object(A.a)(e, i, .5 + .5 * r, 1),
            e
        }
        computeCssColor(e) {
            return this.compute(R, e),
            `rgb(${100 * R[0]}%,${100 * R[1]}%,${100 * R[2]}%)`
        }
        randomize() {
            this.hashSeed = Object(c.b)(),
            this.changed.dispatch()
        }
        toString() {
            return `new SegmentColorHash(${this.hashSeed})`
        }
        toJSON() {
            return 0 === this.hashSeed ? void 0 : this.hashSeed
        }
        reset() {
            this.restoreState(0)
        }
        restoreState(e) {
            const t = e >>> 0;
            t !== this.hashSeed && (this.hashSeed = t,
            this.changed.dispatch())
        }
    }
    class N {
        constructor(e) {
            this.prefix = e,
            this.hashMapShaderManager = new L("segmentStatedColorHash")
        }
        defineShader(e) {
            this.hashMapShaderManager.defineShader(e);
            let t = `\nbool ${this.getFunctionName}(uint64_t x, out vec3 value) {\n  uint64_t uint64Value;\n  if (${this.hashMapShaderManager.getFunctionName}(x, uint64Value)) {\n    uint uintValue = uint64Value.value[0];\n    value.x = float((uintValue & 0xff0000u) >> 16) / 255.0;\n    value.y = float((uintValue & 0x00ff00u) >>  8) / 255.0;\n    value.z = float((uintValue & 0x0000ffu))       / 255.0;\n    return true;\n  }\n  return false;\n}\n`;
            e.addFragmentCode(t)
        }
        get getFunctionName() {
            return `${this.prefix}_get`
        }
        enable(e, t, n) {
            this.hashMapShaderManager.enable(e, t, n)
        }
        disable(e, t) {
            this.hashMapShaderManager.disable(e, t)
        }
    }
    var V = n(53);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const B = Symbol("disjoint_sets:rank")
      , F = Symbol("disjoint_sets:parent")
      , _ = Symbol("disjoint_sets:next")
      , U = Symbol("disjoint_sets:prev");
    function z(e) {
        let t = e
          , n = e[F];
        for (; n !== e; )
            n = (e = n)[F];
        for (e = t[F]; n !== e; )
            t[F] = n,
            t = e,
            e = t[F];
        return n
    }
    function *G(e) {
        let t = e;
        do {
            yield t,
            t = t[_]
        } while (t !== e)
    }
    const $ = Symbol("disjoint_sets:min");
    class W {
        constructor() {
            this.map = new Map,
            this.generation = 0
        }
        get(e) {
            let t = e.toString()
              , n = this.map.get(t);
            return void 0 === n ? e : z(n)[$]
        }
        isMinElement(e) {
            let t = this.get(e);
            return t === e || u.a.equal(t, e)
        }
        makeSet(e) {
            let t = e.toString()
              , {map: n} = this
              , i = n.get(t);
            return void 0 === i ? (i = e.clone(),
            (r = i)[F] = r,
            r[B] = 0,
            r[_] = r[U] = r,
            i[$] = i,
            n.set(t, i),
            i) : z(i);
            var r
        }
        link(e, t) {
            if ((e = this.makeSet(e)) === (t = this.makeSet(t)))
                return !1;
            this.generation++;
            let n = function(e, t) {
                let n = e[B]
                  , i = t[B];
                return n > i ? (t[F] = e,
                e) : (e[F] = t,
                n === i && (t[B] = i + 1),
                t)
            }(e, t);
            !function(e, t) {
                let n = e[U]
                  , i = t[U];
                t[U] = n,
                n[_] = t,
                e[U] = i,
                i[_] = e
            }(e, t);
            let i = e[$]
              , r = t[$];
            return n[$] = u.a.less(i, r) ? i : r,
            !0
        }
        *setElements(e) {
            let t = e.toString()
              , n = this.map.get(t);
            void 0 === n ? yield e : yield*G(n)
        }
        clear() {
            let {map: e} = this;
            return 0 !== e.size && (++this.generation,
            e.clear(),
            !0)
        }
        get size() {
            return this.map.size
        }
        *mappings(e=new Array(2)) {
            for (let t of this.map.values())
                e[0] = t,
                e[1] = z(t)[$],
                yield e
        }
        [Symbol.iterator]() {
            return this.mappings()
        }
        toJSON() {
            let e = new Array;
            for (let n of this.map.values())
                if ((t = n)[F] === t) {
                    let t = new Array;
                    for (let e of G(n))
                        t.push(e);
                    t.sort(u.a.compare),
                    e.push(t)
                }
            var t;
            return e.sort((e,t)=>u.a.compare(e[0], t[0])),
            e.map(e=>e.map(e=>e.toString()))
        }
    }
    var H = n(0)
      , J = n(11);
    let q = class extends J.c {
        constructor() {
            super(...arguments),
            this.disjointSets = new W,
            this.changed = new I.a
        }
        get value() {
            return this
        }
        static makeWithCounterpart(e) {
            let t = new this;
            return t.initializeCounterpart(e),
            t
        }
        disposed() {
            this.disjointSets = void 0,
            this.changed = void 0,
            super.disposed()
        }
        link(e, t) {
            if (this.disjointSets.link(e, t)) {
                let {rpc: n} = this;
                n && n.invoke("DisjointUint64Sets.add", {
                    id: this.rpcId,
                    al: e.low,
                    ah: e.high,
                    bl: t.low,
                    bh: t.high
                }),
                this.changed.dispatch()
            }
        }
        get(e) {
            return this.disjointSets.get(e)
        }
        clear() {
            if (this.disjointSets.clear()) {
                let {rpc: e} = this;
                e && e.invoke("DisjointUint64Sets.clear", {
                    id: this.rpcId
                }),
                this.changed.dispatch()
            }
        }
        setElements(e) {
            return this.disjointSets.setElements(e)
        }
        get size() {
            return this.disjointSets.size
        }
        toJSON() {
            return this.disjointSets.toJSON()
        }
        restoreState(e) {
            if (this.clear(),
            void 0 !== e) {
                let t = [new u.a, new u.a];
                Object(H.b)(e, e=>{
                    Object(H.b)(e, (e,n)=>{
                        t[n % 2].parseString(String(e), 10),
                        0 !== n && this.link(t[0], t[1])
                    }
                    )
                }
                )
            }
        }
    }
    ;
    q = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }([Object(J.f)("DisjointUint64Sets")], q);
    const Y = new u.a
      , X = new u.a;
    Object(J.e)("DisjointUint64Sets.add", (function(e) {
        let t = this.get(e.id);
        Y.low = e.al,
        Y.high = e.ah,
        X.low = e.bl,
        X.high = e.bh,
        t.disjointSets.link(Y, X) && t.changed.dispatch()
    }
    )),
    Object(J.e)("DisjointUint64Sets.clear", (function(e) {
        let t = this.get(e.id);
        t.disjointSets.clear() && t.changed.dispatch()
    }
    ));
    var K = n(56)
      , Z = n(9)
      , Q = n(28)
      , ee = n(112)
      , te = n(7);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class ne {
        constructor(e) {
            this.disjointSets = e,
            this.generation = Number.NaN,
            this.hashMap = new w
        }
        update() {
            let {disjointSets: e} = this;
            const {generation: t} = e;
            if (this.generation !== t) {
                this.generation = t;
                let {hashMap: n} = this;
                n.clear();
                for (let[t,i] of e.mappings())
                    n.set(t, i)
            }
        }
    }
    class ie extends ee.a {
        constructor(e, t) {
            super(e, {
                shaderParameters: new te.a(e=>({
                    hasEquivalences: e.registerDisposer(Object(te.g)(e=>0 !== e.size, [t.segmentEquivalences])),
                    hasHighlightedSegments: e.registerDisposer(Object(te.g)(e=>0 !== e.size, [t.highlightedSegments])),
                    hasSegmentStatedColors: e.registerDisposer(Object(te.g)(e=>0 !== e.size, [t.segmentStatedColors])),
                    hideSegmentZero: t.hideSegmentZero
                })),
                transform: t.transform,
                renderScaleHistogram: t.renderScaleHistogram,
                renderScaleTarget: t.renderScaleTarget,
                localPosition: t.localPosition
            }),
            this.displayState = t,
            this.segmentColorShaderManager = new P("segmentColorHash"),
            this.segmentStatedColorShaderManager = new N("segmentStatedColor"),
            this.gpuSegmentStatedColorHashTable = M.get(this.gl, this.displayState.segmentStatedColors.hashTable),
            this.hashTableManager = new D("visibleSegments"),
            this.gpuHashTable = M.get(this.gl, this.displayState.visibleSegments.hashTable),
            this.hashTableManagerHighlighted = new D("highlightedSegments"),
            this.gpuHashTableHighlighted = M.get(this.gl, this.displayState.highlightedSegments.hashTable),
            this.equivalencesShaderManager = new L("equivalences"),
            this.equivalencesHashMap = new ne(this.displayState.segmentEquivalences.disjointSets),
            this.gpuEquivalencesHashTable = M.get(this.gl, this.equivalencesHashMap.hashMap),
            this.registerDisposer(this.shaderParameters),
            Object(V.f)(t, this),
            this.registerDisposer(t.selectedAlpha.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(t.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch))
        }
        getSources(e) {
            return this.multiscaleSource.getSources(e)
        }
        defineShader(e, t) {
            this.hashTableManager.defineShader(e),
            e.addFragmentCode("\nuint64_t getUint64DataValue() {\n  return toUint64(getDataValue());\n}\n"),
            t.hasEquivalences ? (this.equivalencesShaderManager.defineShader(e),
            e.addFragmentCode(`\nuint64_t getMappedObjectId() {\n  uint64_t value = getUint64DataValue();\n  uint64_t mappedValue;\n  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {\n    return mappedValue;\n  }\n  return value;\n}\n`)) : e.addFragmentCode("\nuint64_t getMappedObjectId() {\n  return getUint64DataValue();\n}\n"),
            this.segmentColorShaderManager.defineShader(e),
            e.addUniform("highp uvec2", "uSelectedSegment"),
            e.addUniform("highp uint", "uShowAllSegments"),
            e.addUniform("highp float", "uSelectedAlpha"),
            e.addUniform("highp float", "uNotSelectedAlpha"),
            e.addUniform("highp float", "uSaturation");
            let n = "\n  uint64_t value = getMappedObjectId();\n\n  float alpha = uSelectedAlpha;\n  float saturation = uSaturation;\n";
            t.hideSegmentZero && (n += "\n  if (value.value[0] == 0u && value.value[1] == 0u) {\n    emit(vec4(vec4(0, 0, 0, 0)));\n    return;\n  }\n"),
            n += `\n  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);\n  if (uSelectedSegment == value.value) {\n    saturation *= has ? 0.5 : 0.75;\n  } else if (!has) {\n    alpha = uNotSelectedAlpha;\n  }\n`,
            t.hasSegmentStatedColors ? (this.segmentStatedColorShaderManager.defineShader(e),
            n += `\n  vec3 rgb;\n  if (!${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {\n    rgb = segmentColorHash(value);\n  }\n`) : n += "\n  vec3 rgb = segmentColorHash(value);\n",
            t.hasHighlightedSegments && (this.hashTableManagerHighlighted.defineShader(e),
            n += `\n  if (${this.hashTableManagerHighlighted.hasFunctionName}(value)) {\n    rgb = vec3(0.2,0.2,2.0);\n    saturation = 1.0;\n  };\n`),
            n += "\n  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));\n",
            e.setFragmentMain(n)
        }
        initializeShader(e, t, n) {
            const {gl: i} = this
              , {displayState: r} = this
              , {segmentSelectionState: s, visibleSegments: a} = this.displayState;
            let o = 0
              , l = 0;
            if (s.hasSelectedSegment) {
                let e = s.selectedSegment;
                o = e.low,
                l = e.high
            }
            i.uniform1f(t.uniform("uSelectedAlpha"), this.displayState.selectedAlpha.value),
            i.uniform1f(t.uniform("uSaturation"), this.displayState.saturation.value),
            i.uniform1f(t.uniform("uNotSelectedAlpha"), this.displayState.notSelectedAlpha.value),
            i.uniform2ui(t.uniform("uSelectedSegment"), o, l),
            i.uniform1ui(t.uniform("uShowAllSegments"), a.hashTable.size ? 0 : 1),
            this.hashTableManager.enable(i, t, this.gpuHashTable),
            n.hasHighlightedSegments && this.hashTableManagerHighlighted.enable(i, t, this.gpuHashTableHighlighted),
            n.hasEquivalences && (this.equivalencesHashMap.update(),
            this.equivalencesShaderManager.enable(i, t, this.gpuEquivalencesHashTable)),
            this.segmentColorShaderManager.enable(i, t, r.segmentColorHash),
            n.hasSegmentStatedColors && this.segmentStatedColorShaderManager.enable(i, t, this.gpuSegmentStatedColorHashTable)
        }
        endSlice(e, t, n) {
            const {gl: i} = this;
            this.hashTableManager.disable(i, t),
            n.hasHighlightedSegments && this.hashTableManagerHighlighted.disable(i, t),
            n.hasEquivalences && this.equivalencesShaderManager.disable(i, t),
            n.hasSegmentStatedColors && this.segmentStatedColorShaderManager.disable(i, t),
            super.endSlice(e, t, n)
        }
    }
    var re, se = n(95), ae = n(17), oe = n(82);
    let le = re = class extends J.c {
        constructor() {
            super(...arguments),
            this.hashTable = new w,
            this.changed = new I.b
        }
        get value() {
            return this
        }
        static makeWithCounterpart(e) {
            let t = new re;
            return t.initializeCounterpart(e),
            t
        }
        disposed() {
            super.disposed(),
            this.hashTable = void 0,
            this.changed = void 0
        }
        set_(e, t) {
            return this.hashTable.set(e, t)
        }
        set(e, t) {
            if (this.set_(e, t)) {
                let {rpc: n} = this;
                n && n.invoke("Uint64Map.set", {
                    id: this.rpcId,
                    key: e,
                    value: t
                }),
                this.changed.dispatch(e, !0)
            }
        }
        has(e) {
            return this.hashTable.has(e)
        }
        get(e, t) {
            return this.hashTable.get(e, t)
        }
        [Symbol.iterator]() {
            return this.hashTable.entries()
        }
        delete_(e) {
            return this.hashTable.delete(e)
        }
        delete(e) {
            if (this.delete_(e)) {
                let {rpc: t} = this;
                t && t.invoke("Uint64Map.delete", {
                    id: this.rpcId,
                    key: e
                }),
                this.changed.dispatch(e, !1)
            }
        }
        get size() {
            return this.hashTable.size
        }
        clear() {
            if (this.hashTable.clear()) {
                let {rpc: e} = this;
                e && e.invoke("Uint64Map.clear", {
                    id: this.rpcId
                }),
                this.changed.dispatch(null, !1)
            }
        }
        toJSON() {
            let e = {};
            for (let[t,n] of this.hashTable.entries())
                e[t.toString()] = n.toString();
            return e
        }
    }
    ;
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var ce;
    le = re = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }([Object(J.f)("Uint64Map")], le),
    Object(J.e)("Uint64Map.set", (function(e) {
        let t = this.get(e.id);
        t.set_(e.key, e.value) && t.changed.dispatch()
    }
    )),
    Object(J.e)("Uint64Map.delete", (function(e) {
        let t = this.get(e.id);
        t.delete_(e.key) && t.changed.dispatch()
    }
    )),
    Object(J.e)("Uint64Map.clear", (function(e) {
        let t = this.get(e.id);
        t.hashTable.clear() && t.changed.dispatch()
    }
    ));
    let ue = ce = class extends J.c {
        constructor() {
            super(...arguments),
            this.hashTable = new g,
            this.changed = new I.b
        }
        get value() {
            return this
        }
        static makeWithCounterpart(e) {
            let t = new ce;
            return t.initializeCounterpart(e),
            t
        }
        disposed() {
            super.disposed(),
            this.hashTable = void 0,
            this.changed = void 0
        }
        add_(e) {
            return this.hashTable.add(e)
        }
        add(e) {
            if (this.add_(e)) {
                let {rpc: t} = this;
                t && t.invoke("Uint64Set.add", {
                    id: this.rpcId,
                    value: e
                }),
                this.changed.dispatch(e, !0)
            }
        }
        has(e) {
            return this.hashTable.has(e)
        }
        [Symbol.iterator]() {
            return this.hashTable.keys()
        }
        delete_(e) {
            return this.hashTable.delete(e)
        }
        delete(e) {
            if (this.delete_(e)) {
                let {rpc: t} = this;
                t && t.invoke("Uint64Set.delete", {
                    id: this.rpcId,
                    value: e
                }),
                this.changed.dispatch(e, !1)
            }
        }
        get size() {
            return this.hashTable.size
        }
        clear() {
            if (this.hashTable.clear()) {
                let {rpc: e} = this;
                e && e.invoke("Uint64Set.clear", {
                    id: this.rpcId
                }),
                this.changed.dispatch(null, !1)
            }
        }
        toJSON() {
            let e = new Array;
            for (let t of this)
                e.push(t.toString());
            return e.sort(),
            e
        }
    }
    ;
    ue = ce = function(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            a = Reflect.decorate(e, t, n, i);
        else
            for (var o = e.length - 1; o >= 0; o--)
                (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a),
        a
    }([Object(J.f)("Uint64Set")], ue),
    Object(J.e)("Uint64Set.add", (function(e) {
        let t = this.get(e.id);
        t.add_(e.value) && t.changed.dispatch()
    }
    )),
    Object(J.e)("Uint64Set.delete", (function(e) {
        let t = this.get(e.id);
        t.delete_(e.value) && t.changed.dispatch()
    }
    )),
    Object(J.e)("Uint64Set.clear", (function(e) {
        let t = this.get(e.id);
        t.hashTable.clear() && t.changed.dispatch()
    }
    ));
    var de = n(62)
      , he = n(34)
      , pe = n(96)
      , fe = n(102)
      , me = n(78)
      , ge = n(79)
      , ve = n(72)
      , be = n(87);
    n(175);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let ye = new u.a;
    class Se extends C.a {
        constructor(e) {
            super(),
            this.displayState = e,
            this.element = document.createElement("div"),
            this.clearButton = document.createElement("button"),
            this.itemContainer = document.createElement("span"),
            this.items = new Map;
            let {element: t, clearButton: n, itemContainer: i} = this;
            t.className = "segment-set-widget neuroglancer-noselect",
            n.className = "clear-button",
            n.title = "Remove all segment IDs",
            this.registerEventListener(n, "click", ()=>{
                this.visibleSegments.clear()
            }
            ),
            i.className = "item-container",
            t.appendChild(i),
            i.appendChild(n),
            this.registerDisposer(e.visibleSegments.changed.add((e,t)=>{
                this.handleSetChanged(e, t)
            }
            )),
            this.registerDisposer(e.segmentColorHash.changed.add(()=>{
                this.handleColorChanged()
            }
            ));
            for (let t of e.visibleSegments)
                this.addElement(t.toString());
            this.updateClearButtonVisibility()
        }
        get visibleSegments() {
            return this.displayState.visibleSegments
        }
        get segmentColorHash() {
            return this.displayState.segmentColorHash
        }
        get segmentSelectionState() {
            return this.displayState.segmentSelectionState
        }
        updateClearButtonVisibility() {
            let {clearButton: e} = this;
            e.style.display = this.displayState.visibleSegments.size > 0 ? "" : "none"
        }
        handleSetChanged(e, t) {
            this.updateClearButtonVisibility();
            let {items: n} = this;
            if (null === e) {
                let {itemContainer: e, clearButton: t} = this;
                for (; ; ) {
                    let n = e.lastElementChild;
                    if (n === t)
                        break;
                    e.removeChild(n)
                }
                n.clear()
            } else if (t)
                this.addElement(e.toString());
            else {
                let t = e.toString()
                  , i = n.get(t);
                i.parentElement.removeChild(i),
                n.delete(t)
            }
        }
        addElement(e) {
            let t = document.createElement("button");
            t.className = "segment-button",
            t.textContent = e,
            t.title = `Remove segment ID ${e}`;
            let n = this;
            t.addEventListener("click", (function() {
                ye.tryParseString(this.textContent),
                n.visibleSegments.delete(ye)
            }
            )),
            t.addEventListener("mouseenter", (function() {
                ye.tryParseString(this.textContent),
                n.segmentSelectionState.set(ye)
            }
            )),
            t.addEventListener("mouseleave", (function() {
                ye.tryParseString(this.textContent),
                n.segmentSelectionState.set(null)
            }
            )),
            this.setItemColor(t),
            this.itemContainer.appendChild(t),
            this.items.set(e, t)
        }
        setItemColor(e) {
            ye.tryParseString(e.textContent),
            e.style.backgroundColor = this.segmentColorHash.computeCssColor(ye)
        }
        handleColorChanged() {
            this.items.forEach(e=>{
                this.setItemColor(e)
            }
            )
        }
        disposed() {
            let {element: e} = this
              , {parentElement: t} = e;
            t && t.removeChild(e),
            super.disposed()
        }
    }
    var we = n(80)
      , xe = n(81)
      , Ce = n(41)
      , Oe = n(114);
    class ke {
        constructor() {
            this.ara_id = new Map([[1, "1: TMv: Tuberomammillary nucleus, ventral part"], [2, "2: SSp-m6b: Primary somatosensory area, mouth, layer 6b"], [3, "3: sec: secondary fissure"], [4, "4: IC: Inferior colliculus"], [6, "6: int: internal capsule"], [7, "7: PSV: Principal sensory nucleus of the trigeminal"], [9, "9: SSp-tr6a: Primary somatosensory area, trunk, layer 6a"], [10, "10: SCig: Superior colliculus, motor related, intermediate gray layer"], [11, "11: plf: posterolateral fissure"], [12, "12: IF: Interfascicular nucleus raphe"], [14, "14: im: internal medullary lamina of the thalamus"], [15, "15: PT: Parataenial nucleus"], [16, "16: 6b: Layer 6b, isocortex"], [17, "17: SCiw: Superior colliculus, motor related, intermediate white layer"], [18, "18: nf: nodular fissure"], [19, "19: IG: Induseum griseum"], [20, "20: ENTl2: Entorhinal area, lateral part, layer 2"], [21, "21: lotg: lateral olfactory tract, general"], [22, "22: PTLp: Posterior parietal association areas"], [23, "23: AAA: Anterior amygdalar area"], [25, "25: sif: simple fissure"], [26, "26: SCdg: Superior colliculus, motor related, deep gray layer"], [27, "27: IGL: Intergeniculate leaflet of the lateral geniculate complex"], [28, "28: ENTl6a: Entorhinal area, lateral part, layer 6a"], [29, "29: sttl: lateral spinothalamic tract"], [30, "30: PVa: Periventricular hypothalamic nucleus, anterior part"], [31, "31: ACA: Anterior cingulate area"], [33, "33: VISp6a: Primary visual area, layer 6a"], [34, "34: icf: intercrural fissure"], [35, "35: III: Oculomotor nucleus"], [36, "36: GU1: Gustatory areas, layer 1"], [37, "37: lab: longitudinal association bundle"], [38, "38: PVH: Paraventricular hypothalamic nucleus"], [39, "39: ACAd: Anterior cingulate area, dorsal part"], [41, "41: VISpm2/3: posteromedial visual area, layer 2/3"], [42, "42: SCdw: Superior colliculus, motor related, deep white layer"], [43, "43: apf: ansoparamedian fissure"], [44, "44: ILA: Infralimbic area"], [45, "45: SPVOrdm: Spinal nucleus of the trigeminal, oral part, rostral dorsomedial part"], [46, "46: mfbsma: mammillary related"], [47, "47: PVHam: Paraventricular hypothalamic nucleus, magnocellular division, anterior magnocellular part"], [48, "48: ACAv: Anterior cingulate area, ventral part"], [49, "49: ipf: intraparafloccular fissure"], [50, "50: PRC: Precommissural nucleus"], [51, "51: ILM: Intralaminar nuclei of the dorsal thalamus"], [52, "52: ENTl3: Entorhinal area, lateral part, layer 3"], [53, "53: SPVOmdmd: Spinal nucleus of the trigeminal, oral part, middle dorsomedial part, dorsal zone"], [54, "54: mfb: medial forebrain bundle"], [55, "55: PVHap: Paraventricular hypothalamic nucleus, parvicellular division, anterior parvicellular part"], [56, "56: ACB: Nucleus accumbens"], [57, "57: pms: paramedian sulcus"], [58, "58: MT: Medial terminal nucleus of the accessory optic tract"], [59, "59: IMD: Intermediodorsal nucleus of the thalamus"], [60, "60: ENTl6b: Entorhinal area, lateral part, layer 6b"], [61, "61: SPVOmdmv: Spinal nucleus of the trigeminal, oral part, middle dorsomedial part, ventral zone"], [62, "62: mlf: medial longitudinal fascicle"], [63, "63: PVHd: Paraventricular hypothalamic nucleus, descending division"], [64, "64: AD: Anterodorsal nucleus"], [65, "65: pfs: parafloccular sulcus"], [66, "66: LT: Lateral terminal nucleus of the accessory optic tract"], [67, "67: INC: Interstitial nucleus of Cajal"], [68, "68: FRP1: Frontal pole, layer 1"], [69, "69: SPVOvl: Spinal nucleus of the trigeminal, oral part, ventrolateral part"], [70, "70: mfbsm: midbrain related"], [71, "71: PVHm: Paraventricular hypothalamic nucleus, magnocellular division"], [72, "72: ADP: Anterodorsal preoptic nucleus"], [73, "73: VS: ventricular systems"], [74, "74: VISl6a: Lateral visual area, layer 6a"], [75, "75: DT: Dorsal terminal nucleus of the accessory optic tract"], [76, "76: INV: Interstitial nucleus of the vestibular nerve"], [77, "77: SPVOcdm: Spinal nucleus of the trigeminal, oral part, caudal dorsomedial part"], [78, "78: mcp: middle cerebellar peduncle"], [79, "79: PVHmm: Paraventricular hypothalamic nucleus, magnocellular division, medial magnocellular part"], [80, "80: AHA: Anterior hypothalamic area"], [81, "81: VL: lateral ventricle"], [82, "82: NLLd: Nucleus of the lateral lemniscus, dorsal part"], [83, "83: IO: Inferior olivary complex"], [84, "84: PL6a: Prelimbic area, layer 6a"], [85, "85: sct: spinocerebellar tract"], [86, "86: mtc: middle thalamic commissure"], [87, "87: PVHmpd: Paraventricular hypothalamic nucleus, parvicellular division, medial parvicellular part, dorsal zone"], [88, "88: AHN: Anterior hypothalamic nucleus"], [89, "89: RC: rhinocele"], [90, "90: NLLh: Nucleus of the lateral lemniscus, horizontal part"], [91, "91: IP: Interposed nucleus"], [92, "92: ENTl4: Entorhinal area, lateral part, layer 4"], [93, "93: moV: motor root of the trigeminal nerve"], [94, "94: PVHp: Paraventricular hypothalamic nucleus, parvicellular division"], [95, "95: AI: Agranular insular area"], [96, "96: DCO: Dorsal cochlear nucleus"], [97, "97: TEa1: Temporal association areas, layer 1"], [98, "98: SEZ: subependymal zone"], [99, "99: NLLv: Nucleus of the lateral lemniscus, ventral part"], [100, "100: IPN: Interpeduncular nucleus"], [101, "101: VCO: Ventral cochlear nucleus"], [102, "102: nst: nigrostriatal tract"], [103, "103: PVHpm: Paraventricular hypothalamic nucleus, magnocellular division, posterior magnocellular part"], [104, "104: AId: Agranular insular area, dorsal part"], [105, "105: SOCm: Superior olivary complex, medial part"], [106, "106: ISN: Inferior salivatory nucleus"], [107, "107: MO1: Somatomotor areas, Layer 1"], [108, "108: chpl: choroid plexus"], [109, "109: ntt: nigrothalamic fibers"], [110, "110: PVHpv: Paraventricular hypothalamic nucleus, parvicellular division, periventricular part"], [111, "111: AIp: Agranular insular area, posterior part"], [112, "112: CNlam: Granular lamina of the cochlear nuclei"], [113, "113: SSp-ll2/3: Primary somatosensory area, lower limb, layer 2/3"], [114, "114: SOCl: Superior olivary complex, lateral part"], [115, "115: IV: Trochlear nucleus"], [116, "116: chfl: choroid fissure"], [117, "117: och: optic chiasm"], [118, "118: PVi: Periventricular hypothalamic nucleus, intermediate part"], [119, "119: AIv: Agranular insular area, ventral part"], [120, "120: AIp1: Agranular insular area, posterior part, layer 1"], [121, "121: VISl6b: Lateral visual area, layer 6b"], [122, "122: POR: Superior olivary complex, periolivary region"], [123, "123: KF: Koelliker-Fuse subnucleus"], [124, "124: IVF: interventricular foramen"], [125, "125: opt: optic tract"], [126, "126: PVp: Periventricular hypothalamic nucleus, posterior part"], [127, "127: AM: Anteromedial nucleus"], [128, "128: MRN: Midbrain reticular nucleus"], [129, "129: V3: third ventricle"], [130, "130: CSm: Superior central nucleus raphe, medial part"], [131, "131: LA: Lateral amygdalar nucleus"], [132, "132: PL6b: Prelimbic area, layer 6b"], [133, "133: PVpo: Periventricular hypothalamic nucleus, preoptic part"], [134, "134: ptf: pallidotegmental fascicle"], [135, "135: AMB: Nucleus ambiguus"], [136, "136: IRN: Intermediate reticular nucleus"], [137, "137: CSl: Superior central nucleus raphe, lateral part"], [138, "138: LAT: Lateral group of the dorsal thalamus"], [139, "139: ENTl5: Entorhinal area, lateral part, layer 5"], [140, "140: AQ: cerebral aqueduct"], [141, "141: PVR: Periventricular region"], [142, "142: pap: pallidothalamic pathway"], [143, "143: AMBv: Nucleus ambiguus, ventral division"], [144, "144: OT1-3: Olfactory tubercle, layers 1-3"], [145, "145: V4: fourth ventricle"], [146, "146: PRNr: Pontine reticular nucleus"], [147, "147: LC: Locus ceruleus"], [148, "148: GU4: Gustatory areas, layer 4"], [149, "149: PVT: Paraventricular nucleus of the thalamus"], [150, "150: pvbh: periventricular bundle of the hypothalamus"], [151, "151: AOB: Accessory olfactory bulb"], [152, "152: PIR1-3: Piriform area, layers 1-3"], [153, "153: V4r: lateral recess"], [154, "154: PHY: Perihypoglossal nuclei"], [155, "155: LD: Lateral dorsal nucleus of thalamus"], [156, "156: AUDd6a: Dorsal auditory area, layer 6a"], [157, "157: PVZ: Periventricular zone"], [158, "158: pc: posterior commissure"], [159, "159: AON: Anterior olfactory nucleus"], [160, "160: AON1: Anterior olfactory nucleus, layer 1"], [161, "161: NIS: Nucleus intercalatus"], [162, "162: LDT: Laterodorsal tegmental nucleus"], [163, "163: AIp2/3: Agranular insular area, posterior part, layer 2/3"], [164, "164: c: central canal, spinal cord/medulla"], [165, "165: RAmb: Midbrain raphe nuclei"], [166, "166: pmx: premammillary commissure"], [167, "167: AONd: Anterior olfactory nucleus, dorsal part"], [168, "168: AON2: Anterior olfactory nucleus, layer 2"], [169, "169: PRP: Nucleus prepositus"], [170, "170: LGd: Dorsal part of the lateral geniculate complex"], [171, "171: PL1: Prelimbic area, layer 1"], [173, "173: RCH: Retrochiasmatic area"], [174, "174: poc: preoptic commissure"], [175, "175: AONe: Anterior olfactory nucleus, external part"], [177, "177: NR: Nucleus of Roller"], [178, "178: LGv: Ventral part of the lateral geniculate complex"], [179, "179: ACA6a: Anterior cingulate area, layer 6a"], [180, "180: GU2/3: Gustatory areas, layer 2/3"], [181, "181: RE: Nucleus of reuniens"], [182, "182: php: propriohypothalamic pathways"], [183, "183: AONl: Anterior olfactory nucleus, lateral part"], [184, "184: FRP: Frontal pole, cerebral cortex"], [185, "185: PPYd: Parapyramidal nucleus, deep part"], [186, "186: LH: Lateral habenula"], [187, "187: GU5: Gustatory areas, layer 5"], [188, "188: AOBgl: Accessory olfactory bulb, glomerular layer"], [189, "189: RH: Rhomboid nucleus"], [190, "190: py: pyramid"], [191, "191: AONm: Anterior olfactory nucleus, medial part"], [192, "192: COAa1: Cortical amygdalar area, anterior part, layer 1"], [193, "193: PPYs: Parapyramidal nucleus, superficial part"], [194, "194: LHA: Lateral hypothalamic area"], [195, "195: PL2: Prelimbic area, layer 2"], [196, "196: AOBgr: Accessory olfactory bulb, granular layer"], [197, "197: RL: Rostral linear nucleus raphe"], [198, "198: pyd: pyramidal decussation"], [199, "199: AONpv: Anterior olfactory nucleus, posteroventral part"], [200, "200: COAa2: Cortical amygdalar area, anterior part, layer 2"], [201, "201: SSp-bfd2/3: Primary somatosensory area, barrel field, layer 2/3"], [202, "202: MV: Medial vestibular nucleus"], [203, "203: LIN: Linear nucleus of the medulla"], [204, "204: AOBmi: Accessory olfactory bulb, mitral layer"], [205, "205: rstl: retriculospinal tract, lateral part"], [206, "206: RM: Nucleus raphe magnus"], [207, "207: AP: Area postrema"], [208, "208: COAa3: Cortical amygdalar area, anterior part, layer 3"], [209, "209: LAV: Lateral vestibular nucleus"], [210, "210: LM: Lateral mammillary nucleus"], [211, "211: ACAd2/3: Anterior cingulate area, dorsal part, layer 2/3"], [212, "212: MOBgl: Main olfactory bulb, glomerular layer"], [213, "213: rstm: retriculospinal tract, medial part"], [214, "214: RN: Red nucleus"], [215, "215: APN: Anterior pretectal nucleus"], [216, "216: COApl1: Cortical amygdalar area, posterior part, lateral zone, layer 1"], [217, "217: SUV: Superior vestibular nucleus"], [218, "218: LP: Lateral posterior nucleus of the thalamus"], [219, "219: MO2/3: Somatomotor areas, Layer 2/3"], [220, "220: MOBgr: Main olfactory bulb, granule layer"], [221, "221: rrt: rubroreticular tract"], [222, "222: RO: Nucleus raphe obscurus"], [223, "223: ARH: Arcuate hypothalamic nucleus"], [224, "224: COApl2: Cortical amygdalar area, posterior part, lateral zone, layer 2"], [225, "225: SPIV: Spinal vestibular nucleus"], [226, "226: LPO: Lateral preoptic area"], [227, "227: ACA6b: Anterior cingulate area, layer 6b"], [228, "228: MOBipl: Main olfactory bulb, inner plexiform layer"], [229, "229: sV: sensory root of the trigeminal nerve"], [230, "230: RPA: Nucleus raphe pallidus"], [231, "231: AT: Anterior tegmental nucleus"], [232, "232: COApl3: Cortical amygdalar area, posterior part, lateral zone, layer 3"], [233, "233: VISal5: Anterolateral visual area, layer 5"], [234, "234: TEa4: Temporal association areas, layer 4"], [235, "235: LRN: Lateral reticular nucleus"], [236, "236: MOBmi: Main olfactory bulb, mitral layer"], [237, "237: ts: solitary tract"], [238, "238: RPO: Nucleus raphe pontis"], [239, "239: ATN: Anterior group of the dorsal thalamus"], [240, "240: COApm1: Cortical amygdalar area, posterior part, medial zone, layer 1"], [241, "241: PTLp2/3: Posterior parietal association areas, layer 2/3"], [242, "242: LS: Lateral septal nucleus"], [243, "243: AUDd6b: Dorsal auditory area, layer 6b"], [244, "244: MOBopl: Main olfactory bulb, outer plexiform layer"], [245, "245: scrt: spinocervical tract"], [246, "246: RR: Midbrain reticular nucleus, retrorubral area"], [247, "247: AUD: Auditory areas"], [248, "248: COApm2: Cortical amygdalar area, posterior part, medial zone, layer 2"], [249, "249: AUDpo6a: Posterior auditory area, layer 6a"], [250, "250: LSc: Lateral septal nucleus, caudal (caudodorsal) part"], [251, "251: AUDp2/3: Primary auditory area, layer 2/3"], [252, "252: AUDd5: Dorsal auditory area, layer 5"], [253, "253: shp: spinohypothalamic pathway"], [254, "254: RSP: Retrosplenial area"], [255, "255: AV: Anteroventral nucleus of thalamus"], [256, "256: COApm3: Cortical amygdalar area, posterior part, medial zone, layer 3"], [257, "257: VISpm6a: posteromedial visual area, layer 6a"], [258, "258: LSr: Lateral septal nucleus, rostral (rostroventral) part"], [259, "259: ENTmv1: Entorhinal area, medial part, ventral zone, layer 1"], [260, "260: NLOT1: Nucleus of the lateral olfactory tract, molecular layer"], [261, "261: sop: spino-olivary pathway"], [262, "262: RT: Reticular nucleus of the thalamus"], [263, "263: AVP: Anteroventral preoptic nucleus"], [264, "264: ORB1: Orbital area, layer 1"], [266, "266: LSv: Lateral septal nucleus, ventral part"], [267, "267: DP6a: Dorsal peduncular area, layer 6a"], [268, "268: NLOT2: Nucleus of the lateral olfactory tract, pyramidal layer"], [269, "269: VISpl2/3: Posterolateral visual area, layer 2/3"], [270, "270: srp: spinoreticular pathway"], [271, "271: SAG: Nucleus sagulum"], [272, "272: AVPV: Anteroventral periventricular nucleus"], [274, "274: RSPd6a: Retrosplenial area, dorsal part, layer 6a"], [275, "275: LSX: Lateral septal complex"], [276, "276: PIR1: Piriform area, molecular layer"], [277, "277: stp: spinotectal pathway"], [278, "278: sAMY: Striatum-like amygdalar nuclei"], [279, "279: RSPagl6b: Retrosplenial area, lateral agranular part, layer 6b"], [280, "280: B: Barrington's nucleus"], [281, "281: VISam1: Anteromedial visual area, layer 1"], [283, "283: LTN: Lateral tegmental nucleus"], [284, "284: PIR2: Piriform area, pyramidal layer"], [285, "285: step: spinotelenchephalic pathway"], [286, "286: SCH: Suprachiasmatic nucleus"], [287, "287: BAC: Bed nucleus of the anterior commissure"], [288, "288: ORBvl2/3: Orbital area, ventrolateral part, layer 2/3"], [289, "289: TEa5: Temporal association areas, layer 5"], [290, "290: LZ: Hypothalamic lateral zone"], [291, "291: PIR3: Piriform area, polymorph layer"], [292, "292: BA: Bed nucleus of the accessory olfactory tract"], [293, "293: svp: spinovestibular pathway"], [294, "294: SCm: Superior colliculus, motor related"], [295, "295: BLA: Basolateral amygdalar nucleus"], [296, "296: ACAv2/3: Anterior cingulate area, ventral part, layer 2/3"], [297, "297: TTd1-4: Taenia tecta, dorsal part, layers 1-4"], [298, "298: MA: Magnocellular nucleus"], [299, "299: MO5: Somatomotor areas, Layer 5"], [300, "300: LGvl: Ventral part of the lateral geniculate complex, lateral zone"], [301, "301: st: stria terminalis"], [302, "302: SCs: Superior colliculus, sensory related"], [303, "303: BLAa: Basolateral amygdalar nucleus, anterior part"], [304, "304: PL2/3: Prelimbic area, layer 2/3"], [305, "305: VISp6b: Primary visual area, layer 6b"], [306, "306: TTv1-3: Taenia tecta, ventral part, layers 1-3"], [307, "307: MARN: Magnocellular reticular nucleus"], [308, "308: PTLp6a: Posterior parietal association areas, layer 6a"], [309, "309: snp: striatonigral pathway"], [310, "310: SF: Septofimbrial nucleus"], [311, "311: BLAp: Basolateral amygdalar nucleus, posterior part"], [312, "312: ENTl4/5: Entorhinal area, lateral part, layer 4/5"], [313, "313: MB: Midbrain"], [314, "314: AIp6a: Agranular insular area, posterior part, layer 6a"], [315, "315: Isocortex: Isocortex"], [316, "316: LGvm: Ventral part of the lateral geniculate complex, medial zone"], [317, "317: stf: subthalamic fascicle"], [318, "318: SG: Supragenual nucleus"], [319, "319: BMA: Basomedial amygdalar nucleus"], [320, "320: MOp1: Primary motor area, Layer 1"], [321, "321: SubG: Subgeniculate nucleus"], [322, "322: SSp: Primary somatosensory area"], [323, "323: MBmot: Midbrain, motor related"], [324, "324: ENTmv2: Entorhinal area, medial part, ventral zone, layer 2"], [325, "325: SGN: Suprageniculate nucleus"], [326, "326: scp: superior cerebelar peduncles"], [327, "327: BMAa: Basomedial amygdalar nucleus, anterior part"], [328, "328: AId2/3: Agranular insular area, dorsal part, layer 2/3"], [329, "329: SSp-bfd: Primary somatosensory area, barrel field"], [330, "330: RSPd6b: Retrosplenial area, dorsal part, layer 6b"], [331, "331: MBO: Mammillary body"], [332, "332: ASO: Accessory supraoptic group"], [333, "333: SH: Septohippocampal nucleus"], [334, "334: BMAp: Basomedial amygdalar nucleus, posterior part"], [335, "335: PERI6a: Perirhinal area, layer 6a"], [336, "336: csc: superior colliculus commissure"], [337, "337: SSp-ll: Primary somatosensory area, lower limb"], [338, "338: SFO: Subfornical organ"], [339, "339: MBsen: Midbrain, sensory related"], [340, "340: PTLp6b: Posterior parietal association areas, layer 6b"], [341, "341: smd: supramammillary decussation"], [342, "342: SI: Substantia innominata"], [343, "343: BS: Brain stem"], [344, "344: AIp5: Agranular insular area, posterior part, layer 5"], [345, "345: SSp-m: Primary somatosensory area, mouth"], [346, "346: SSp2/3: Primary somatosensory area, layer 2/3"], [347, "347: SBPV: Subparaventricular zone"], [348, "348: MBsta: Midbrain, behavioral state related"], [349, "349: sup: supraoptic commissures"], [350, "350: SLC: Subceruleus nucleus"], [351, "351: BST: Bed nuclei of the stria terminalis"], [352, "352: ORB5: Orbital area, layer 5"], [353, "353: SSp-n: Primary somatosensory area, nose"], [354, "354: MY: Medulla"], [355, "355: AIp6b: Agranular insular area, posterior part, layer 6b"], [356, "356: PST: Preparasubthalamic nucleus"], [357, "357: ttp: tectothalamic pathway"], [358, "358: SLD: Sublaterodorsal nucleus"], [359, "359: BSTa: Bed nuclei of the stria terminalis, anterior division"], [360, "360: DP2/3: Dorsal peduncular area, layer 2/3"], [361, "361: SSp-tr: Primary somatosensory area, trunk"], [362, "362: MD: Mediodorsal nucleus of thalamus"], [363, "363: PL5: Prelimbic area, layer 5"], [364, "364: PSTN: Parasubthalamic nucleus"], [365, "365: tp: thalamic peduncles"], [366, "366: SMT: Submedial nucleus of the thalamus"], [367, "367: BSTp: Bed nuclei of the stria terminalis, posterior division"], [368, "368: PERI6b: Perirhinal area, layer 6b"], [369, "369: SSp-ul: Primary somatosensory area, upper limb"], [370, "370: MY-mot: Medulla, motor related"], [371, "371: ENTmv3: Entorhinal area, medial part, ventral zone, layer 3"], [372, "372: ICB: Infracerebellar nucleus"], [373, "373: tct: trigeminocerebellar tract"], [374, "374: SNc: Substantia nigra, compact part"], [375, "375: CA: Ammon's horn"], [376, "376: COApl1-3: Cortical amygdalar area, posterior part, lateral zone, layers 1-3"], [377, "377: VISpl6a: Posterolateral visual area, layer 6a"], [378, "378: SSs: Supplemental somatosensory area"], [379, "379: MY-sat: Medulla, behavioral state related"], [380, "380: cuf: cuneate fascicle"], [381, "381: SNr: Substantia nigra, reticular part"], [382, "382: CA1: Field CA1"], [383, "383: COApm1-3: Cortical amygdalar area, posterior part, medial zone, layers 1-3"], [384, "384: IVd: trochlear nerve decussation"], [385, "385: VISp: Primary visual area"], [386, "386: MY-sen: Medulla, sensory related"], [387, "387: ENTl5/6: Entorhinal area, lateral part, layer 5/6"], [388, "388: grf: gracile fascicle"], [389, "389: sttv: ventral spinothalamic tract"], [390, "390: SO: Supraoptic nucleus"], [391, "391: CA1slm: Field CA1, stratum lacunosum-moleculare"], [392, "392: NLOT1-3: Nucleus of the lateral olfactory tract, layers 1-3"], [393, "393: VISpl6b: Posterolateral visual area, layer 6b"], [394, "394: VISam: Anteromedial visual area"], [395, "395: MDRN: Medullary reticular nucleus"], [396, "396: iaf: internal arcuate fibers"], [397, "397: vtd: ventral tegmental decussation"], [398, "398: SOC: Superior olivary complex"], [399, "399: CA1so: Field CA1, stratum oriens"], [400, "400: PAA1-3: Piriform-amygdalar area, layers 1-3"], [401, "401: VISam4: Anteromedial visual area, layer 4"], [402, "402: VISal: Anterolateral visual area"], [403, "403: MEA: Medial amygdalar nucleus"], [404, "404: oct: olivocerebellar tract"], [405, "405: vlt: ventrolateral hypothalamic tract"], [406, "406: SPF: Subparafascicular nucleus"], [407, "407: CA1sp: Field CA1, pyramidal layer"], [408, "408: PAA1: Piriform-amygdalar area, molecular layer"], [409, "409: VISl: Lateral visual area"], [410, "410: rct: reticulocerebellar tract"], [411, "411: MEAad: Medial amygdalar nucleus, anterodorsal part"], [412, "412: ORBl2/3: Orbital area, lateral part, layer 2/3"], [413, "413: vVIIIn: vestibular nerve"], [414, "414: SPFm: Subparafascicular nucleus, magnocellular part"], [415, "415: CA1sr: Field CA1, stratum radiatum"], [416, "416: PAA2: Piriform-amygdalar area, pyramidal layer"], [417, "417: VISrl: Rostrolateral visual area"], [418, "418: MEAav: Medial amygdalar nucleus, anteroventral part"], [419, "419: ENTmv4: Entorhinal area, medial part, ventral zone, layer 4"], [420, "420: db: precommissural fornix diagonal band"], [421, "421: VISl1: Lateral visual area, layer 1"], [422, "422: SPFp: Subparafascicular nucleus, parvicellular part"], [423, "423: CA2: Field CA2"], [424, "424: PAA3: Piriform-amygdalar area, polymorph layer"], [425, "425: VISpl: Posterolateral visual area"], [426, "426: MEApd: Medial amygdalar nucleus, posterodorsal part"], [427, "427: ECT2/3: Ectorhinal area/Layer 2/3"], [428, "428: mct: medial corticohypothalamic tract"], [429, "429: SPVC: Spinal nucleus of the trigeminal, caudal part"], [430, "430: RSPv2/3: Retrosplenial area, ventral part, layer 2/3"], [431, "431: CA2slm: Field CA2, stratum lacunosum-moleculare"], [432, "432: NC: Nucleus circularis"], [433, "433: VISam5: Anteromedial visual area, layer 5"], [434, "434: RSPd2/3: Retrosplenial area, dorsal part, layer 2/3"], [435, "435: MEApv: Medial amygdalar nucleus, posteroventral part"], [436, "436: fx: columns of the fornix"], [437, "437: SPVI: Spinal nucleus of the trigeminal, interpolar part"], [438, "438: CA2so: Field CA2, stratum oriens"], [439, "439: PVHdp: Paraventricular hypothalamic nucleus, descending division, dorsal parvicellular part"], [440, "440: ORBl6a: Orbital area, lateral part, layer 6a"], [441, "441: VISam6b: Anteromedial visual area, layer 6b"], [442, "442: RSPd1: Retrosplenial area, dorsal part, layer 1"], [443, "443: dhc: dorsal hippocampal commissure"], [444, "444: MED: Medial group of the dorsal thalamus"], [445, "445: SPVO: Spinal nucleus of the trigeminal, oral part"], [446, "446: CA2sp: Field CA2, pyramidal layer"], [447, "447: PVHf: Paraventricular hypothalamic nucleus, descending division, forniceal part"], [448, "448: ORBl1: Orbital area, lateral part, layer 1"], [449, "449: vhc: ventral hippocampal commissure"], [450, "450: SSp-ul1: Primary somatosensory area, upper limb, layer 1"], [451, "451: BLAv: Basolateral amygdalar nucleus, ventral part"], [452, "452: MEPO: Median preoptic nucleus"], [453, "453: SS: Somatosensory areas"], [454, "454: CA2sr: Field CA2, stratum radiatum"], [455, "455: PVHlp: Paraventricular hypothalamic nucleus, descending division, lateral parvicellular part"], [456, "456: AUDpo6b: Posterior auditory area, layer 6b"], [457, "457: VIS6a: Visual areas, layer 6a"], [458, "458: OT1: Olfactory tubercle, molecular layer"], [459, "459: aolt: accessory olfactory tract"], [460, "460: MEV: Midbrain trigeminal nucleus"], [461, "461: SSp-tr6b: Primary somatosensory area, trunk, layer 6b"], [462, "462: SSN: Superior salivatory nucleus"], [463, "463: CA3: Field CA3"], [464, "464: PVHmpv: Paraventricular hypothalamic nucleus, descending division, medial parvicellular part, ventral zone"], [465, "465: OT2: Olfactory tubercle, pyramidal layer"], [466, "466: alv: alveus"], [467, "467: MEZ: Hypothalamic medial zone"], [468, "468: ENTm2a: Entorhinal area, medial part, dorsal zone, layer 2a"], [469, "469: VISpm6b: posteromedial visual area, layer 6b"], [470, "470: STN: Subthalamic nucleus"], [471, "471: CA3slm: Field CA3, stratum lacunosum-moleculare"], [472, "472: MEApd-a: Medial amygdalar nucleus, posterodorsal part, sublayer a"], [473, "473: OT3: Olfactory tubercle, polymorph layer"], [474, "474: ab: angular path"], [475, "475: MG: Medial geniculate complex"], [476, "476: ORB6a: Orbital area, layer 6a"], [477, "477: STR: Striatum"], [478, "478: SSp-ll6a: Primary somatosensory area, lower limb, layer 6a"], [479, "479: CA3slu: Field CA3, stratum lucidum"], [480, "480: MEApd-b: Medial amygdalar nucleus, posterodorsal part, sublayer b"], [481, "481: isl: Islands of Calleja"], [482, "482: bic: brachium of the inferior colliculus"], [483, "483: MH: Medial habenula"], [484, "484: ORBm1: Orbital area, medial part, layer 1"], [485, "485: STRd: Striatum dorsal region"], [486, "486: CA3so: Field CA3, stratum oriens"], [487, "487: MEApd-c: Medial amygdalar nucleus, posterodorsal part, sublayer c"], [488, "488: ORBl6b: Orbital area, lateral part, layer 6b"], [489, "489: islm: Major island of Calleja"], [490, "490: bct: bulbocerebellar tract"], [491, "491: MM: Medial mammillary nucleus"], [492, "492: ORB2/3: Orbital area, layer 2/3"], [493, "493: STRv: Striatum ventral region"], [494, "494: SCig-a: Superior colliculus, motor related, intermediate gray layer, sublayer a"], [495, "495: CA3sp: Field CA3, pyramidal layer"], [496, "496: DP1: Dorsal peduncular area, layer 1"], [497, "497: VIS6b: Visual areas, layer 6b"], [498, "498: BSTam: Bed nuclei of the stria terminalis, anterior division, anteromedial area"], [499, "499: cct: cuneocerebellar tract"], [500, "500: MO: Somatomotor areas"], [501, "501: VISpm4: posteromedial visual area, layer 4"], [502, "502: SUB: Subiculum"], [503, "503: SCig-b: Superior colliculus, motor related, intermediate gray layer, sublayer b"], [504, "504: CA3sr: Field CA3, stratum radiatum"], [505, "505: BSTdm: Bed nuclei of the stria terminalis, anterior division, dorsomedial nucleus"], [506, "506: das: dorsal acoustic stria"], [507, "507: MOB: Main olfactory bulb"], [508, "508: ENTm2b: Entorhinal area, medial part, dorsal zone, layer 2b"], [509, "509: SUBd: Subiculum, dorsal part"], [510, "510: SSp-ll6b: Primary somatosensory area, lower limb, layer 6b"], [511, "511: SCig-c: Superior colliculus, motor related, intermediate gray layer, sublayer c"], [512, "512: CB: Cerebellum"], [513, "513: BSTfu: Bed nuclei of the stria terminalis, anterior division, fusiform nucleus"], [514, "514: dc: dorsal column"], [515, "515: MPN: Medial preoptic nucleus"], [516, "516: ORB6b: Orbital area, layer 6b"], [517, "517: TR1-3: Postpiriform transition area, layers 1-3"], [518, "518: SUBv: Subiculum, ventral part"], [519, "519: CBN: Cerebellar nuclei"], [520, "520: AUDv6a: Ventral auditory area, layer 6a"], [521, "521: BSTmg: Bed nuclei of the stria terminalis, anterior division, magnocellular nucleus"], [522, "522: dcm: dorsal commissure of the spinal cord"], [523, "523: MPO: Medial preoptic area"], [524, "524: ORBm2: Orbital area, medial part, layer 2"], [525, "525: SUM: Supramammillary nucleus"], [526, "526: ENTm1: Entorhinal area, medial part, dorsal zone, layer 1"], [527, "527: AUDd1: Dorsal auditory area, layer 1"], [528, "528: CBX: Cerebellar cortex"], [529, "529: BSTv: Bed nuclei of the stria terminalis, anterior division, ventral nucleus"], [530, "530: df: dorsal fornix"], [531, "531: MPT: Medial pretectal area"], [532, "532: PTLp1: Posterior parietal association areas, layer 1"], [533, "533: VISpm: posteromedial visual area"], [534, "534: SUT: Supratrigeminal nucleus"], [535, "535: DP2: Dorsal peduncular area, layer 2"], [536, "536: CEA: Central amygdalar nucleus"], [537, "537: BSTal: Bed nuclei of the stria terminalis, anterior division, anterolateral area"], [538, "538: lotd: dorsal limb"], [539, "539: MRNm: Midbrain reticular nucleus, magnocellular part"], [540, "540: PERI1: Perirhinal area, layer 1"], [541, "541: TEa: Temporal association areas"], [542, "542: RSPv1: Retrosplenial area, ventral part, layer 1"], [543, "543: ENTm2: Entorhinal area, medial part, dorsal zone, layer 2"], [544, "544: CEAc: Central amygdalar nucleus, capsular part"], [545, "545: RSPd4: Retrosplenial area, dorsal part, layer 4"], [546, "546: BSTju: Bed nuclei of the stria terminalis, anterior division, juxtacapsular nucleus"], [547, "547: dlf: dorsal longitudinal fascicle"], [548, "548: MRNmg: Midbrain reticular nucleus, magnocellular part, general"], [549, "549: TH: Thalamus"], [550, "550: ENTm5/6: Entorhinal area, medial part, dorsal zone, layer 5/6"], [551, "551: CEAl: Central amygdalar nucleus, lateral part"], [552, "552: PRNv: Pontine reticular nucleus, ventral part"], [553, "553: sctd: dorsal spinocerebellar tract"], [554, "554: BSTov: Bed nuclei of the stria terminalis, anterior division, oval nucleus"], [555, "555: MRNp: Midbrain reticular nucleus, parvicellular part"], [556, "556: ILA2/3: Infralimbic area, layer 2/3"], [557, "557: TM: Tuberomammillary nucleus"], [558, "558: SSp-n1: Primary somatosensory area, nose, layer 1"], [559, "559: CEAm: Central amygdalar nucleus, medial part"], [560, "560: CNspg: Cochlear nucleus, subpedunclular granular region"], [561, "561: VIS2/3: Visual areas, layer 2/3"], [562, "562: BSTrh: Bed nuclei of the stria terminalis, anterior division, rhomboid nucleus"], [563, "563: dtt: dorsal tegmental tract"], [564, "564: MS: Medial septal nucleus"], [565, "565: VISpm5: posteromedial visual area, layer 5"], [566, "566: TR: Postpiriform transition area"], [567, "567: CH: Cerebrum"], [568, "568: ACVI: Accessory abducens nucleus"], [569, "569: BSTd: Bed nuclei of the stria terminalis, posterior division, dorsal nucleus"], [570, "570: dl: dorsolateral fascicle"], [571, "571: MTN: Midline group of the dorsal thalamus"], [572, "572: ACA1: Anterior cingulate area, layer 1"], [573, "573: VISl4: Lateral visual area, layer 4"], [574, "574: TRN: Tegmental reticular nucleus"], [575, "575: CL: Central lateral nucleus of the thalamus"], [576, "576: ACVII: Accessory facial motor nucleus"], [577, "577: SSp-ul4: Primary somatosensory area, upper limb, layer 4"], [578, "578: BSTpr: Bed nuclei of the stria terminalis, posterior division, principal nucleus"], [579, "579: ec: external capsule"], [580, "580: NB: Nucleus of the brachium of the inferior colliculus"], [581, "581: TRS: Triangular nucleus of septum"], [582, "582: ORBm2/3: Orbital area, medial part, layer 2/3"], [583, "583: CLA: Claustrum"], [584, "584: COApl1-2: Cortical amygdalar area, posterior part, lateral zone, layers 1-2"], [585, "585: BSTif: Bed nuclei of the stria terminalis, posterior division, interfascicular nucleus"], [586, "586: fpr: fasciculus proprius"], [587, "587: ND: Nucleus of Darkschewitsch"], [588, "588: ACAv1: Anterior cingulate area, ventral part, layer 1"], [589, "589: TT: Taenia tecta"], [590, "590: RSPv6a: Retrosplenial area, ventral part, layer 6a"], [591, "591: CLI: Central linear nucleus raphe"], [592, "592: COApm1-2: Cortical amygdalar area, posterior part, medial zone, layers 1-2"], [593, "593: VISp1: Primary visual area, layer 1"], [594, "594: BSTtr: Bed nuclei of the stria terminalis, posterior division, transverse nucleus"], [595, "595: fr: fasciculus retroflexus"], [596, "596: NDB: Diagonal band nucleus"], [597, "597: TTd: Taenia tecta, dorsal part"], [598, "598: AUDv6b: Ventral auditory area, layer 6b"], [599, "599: CM: Central medial nucleus of the thalamus"], [600, "600: AUDd2/3: Dorsal auditory area, layer 2/3"], [601, "601: VISal6a: Anterolateral visual area, layer 6a"], [602, "602: BSTse: Bed nuclei of the stria terminalis, posterior division, strial extension"], [603, "603: fi: fimbria"], [604, "604: NI: Nucleus incertus"], [605, "605: TTv: Taenia tecta, ventral part"], [606, "606: RSPv2: Retrosplenial area, ventral part, layer 2"], [607, "607: CN: Cochlear nuclei"], [608, "608: ORBvl6a: Orbital area, ventrolateral part, layer 6a"], [609, "609: SPA: Subparafascicular area"], [610, "610: RSPd5: Retrosplenial area, dorsal part, layer 5"], [611, "611: hbc: habenular commissure"], [612, "612: NLL: Nucleus of the lateral lemniscus"], [613, "613: VISl5: Lateral visual area, layer 5"], [614, "614: TU: Tuberal nucleus"], [615, "615: SNl: Substantia nigra, lateral part"], [616, "616: CUN: Cuneiform nucleus"], [617, "617: MDc: Mediodorsal nucleus of the thalamus, central part"], [618, "618: hc: hippocampal commissures"], [619, "619: NLOT: Nucleus of the lateral olfactory tract"], [620, "620: ORBm5: Orbital area, medial part, layer 5"], [621, "621: V: Motor nucleus of trigeminal"], [622, "622: RSPv6b: Retrosplenial area, ventral part, layer 6b"], [623, "623: CNU: Cerebral nuclei"], [624, "624: IPF: Interpeduncular fossa"], [625, "625: SSp-ul5: Primary somatosensory area, upper limb, layer 5"], [626, "626: MDl: Mediodorsal nucleus of the thalamus, lateral part"], [627, "627: hht: hypothalamohypophysial tract"], [628, "628: NOT: Nucleus of the optic tract"], [629, "629: VAL: Ventral anterior-lateral complex of the thalamus"], [630, "630: ORBl5: Orbital area, lateral part, layer 5"], [631, "631: COA: Cortical amygdalar area"], [632, "632: DG-sg: Dentate gyrus, granule cell layer"], [633, "633: cic: inferior colliculus commissure"], [634, "634: NPC: Nucleus of the posterior commissure"], [635, "635: PTLp4: Posterior parietal association areas, layer 4"], [636, "636: MDm: Mediodorsal nucleus of the thalamus, medial part"], [637, "637: VENT: Ventral group of the dorsal thalamus"], [638, "638: GU6a: Gustatory areas, layer 6a"], [639, "639: COAa: Cortical amygdalar area, anterior part"], [640, "640: EV: Efferent vestibular nucleus"], [641, "641: ias: intermediate acoustic stria"], [642, "642: NTB: Nucleus of the trapezoid body"], [643, "643: AUDpo2/3: Posterior auditory area, layer 2/3"], [644, "644: MO6a: Somatomotor areas, Layer 6a"], [645, "645: VERM: Vermal regions"], [646, "646: DP5: Dorsal peduncular area, layer 5"], [647, "647: COAp: Cortical amygdalar area, posterior part"], [648, "648: MOp5: Primary motor area, Layer 5"], [649, "649: VISal6b: Anterolateral visual area, layer 6b"], [650, "650: jrb: juxtarestiform body"], [651, "651: NTS: Nucleus of the solitary tract"], [652, "652: PVHpml: Paraventricular hypothalamic nucleus, magnocellular division, posterior magnocellular part, lateral zone"], [653, "653: VI: Abducens nucleus"], [654, "654: SSp-n4: Primary somatosensory area, nose, layer 4"], [655, "655: COApl: Cortical amygdalar area, posterior part, lateral zone"], [656, "656: MOs1: Secondary motor area, layer 1"], [657, "657: SSp-m2/3: Primary somatosensory area, mouth, layer 2/3"], [658, "658: ll: lateral lemniscus"], [659, "659: NTSce: Nucleus of the solitary tract, central part"], [660, "660: PVHpmm: Paraventricular hypothalamic nucleus, magnocellular division, posterior magnocellular part, medial zone"], [661, "661: VII: Facial motor nucleus"], [662, "662: GU6b: Gustatory areas, layer 6b"], [663, "663: COApm: Cortical amygdalar area, posterior part, medial zone"], [664, "664: ENTm3: Entorhinal area, medial part, dorsal zone, layer 3"], [665, "665: lot: lateral olfactory tract, body"], [666, "666: NTSco: Nucleus of the solitary tract, commissural part"], [667, "667: FRP2/3: Frontal pole, layer 2/3"], [668, "668: DMHa: Dorsomedial nucleus of the hypothalamus, anterior part"], [669, "669: VIS: Visual areas"], [670, "670: SSp-tr2/3: Primary somatosensory area, trunk, layer 2/3"], [671, "671: RSPagl1: Retrosplenial area, lateral agranular part, layer 1"], [672, "672: CP: Caudoputamen"], [673, "673: mp: mammillary peduncle"], [674, "674: NTSge: Nucleus of the solitary tract, gelatinous part"], [675, "675: AIv6a: Agranular insular area, ventral part, layer 6a"], [676, "676: DMHp: Dorsomedial nucleus of the hypothalamus, posterior part"], [677, "677: VISC: Visceral area"], [678, "678: AUDd4: Dorsal auditory area, layer 4"], [679, "679: CS: Superior central nucleus raphe"], [680, "680: ORBvl6b: Orbital area, ventrolateral part, layer 6b"], [681, "681: mtg: mammillotegmental tract"], [682, "682: NTSl: Nucleus of the solitary tract, lateral part"], [683, "683: PTLp5: Posterior parietal association areas, layer 5"], [684, "684: DMHv: Dorsomedial nucleus of the hypothalamus, ventral part"], [685, "685: VM: Ventral medial nucleus of the thalamus"], [686, "686: SSp6a: Primary somatosensory area, layer 6a"], [687, "687: RSPv5: Retrosplenial area, ventral part, layer 5"], [688, "688: CTX: Cerebral cortex"], [689, "689: VLPO: Ventrolateral preoptic nucleus"], [690, "690: mtt: mammillothalamic tract"], [691, "691: NTSm: Nucleus of the solitary tract, medial part"], [692, "692: PERI5: Perirhinal area, layer 5"], [693, "693: VMH: Ventromedial hypothalamic nucleus"], [694, "694: AIv2/3: Agranular insular area, ventral part, layer 2/3"], [695, "695: CTXpl: Cortical plate"], [696, "696: AUDpo1: Posterior auditory area, layer 1"], [697, "697: ml: medial lemniscus"], [698, "698: OLF: Olfactory areas"], [699, "699: AIv6b: Agranular insular area, ventral part, layer 6b"], [700, "700: AHNa: Anterior hypothalamic nucleus, anterior part"], [701, "701: VNC: Vestibular nuclei"], [702, "702: SSp-n5: Primary somatosensory area, nose, layer 5"], [703, "703: CTXsp: Cortical subplate"], [704, "704: AIv1: Agranular insular area, ventral part, layer 1"], [705, "705: mtV: midbrain tract of the trigeminal nerve"], [706, "706: OP: Olivary pretectal nucleus"], [707, "707: ILA1: Infralimbic area, layer 1"], [708, "708: AHNc: Anterior hypothalamic nucleus, central part"], [709, "709: VP: Ventral posterior complex of the thalamus"], [710, "710: VIn: abducens nerve"], [711, "711: CU: Cuneate nucleus"], [712, "712: ENTm4: Entorhinal area, medial part, dorsal zone, layer 4"], [713, "713: per: perforant path"], [714, "714: ORB: Orbital area"], [715, "715: ENTl2a: Entorhinal area, lateral part, layer 2a"], [716, "716: AHNd: Anterior hypothalamic nucleus, dorsal part"], [717, "717: XIn: accessory spinal nerve"], [718, "718: VPL: Ventral posterolateral nucleus of the thalamus"], [719, "719: SSp6b: Primary somatosensory area, layer 6b"], [720, "720: DCN: Dorsal column nuclei"], [721, "721: VISp4: Primary visual area, layer 4"], [722, "722: pvbt: periventricular bundle of the thalamus"], [723, "723: ORBl: Orbital area, lateral part"], [724, "724: AHNp: Anterior hypothalamic nucleus, posterior part"], [725, "725: VPLpc: Ventral posterolateral nucleus of the thalamus, parvicellular part"], [726, "726: DG: Dentate gyrus"], [727, "727: ENTm5: Entorhinal area, medial part, dorsal zone, layer 5"], [728, "728: arb: arbor vitae"], [729, "729: TEa6a: Temporal association areas, layer 6a"], [730, "730: PIS: pineal stalk"], [731, "731: ORBm: Orbital area, medial part"], [732, "732: Mmme: Medial mammillary nucleus, median part"], [733, "733: VPM: Ventral posteromedial nucleus of the thalamus"], [734, "734: DGcr: Dentate gyrus crest"], [735, "735: AUDp1: Primary auditory area, layer 1"], [736, "736: ctb: central tegmental bundle"], [737, "737: fxpo: postcommissural fornix"], [738, "738: ORBv: Orbital area, ventral part"], [739, "739: ACA5: Anterior cingulate area, layer 5"], [740, "740: MPNc: Medial preoptic nucleus, central part"], [741, "741: VPMpc: Ventral posteromedial nucleus of the thalamus, parvicellular part"], [742, "742: DGcr-mo: Dentate gyrus crest, molecular layer"], [743, "743: ENTm6: Entorhinal area, medial part, dorsal zone, layer 6"], [744, "744: cbc: cerebellar commissure"], [745, "745: fxprg: precommissural fornix, general"], [746, "746: ORBvl: Orbital area, ventrolateral part"], [747, "747: ILA2: Infralimbic area, layer 2"], [748, "748: MPNl: Medial preoptic nucleus, lateral part"], [749, "749: VTA: Ventral tegmental area"], [750, "750: VISpl1: Posterolateral visual area, layer 1"], [751, "751: DGcr-po: Dentate gyrus crest, polymorph layer"], [752, "752: cbp: cerebellar peduncles"], [753, "753: pm: principal mammillary tract"], [754, "754: OT: Olfactory tubercle"], [755, "755: AUDv2/3: Ventral auditory area, layer 2/3"], [756, "756: MPNm: Medial preoptic nucleus, medial part"], [757, "757: VTN: Ventral tegmental nucleus"], [758, "758: DGcr-sg: Dentate gyrus crest, granule cell layer"], [759, "759: AUDpo4: Posterior auditory area, layer 4"], [760, "760: epsc: cerebral nuclei related"], [761, "761: VMHa: Ventromedial hypothalamic nucleus, anterior part"], [762, "762: phpd: propriohypothalamic pathways, dorsal"], [763, "763: OV: Vascular organ of the lamina terminalis"], [764, "764: ENTl2b: Entorhinal area, lateral part, layer 2b"], [765, "765: x: Nucleus x"], [766, "766: DGlb: Dentate gyrus lateral blade"], [767, "767: MOs5: Secondary motor area, layer 5"], [768, "768: mfbc: cerebrum related"], [769, "769: VMHc: Ventromedial hypothalamic nucleus, central part"], [770, "770: phpl: propriohypothalamic pathways, lateral"], [771, "771: P: Pons"], [772, "772: ACAv5: Anterior cingulate area, ventral part, layer 5"], [773, "773: XII: Hypoglossal nucleus"], [774, "774: RSPagl5: Retrosplenial area, lateral agranular part, layer 5"], [775, "775: DGlb-mo: Dentate gyrus lateral blade, molecular layer"], [776, "776: cc: corpus callosum"], [777, "777: VMHdm: Ventromedial hypothalamic nucleus, dorsomedial part"], [778, "778: VISp5: Primary visual area, layer 5"], [779, "779: phpm: propriohypothalamic pathways, medial"], [780, "780: PA: Posterior amygdalar nucleus"], [781, "781: y: Nucleus y"], [782, "782: DGlb-po: Dentate gyrus lateral blade, polymorph layer"], [783, "783: AId6a: Agranular insular area, dorsal part, layer 6a"], [784, "784: cst: corticospinal tract"], [785, "785: VMHvl: Ventromedial hypothalamic nucleus, ventrolateral part"], [786, "786: TEa6b: Temporal association areas, layer 6b"], [787, "787: phpv: propriohypothalamic pathways, ventral"], [788, "788: PAA: Piriform-amygdalar area"], [789, "789: z: Nucleus z"], [790, "790: DGlb-sg: Dentate gyrus lateral blade, granule cell layer"], [791, "791: AUDpo5: Posterior auditory area, layer 5"], [792, "792: drt: dorsal roots"], [793, "793: SSp1: Primary somatosensory area, layer 1"], [794, "794: sptV: spinal tract of the trigeminal nerve"], [795, "795: PAG: Periaqueductal gray"], [796, "796: A13: Dopaminergic A13 group"], [797, "797: ZI: Zona incerta"], [798, "798: VIIn: facial nerve"], [799, "799: DGmb: Dentate gyrus medial blade"], [800, "800: AIv5: Agranular insular area, ventral part, layer 5"], [801, "801: VIS1: Visual areas, layer 1"], [802, "802: sm: stria medullaris"], [803, "803: PAL: Pallidum"], [804, "804: FF: Fields of Forel"], [805, "805: VISpm1: posteromedial visual area, layer 1"], [806, "806: SSs2/3: Supplemental somatosensory area, layer 2/3"], [807, "807: DGmb-mo: Dentate gyrus medial blade, molecular layer"], [808, "808: IXn: glossopharyngeal nerve"], [809, "809: PALc: Pallidum, caudal region"], [810, "810: ACAv6a: Anterior cingulate area, ventral part, 6a"], [811, "811: ICc: Inferior colliculus, central nucleus"], [812, "812: dscp: superior cerebellar peduncle decussation"], [813, "813: XIIn: hypoglossal nerve"], [814, "814: DP: Dorsal peduncular area"], [815, "815: DGmb-po: Dentate gyrus medial blade, polymorph layer"], [816, "816: AUDp4: Primary auditory area, layer 4"], [817, "817: supa: supraoptic commissures, anterior"], [818, "818: PALd: Pallidum, dorsal region"], [819, "819: ACAv6b: Anterior cingulate area, ventral part, 6b"], [820, "820: ICd: Inferior colliculus, dorsal nucleus"], [821, "821: VISp2/3: Primary visual area, layer 2/3"], [822, "822: RHP: Retrohippocampal region"], [823, "823: DGmb-sg: Dentate gyrus medial blade, granule cell layer"], [824, "824: mfsbshy: hypothalamus related"], [825, "825: supd: supraoptic commissures, dorsal"], [826, "826: PALm: Pallidum, medial region"], [827, "827: ILA5: Infralimbic area, layer 5"], [828, "828: ICe: Inferior colliculus, external nucleus"], [829, "829: SUBd-m: Subiculum, dorsal part, molecular layer"], [830, "830: DMH: Dorsomedial nucleus of the hypothalamus"], [831, "831: AId6b: Agranular insular area, dorsal part, layer 6b"], [832, "832: IIIn: oculomotor nerve"], [833, "833: supv: supraoptic commissures, ventral"], [834, "834: SCzo: Superior colliculus, zonal layer"], [835, "835: PALv: Pallidum, ventral region"], [836, "836: ECT1: Ectorhinal area/Layer 1"], [837, "837: SUBd-sr: Subiculum, dorsal part, stratum radiatum"], [838, "838: SSp-n2/3: Primary somatosensory area, nose, layer 2/3"], [839, "839: DMX: Dorsal motor nucleus of the vagus nerve"], [840, "840: In: olfactory nerve"], [841, "841: tb: trapezoid body"], [842, "842: SCsg: Superior colliculus, superficial gray layer"], [843, "843: PAR: Parasubiculum"], [844, "844: MOp6a: Primary motor area, Layer 6a"], [845, "845: SUBd-sp: Subiculum, dorsal part, pyramidal layer"], [846, "846: DN: Dentate nucleus"], [847, "847: AUDp5: Primary auditory area, layer 5"], [848, "848: IIn: optic nerve"], [849, "849: VISC6b: Visceral area, layer 6b"], [850, "850: uf: uncinate fascicle"], [851, "851: SCop: Superior colliculus, optic layer"], [852, "852: PARN: Parvicellular reticular nucleus"], [853, "853: SUBv-m: Subiculum, ventral part, molecular layer"], [854, "854: SSp-ul2/3: Primary somatosensory area, upper limb, layer 2/3"], [855, "855: rst: retriculospinal tract"], [856, "856: DORpm: Thalamus, polymodal association cortex related"], [857, "857: VISC6a: Visceral area, layer 6a"], [858, "858: vc: ventral commissure of the spinal cord"], [859, "859: PAS: Parasolitary nucleus"], [860, "860: PBlc: Parabrachial nucleus, lateral division, central lateral part"], [861, "861: SUBv-sr: Subiculum, ventral part, stratum radiatum"], [862, "862: SSs6a: Supplemental somatosensory area, layer 6a"], [863, "863: rust: rubrospinal tract"], [864, "864: DORsm: Thalamus, sensory-motor cortex related"], [865, "865: SSp4: Primary somatosensory area, layer 4"], [866, "866: sctv: ventral spinocerebellar tract"], [867, "867: PB: Parabrachial nucleus"], [868, "868: PBld: Parabrachial nucleus, lateral division, dorsal lateral part"], [869, "869: VISpl4: Posterolateral visual area, layer 4"], [870, "870: SUBv-sp: Subiculum, ventral part, pyramidal layer"], [871, "871: sst: spinothalamic tract"], [872, "872: DR: Dorsal nucleus raphe"], [873, "873: SSs1: Supplemental somatosensory area, layer 1"], [874, "874: PBG: Parabigeminal nucleus"], [875, "875: PBle: Parabrachial nucleus, lateral division, external lateral part"], [876, "876: aot: accessory optic tract"], [877, "877: tsp: tectospinal pathway"], [878, "878: SSp-m1: Primary somatosensory area, mouth, layer 1"], [879, "879: RSPd: Retrosplenial area, dorsal part"], [880, "880: DTN: Dorsal tegmental nucleus"], [881, "881: PBl: Parabrachial nucleus, lateral division"], [882, "882: MOp6b: Primary motor area, Layer 6b"], [883, "883: PBls: Parabrachial nucleus, lateral division, superior lateral part"], [884, "884: amc: amygdalar capsule"], [885, "885: tn: terminal nerve"], [886, "886: RSPv: Retrosplenial area, ventral part"], [887, "887: ECO: Efferent cochlear group"], [888, "888: PERI2/3: Perirhinal area, layer 2/3"], [889, "889: SSp-n6a: Primary somatosensory area, nose, layer 6a"], [890, "890: PBm: Parabrachial nucleus, medial division"], [891, "891: PBlv: Parabrachial nucleus, lateral division, ventral lateral part"], [892, "892: apd: ansa peduncularis"], [893, "893: SSs6b: Supplemental somatosensory area, layer 6b"], [894, "894: RSPagl: Retrosplenial area, lateral agranular part"], [895, "895: ECT: Ectorhinal area"], [896, "896: lfbst: thalamus related"], [897, "897: VISC1: Visceral area, layer 1"], [898, "898: PCG: Pontine central gray"], [899, "899: PBme: Parabrachial nucleus, medial division, external medial part"], [900, "900: aco: anterior commissure, olfactory limb"], [901, "901: Vn: trigeminal nerve"], [902, "902: VISpl5: Posterolateral visual area, layer 5"], [903, "903: ECU: External cuneate nucleus"], [904, "904: MSC: Medial septal complex"], [905, "905: VISal2/3: Anterolateral visual area, layer 2/3"], [906, "906: RSPagl6a: Retrosplenial area, lateral agranular part, layer 6a"], [907, "907: PCN: Paracentral nucleus"], [908, "908: act: anterior commissure, temporal limb"], [909, "909: ENT: Entorhinal area"], [910, "910: ORBm6a: Orbital area, medial part, layer 6a"], [911, "911: IVn: trochlear nerve"], [912, "912: LING: Lingula (I)"], [913, "913: VIS4: Visual areas, layer 4"], [914, "914: PD: Posterodorsal preoptic nucleus"], [915, "915: PBmm: Parabrachial nucleus, medial division, medial medial part"], [916, "916: bsc: brachium of the superior colliculus"], [917, "917: Xn: vagus nerve"], [918, "918: ENTl: Entorhinal area, lateral part"], [919, "919: ACAd6a: Anterior cingulate area, dorsal part, layer 6a"], [920, "920: CENT: Central lobule"], [921, "921: SSp5: Primary somatosensory area, layer 5"], [922, "922: PERI: Perirhinal area"], [923, "923: PBmv: Parabrachial nucleus, medial division, ventral medial part"], [924, "924: cpd: cerebal peduncle"], [925, "925: vrt: ventral roots"], [926, "926: ENTm: Entorhinal area, medial part, dorsal zone"], [927, "927: ACAd6b: Anterior cingulate area, dorsal part, layer 6b"], [928, "928: CUL: Culmen"], [929, "929: SSp-n6b: Primary somatosensory area, nose, layer 6b"], [930, "930: PF: Parafascicular nucleus"], [931, "931: PG: Pontine gray"], [932, "932: cett: cervicothalamic tract"], [933, "933: VIIIn: vestibulocochlear nerve"], [934, "934: ENTmv: Entorhinal area, medial part, ventral zone"], [935, "935: ACAd1: Anterior cingulate area, dorsal part, layer 1"], [936, "936: DEC: Declive (VI)"], [937, "937: VIS5: Visual areas, layer 5"], [938, "938: PGRN: Paragigantocellular reticular nucleus"], [939, "939: AMBd: Nucleus ambiguus, dorsal division"], [940, "940: cing: cingulum bundle"], [941, "941: vsp: vestibulospinal pathway"], [942, "942: EP: Endopiriform nucleus"], [943, "943: MOp2/3: Primary motor area, Layer 2/3"], [944, "944: FOTU: Folium-tuber vermis (VII)"], [945, "945: SSp-ul6a: Primary somatosensory area, upper limb, layer 6a"], [946, "946: PH: Posterior hypothalamic nucleus"], [947, "947: MO6b: Somatomotor areas, Layer 6b"], [948, "948: cVIIIn: cochlear nerve"], [949, "949: von: vomeronasal nerve"], [950, "950: SSp-m4: Primary somatosensory area, mouth, layer 4"], [951, "951: PYR: Pyramus (VIII)"], [952, "952: EPd: Endopiriform nucleus, dorsal part"], [953, "953: PIN: Pineal body"], [954, "954: AUDp6a: Primary auditory area, layer 6a"], [955, "955: LRNm: Lateral reticular nucleus, magnocellular part"], [956, "956: fa: corpus callosum, anterior forceps"], [957, "957: UVU: Uvula (IX)"], [958, "958: EPI: Epithalamus"], [959, "959: AUDv1: Ventral auditory area, layer 1"], [960, "960: cbf: cerebellum related fiber tracts"], [961, "961: PIR: Piriform area"], [962, "962: MOs2/3: Secondary motor area, layer 2/3"], [963, "963: LRNp: Lateral reticular nucleus, parvicellular part"], [964, "964: ee: corpus callosum, extreme capsule"], [965, "965: RSPagl2/3: Retrosplenial area, lateral agranular part, layer 2/3"], [966, "966: EPv: Endopiriform nucleus, ventral part"], [967, "967: cm: cranial nerves"], [968, "968: NOD: Nodulus (X)"], [969, "969: ORBvl1: Orbital area, ventrolateral part, layer 1"], [970, "970: PGRNd: Paragigantocellular reticular nucleus, dorsal part"], [971, "971: fp: corpus callosum, posterior forceps"], [972, "972: PL: Prelimbic area"], [973, "973: VISl2/3: Lateral visual area, layer 2/3"], [974, "974: SSp-m5: Primary somatosensory area, mouth, layer 5"], [975, "975: EW: Edinger-Westphal nucleus"], [976, "976: CENT2: Lobule II"], [977, "977: ECT6a: Ectorhinal area/Layer 6a"], [978, "978: PGRNl: Paragigantocellular reticular nucleus, lateral part"], [979, "979: ccr: corpus callosum, rostrum"], [980, "980: PMd: Dorsal premammillary nucleus"], [981, "981: SSp-bfd1: Primary somatosensory area, barrel field, layer 1"], [982, "982: FC: Fasciola cinerea"], [983, "983: lfbs: lateral forebrain bundle system"], [984, "984: CENT3: Lobule III"], [985, "985: MOp: Primary motor area"], [986, "986: ccs: corpus callosum, splenium"], [987, "987: P-mot: Pons, motor related"], [988, "988: ECT5: Ectorhinal area/Layer 5"], [989, "989: FN: Fastigial nucleus"], [990, "990: AUDv4: Ventral auditory area, layer 4"], [991, "991: mfbs: medial forebrain bundle system"], [992, "992: CUL4: Lobule IV"], [993, "993: MOs: Secondary motor area"], [994, "994: cbt: corticobulbar tract"], [995, "995: PMR: Paramedian reticular nucleus"], [996, "996: AId1: Agranular insular area, dorsal part, layer 1"], [997, "997: root: root"], [998, "998: FS: Fundus of striatum"], [999, "999: ENTl2/3: Entorhinal area, lateral part, layer 2/3"], [1e3, "1000: eps: extrapyramidal fiber systems"], [1001, "1001: CUL5: Lobule V"], [1002, "1002: AUDp: Primary auditory area"], [1003, "1003: cpt: corticopontine tract"], [1004, "1004: PMv: Ventral premammillary nucleus"], [1005, "1005: AUDp6b: Primary auditory area, layer 6b"], [1006, "1006: SSp-tr1: Primary somatosensory area, trunk, layer 1"], [1007, "1007: SIM: Simple lobule"], [1008, "1008: GENd: Geniculate group, dorsal thalamus"], [1009, "1009: fiber tracts: fiber tracts"], [1010, "1010: VISC4: Visceral area, layer 4"], [1011, "1011: AUDd: Dorsal auditory area"], [1012, "1012: crt: corticorubral tract"], [1014, "1014: GENv: Geniculate group, ventral thalamus"], [1015, "1015: ACAd5: Anterior cingulate area, dorsal part, layer 5"], [1016, "1016: onl: olfactory nerve layer of main olfactory bulb"], [1017, "1017: AN: Ansiform lobule"], [1018, "1018: AUDv: Ventral auditory area"], [1019, "1019: cstc: corticospinal tract, crossed"], [1020, "1020: PO: Posterior complex of the thalamus"], [1021, "1021: MOs6a: Secondary motor area, layer 6a"], [1022, "1022: GPe: Globus pallidus, external segment"], [1023, "1023: AUDv5: Ventral auditory area, layer 5"], [1024, "1024: grv: grooves"], [1025, "1025: PRM: Paramedian lobule"], [1026, "1026: SSp-ul6b: Primary somatosensory area, upper limb, layer 6b"], [1027, "1027: AUDpo: Posterior auditory area"], [1028, "1028: cstu: corticospinal tract, uncrossed"], [1029, "1029: POL: Posterior limiting nucleus of the thalamus"], [1030, "1030: SSp-ll1: Primary somatosensory area, lower limb, layer 1"], [1031, "1031: GPi: Globus pallidus, internal segment"], [1032, "1032: grv of CTX: grooves of the cerebral cortex"], [1033, "1033: COPY: Copula pyramidis"], [1034, "1034: TTd1: Taenia tecta, dorsal part, layer 1"], [1035, "1035: SSs4: Supplemental somatosensory area, layer 4"], [1036, "1036: cte: corticotectal tract"], [1037, "1037: POST: Postsubiculum"], [1038, "1038: SSp-bfd6a: Primary somatosensory area, barrel field, layer 6a"], [1039, "1039: GR: Gracile nucleus"], [1040, "1040: grv of CBX: grooves of the cerebellar cortex"], [1041, "1041: PFL: Paraflocculus"], [1042, "1042: TTd2: Taenia tecta, dorsal part, layer 2"], [1043, "1043: tspc: crossed tectospinal pathway"], [1044, "1044: PP: Peripeduncular nucleus"], [1045, "1045: ECT6b: Ectorhinal area/Layer 6b"], [1046, "1046: VISam6a: Anteromedial visual area, layer 6a"], [1047, "1047: SSp-bfd4: Primary somatosensory area, barrel field, layer 4"], [1048, "1048: GRN: Gigantocellular reticular nucleus"], [1049, "1049: FL: Flocculus"], [1050, "1050: TTd3: Taenia tecta, dorsal part, layer 3"], [1051, "1051: tspd: direct tectospinal pathway"], [1052, "1052: PPN: Pedunculopontine nucleus"], [1053, "1053: ACA2/3: Anterior cingulate area, layer 2/3"], [1054, "1054: ILA6a: Infralimbic area, layer 6a"], [1055, "1055: eg: endorhinal groove"], [1056, "1056: ANcr1: Crus 1"], [1057, "1057: GU: Gustatory areas"], [1058, "1058: VISC5: Visceral area, layer 5"], [1059, "1059: TTd4: Taenia tecta, dorsal part, layer 4"], [1060, "1060: dtd: doral tegmental decussation"], [1061, "1061: PPT: Posterior pretectal nucleus"], [1062, "1062: SSp-bfd6b: Primary somatosensory area, barrel field, layer 6b"], [1063, "1063: hf: hippocampal fissure"], [1064, "1064: ANcr2: Crus 2"], [1065, "1065: HB: Hindbrain"], [1066, "1066: VISam2/3: Anteromedial visual area, layer 2/3"], [1067, "1067: TTv1: Taenia tecta, ventral part, layer 1"], [1068, "1068: mfbst: dorsal thalamus related"], [1069, "1069: PPY: Parapyramidal nucleus"], [1070, "1070: SSp-bfd5: Primary somatosensory area, barrel field, layer 5"], [1071, "1071: rf: rhinal fissure"], [1072, "1072: MGd: Medial geniculate complex, dorsal part"], [1073, "1073: HEM: Hemispheric regions"], [1074, "1074: VISal1: Anterolateral visual area, layer 1"], [1075, "1075: TTv2: Taenia tecta, ventral part, layer 2"], [1076, "1076: cvb: efferent cochleovestibular bundle"], [1077, "1077: PR: Perireunensis nucleus"], [1078, "1078: ri: rhinal incisure"], [1079, "1079: MGv: Medial geniculate complex, ventral part"], [1080, "1080: HIP: Hippocampal region"], [1081, "1081: ILA6b: Infralimbic area, layer 6b"], [1082, "1082: TTv3: Taenia tecta, ventral part, layer 3"], [1083, "1083: mfbse: epithalamus related"], [1084, "1084: PRE: Presubiculum"], [1085, "1085: MOs6b: Secondary motor area, layer 6b"], [1086, "1086: SSp-tr4: Primary somatosensory area, trunk, layer 4"], [1087, "1087: pce: precentral fissure"], [1088, "1088: MGm: Medial geniculate complex, medial part"], [1089, "1089: HPF: Hippocampal formation"], [1090, "1090: SSs5: Supplemental somatosensory area, layer 5"], [1091, "1091: CUL4, 5: Lobules IV-V"], [1092, "1092: em: external medullary lamina of the thalamus"], [1093, "1093: PRNc: Pontine reticular nucleus, caudal part"], [1094, "1094: SSp-ll4: Primary somatosensory area, lower limb, layer 4"], [1095, "1095: pcf: preculminate fissure"], [1096, "1096: AMd: Anteromedial nucleus, dorsal part"], [1097, "1097: HY: Hypothalamus"], [1098, "1098: MDRNd: Medullary reticular nucleus, dorsal part"], [1099, "1099: fxs: fornix system"], [1100, "1100: PRT: Pretectal region"], [1101, "1101: AId5: Agranular insular area, dorsal part, layer 5"], [1102, "1102: SSp-m6a: Primary somatosensory area, mouth, layer 6a"], [1103, "1103: pri: primary fissure"], [1104, "1104: AMv: Anteromedial nucleus, ventral part"], [1105, "1105: IA: Intercalated amygdalar nucleus"], [1106, "1106: VISC2/3: Visceral area, layer 2/3"], [1107, "1107: MDRNv: Medullary reticular nucleus, ventral part"], [1108, "1108: ccg: genu of corpus callosum"], [1109, "1109: PS: Parastrial nucleus"], [1110, "1110: SUMl: Supramammillary nucleus, lateral part"], [1111, "1111: SSp-tr5: Primary somatosensory area, trunk, layer 5"], [1112, "1112: psf: posterior superior fissure"], [1113, "1113: IAD: Interanterodorsal nucleus of the thalamus"], [1114, "1114: VISal4: Anterolateral visual area, layer 4"], [1116, "1116: gVIIn: genu of the facial nerve"], [1117, "1117: P-sat: Pons, behavioral state related"], [1118, "1118: SUMm: Supramammillary nucleus, medial part"], [1119, "1119: ppf: prepyramidal fissure"], [1120, "1120: IAM: Interanteromedial nucleus of the thalamus"], [1121, "1121: ENTl1: Entorhinal area, lateral part, layer 1"], [1123, "1123: icp: inferior cerebellar peduncle"], [1124, "1124: PSCH: Suprachiasmatic preoptic nucleus"], [1125, "1125: ORBvl5: Orbital area, ventrolateral part, layer 5"], [1126, "1126: TMd: Tuberomammillary nucleus, dorsal part"], [1127, "1127: TEa2/3: Temporal association areas, layer 2/3"], [1128, "1128: SSp-ll5: Primary somatosensory area, lower limb, layer 5"], [1129, "1129: IB: Interbrain"], [1131, "1131: iVIIn: intermediate nerve"], [1132, "1132: P-sen: Pons, sensory related"], [1133, "1133: ENTmv5/6: Entorhinal area, medial part, ventral zone, layer 5/6"], [1139, "1139: NLOT3: Nucleus of the lateral olfactory tract, layer 3"], [1140, "1140: TR1: Postpiriform transition area, layers 1"], [1141, "1141: TR2: Postpiriform transition area, layers 2"], [1142, "1142: TR3: Postpiriform transition area, layers 3"], [1143, "1143: CBXgr: Cerebellar cortex, granular layer"], [1144, "1144: CBXmo: Cerebellar cortex, molecular layer"], [1145, "1145: CBXpu: Cerebellar cortex, Purkinje layer"]]),
            console.log("Atlas created!")
        }
        getNameForId(e) {
            return this.ara_id.has(e) ? this.ara_id.get(e) : "UNKNOWN"
        }
    }
    n.d(t, "SegmentationUserLayer", (function() {
        return Te
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const Ee = Object(oe.a)(i.j);
    class Te extends Ee {
        constructor(e, t) {
            super(e, t),
            this.atlas = null,
            this.sliceViewRenderScaleHistogram = new o.a,
            this.sliceViewRenderScaleTarget = Object(o.e)(1),
            this.displayState = {
                segmentColorHash: j.getDefault(),
                segmentStatedColors: le.makeWithCounterpart(this.manager.worker),
                segmentSelectionState: new V.a,
                selectedAlpha: Object(se.a)(.5),
                saturation: Object(se.a)(1),
                notSelectedAlpha: Object(se.a)(0),
                objectAlpha: Object(se.a)(1),
                hideSegmentZero: new ae.b(!0,!0),
                visibleSegments: ue.makeWithCounterpart(this.manager.worker),
                highlightedSegments: ue.makeWithCounterpart(this.manager.worker),
                segmentEquivalences: q.makeWithCounterpart(this.manager.worker),
                skeletonRenderingOptions: new K.c,
                shaderError: Object(he.b)(),
                renderScaleHistogram: new o.a,
                renderScaleTarget: Object(o.e)(1)
            },
            this.objectLayerStateChanged = new I.a,
            this.ontfield = document.getElementById("onttext"),
            this.has2dLayer = this.registerDisposer(Object(te.h)(e=>e.some(e=>e instanceof ie), {
                changed: this.layersChanged,
                value: this.renderLayers
            })),
            this.has3dLayer = this.registerDisposer(Object(te.h)(e=>e.some(e=>e instanceof s.a || e instanceof s.c || e instanceof K.a || e instanceof K.e), {
                changed: this.layersChanged,
                value: this.renderLayers
            })),
            this.hasSkeletonsLayer = this.registerDisposer(Object(te.h)(e=>e.some(e=>e instanceof K.a), {
                changed: this.layersChanged,
                value: this.renderLayers
            })),
            this.atlas = new ke,
            this.displayState.visibleSegments.changed.add(this.specificationChanged.dispatch),
            this.displayState.segmentEquivalences.changed.add(this.specificationChanged.dispatch),
            this.displayState.segmentSelectionState.bindTo(this.manager.layerSelectedValues, this),
            this.displayState.selectedAlpha.changed.add(this.specificationChanged.dispatch),
            this.displayState.saturation.changed.add(this.specificationChanged.dispatch),
            this.displayState.notSelectedAlpha.changed.add(this.specificationChanged.dispatch),
            this.displayState.objectAlpha.changed.add(this.specificationChanged.dispatch),
            this.displayState.hideSegmentZero.changed.add(this.specificationChanged.dispatch),
            this.displayState.skeletonRenderingOptions.changed.add(this.specificationChanged.dispatch),
            this.displayState.segmentColorHash.changed.add(this.specificationChanged.dispatch),
            this.displayState.segmentStatedColors.changed.add(this.specificationChanged.dispatch),
            this.displayState.renderScaleTarget.changed.add(this.specificationChanged.dispatch),
            this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch),
            this.tabs.add("rendering", {
                label: "Rendering",
                order: -100,
                getter: ()=>new De(this)
            }),
            this.tabs.default = "rendering"
        }
        getValueAt(e, t) {
            let n = super.getValueAt(e, t);
            return null !== n && +n !== this.oldvalue && void 0 !== n && void 0 !== this.atlas && null !== this.atlas && null != this.ontfield && (this.ontfield.innerHTML = "" + this.atlas.getNameForId(+n.toString())),
            this.oldvalue = +n,
            n
        }
        get volumeOptions() {
            return {
                volumeType: Z.b.SEGMENTATION
            }
        }
        activateDataSubsources(e) {
            for (const t of e) {
                if (this.addStaticAnnotations(t))
                    continue;
                const {volume: e, mesh: n} = t.subsourceEntry.subsource;
                if (e instanceof Q.a) {
                    switch (e.dataType) {
                    case Z.a.FLOAT32:
                        t.deactivate("Data type not compatible with segmentation layer");
                        continue
                    }
                    t.activate(()=>t.addRenderLayer(new ie(e,Object.assign(Object.assign({}, this.displayState), {
                        transform: t.getRenderLayerTransform(),
                        renderScaleTarget: this.sliceViewRenderScaleTarget,
                        renderScaleHistogram: this.sliceViewRenderScaleHistogram,
                        localPosition: this.localPosition
                    }))))
                } else
                    void 0 !== n ? t.activate(()=>{
                        const e = Object.assign(Object.assign({}, this.displayState), {
                            transform: t.getRenderLayerTransform()
                        });
                        if (n instanceof s.b)
                            t.addRenderLayer(new s.a(this.manager.chunkManager,n,e));
                        else if (n instanceof s.d)
                            t.addRenderLayer(new s.c(this.manager.chunkManager,n,e));
                        else {
                            const i = new K.b(this.manager.chunkManager,n,e);
                            t.addRenderLayer(new K.a(i.addRef())),
                            t.addRenderLayer(new K.e(i))
                        }
                    }
                    ) : t.deactivate("Not compatible with segmentation layer")
            }
        }
        getLegacyDataSourceSpecifications(e, t, n) {
            const i = super.getLegacyDataSourceSpecifications(e, t, n)
              , s = Object(H.B)(t, "mesh", e=>null === e ? null : Object(H.E)(e))
              , a = Object(H.B)(t, "skeletons", e=>null === e ? null : Object(H.E)(e));
            if (void 0 !== s || void 0 !== a)
                for (const e of i)
                    e.enableDefaultSubsources = !1,
                    e.subsources = new Map([["default", {
                        enabled: !0
                    }], ["bounds", {
                        enabled: !0
                    }]]);
            return null != s && i.push(Object(r.c)(this.manager.dataSourceProviderRegistry.convertLegacyUrl({
                url: s,
                type: "mesh"
            }))),
            null != a && i.push(Object(r.c)(this.manager.dataSourceProviderRegistry.convertLegacyUrl({
                url: a,
                type: "skeletons"
            }))),
            i
        }
        restoreState(e) {
            super.restoreState(e),
            this.displayState.selectedAlpha.restoreState(e.selectedAlpha),
            this.displayState.saturation.restoreState(e.saturation),
            this.displayState.notSelectedAlpha.restoreState(e.notSelectedAlpha),
            this.displayState.objectAlpha.restoreState(e.objectAlpha),
            this.displayState.hideSegmentZero.restoreState(e.hideSegmentZero);
            const {skeletonRenderingOptions: t} = this.displayState;
            t.restoreState(e.skeletonRendering);
            const n = e.skeletonShader;
            void 0 !== n && t.shader.restoreState(n),
            this.displayState.segmentColorHash.restoreState(e.colorSeed),
            this.displayState.renderScaleTarget.restoreState(e.meshRenderScale),
            Object(H.y)(e, "equivalences", e=>{
                this.displayState.segmentEquivalences.restoreState(e)
            }
            );
            const i = (t,n)=>{
                Object(H.y)(e, t, e=>{
                    if (void 0 !== e) {
                        let {segmentEquivalences: t} = this.displayState;
                        Object(H.b)(e, e=>{
                            let i = u.a.parseString(String(e), 10);
                            n.add(t.get(i))
                        }
                        )
                    }
                }
                )
            }
            ;
            i("segments", this.displayState.visibleSegments),
            i("highlights", this.displayState.highlightedSegments),
            this.displayState.highlightedSegments.changed.add(()=>{
                this.specificationChanged.dispatch()
            }
            ),
            Object(H.y)(e, "segmentColors", e=>{
                if (void 0 !== e) {
                    let {segmentEquivalences: t} = this.displayState
                      , n = Object(H.x)(e, e=>Object(de.c)(String(e)));
                    for (let[e,i] of n) {
                        const n = u.a.parseString(String(e))
                          , r = new u.a(Object(de.b)(i));
                        this.displayState.segmentStatedColors.set(t.get(n), r)
                    }
                }
            }
            ),
            this.sliceViewRenderScaleTarget.restoreState(e.crossSectionRenderScale)
        }
        toJSON() {
            const e = super.toJSON();
            e.selectedAlpha = this.displayState.selectedAlpha.toJSON(),
            e.notSelectedAlpha = this.displayState.notSelectedAlpha.toJSON(),
            e.saturation = this.displayState.saturation.toJSON(),
            e.objectAlpha = this.displayState.objectAlpha.toJSON(),
            e.hideSegmentZero = this.displayState.hideSegmentZero.toJSON(),
            e.colorSeed = this.displayState.segmentColorHash.toJSON();
            let {segmentStatedColors: t} = this.displayState;
            if (t.size > 0) {
                let n = t.toJSON();
                Object.keys(n).map(e=>n[e] = "#" + parseInt(n[e], 10).toString(16).padStart(6, "0")),
                e.segmentColors = n
            }
            let {visibleSegments: n} = this.displayState;
            n.size > 0 && (e.segments = n.toJSON());
            let {highlightedSegments: i} = this.displayState;
            i.size > 0 && (e.highlights = i.toJSON());
            let {segmentEquivalences: r} = this.displayState;
            return r.size > 0 && (e.equivalences = r.toJSON()),
            e.skeletonRendering = this.displayState.skeletonRenderingOptions.toJSON(),
            e.meshRenderScale = this.displayState.renderScaleTarget.toJSON(),
            e.crossSectionRenderScale = this.sliceViewRenderScaleTarget.toJSON(),
            e
        }
        transformPickedValue(e) {
            if (null == e)
                return e;
            let {segmentEquivalences: t} = this.displayState;
            if (0 === t.size)
                return e;
            "number" == typeof e && (e = new u.a(e,0));
            let n = t.get(e);
            return u.a.equal(n, e) ? e : new V.c(e,n)
        }
        handleAction(e) {
            switch (e) {
            case "recolor":
                this.displayState.segmentColorHash.randomize();
                break;
            case "clear-segments":
                this.displayState.visibleSegments.clear();
                break;
            case "select":
                {
                    let {segmentSelectionState: e} = this.displayState;
                    if (e.hasSelectedSegment) {
                        let t = e.selectedSegment
                          , {visibleSegments: n} = this.displayState;
                        n.has(t) ? n.delete(t) : n.add(t)
                    }
                    break
                }
            case "highlight":
                {
                    let {segmentSelectionState: e} = this.displayState;
                    if (e.hasSelectedSegment) {
                        let t = e.selectedSegment
                          , {highlightedSegments: n} = this.displayState;
                        n.has(t) ? n.delete(t) : n.add(t)
                    }
                    break
                }
            }
        }
    }
    function Me(e) {
        return new we.a({
            fragmentMain: e.displayState.skeletonRenderingOptions.shader,
            shaderError: e.displayState.shaderError,
            shaderControlState: e.displayState.skeletonRenderingOptions.shaderControlState
        })
    }
    Te.type = "segmentation";
    class De extends Ce.b {
        constructor(e) {
            super(),
            this.layer = e;
            const {element: t} = this;
            t.classList.add("segmentation-dropdown");
            {
                const e = this.registerDisposer(new ve.a(this.layer.displayState.saturation));
                e.promptElement.textContent = "Saturation",
                t.appendChild(e.element)
            }
            const n = this.registerDisposer(new pe.a(e.has2dLayer,(e,t,n)=>{
                if (!e)
                    return;
                const i = n.registerDisposer(new ve.a(this.layer.displayState.selectedAlpha));
                i.promptElement.textContent = "Opacity (on)",
                t.appendChild(i.element);
                const r = n.registerDisposer(new ve.a(this.layer.displayState.notSelectedAlpha));
                r.promptElement.textContent = "Opacity (off)",
                t.appendChild(r.element);
                {
                    const e = n.registerDisposer(new be.a(this.layer.sliceViewRenderScaleHistogram,this.layer.sliceViewRenderScaleTarget));
                    e.label.textContent = "Resolution (slice)",
                    t.appendChild(e.element)
                }
            }
            ,this.visibility));
            t.appendChild(n.element);
            const i = this.registerDisposer(new pe.a(e.has3dLayer,(e,t,n)=>{
                if (!e)
                    return;
                {
                    const e = n.registerDisposer(new be.a(this.layer.displayState.renderScaleHistogram,this.layer.displayState.renderScaleTarget));
                    e.label.textContent = "Resolution (mesh)",
                    t.appendChild(e.element)
                }
                const i = n.registerDisposer(new ve.a(this.layer.displayState.objectAlpha));
                i.promptElement.textContent = "Opacity (3d)",
                t.appendChild(i.element)
            }
            ,this.visibility));
            t.appendChild(i.element);
            {
                const n = this.registerDisposer(new ae.c(e.displayState.hideSegmentZero));
                n.element.className = "neuroglancer-segmentation-dropdown-hide-segment-zero neuroglancer-noselect";
                const i = document.createElement("label");
                i.className = "neuroglancer-segmentation-dropdown-hide-segment-zero neuroglancer-noselect",
                i.appendChild(document.createTextNode("Hide segment ID 0")),
                i.appendChild(n.element),
                t.appendChild(i)
            }
            const r = this.registerDisposer(new Se(this.layer.displayState))
              , s = this.registerDisposer(new Oe.a);
            s.element.classList.add("add-segment"),
            s.element.title = "Add one or more segment IDs",
            t.appendChild(this.registerDisposer(s).element),
            this.registerDisposer(s.valuesEntered.add(e=>{
                for (const t of e)
                    this.layer.displayState.visibleSegments.add(t)
            }
            )),
            t.appendChild(this.registerDisposer(r).element);
            const a = this.registerDisposer(new pe.a(e.hasSkeletonsLayer,(t,n,i)=>{
                if (!t)
                    return;
                const r = (e,t)=>{
                    {
                        const r = i.registerDisposer(new fe.a(e.mode))
                          , s = document.createElement("label");
                        s.className = "neuroglancer-segmentation-dropdown-skeleton-render-mode neuroglancer-noselect",
                        s.appendChild(document.createTextNode(`Skeleton mode (${t})`)),
                        s.appendChild(r.element),
                        n.appendChild(s)
                    }
                    {
                        const i = this.registerDisposer(new ve.a(e.lineWidth,{
                            min: 1,
                            max: 40,
                            step: 1
                        }));
                        i.promptElement.textContent = `Skeleton line width (${t})`,
                        n.appendChild(i.element)
                    }
                }
                ;
                r(e.displayState.skeletonRenderingOptions.params2d, "2d"),
                r(e.displayState.skeletonRenderingOptions.params3d, "3d");
                let s = document.createElement("div");
                s.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
                let a = document.createElement("div");
                a.style.flex = "1",
                a.textContent = "Skeleton shader:",
                s.appendChild(a),
                s.appendChild(Object(ge.a)({
                    title: "Show larger editor view",
                    onClick: ()=>{
                        new Le(this.layer)
                    }
                })),
                s.appendChild(Object(me.a)({
                    title: "Documentation on skeleton rendering",
                    href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
                })),
                n.appendChild(s);
                const o = i.registerDisposer(Me(this.layer));
                n.appendChild(o.element),
                n.appendChild(i.registerDisposer(new xe.a(e.displayState.skeletonRenderingOptions.shaderControlState)).element),
                o.textEditor.refresh()
            }
            ,this.visibility));
            t.appendChild(a.element)
        }
    }
    class Le extends a.a {
        constructor(e) {
            super(),
            this.layer = e,
            this.codeWidget = this.registerDisposer(Me(this.layer)),
            this.content.classList.add("neuroglancer-segmentation-layer-skeleton-shader-overlay"),
            this.content.appendChild(this.codeWidget.element),
            this.codeWidget.textEditor.refresh()
        }
    }
    Object(i.q)("segmentation", Te),
    Object(i.s)(Z.b.SEGMENTATION, Te),
    Object(i.r)(e=>{
        if (void 0 !== e.mesh)
            return Te
    }
    )
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i, r = n(8), s = n(54), a = n(14), o = n(4), l = n(74), c = n(33), u = n(68);
    !function(e) {
        e[e.RAW = 0] = "RAW",
        e[e.JPEG = 1] = "JPEG",
        e[e.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION"
    }(i || (i = {}));
    class d {
    }
    d.RPC_ID = "brainmaps/VolumeChunkSource";
    class h {
    }
    h.RPC_ID = "brainmaps/MultiscaleMeshSource";
    class p {
    }
    p.RPC_ID = "brainmaps/MeshSource";
    class f {
    }
    f.RPC_ID = "brainmaps/SkeletonSource";
    class m {
    }
    m.RPC_ID = "brainmaps/Annotation";
    class g {
    }
    g.RPC_ID = "brainmaps/AnnotationSpatialIndex";
    var v = n(63)
      , b = n(49)
      , y = n(56)
      , S = n(44)
      , w = n(9)
      , x = n(28)
      , C = n(35)
      , O = n(6)
      , k = n(39)
      , E = n(1)
      , T = n(0)
      , M = n(42)
      , D = n(108);
    n.d(t, "BrainmapsSkeletonSource", (function() {
        return P
    }
    )),
    n.d(t, "VolumeInfo", (function() {
        return V
    }
    )),
    n.d(t, "MultiscaleVolumeInfo", (function() {
        return U
    }
    )),
    n.d(t, "MultiscaleVolumeChunkSource", (function() {
        return z
    }
    )),
    n.d(t, "parseVolumeKey", (function() {
        return $
    }
    )),
    n.d(t, "VolumeList", (function() {
        return q
    }
    )),
    n.d(t, "parseChangeStackList", (function() {
        return Y
    }
    )),
    n.d(t, "BrainmapsAnnotationSource", (function() {
        return K
    }
    )),
    n.d(t, "BrainmapsDataSource", (function() {
        return Q
    }
    )),
    n.d(t, "productionInstance", (function() {
        return ee
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class L extends (Object(a.f)(Object(l.a)()(x.c), d)) {
    }
    class A extends (Object(a.f)(Object(l.a)()(b.d), h)) {
    }
    class I extends (Object(a.f)(Object(l.a)()(b.b), p)) {
    }
    class P extends (Object(a.f)(Object(l.a)()(y.d), f)) {
    }
    class R extends (Object(a.f)(Object(l.a)()(s.a), g)) {
    }
    const j = new Map;
    function N(e) {
        Object(T.w)(e);
        try {
            return {
                corner: Object(T.y)(e, "corner", e=>Object(T.g)(E.t.create(), e, T.p)),
                size: Object(T.y)(e, "size", e=>Object(T.g)(E.t.create(), e, T.r)),
                metadata: Object(T.y)(e, "metadata", T.C)
            }
        } catch (e) {
            throw new Error(`Failed to parse bounding box: ${e.message}`)
        }
    }
    j.set("UINT8", w.a.UINT8),
    j.set("FLOAT", w.a.FLOAT32),
    j.set("UINT32", w.a.UINT32),
    j.set("UINT64", w.a.UINT64);
    class V {
        constructor(e) {
            try {
                Object(T.w)(e),
                this.numChannels = Object(T.y)(e, "channelCount", T.D),
                this.dataType = Object(T.y)(e, "channelType", e=>Object(T.v)(e, j)),
                this.voxelSize = Object(T.y)(e, "pixelSize", e=>Object(T.g)(E.t.create(), e, T.r)),
                this.upperVoxelBound = Object(T.y)(e, "volumeSize", e=>Object(T.g)(E.t.create(), e, T.D)),
                this.boundingBoxes = Object(T.y)(e, "boundingBox", e=>void 0 === e ? [] : Object(T.b)(e, N))
            } catch (e) {
                throw new Error(`Failed to parse BrainMaps volume geometry: ${e.message}`)
            }
        }
    }
    function B(e) {
        return Object(T.w)(e),
        {
            name: Object(T.y)(e, "name", T.E),
            type: Object(T.y)(e, "type", T.E)
        }
    }
    const F = new RegExp("^(.*)_([0-9]+)x([0-9]+)x([0-9]+)_lod([0-9]+)_([0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)$");
    function _(e, t) {
        const n = function(e, t) {
            const n = new Map
              , i = e.scales[0]
              , r = new Set;
            for (const e of t) {
                if ("TRIANGLES" !== e.type)
                    continue;
                const t = e.name.match(F);
                if (null === t)
                    continue;
                const s = t[1];
                let a = n.get(s);
                void 0 === a && (a = {
                    key: s,
                    chunkShape: E.t.create(),
                    lods: []
                },
                n.set(s, a));
                const o = parseInt(t[5]);
                if (void 0 !== a.lods[o]) {
                    r.add(s);
                    continue
                }
                const l = E.t.fromValues(parseInt(t[2], 10), parseInt(t[3], 10), parseInt(t[4], 10))
                  , c = new Uint32Array(3);
                for (let e = 0; e < 3; ++e)
                    c[e] = Math.ceil(i.upperVoxelBound[e] / l[e]);
                a.lods[o] = {
                    info: e,
                    scale: parseFloat(t[6]),
                    relativeBlockShape: l,
                    gridShape: c
                }
            }
            const s = [];
            e: for (const e of n.values()) {
                if (r.has(e.key))
                    continue e;
                const t = e.lods[0];
                if (void 0 === t)
                    continue e;
                const n = t.relativeBlockShape;
                E.t.multiply(e.chunkShape, n, i.voxelSize);
                for (let t = 1; t < e.lods.length; ++t) {
                    const i = e.lods[t];
                    if (void 0 === i)
                        continue e;
                    const {relativeBlockShape: r} = i;
                    for (let e = 0; e < 3; ++e) {
                        const t = r[e]
                          , i = n[e];
                        if (t < i || t % i != 0)
                            continue e;
                        r[e] = t / i
                    }
                }
                n.fill(1),
                s.push(e)
            }
            return s
        }(e, t)
          , i = []
          , r = e=>{
            i.some(t=>t.name === e.name) || i.push(e)
        }
          , s = new Set;
        for (const e of n) {
            r({
                multi: e,
                single: void 0,
                name: e.key,
                partOfMultiscale: !1
            });
            for (const t of e.lods)
                s.add(t.info)
        }
        for (const e of t)
            r({
                single: e,
                multi: void 0,
                name: e.name,
                partOfMultiscale: s.has(e)
            });
        return i
    }
    class U {
        constructor(e) {
            try {
                Object(T.w)(e);
                let t = this.scales = Object(T.y)(e, "geometry", e=>Object(T.b)(e, e=>new V(e)));
                if (0 === t.length)
                    throw new Error("Expected at least one scale.");
                let n = t[0]
                  , i = this.numChannels = n.numChannels
                  , r = this.dataType = n.dataType;
                for (let e = 1, n = t.length; e < n; ++e) {
                    let n = t[e];
                    if (n.dataType !== r)
                        throw new Error(`Scale ${e} has data type ${w.a[n.dataType]} ` + `but scale 0 has data type ${w.a[r]}.`);
                    if (n.numChannels !== i)
                        throw new Error(`Scale ${e} has ${n.numChannels} channel(s) ` + `but scale 0 has ${i} channels.`)
                }
                this.box = {
                    lowerBounds: new Float64Array(3),
                    upperBounds: new Float64Array(n.upperVoxelBound)
                }
            } catch (e) {
                throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${e.message}`)
            }
        }
        getModelSpace(e=!1) {
            const t = this.scales[0]
              , n = ["x", "y", "z"]
              , i = ["m", "m", "m"]
              , r = Array.from(t.voxelSize, e=>e / 1e9)
              , s = [0, 0, 0]
              , a = Array.from(t.upperVoxelBound);
            return e && (n.push("c^"),
            i.push(""),
            r.push(1),
            s.push(0),
            a.push(this.numChannels)),
            Object(o.z)({
                names: n,
                units: i,
                scales: Float64Array.from(r),
                boundingBoxes: [Object(o.B)({
                    lowerBounds: new Float64Array(n.length),
                    upperBounds: Float64Array.from(a)
                })]
            })
        }
    }
    class z extends x.a {
        constructor(e, t, n, i, r, s, a) {
            super(e),
            this.instance = t,
            this.credentialsProvider = n,
            this.volumeId = i,
            this.changeSpec = r,
            this.multiscaleVolumeInfo = s,
            this.encoding = a.encoding,
            this.chunkLayoutPreference = a.chunkLayoutPreference;
            let o = w.b.IMAGE;
            this.dataType === w.a.UINT64 && (o = w.b.SEGMENTATION),
            this.volumeType = o
        }
        get scales() {
            return this.multiscaleVolumeInfo.scales
        }
        get dataType() {
            return this.multiscaleVolumeInfo.dataType
        }
        get rank() {
            return 1 !== this.multiscaleVolumeInfo.numChannels ? 4 : 3
        }
        getSources(e) {
            let t = i.RAW;
            this.dataType === w.a.UINT64 && this.volumeType === w.b.SEGMENTATION ? t = i.COMPRESSED_SEGMENTATION : this.volumeType === w.b.IMAGE && this.dataType === w.a.UINT8 && 1 === this.multiscaleVolumeInfo.numChannels && this.encoding !== i.RAW && !0 !== e.discreteValues && (t = i.JPEG);
            const n = this.scales[0]
              , {upperVoxelBound: r} = n
              , s = E.t.create()
              , {rank: a} = this;
            return Object(O.k)(this.scales.map((i,o)=>{
                E.t.divide(s, i.voxelSize, n.voxelSize);
                let l, c = i.upperVoxelBound, {numChannels: u} = i;
                const d = new Float32Array((a + 1) ** 2);
                d[(a + 1) * a + a] = 1;
                const h = new Float32Array(a);
                1 !== u && (c = Float32Array.of(...c, u),
                l = Uint32Array.of(1, 1, 1, u),
                d[3 * (a + 1) + 3] = 1,
                h[3] = u);
                for (let e = 0; e < 3; ++e)
                    d[(a + 1) * e + e] = s[e],
                    h[e] = r[e] / s[e];
                return Object(w.c)({
                    rank: a,
                    minBlockSize: l,
                    chunkToMultiscaleTransform: d,
                    dataType: i.dataType,
                    upperVoxelBound: c,
                    volumeType: this.volumeType,
                    volumeSourceOptions: e,
                    chunkLayoutPreference: this.chunkLayoutPreference,
                    maxCompressedSegmentationBlockSize: E.t.fromValues(64, 64, 64)
                }).map(e=>({
                    chunkSource: this.chunkManager.getChunkSource(L, {
                        credentialsProvider: this.credentialsProvider,
                        spec: e,
                        parameters: {
                            volumeId: this.volumeId,
                            changeSpec: this.changeSpec,
                            scaleIndex: o,
                            encoding: t,
                            instance: this.instance
                        }
                    }),
                    chunkToMultiscaleTransform: d,
                    upperClipBound: h
                }))
            }
            ))
        }
    }
    function G(e) {
        const t = E.l.create()
          , n = e.scales[0].voxelSize;
        for (let e = 0; e < 3; ++e)
            t[5 * e] = 1 / n[e];
        return t
    }
    function $(e) {
        const t = e.match(/^([^:?\/]+:[^:?\/]+:[^:?\/]+)(?::([^:?\/]+))?(?:\/([^?]+))?(?:\?(.*))?$/);
        if (null === t)
            throw new Error(`Invalid Brain Maps volume key: ${JSON.stringify(e)}.`);
        let n;
        void 0 !== t[2] && (n = {
            changeStackId: t[2]
        });
        const i = Object(T.f)(t[4] || "");
        return {
            volumeId: t[1],
            changeSpec: n,
            meshName: t[3],
            parameters: i
        }
    }
    function W(e) {
        try {
            return Object(T.w)(e),
            {
                id: Object(T.y)(e, "id", T.E),
                label: Object(T.y)(e, "label", T.E),
                description: Object(T.y)(e, "description", T.C)
            }
        } catch (e) {
            throw new Error(`Failed to parse project: ${e.message}`)
        }
    }
    function H(e) {
        try {
            return Object(T.w)(e),
            Object(T.y)(e, "project", e=>void 0 === e ? [] : Object(T.b)(e, W))
        } catch (e) {
            throw new Error(`Error parsing project list: ${e.message}`)
        }
    }
    function J(e, t) {
        try {
            return Object(T.w)(e),
            Object(T.y)(e, t, e=>void 0 === e ? [] : Object(T.b)(e, T.E))
        } catch (e) {
            throw new Error(`Error parsing dataset list: ${e.message}`)
        }
    }
    class q {
        constructor(e, t) {
            this.projects = new Map,
            this.hierarchicalVolumeIds = new Map;
            const {projects: n} = this;
            for (let t of H(e))
                n.set(t.id, t);
            try {
                Object(T.w)(t);
                let e = this.volumeIds = Object(T.y)(t, "volumeId", e=>void 0 === e ? [] : Object(T.b)(e, T.E));
                e.sort();
                let n = new Map;
                for (let t of e) {
                    let e = 0;
                    for (; ; ) {
                        let i = t.indexOf(":", e);
                        -1 === i ? i = void 0 : ++i;
                        let r = t.substring(0, e)
                          , s = n.get(r);
                        if (void 0 === s && (s = new Set,
                        n.set(r, s)),
                        s.add(t.substring(e, i)),
                        void 0 === i)
                            break;
                        e = i
                    }
                }
                let {hierarchicalVolumeIds: i} = this;
                for (let[e,t] of n)
                    i.set(e, Array.from(t))
            } catch (e) {
                throw new Error(`Failed to parse Brain Maps volume list reply: ${e.message}`)
            }
        }
    }
    function Y(e) {
        return Object(T.y)(e, "changeStackId", e=>void 0 === e ? void 0 : Object(T.b)(e, T.E))
    }
    const X = Object(a.f)(Object(l.a)()(s.b), m);
    class K extends X {
        constructor(e, t) {
            super(e, Object.assign({
                rank: 3,
                relationships: ["segments"],
                properties: []
            }, t)),
            this.credentialsProvider = this.registerDisposer(t.credentialsProvider.addRef())
        }
        getSources() {
            const {upperVoxelBound: e} = this.parameters
              , t = Object(S.m)({
                rank: 3,
                chunkDataSize: e,
                upperVoxelBound: e
            })
              , n = E.l.create();
            return [[{
                chunkSource: this.chunkManager.getChunkSource(R, {
                    parent: this,
                    spec: Object.assign({
                        limit: 0,
                        chunkToMultiscaleTransform: n
                    }, t),
                    parameters: this.parameters,
                    credentialsProvider: this.credentialsProvider
                }),
                chunkToMultiscaleTransform: n
            }]]
        }
    }
    const Z = [{
        key: {
            value: "encoding",
            description: "Volume chunk data encoding"
        },
        values: [{
            value: "raw",
            description: ""
        }, {
            value: "jpeg",
            description: ""
        }, {
            value: "compressed_segmentation",
            description: ""
        }]
    }, {
        key: {
            value: "chunkLayout",
            description: "Volume chunk layout preference"
        },
        values: [{
            value: "isotropic",
            description: ""
        }, {
            value: "flat",
            description: ""
        }]
    }];
    class Q extends c.a {
        constructor(e, t) {
            super(),
            this.instance = e,
            this.credentialsProvider = t
        }
        get description() {
            return this.instance.description
        }
        getMultiscaleInfo(e, t) {
            return e.memoize.getUncounted({
                type: "brainmaps:getMultiscaleInfo",
                volumeId: t,
                instance: this.instance,
                credentialsProvider: Object(M.a)(this.credentialsProvider)
            }, ()=>Object(u.b)(this.instance, this.credentialsProvider, {
                method: "GET",
                path: `/v1beta2/volumes/${t}`,
                responseType: "json"
            }).then(e=>new U(e)))
        }
        getMeshesInfo(e, t) {
            return e.memoize.getUncounted({
                type: "brainmaps:getMeshesInfo",
                volumeId: t,
                instance: this.instance,
                credentialsProvider: Object(M.a)(this.credentialsProvider)
            }, ()=>Object(u.b)(this.instance, this.credentialsProvider, {
                method: "GET",
                path: `/v1beta2/objects/${t}/meshes`,
                responseType: "json"
            }).then(e=>function(e) {
                try {
                    return Object(T.w)(e),
                    Object(T.y)(e, "meshes", e=>void 0 === e ? [] : Object(T.b)(e, B))
                } catch (e) {
                    throw new Error(`Failed to parse BrainMaps meshes specification: ${e.message}`)
                }
            }(e)))
        }
        get(e) {
            const {volumeId: t, changeSpec: n, meshName: s, parameters: a} = $(e.providerUrl);
            Object(T.w)(a);
            const l = Object(T.B)(a, "encoding", e=>Object(T.o)(e, i))
              , c = Object(T.B)(a, "chunkLayout", e=>Object(T.o)(e, S.a))
              , u = Object.assign(Object.assign({}, e), {
                encoding: l,
                chunkLayoutPreference: c
            });
            return e.chunkManager.memoize.getUncounted({
                type: "brainmaps:get",
                instance: this.instance,
                volumeId: t,
                changeSpec: n,
                brainmapsOptions: u
            }, async()=>{
                const [i,a] = await Promise.all([this.getMultiscaleInfo(e.chunkManager, t), this.getMeshesInfo(e.chunkManager, t)])
                  , l = new z(e.chunkManager,this.instance,this.credentialsProvider,t,n,i,u)
                  , c = {
                    modelTransform: Object(o.A)(i.getModelSpace(1 !== i.numChannels)),
                    subsources: [{
                        id: void 0 === s ? "default" : "volume",
                        subsource: {
                            volume: l
                        },
                        default: void 0 === s
                    }]
                }
                  , d = Object(r.n)(i.box);
                i.scales[0].boundingBoxes.forEach((e,t)=>{
                    d.add({
                        type: r.e.AXIS_ALIGNED_BOUNDING_BOX,
                        description: e.metadata,
                        pointA: e.corner,
                        pointB: E.t.add(E.t.create(), e.corner, e.size),
                        id: `boundingBox${t}`,
                        properties: []
                    })
                }
                ),
                c.subsources.push({
                    id: "bounds",
                    subsource: {
                        staticAnnotations: d
                    },
                    default: !0
                });
                const h = _(i, a)
                  , p = (r,a)=>{
                    let o;
                    const {single: l} = r;
                    if (void 0 !== l)
                        o = "TRIANGLES" === l.type ? e.chunkManager.getChunkSource(I, {
                            credentialsProvider: this.credentialsProvider,
                            parameters: {
                                instance: this.instance,
                                volumeId: t,
                                meshName: l.name,
                                changeSpec: n
                            }
                        }) : e.chunkManager.getChunkSource(P, {
                            credentialsProvider: this.credentialsProvider,
                            parameters: {
                                instance: this.instance,
                                volumeId: t,
                                meshName: r.name,
                                changeSpec: n
                            }
                        });
                    else {
                        const i = r.multi;
                        o = e.chunkManager.getChunkSource(A, {
                            credentialsProvider: this.credentialsProvider,
                            format: {
                                fragmentRelativeVertices: !1,
                                vertexPositionFormat: v.e.float32
                            },
                            parameters: {
                                instance: this.instance,
                                volumeId: t,
                                info: i,
                                changeSpec: n
                            }
                        })
                    }
                    c.subsources.push({
                        id: void 0 === s ? `/${r.name}` : "default",
                        subsource: {
                            mesh: o
                        },
                        subsourceToModelSubspaceTransform: G(i),
                        modelSubspaceDimensionIndices: [0, 1, 2],
                        default: a
                    })
                }
                ;
                if (void 0 !== s) {
                    const e = h.find(e=>e.name === s);
                    if (void 0 === e)
                        throw new Error(`Mesh/skeleton source not found: ${JSON.stringify(e)}`);
                    p(e, !0)
                } else {
                    let e = !0;
                    for (const t of h)
                        t.partOfMultiscale || (p(t, e),
                        e = !1)
                }
                return void 0 !== n && c.subsources.push({
                    id: "spatials",
                    default: !0,
                    subsource: {
                        annotation: e.chunkManager.getChunkSource(K, {
                            parameters: {
                                volumeId: t,
                                changestack: n.changeStackId,
                                instance: this.instance,
                                upperVoxelBound: i.scales[0].upperVoxelBound
                            },
                            credentialsProvider: this.credentialsProvider
                        })
                    }
                }),
                c
            }
            )
        }
        getProjectList(e) {
            return e.memoize.getUncounted({
                instance: this.instance,
                type: "brainmaps:getProjectList"
            }, ()=>{
                let e = Object(u.b)(this.instance, this.credentialsProvider, {
                    method: "GET",
                    path: "/v1beta2/projects",
                    responseType: "json"
                }).then(e=>H(e));
                const t = `${this.instance.description} project list`;
                return C.a.forPromise(e, {
                    delay: !0,
                    initialMessage: `Retrieving ${t}.`,
                    errorPrefix: `Error retrieving ${t}: `
                }),
                e
            }
            )
        }
        getDatasetList(e, t) {
            return e.memoize.getUncounted({
                instance: this.instance,
                type: `brainmaps:${t}:getDatasetList`
            }, ()=>{
                let e = Object(u.b)(this.instance, this.credentialsProvider, {
                    method: "GET",
                    path: `/v1beta2/datasets?project_id=${t}`,
                    responseType: "json"
                }).then(e=>J(e, "datasetIds"));
                const n = `${this.instance.description} dataset list`;
                return C.a.forPromise(e, {
                    delay: !0,
                    initialMessage: `Retrieving ${n}`,
                    errorPrefix: `Error retrieving ${n}`
                }),
                e
            }
            )
        }
        getVolumeList(e, t, n) {
            return e.memoize.getUncounted({
                instance: this.instance,
                type: `brainmaps:${t}:${n}:getVolumeList`
            }, ()=>{
                let e = Object(u.b)(this.instance, this.credentialsProvider, {
                    method: "GET",
                    path: `/v1beta2/volumes?project_id=${t}&dataset_id=${n}`,
                    responseType: "json"
                }).then(e=>{
                    const i = J(e, "volumeId")
                      , r = t.length + n.length + 2
                      , s = [];
                    for (const e of i)
                        s.push(e.substring(r));
                    return s
                }
                );
                const i = `${this.instance.description} volume list`;
                return C.a.forPromise(e, {
                    delay: !0,
                    initialMessage: `Retrieving ${i}`,
                    errorPrefix: `Error retrieving ${i}`
                }),
                e
            }
            )
        }
        getChangeStackList(e, t) {
            return e.memoize.getUncounted({
                instance: this.instance,
                type: "brainmaps:getChangeStackList",
                volumeId: t
            }, ()=>{
                let e = Object(u.b)(this.instance, this.credentialsProvider, {
                    method: "GET",
                    path: `/v1beta2/changes/${t}/change_stacks`,
                    responseType: "json"
                }).then(e=>Y(e));
                const n = `change stacks for ${t}`;
                return C.a.forPromise(e, {
                    delay: !0,
                    initialMessage: `Retrieving ${n}.`,
                    errorPrefix: `Error retrieving ${n}: `
                }),
                e
            }
            )
        }
        async completeUrl(e) {
            const {providerUrl: t} = e
              , n = t.match(/^([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*))?(?:\/([^?]*))?(?:\?(.*))?)?)?$/);
            if (null === n)
                throw null;
            const [,i,r,s,a,o,l] = n;
            if (void 0 !== l)
                return Object(k.a)(t.length - l.length, await Object(k.b)(l, Z));
            if (void 0 !== o) {
                const n = `${i}:${r}:${s}`
                  , a = await this.getMeshesInfo(e.chunkManager, n)
                  , l = []
                  , c = new Set;
                for (const e of a)
                    if (e.name.startsWith(o))
                        switch (e.type) {
                        case "LINE_SEGMENTS":
                            l.push({
                                value: e.name,
                                description: "Skeletons"
                            });
                            break;
                        case "TRIANGLES":
                            {
                                l.push({
                                    value: e.name,
                                    description: "Mesh (single-resolution)"
                                });
                                const t = e.name.match(F);
                                if (null !== t) {
                                    const e = t[1];
                                    if (c.has(e))
                                        break;
                                    c.add(e),
                                    l.push({
                                        value: e,
                                        description: "Mesh (multi-resolution)"
                                    })
                                }
                                break
                            }
                        }
                return l.sort((e,t)=>Object(D.a)(e.value, t.value)),
                {
                    offset: t.length - o.length,
                    completions: l
                }
            }
            if (void 0 !== a) {
                const n = `${i}:${r}:${s}`
                  , o = await this.getChangeStackList(e.chunkManager, n);
                if (void 0 === o)
                    throw null;
                return {
                    offset: t.length - a.length,
                    completions: Object(k.c)(a, o)
                }
            }
            if (void 0 !== s)
                return {
                    offset: t.length - s.length,
                    completions: Object(k.c)(s, await this.getVolumeList(e.chunkManager, i, r))
                };
            if (void 0 !== r) {
                const n = await this.getDatasetList(e.chunkManager, i);
                return {
                    offset: t.length - r.length,
                    completions: Object(k.c)(r, n.map(e=>`${e}:`))
                }
            }
            const c = await this.getProjectList(e.chunkManager);
            return {
                offset: 0,
                completions: Object(k.d)(i, c, e=>`${e.id}:`, e=>e.label)
            }
        }
    }
    const ee = {
        description: "Google Brain Maps",
        serverUrl: "https://brainmaps.googleapis.com"
    }
}
, function(e, t) {
    e.exports = function(e) {
        var t = typeof e;
        return null != e && ("object" == t || "function" == t)
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t),
    n.d(t, "VtkDataSource", (function() {
        return o
    }
    ));
    var i = n(4)
      , r = n(33)
      , s = n(97)
      , a = n(83);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class o extends r.a {
        get description() {
            return "VTK mesh file"
        }
        async get(e) {
            const t = await Object(s.d)(e.chunkManager, {
                meshSourceUrl: e.url,
                attributeSourceUrls: []
            })
              , n = Object(i.z)({
                rank: 3,
                names: ["x", "y", "z"],
                units: ["m", "m", "m"],
                scales: Float64Array.of(1e-9, 1e-9, 1e-9)
            });
            return {
                modelTransform: Object(i.A)(n),
                subsources: [{
                    id: "default",
                    default: !0,
                    subsource: {
                        singleMesh: t
                    }
                }]
            }
        }
        completeUrl(e) {
            return Object(a.a)(e.providerUrl, e.cancellationToken)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(8)
      , r = n(14)
      , s = n(4)
      , a = n(33);
    class o {
    }
    o.RPC_ID = "nifti/VolumeChunkSource";
    var l = n(9)
      , c = n(28)
      , u = n(23)
      , d = n(83)
      , h = n(15);
    n.d(t, "NiftiMultiscaleVolumeChunkSource", (function() {
        return f
    }
    )),
    n.d(t, "NiftiDataSource", (function() {
        return m
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class p extends (Object(r.f)(c.c, o)) {
    }
    class f extends c.a {
        constructor(e, t, n) {
            super(e),
            this.url = t,
            this.info = n
        }
        get dataType() {
            return this.info.dataType
        }
        get volumeType() {
            return l.b.UNKNOWN
        }
        get rank() {
            return this.info.rank
        }
        getSources(e) {
            let {info: t} = this;
            const n = h.c(Float32Array, t.rank + 1)
              , i = Object(l.e)({
                rank: t.rank,
                volumeType: l.b.UNKNOWN,
                chunkDataSize: t.volumeSize,
                dataType: t.dataType,
                upperVoxelBound: Float32Array.from(t.volumeSize),
                chunkToMultiscaleTransform: n,
                volumeSourceOptions: e
            });
            return [[{
                chunkSource: this.chunkManager.getChunkSource(p, {
                    spec: i,
                    parameters: {
                        url: this.url
                    }
                }),
                chunkToMultiscaleTransform: n
            }]]
        }
    }
    class m extends a.a {
        get description() {
            return "Single NIfTI file"
        }
        get(e) {
            return t = e.chunkManager,
            n = e.providerUrl,
            t.memoize.getUncounted({
                type: "nifti/getVolume",
                url: n
            }, async()=>{
                const e = await function(e, t, n) {
                    return e.rpc.promiseInvoke("nifti/getNiftiVolumeInfo", {
                        chunkManager: e.addCounterpartRef(),
                        url: t
                    }, n)
                }(t, n, u.e)
                  , r = new f(t,n,e)
                  , a = {
                    lowerBounds: new Float64Array(e.rank),
                    upperBounds: Float64Array.from(e.volumeSize)
                }
                  , o = Object(s.z)({
                    rank: e.rank,
                    names: e.sourceNames,
                    scales: e.sourceScales,
                    units: e.units,
                    boundingBoxes: [Object(s.B)(a)]
                })
                  , l = Object(s.z)({
                    rank: e.rank,
                    names: e.viewNames,
                    scales: e.viewScales,
                    units: e.units
                });
                return {
                    subsources: [{
                        id: "default",
                        default: !0,
                        subsource: {
                            volume: r
                        }
                    }, {
                        id: "bounds",
                        default: !0,
                        subsource: {
                            staticAnnotations: Object(i.n)(a)
                        }
                    }],
                    modelTransform: {
                        sourceRank: e.rank,
                        rank: e.rank,
                        inputSpace: o,
                        outputSpace: l,
                        transform: e.transform
                    }
                }
            }
            );
            var t, n
        }
        completeUrl(e) {
            return Object(d.a)(e.providerUrl, e.cancellationToken)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i, r = n(8), s = n(14), a = n(4), o = n(33);
    !function(e) {
        e[e.RAW = 0] = "RAW",
        e[e.GZIP = 1] = "GZIP"
    }(i || (i = {}));
    class l {
    }
    l.RPC_ID = "n5/VolumeChunkSource";
    var c = n(9)
      , u = n(28)
      , d = n(6)
      , h = n(83)
      , p = n(20)
      , f = n(0)
      , m = n(15)
      , g = n(37);
    n.d(t, "MultiscaleVolumeChunkSource", (function() {
        return b
    }
    )),
    n.d(t, "N5DataSource", (function() {
        return E
    }
    ));
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class v extends (Object(s.f)(u.c, l)) {
    }
    class b extends u.a {
        constructor(e, t, n) {
            let i, r;
            if (super(e),
            this.multiscaleMetadata = t,
            this.scales = n,
            n.forEach((e,t)=>{
                if (void 0 !== e) {
                    if (void 0 === r && (r = t),
                    void 0 !== i && e.dataType !== i)
                        throw new Error(`Scale s${t} has data type ${c.a[e.dataType]} but expected ${c.a[i]}.`);
                    i = e.dataType
                }
            }
            ),
            void 0 === i)
                throw new Error("At least one scale must be specified.");
            const s = t.scales[r]
              , o = n[r];
            this.dataType = i,
            this.volumeType = c.b.IMAGE,
            this.baseScaleIndex = r;
            const l = t.modelSpace
              , {rank: u} = l;
            this.modelSpace = Object(a.z)({
                names: l.names,
                scales: l.scales,
                units: l.units,
                boundingBoxes: [{
                    transform: Object(m.b)(Float64Array, s.downsamplingFactor, !1),
                    box: {
                        lowerBounds: new Float64Array(u),
                        upperBounds: new Float64Array(o.size)
                    }
                }]
            })
        }
        get rank() {
            return this.modelSpace.rank
        }
        getSources(e) {
            const {} = this
              , {scales: t, rank: n} = this
              , i = this.multiscaleMetadata.scales;
            return Object(d.k)(t.filter(e=>void 0 !== e).map((t,r)=>{
                const s = i[r]
                  , a = Object(m.b)(Float32Array, s.downsamplingFactor);
                return Object(c.c)({
                    rank: n,
                    chunkToMultiscaleTransform: a,
                    dataType: t.dataType,
                    upperVoxelBound: t.size,
                    volumeType: this.volumeType,
                    chunkDataSizes: [t.chunkSize],
                    volumeSourceOptions: e
                }).map(e=>({
                    chunkSource: this.chunkManager.getChunkSource(v, {
                        spec: e,
                        parameters: {
                            url: Object(p.d)(s.url),
                            encoding: t.encoding
                        }
                    }),
                    chunkToMultiscaleTransform: a
                }))
            }
            ))
        }
    }
    class y {
        constructor(e) {
            let t;
            Object(f.w)(e),
            this.dataType = Object(f.y)(e, "dataType", e=>Object(f.o)(e, c.a)),
            this.size = Float32Array.from(Object(f.y)(e, "dimensions", e=>Object(f.b)(e, f.D))),
            this.chunkSize = Object(f.y)(e, "blockSize", e=>Object(f.d)(new Uint32Array(this.size.length), e, f.D)),
            Object(f.B)(e, "compression", e=>{
                t = Object(f.y)(e, "type", e=>Object(f.o)(e, i))
            }
            ),
            void 0 === t && (t = Object(f.y)(e, "compressionType", e=>Object(f.o)(e, i))),
            this.encoding = t
        }
    }
    async function S(e, t, n) {
        const i = function(e) {
            let {protocol: t, host: n, path: i} = Object(p.e)(e);
            i.endsWith("/") && (i = i.substring(0, i.length - 1));
            const r = [];
            for (; ; ) {
                r.push(`${t}://${n}${i}/attributes.json`);
                const e = i.lastIndexOf("/");
                if (-1 === e)
                    break;
                i = i.substring(0, e)
            }
            return r
        }(t).map(p.d)
          , r = await Promise.all(i.map((t,r)=>function(e, t, n) {
            return t = Object(p.d)(t),
            e.memoize.getUncounted({
                type: "n5:attributes.json",
                url: t
            }, ()=>Object(p.c)(t).then(e=>e.json()).then(e=>{
                try {
                    return Object(f.w)(e)
                } catch (e) {
                    throw new Error(`Error reading attributes from ${t}: ${e.message}`)
                }
            }
            ).catch(e=>{
                if (e instanceof p.a && 404 === e.status) {
                    if (n)
                        return;
                    return {}
                }
                throw e
            }
            ))
        }(e, t, n && r === i.length - 1)));
        if (-1 === r.indexOf(void 0))
            return Object.assign({}, ...r)
    }
    function w(e, t) {
        if (-1 !== e && t !== e)
            throw new Error(`Rank mismatch, received ${t} but expected ${e}`);
        return t
    }
    function x(e) {
        return Float64Array.from(Object(f.b)(e, f.r))
    }
    function C(e) {
        const t = Object(f.a)(e);
        if (0 === t.length)
            throw new Error("Expected non-empty array");
        let n = -1;
        return {
            all: Object(f.b)(t, e=>{
                const t = x(e);
                return n = w(n, t.length),
                t
            }
            ),
            single: void 0,
            rank: n
        }
    }
    const O = ["x", "y", "z", "t", "c"];
    function k(e, t) {
        Object(f.w)(t);
        let n, i, r = -1, s = Object(f.B)(t, "resolution", e=>{
            const t = Float64Array.from(Object(f.b)(e, f.r));
            return r = w(r, t.length),
            t
        }
        ), o = Object(f.B)(t, "axes", e=>{
            const t = Object(f.b)(e, f.E);
            return r = w(r, t.length),
            t
        }
        ), l = Object(f.B)(t, "units", e=>{
            const t = Object(f.b)(e, g.g);
            return r = w(r, t.length),
            t
        }
        ), c = {
            unit: "m",
            exponent: -9
        };
        Object(f.B)(t, "downsamplingFactors", e=>{
            const {single: t, all: s, rank: a} = function(e) {
                const t = Object(f.a)(e);
                if (0 === t.length)
                    throw new Error("Expected non-empty array");
                if (Array.isArray(t[0]))
                    return C(t);
                const n = x(e);
                return {
                    all: void 0,
                    single: n,
                    rank: n.length
                }
            }(e);
            r = w(r, a),
            void 0 !== t && (n = t),
            void 0 !== s && (i = s)
        }
        ),
        Object(f.B)(t, "pixelResolution", e=>{
            c = Object(f.y)(e, "unit", g.g),
            Object(f.B)(e, "dimensions", e=>{
                s = Float64Array.from(Object(f.b)(e, f.r)),
                r = w(r, s.length)
            }
            )
        }
        ),
        Object(f.B)(t, "scales", e=>{
            const {all: t, rank: n} = C(e);
            r = w(r, n),
            i = t
        }
        );
        const u = Object(f.B)(t, "dimensions", e=>{
            const t = Object(f.b)(e, f.D);
            return r = w(r, t.length),
            t
        }
        );
        if (-1 === r)
            throw new Error("Unable to determine rank of dataset");
        void 0 === o && (o = function(e) {
            const t = O.slice(0, e);
            for (; t.length < e; )
                t.push(`d${t.length + 1}`);
            return t
        }(r)),
        void 0 === l && (l = new Array(r),
        l.fill(c)),
        void 0 === s && (s = new Float64Array(r),
        s.fill(1));
        for (let e = 0; e < r; ++e)
            s[e] = Object(g.e)(s[e], l[e].exponent);
        const d = Object(a.z)({
            rank: r,
            valid: !0,
            names: o,
            scales: s,
            units: l.map(e=>e.unit)
        });
        if (void 0 === u) {
            if (void 0 === i)
                throw new Error("Not valid single-resolution or multi-resolution dataset");
            return {
                modelSpace: d,
                url: e,
                attributes: t,
                scales: i.map((t,n)=>({
                    url: `${e}/s${n}`,
                    downsamplingFactor: t
                }))
            }
        }
        return void 0 === n && (n = new Float64Array(r),
        n.fill(1)),
        {
            modelSpace: d,
            url: e,
            attributes: t,
            scales: [{
                url: e,
                downsamplingFactor: n
            }]
        }
    }
    class E extends o.a {
        get description() {
            return "N5 data source"
        }
        get(e) {
            let t = e.providerUrl;
            return t.endsWith("/") && (t = t.substring(0, t.length - 1)),
            e.chunkManager.memoize.getUncounted({
                type: "n5:MultiscaleVolumeChunkSource",
                url: t
            }, async()=>{
                const n = await S(e.chunkManager, t, !1)
                  , i = await k(t, n)
                  , s = await function(e, t) {
                    return Promise.all(t.scales.map(async t=>{
                        const n = await S(e, t.url, !0);
                        if (void 0 !== n)
                            return new y(n)
                    }
                    ))
                }(e.chunkManager, i)
                  , o = new b(e.chunkManager,i,s);
                return {
                    modelTransform: Object(a.A)(o.modelSpace),
                    subsources: [{
                        id: "default",
                        default: !0,
                        url: void 0,
                        subsource: {
                            volume: o
                        }
                    }, {
                        id: "bounds",
                        default: !0,
                        url: void 0,
                        subsource: {
                            staticAnnotations: Object(r.n)(i.modelSpace.bounds)
                        }
                    }]
                }
            }
            )
        }
        completeUrl(e) {
            return Object(h.a)(e.providerUrl, e.cancellationToken)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(8)
      , r = n(14)
      , s = n(4)
      , a = n(74)
      , o = n(33)
      , l = n(73);
    class c extends /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class {
    }
    {
        static stringify(e) {
            return `boss:volume:${e.baseUrl}/${e.collection}/${e.experiment}/${e.channel}/${e.resolution}/${e.encoding}`
        }
    }
    c.RPC_ID = "boss/VolumeChunkSource";
    class u {
        static stringify(e) {
            return `boss:mesh:${e.baseUrl}`
        }
    }
    u.RPC_ID = "boss/MeshChunkSource";
    var d = n(49)
      , h = n(9)
      , p = n(28)
      , f = n(6)
      , m = n(39)
      , g = n(1)
      , v = n(20)
      , b = n(0);
    n.d(t, "BossMultiscaleVolumeChunkSource", (function() {
        return M
    }
    )),
    n.d(t, "getExperimentInfo", (function() {
        return L
    }
    )),
    n.d(t, "getChannelInfo", (function() {
        return A
    }
    )),
    n.d(t, "getDownsampleInfoForChannel", (function() {
        return I
    }
    )),
    n.d(t, "parseDownsampleScales", (function() {
        return P
    }
    )),
    n.d(t, "parseDownsampleInfoForChannel", (function() {
        return R
    }
    )),
    n.d(t, "getDataSource", (function() {
        return j
    }
    )),
    n.d(t, "getCollections", (function() {
        return V
    }
    )),
    n.d(t, "getExperiments", (function() {
        return B
    }
    )),
    n.d(t, "getCoordinateFrame", (function() {
        return F
    }
    )),
    n.d(t, "collectionExperimentChannelCompleter", (function() {
        return _
    }
    )),
    n.d(t, "BossDataSource", (function() {
        return U
    }
    ));
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class y extends (Object(r.f)(Object(a.a)()(p.c), c)) {
    }
    class S extends (Object(r.f)(Object(a.a)()(d.b), u)) {
    }
    let w = new Map;
    w.set("image", h.b.IMAGE),
    w.set("annotation", h.b.SEGMENTATION);
    const x = new Set(["npz", "jpeg"])
      , C = Uint32Array.of(512, 512, 16);
    var O;
    function k(e, t) {
        Object(b.w)(e);
        const n = Object(b.y)(e, "voxel_unit", e=>Object(b.o)(e, O))
          , i = function(e) {
            switch (e) {
            case O.MICROMETERS:
                return 1e6;
            case O.MILLIMETERS:
                return 1e3;
            case O.CENTIMETERS:
                return 100;
            case O.NANOMETERS:
                return 1e9
            }
        }(n)
          , r = new Float32Array(3)
          , s = new Float64Array(3)
          , a = new Float64Array(3)
          , o = new Float64Array(3)
          , l = ["x", "y", "z"];
        for (let t = 0; t < 3; ++t) {
            const n = l[t];
            r[t] = Object(b.y)(e, `${n}_voxel_size`, b.r),
            s[t] = r[t] / i,
            a[t] = Object(b.y)(e, `${n}_start`, b.u),
            o[t] = Object(b.y)(e, `${n}_stop`, b.u)
        }
        return t.coordFrame = {
            voxelSizeBaseInMeters: s,
            voxelSizeBaseInOriginalUnits: r,
            voxelOffsetBase: a,
            imageSizeBase: o,
            voxelUnit: n,
            names: l
        },
        t
    }
    function E(e) {
        let t = w.get(e);
        return void 0 === t && (t = h.b.UNKNOWN),
        t
    }
    function T(e) {
        Object(b.w)(e);
        let t = Object(b.y)(e, "type", b.E)
          , n = !1;
        return "DOWNSAMPLED" === Object(b.y)(e, "downsample_status", b.E) && (n = !0),
        {
            channelType: t,
            description: Object(b.y)(e, "description", b.E),
            volumeType: E(t),
            dataType: Object(b.y)(e, "datatype", e=>Object(b.o)(e, h.a)),
            downsampled: n,
            scales: [],
            key: Object(b.y)(e, "name", b.E)
        }
    }
    !function(e) {
        e[e.NANOMETERS = 0] = "NANOMETERS",
        e[e.MICROMETERS = 1] = "MICROMETERS",
        e[e.MILLIMETERS = 2] = "MILLIMETERS",
        e[e.CENTIMETERS = 3] = "CENTIMETERS"
    }(O || (O = {}));
    class M extends p.a {
        constructor(e, t, n, i, r, s) {
            if (super(e),
            this.baseUrl = t,
            this.credentialsProvider = n,
            this.experimentInfo = i,
            this.parameters = s,
            this.meshPath = void 0,
            this.meshUrl = void 0,
            void 0 === r) {
                const e = Array.from(i.channels.keys());
                if (1 !== e.length)
                    throw new Error(`Experiment contains multiple channels: ${JSON.stringify(e)}`);
                r = e[0]
            }
            const a = i.channels.get(r);
            if (void 0 === a)
                throw new Error(`Specified channel ${JSON.stringify(r)} is not one of the supported channels ${JSON.stringify(Array.from(i.channels.keys()))}`);
            if (this.channel = r,
            this.channelInfo = a,
            this.scales = a.scales,
            void 0 === i.coordFrame)
                throw new Error(`Specified experiment ${JSON.stringify(i.key)} does not have a valid coordinate frame`);
            this.coordinateFrame = i.coordFrame,
            !1 === this.channelInfo.downsampled && (this.scales = [a.scales[0]]),
            this.experiment = i.key;
            let o = Object(b.C)(s.window);
            if (void 0 !== o) {
                let e = g.s.create()
                  , t = o.split(/,/);
                if (2 === t.length)
                    e[0] = Object(b.p)(t[0]),
                    e[1] = Object(b.p)(t[1]);
                else {
                    if (1 !== t.length)
                        throw new Error(`Invalid window. Must be either one value or two comma separated values: ${JSON.stringify(o)}`);
                    e[0] = 0,
                    e[1] = Object(b.p)(t[1])
                }
                if (this.window = e,
                this.window[0] === this.window[1])
                    throw new Error(`Invalid window. First element must be different from second: ${JSON.stringify(o)}.`)
            }
            let l = Object(b.C)(s.meshurl);
            void 0 !== l && (this.meshUrl = l);
            let c = Object(b.C)(s.encoding);
            if (void 0 === c)
                c = this.volumeType === h.b.IMAGE ? "jpeg" : "npz";
            else if (!x.has(c))
                throw new Error(`Invalid encoding: ${JSON.stringify(c)}.`);
            this.encoding = c
        }
        get dataType() {
            return this.channelInfo.dataType === h.a.UINT16 ? h.a.UINT8 : this.channelInfo.dataType
        }
        get volumeType() {
            return this.channelInfo.volumeType
        }
        get rank() {
            return 3
        }
        getSources(e) {
            return Object(f.k)(this.scales.map(t=>{
                let {downsampleFactors: n, imageSize: i} = t
                  , r = this.coordinateFrame.voxelOffsetBase
                  , s = g.t.create();
                for (let e = 0; e < 3; ++e)
                    s[e] = Math.ceil(r[e]);
                const a = g.l.create();
                for (let e = 0; e < 3; ++e)
                    a[5 * e] = n[e],
                    a[12 + e] = r[e];
                return Object(h.c)({
                    rank: 3,
                    volumeType: this.volumeType,
                    dataType: this.dataType,
                    chunkToMultiscaleTransform: a,
                    chunkDataSizes: [C],
                    baseVoxelOffset: s,
                    upperVoxelBound: i,
                    volumeSourceOptions: e
                }).map(e=>({
                    chunkSource: this.chunkManager.getChunkSource(y, {
                        credentialsProvider: this.credentialsProvider,
                        spec: e,
                        parameters: {
                            baseUrl: this.baseUrl,
                            collection: this.experimentInfo.collection,
                            experiment: this.experimentInfo.key,
                            channel: this.channel,
                            resolution: t.key,
                            encoding: this.encoding,
                            window: this.window
                        }
                    }),
                    chunkToMultiscaleTransform: a
                }))
            }
            ))
        }
        getMeshSource() {
            return void 0 !== this.meshUrl ? this.chunkManager.getChunkSource(S, {
                credentialsProvider: this.credentialsProvider,
                parameters: {
                    baseUrl: this.meshUrl
                }
            }) : null
        }
    }
    const D = /^([^\/?]+)\/([^\/?]+)(?:\/([^\/?]+))?(?:\?(.*))?$/;
    function L(e, t, n, i, r) {
        return e.memoize.getUncounted({
            hostname: t,
            collection: r,
            experiment: i,
            type: "boss:getExperimentInfo"
        }, ()=>Object(l.b)(n, `${t}/latest/collection/${r}/experiment/${i}/`, {}, v.g).then(s=>function(e, t, n, i, r, s) {
            Object(b.w)(e);
            let a = Object(b.y)(e, "channels", e=>Object(b.b)(e, e=>A(t, n, i, s, r, e)));
            return Promise.all(a).then(r=>{
                let s = new Map;
                r.forEach(e=>{
                    s.set(e.key, e)
                }
                );
                let a = {
                    channels: s,
                    scalingLevels: Object(b.y)(e, "num_hierarchy_levels", b.u),
                    coordFrameKey: Object(b.y)(e, "coord_frame", b.E),
                    coordFrame: void 0,
                    key: Object(b.y)(e, "name", b.E),
                    collection: Object(b.y)(e, "collection", b.E)
                };
                return F(t, n, i, a)
            }
            )
        }(s, e, t, n, r, i)))
    }
    function A(e, t, n, i, r, s) {
        return e.memoize.getUncounted({
            hostname: t,
            collection: r,
            experiment: i,
            channel: s,
            type: "boss:getChannelInfo"
        }, ()=>Object(l.b)(n, `${t}/latest/collection/${r}/experiment/${i}/channel/${s}/`, {}, v.g).then(T))
    }
    function I(e, t, n, i, r, s) {
        return e.memoize.getUncounted({
            hostname: t,
            collection: i,
            experiment: r.key,
            channel: s,
            downsample: !0,
            type: "boss:getDownsampleInfoForChannel"
        }, ()=>Object(l.b)(n, `${t}/latest/downsample/${i}/${r.key}/${s}/`, {}, v.g)).then(e=>R(e, r, s))
    }
    function P(e, t) {
        Object(b.w)(e);
        let n = Object(b.y)(e, "voxel_size", e=>Object(b.x)(e, b.l))
          , i = Object(b.y)(e, "extent", e=>Object(b.x)(e, b.k))
          , r = Object(b.y)(e, "num_hierarchy_levels", b.u)
          , s = new Array;
        for (let e = 0; e < r; e++) {
            let r = String(e);
            const a = n.get(r)
              , o = i.get(r);
            if (void 0 === a || void 0 === o)
                throw new Error(`Missing voxel_size/extent for resolution ${r}.`);
            const l = new Float32Array(3);
            for (let e = 0; e < 3; ++e)
                l[e] = a[e] = t[e];
            s[e] = {
                downsampleFactors: l,
                imageSize: o,
                key: r
            }
        }
        return s
    }
    function R(e, t, n) {
        let i = t.coordFrame;
        if (void 0 === i)
            throw new Error(`Missing coordinate frame information for experiment ${t.key}. A valid coordinate frame is required to retrieve downsampling information.`);
        let r = t.channels.get(n);
        if (void 0 === r)
            throw new Error(`Specified channel ${JSON.stringify(n)} is not one of the supported channels ${JSON.stringify(Array.from(t.channels.keys()))}`);
        return r.scales = P(e, i.voxelSizeBaseInOriginalUnits),
        t.channels.set(n, r),
        t
    }
    function j(e, t, n, r) {
        const a = r.match(D);
        if (null === a)
            throw new Error(`Invalid volume path ${JSON.stringify(r)}`);
        const o = a[1]
          , l = a[2]
          , c = a[3]
          , u = Object(b.f)(a[4] || "");
        return e.memoize.getUncounted({
            hostname: t,
            path: r,
            type: "boss:getVolume"
        }, async()=>{
            const r = await L(e, t, n, l, o)
              , a = await I(e, t, n, o, r, c)
              , d = new M(e,t,n,a,c,u)
              , h = a.coordFrame
              , p = {
                lowerBounds: h.voxelOffsetBase,
                upperBounds: Float64Array.from(h.imageSizeBase, (e,t)=>h.voxelOffsetBase[t] + e)
            }
              , f = Object(s.z)({
                rank: 3,
                names: h.names,
                units: ["m", "m", "m"],
                scales: h.voxelSizeBaseInMeters,
                boundingBoxes: [Object(s.B)(p)]
            });
            return {
                modelTransform: Object(s.A)(f),
                subsources: [{
                    id: "default",
                    default: !0,
                    subsource: {
                        volume: d
                    }
                }, {
                    id: "bounds",
                    default: !0,
                    subsource: {
                        staticAnnotations: Object(i.n)(p)
                    }
                }]
            }
        }
        )
    }
    const N = /^((?:http|https):\/\/[^\/?]+)\/(.*)$/;
    function V(e, t, n) {
        return e.memoize.getUncounted({
            hostname: t,
            type: "boss:getCollections"
        }, ()=>Object(l.b)(n, `${t}/latest/collection/`, {}, v.g).then(e=>Object(b.y)(e, "collections", e=>Object(b.b)(e, b.E))))
    }
    function B(e, t, n, i) {
        return e.memoize.getUncounted({
            hostname: t,
            collection: i,
            type: "boss:getExperiments"
        }, ()=>Object(l.b)(n, `${t}/latest/collection/${i}/experiment/`, {}, v.g).then(e=>Object(b.y)(e, "experiments", e=>Object(b.b)(e, b.E))))
    }
    function F(e, t, n, i) {
        let r = i.coordFrameKey;
        return e.memoize.getUncounted({
            hostname: t,
            coordinateframe: r,
            experimentInfo: i,
            type: "boss:getCoordinateFrame"
        }, ()=>Object(l.b)(n, `${t}/latest/coord/${r}/`, {}, v.g).then(e=>k(e, i)))
    }
    function _(e, t, n, i) {
        let r = i.match(/^(?:([^\/]+)(?:\/?([^\/]*)(?:\/?([^\/]*)(?:\/?([^\/]*)?))?)?)?$/);
        if (null === r)
            return Promise.reject(null);
        if (void 0 === r[1])
            return Promise.reject(null);
        if (void 0 === r[2]) {
            let i = r[1] || "";
            return V(e, t, n).then(e=>({
                offset: 0,
                completions: Object(m.d)(i, e, e=>e + "/", ()=>{}
                )
            }))
        }
        if (void 0 === r[3]) {
            let i = r[2] || "";
            return B(e, t, n, r[1]).then(e=>({
                offset: r[1].length + 1,
                completions: Object(m.d)(i, e, e=>e + "/", ()=>{}
                )
            }))
        }
        return L(e, t, n, r[2], r[1]).then(e=>{
            let t = Object(m.d)(r[3], e.channels, e=>e[0], e=>`${e[1].channelType} (${h.a[e[1].dataType]})`);
            return {
                offset: r[1].length + r[2].length + 2,
                completions: t
            }
        }
        )
    }
    class U extends o.a {
        constructor(e) {
            super(),
            this.credentialsManager = e
        }
        get description() {
            return "bossDB: Block & Object Storage System"
        }
        getCredentialsProvider(e) {
            let t = function(e) {
                let t = e.match(/^(?:https:\/\/[^.]+([^\/]+))/);
                if (null === t)
                    throw new Error(`Unable to construct auth server hostname from base hostname ${e}.`);
                return `https://auth${t[1]}/auth`
            }(e);
            return this.credentialsManager.getCredentialsProvider(l.a, t)
        }
        get(e) {
            const t = e.providerUrl.match(N);
            if (null === t)
                throw new Error(`Invalid boss volume path: ${JSON.stringify(e.providerUrl)}`);
            let n = this.getCredentialsProvider(e.providerUrl);
            return j(e.chunkManager, t[1], n, t[2])
        }
        async completeUrl(e) {
            const t = e.providerUrl.match(N);
            if (null === t)
                throw null;
            let n = t[1]
              , i = this.getCredentialsProvider(t[1])
              , r = t[2];
            const s = await _(e.chunkManager, n, i, r);
            return Object(m.a)(t[1].length + 1, s)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i, r = n(8), s = n(14), a = n(4), o = n(33);
    !function(e) {
        e[e.JPEG = 0] = "JPEG",
        e[e.RAW = 1] = "RAW",
        e[e.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION",
        e[e.COMPRESSED_SEGMENTATIONARRAY = 3] = "COMPRESSED_SEGMENTATIONARRAY"
    }(i || (i = {}));
    class l {
    }
    class c extends l {
    }
    c.RPC_ID = "dvid/VolumeChunkSource";
    class u extends l {
    }
    u.RPC_ID = "dvid/SkeletonSource";
    class d extends l {
    }
    d.RPC_ID = "dvid/MeshSource";
    var h = n(49)
      , p = n(56)
      , f = n(9)
      , m = n(28)
      , g = n(35)
      , v = n(6)
      , b = n(39)
      , y = n(1)
      , S = n(20)
      , w = n(0);
    n.d(t, "DataInstanceBaseInfo", (function() {
        return C
    }
    )),
    n.d(t, "DataInstanceInfo", (function() {
        return O
    }
    )),
    n.d(t, "VolumeDataInstanceInfo", (function() {
        return M
    }
    )),
    n.d(t, "parseDataInstance", (function() {
        return D
    }
    )),
    n.d(t, "RepositoryInfo", (function() {
        return L
    }
    )),
    n.d(t, "parseRepositoriesInfo", (function() {
        return A
    }
    )),
    n.d(t, "ServerInfo", (function() {
        return I
    }
    )),
    n.d(t, "getServerInfo", (function() {
        return P
    }
    )),
    n.d(t, "getDataInstanceDetails", (function() {
        return R
    }
    )),
    n.d(t, "getDataSource", (function() {
        return V
    }
    )),
    n.d(t, "completeInstanceName", (function() {
        return B
    }
    )),
    n.d(t, "completeNodeAndInstance", (function() {
        return F
    }
    )),
    n.d(t, "completeUrl", (function() {
        return _
    }
    )),
    n.d(t, "DVIDDataSource", (function() {
        return U
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let x = new Map;
    x.set("uint8", f.a.UINT8),
    x.set("uint32", f.a.UINT32),
    x.set("uint64", f.a.UINT64);
    class C {
        constructor(e) {
            this.obj = e,
            Object(w.w)(e),
            Object(w.y)(e, "TypeName", w.E)
        }
        get typeName() {
            return this.obj.TypeName
        }
        get compressionName() {
            return this.obj.Compression
        }
    }
    class O {
        constructor(e, t, n) {
            this.obj = e,
            this.name = t,
            this.base = n
        }
    }
    class k extends (Object(s.f)(m.c, c)) {
    }
    class E extends (Object(s.f)(p.d, u)) {
    }
    class T extends (Object(s.f)(h.b, d)) {
    }
    class M extends O {
        constructor(e, t, n, r, s) {
            super(e, t, n),
            this.encoding = r;
            let a = Object(w.y)(e, "Extended", w.w)
              , o = Object(w.y)(a, "Values", e=>Object(w.b)(e, w.w));
            if (o.length < 1)
                throw new Error("Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.");
            this.numLevels = 1;
            let l = new Set(s);
            if (r === i.COMPRESSED_SEGMENTATIONARRAY) {
                let e = Object(w.y)(a, "MaxDownresLevel", w.D);
                this.numLevels = e + 1
            } else
                for (; l.has(t + "_" + this.numLevels.toString()); )
                    this.numLevels += 1;
            l.has(t + "_meshes") ? this.meshSrc = t + "_meshes" : this.meshSrc = "",
            l.has(t + "_skeletons") ? this.skeletonSrc = t + "_skeletons" : this.skeletonSrc = "",
            this.dataType = Object(w.y)(o[0], "DataType", e=>Object(w.v)(e, x)),
            this.voxelSize = Object(w.y)(a, "VoxelSize", e=>Object(w.d)(y.t.create(), e, w.r))
        }
        get volumeType() {
            return this.encoding === i.COMPRESSED_SEGMENTATION || this.encoding === i.COMPRESSED_SEGMENTATIONARRAY ? f.b.SEGMENTATION : f.b.IMAGE
        }
        getSources(e, t, n) {
            let {encoding: r} = this
              , s = [];
            for (let a = 0; a < this.numLevels; ++a) {
                const o = Math.pow(2, a)
                  , l = Math.pow(2, -a);
                let c = y.t.create()
                  , u = y.t.create();
                for (let e = 0; e < 3; ++e) {
                    let t = Math.floor(this.lowerVoxelBound[e] * l);
                    c[e] = t - t % 64;
                    let n = Math.ceil((this.upperVoxelBoundInclusive[e] + 1) * l);
                    u[e] = n,
                    n % 64 != 0 && (u[e] += 64 - n % 64)
                }
                let d = t.dataInstanceKey;
                r !== i.COMPRESSED_SEGMENTATIONARRAY && a > 0 && (d += "_" + a.toString());
                let h = {
                    baseUrl: t.baseUrl,
                    nodeKey: t.nodeKey,
                    dataInstanceKey: d,
                    dataScale: a.toString(),
                    encoding: r
                };
                const p = y.l.create();
                for (let e = 0; e < 3; ++e)
                    p[5 * e] = o,
                    p[12 + e] = c[e] * o;
                let m = Object(f.c)({
                    rank: 3,
                    chunkToMultiscaleTransform: p,
                    dataType: this.dataType,
                    baseVoxelOffset: c,
                    upperVoxelBound: y.t.subtract(y.t.create(), u, c),
                    volumeType: this.volumeType,
                    volumeSourceOptions: n,
                    compressedSegmentationBlockSize: r === i.COMPRESSED_SEGMENTATION || r === i.COMPRESSED_SEGMENTATIONARRAY ? y.t.fromValues(8, 8, 8) : void 0
                }).map(t=>({
                    chunkSource: e.getChunkSource(k, {
                        spec: t,
                        parameters: h
                    }),
                    chunkToMultiscaleTransform: p
                }));
                s.push(m)
            }
            return Object(v.k)(s)
        }
    }
    function D(e, t, n) {
        Object(w.w)(e);
        let r = Object(w.y)(e, "Base", e=>new C(e));
        switch (r.typeName) {
        case "uint8blk":
        case "grayscale8":
            let s = -1 !== r.compressionName.indexOf("jpeg");
            return new M(e,t,r,s ? i.JPEG : i.RAW,n);
        case "labels64":
        case "labelblk":
            return new M(e,t,r,i.COMPRESSED_SEGMENTATION,n);
        case "labelarray":
        case "labelmap":
            return new M(e,t,r,i.COMPRESSED_SEGMENTATIONARRAY,n);
        default:
            throw new Error(`DVID data type ${JSON.stringify(r.typeName)} is not supported.`)
        }
    }
    class L {
        constructor(e) {
            if (this.errors = [],
            this.dataInstances = new Map,
            this.vnodes = new Set,
            e instanceof L)
                return this.alias = e.alias,
                this.description = e.description,
                this.errors = e.errors,
                void (this.dataInstances = e.dataInstances);
            Object(w.w)(e),
            this.alias = Object(w.y)(e, "Alias", w.E),
            this.description = Object(w.y)(e, "Description", w.E);
            let t = Object(w.y)(e, "DataInstances", w.w)
              , n = Object.keys(t);
            for (let e of n)
                try {
                    this.dataInstances.set(e, D(t[e], e, n))
                } catch (t) {
                    let n = `Failed to parse data instance ${JSON.stringify(e)}: ${t.message}`;
                    console.log(n),
                    this.errors.push(n)
                }
            let i = Object(w.y)(e, "DAG", w.w)
              , r = Object(w.y)(i, "Nodes", w.w);
            for (let e of Object.keys(r))
                this.vnodes.add(e)
        }
    }
    function A(e) {
        try {
            let t = Object(w.x)(e, e=>new L(e))
              , n = new Map;
            for (let[e,i] of t) {
                n.set(e, i);
                for (let t of i.vnodes)
                    if (t !== e) {
                        let e = new L(i);
                        n.set(t, e)
                    }
            }
            for (let[e,t] of n)
                t.uuid = e;
            return n
        } catch (e) {
            throw new Error(`Failed to parse DVID repositories info: ${e.message}`)
        }
    }
    class I {
        constructor(e) {
            this.repositories = A(e)
        }
        getNode(e) {
            let t = [];
            for (let n of this.repositories.keys())
                n.startsWith(e) && t.push(n);
            if (1 !== t.length)
                throw new Error(`Node key ${JSON.stringify(e)} matches ${JSON.stringify(t)} nodes.`);
            return this.repositories.get(t[0])
        }
    }
    function P(e, t) {
        return e.memoize.getUncounted({
            type: "dvid:getServerInfo",
            baseUrl: t
        }, ()=>{
            const e = Object(S.c)(`${t}/api/repos/info`).then(e=>e.json()).then(e=>new I(e))
              , n = `repository info for DVID server ${t}`;
            return g.a.forPromise(e, {
                initialMessage: `Retrieving ${n}.`,
                delay: !0,
                errorPrefix: `Error retrieving ${n}: `
            }),
            e
        }
        )
    }
    function R(e, t, n, i) {
        return e.memoize.getUncounted({
            type: "dvid:getInstanceDetails",
            baseUrl: t,
            nodeKey: n,
            name: i.name
        }, async()=>{
            let e = Object(S.c)(`${t}/api/node/${n}/${i.name}/info`).then(e=>e.json());
            const r = `datainstance info for node ${n} and instance ${i.name} ` + `on DVID server ${t}`;
            g.a.forPromise(e, {
                initialMessage: `Retrieving ${r}.`,
                delay: !0,
                errorPrefix: `Error retrieving ${r}: `
            });
            const s = await e;
            let a = Object(w.y)(s, "Extended", w.w);
            return i.lowerVoxelBound = Object(w.y)(a, "MinPoint", e=>Object(w.e)(y.t.create(), e)),
            i.upperVoxelBoundInclusive = Object(w.y)(a, "MaxPoint", e=>Object(w.e)(y.t.create(), e)),
            i
        }
        )
    }
    class j extends m.a {
        constructor(e, t, n, i, r) {
            super(e),
            this.baseUrl = t,
            this.nodeKey = n,
            this.dataInstanceKey = i,
            this.info = r
        }
        get dataType() {
            return this.info.dataType
        }
        get volumeType() {
            return this.info.volumeType
        }
        get rank() {
            return 3
        }
        getSources(e) {
            return this.info.getSources(this.chunkManager, {
                baseUrl: this.baseUrl,
                nodeKey: this.nodeKey,
                dataInstanceKey: this.dataInstanceKey
            }, e)
        }
    }
    const N = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/]+)$/;
    function V(e) {
        let t = e.providerUrl.match(N);
        if (null === t)
            throw new Error(`Invalid DVID URL: ${JSON.stringify(e.providerUrl)}.`);
        const n = t[1]
          , i = t[2]
          , s = t[3];
        return e.chunkManager.memoize.getUncounted({
            type: "dvid:MultiscaleVolumeChunkSource",
            baseUrl: n,
            nodeKey: i,
            dataInstanceKey: s
        }, async()=>{
            let t = (await P(e.chunkManager, n)).getNode(i);
            if (void 0 === t)
                throw new Error(`Invalid node: ${JSON.stringify(i)}.`);
            const o = t.dataInstances.get(s);
            if (!(o instanceof M))
                throw new Error(`Invalid data instance ${s}.`);
            const l = await R(e.chunkManager, n, i, o)
              , c = new j(e.chunkManager,n,i,s,l)
              , u = {
                lowerBounds: new Float64Array(l.lowerVoxelBound),
                upperBounds: Float64Array.from(l.upperVoxelBoundInclusive, e=>e + 1)
            }
              , d = Object(a.z)({
                rank: 3,
                names: ["x", "y", "z"],
                units: ["m", "m", "m"],
                scales: Float64Array.from(l.voxelSize, e=>e / 1e9),
                boundingBoxes: [Object(a.B)(u)]
            })
              , h = {
                modelTransform: Object(a.A)(d),
                subsources: [{
                    id: "default",
                    subsource: {
                        volume: c
                    },
                    default: !0
                }]
            };
            if (l.meshSrc) {
                const t = y.l.create();
                for (let e = 0; e < 3; ++e)
                    t[5 * e] = 1 / l.voxelSize[e];
                h.subsources.push({
                    id: "meshes",
                    default: !0,
                    subsource: {
                        mesh: e.chunkManager.getChunkSource(T, {
                            parameters: {
                                baseUrl: n,
                                nodeKey: i,
                                dataInstanceKey: l.meshSrc
                            }
                        })
                    },
                    subsourceToModelSubspaceTransform: t
                })
            }
            return l.skeletonSrc && h.subsources.push({
                id: "skeletons",
                default: !0,
                subsource: {
                    mesh: e.chunkManager.getChunkSource(E, {
                        parameters: {
                            baseUrl: n,
                            nodeKey: i,
                            dataInstanceKey: l.skeletonSrc
                        }
                    })
                }
            }),
            h.subsources.push({
                id: "bounds",
                subsource: {
                    staticAnnotations: Object(r.n)(u)
                },
                default: !0
            }),
            h
        }
        )
    }
    function B(e, t) {
        return {
            offset: 0,
            completions: Object(b.d)(t, e.dataInstances.values(), e=>e.name, e=>`${e.base.typeName}`)
        }
    }
    function F(e, t) {
        let n = t.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
        if (null === n)
            throw new Error("Invalid DVID URL syntax.");
        if (void 0 === n[2])
            return {
                offset: 0,
                completions: Object(b.d)(t, e.repositories.values(), e=>e.uuid + "/", e=>`${e.alias}: ${e.description}`)
            };
        let i = n[1]
          , r = e.getNode(i);
        return Object(b.a)(i.length + 1, B(r, n[2]))
    }
    async function _(e) {
        let t = e.providerUrl.match(/^((?:http|https):\/\/[^\/]+)\/(.*)$/);
        if (null === t)
            throw null;
        let n = t[1]
          , i = t[2];
        const r = await P(e.chunkManager, n);
        return Object(b.a)(n.length + 1, F(r, i))
    }
    class U extends o.a {
        get description() {
            return "DVID"
        }
        get(e) {
            return V(e)
        }
        completeUrl(e) {
            return _(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(8)
      , r = n(14)
      , s = n(4)
      , a = n(33);
    class o extends class extends /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class {
    }
    {
    }
    {
    }
    o.RPC_ID = "render/TileChunkSource";
    var l = n(9)
      , c = n(28)
      , u = n(6)
      , d = n(39)
      , h = n(1)
      , p = n(20)
      , f = n(0);
    n.d(t, "computeStackHierarchy", (function() {
        return T
    }
    )),
    n.d(t, "getOwnerInfo", (function() {
        return M
    }
    )),
    n.d(t, "stackAndProjectCompleter", (function() {
        return A
    }
    )),
    n.d(t, "volumeCompleter", (function() {
        return I
    }
    )),
    n.d(t, "RenderDataSource", (function() {
        return P
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const m = new Set(["jpg", "raw16"])
      , g = Object(r.f)(c.c, o);
    class v extends g {
    }
    const b = new Set(["COMPLETE", "READ_ONLY"])
      , y = new Set(["LOADING"]);
    function S(e) {
        let t = Object(f.b)(e, f.w);
        if (t.length < 1)
            throw new Error("No stacks found for owner object.");
        let n = new Map
          , i = Object(f.y)(t[0], "stackId", x);
        for (let e of t) {
            let t = Object(f.y)(e, "stackId", w)
              , i = C(e);
            if (void 0 !== i) {
                let e = i.project
                  , r = n.get(e);
                if (void 0 === r) {
                    let t = new Map;
                    n.set(e, {
                        stacks: t
                    }),
                    r = n.get(e)
                }
                r.stacks.set(t, i)
            }
        }
        return {
            owner: i,
            projects: n
        }
    }
    function w(e) {
        return Object(f.w)(e),
        Object(f.y)(e, "stack", f.E)
    }
    function x(e) {
        return Object(f.w)(e),
        Object(f.y)(e, "owner", f.E)
    }
    function C(e) {
        Object(f.w)(e);
        let t = Object(f.y)(e, "state", f.E)
          , n = []
          , i = h.t.create()
          , r = h.t.create();
        if (b.has(t)) {
            let t = Object(f.y)(e, "stats", f.w);
            i = function(e) {
                Object(f.w)(e);
                let t = Object(f.y)(e, "stackBounds", f.w)
                  , n = h.t.create();
                return n[0] = Object(f.y)(t, "minX", f.s),
                n[1] = Object(f.y)(t, "minY", f.s),
                n[2] = Object(f.y)(t, "minZ", f.s),
                n
            }(t),
            r = function(e) {
                Object(f.w)(e);
                let t = Object(f.y)(e, "stackBounds", f.w)
                  , n = h.t.create();
                return n[0] = Object(f.y)(t, "maxX", f.s) + 1,
                n[1] = Object(f.y)(t, "maxY", f.s) + 1,
                n[2] = Object(f.y)(t, "maxZ", f.s) + 1,
                n
            }(t),
            t.hasOwnProperty("channelNames") && (n = function(e) {
                return Object(f.w)(e),
                Object(f.y)(e, "channelNames", e=>Object(f.b)(e, f.E))
            }(t))
        } else if (!y.has(t))
            return;
        return {
            lowerVoxelBound: i,
            upperVoxelBound: r,
            voxelResolution: Object(f.y)(e, "currentVersion", O),
            project: Object(f.y)(e, "stackId", k),
            channels: n
        }
    }
    function O(e) {
        Object(f.w)(e);
        let t = h.t.create();
        try {
            t[0] = Object(f.y)(e, "stackResolutionX", f.s),
            t[1] = Object(f.y)(e, "stackResolutionY", f.s),
            t[2] = Object(f.y)(e, "stackResolutionZ", f.s)
        } catch (e) {
            t[0] = 1,
            t[1] = 1,
            t[2] = 1
        }
        return t
    }
    function k(e) {
        return Object(f.w)(e),
        Object(f.y)(e, "project", f.E)
    }
    class E extends c.a {
        constructor(e, t, n, i, r, s, a) {
            super(e),
            this.baseUrl = t,
            this.ownerInfo = n,
            this.project = r,
            this.parameters = a;
            let o = n.projects.get(r);
            if (void 0 === o)
                throw new Error(`Specified project ${JSON.stringify(r)} does not exist for ` + `specified owner ${JSON.stringify(n.owner)}`);
            if (void 0 === i) {
                const e = Array.from(o.stacks.keys());
                if (1 !== e.length)
                    throw new Error(`Dataset contains multiple stacks: ${JSON.stringify(e)}`);
                i = e[0]
            }
            const l = o.stacks.get(i);
            if (void 0 === l)
                throw new Error(`Specified stack ${JSON.stringify(i)} is not one of the supported stacks: ` + JSON.stringify(Array.from(o.stacks.keys())));
            this.stack = i,
            this.stackInfo = l,
            void 0 !== s && s.length > 0 && (this.channel = s),
            this.minIntensity = Object(f.A)(a.minIntensity),
            this.maxIntensity = Object(f.A)(a.maxIntensity),
            this.maxTileSpecsToRender = Object(f.A)(a.maxTileSpecsToRender),
            this.filter = Object(f.z)(a.filter),
            this.minX = Object(f.A)(a.minX),
            this.minY = Object(f.A)(a.minY),
            this.minZ = Object(f.A)(a.minZ),
            this.maxX = Object(f.A)(a.maxX),
            this.maxY = Object(f.A)(a.maxY),
            this.maxZ = Object(f.A)(a.maxZ),
            void 0 !== this.minX && (l.lowerVoxelBound[0] = this.minX),
            void 0 !== this.minY && (l.lowerVoxelBound[1] = this.minY),
            void 0 !== this.minZ && (l.lowerVoxelBound[2] = this.minZ),
            void 0 !== this.maxX && (l.upperVoxelBound[0] = this.maxX),
            void 0 !== this.maxY && (l.upperVoxelBound[1] = this.maxY),
            void 0 !== this.maxZ && (l.upperVoxelBound[2] = this.maxZ);
            let c = Object(f.C)(a.encoding);
            if (void 0 === c)
                c = "jpg";
            else if (!m.has(c))
                throw new Error(`Invalid encoding: ${JSON.stringify(c)}.`);
            this.encoding = c,
            this.numLevels = Object(f.A)(a.numlevels),
            this.dims = h.t.create();
            let u = Object(f.A)(a.tilesize);
            void 0 === u && (u = 1024),
            this.dims[0] = u,
            this.dims[1] = u,
            this.dims[2] = 1
        }
        get dataType() {
            return "raw16" === this.parameters.encoding ? l.a.UINT16 : l.a.UINT8
        }
        get volumeType() {
            return l.b.IMAGE
        }
        get rank() {
            return 3
        }
        getSources(e) {
            const t = [];
            let n = this.numLevels;
            void 0 === n && (n = T(this.stackInfo, this.dims[0]));
            const {lowerVoxelBound: i, upperVoxelBound: r} = this.stackInfo;
            for (let e = 0; e < n; e++) {
                const n = h.l.create()
                  , s = Uint32Array.of(1, 1, 1);
                for (let t = 0; t < 2; ++t)
                    n[5 * t] = Math.pow(2, e),
                    s[t] = this.dims[t];
                const a = h.t.create()
                  , o = h.t.create()
                  , c = h.t.create()
                  , u = h.t.create();
                for (let e = 0; e < 3; e++) {
                    const t = n[5 * e]
                      , s = c[e] = i[e] / t
                      , l = u[e] = r[e] / t;
                    a[e] = Math.floor(s),
                    o[e] = Math.ceil(l)
                }
                const d = Object(l.d)({
                    rank: 3,
                    chunkDataSize: s,
                    dataType: this.dataType,
                    lowerVoxelBound: a,
                    upperVoxelBound: o
                })
                  , p = this.chunkManager.getChunkSource(v, {
                    spec: d,
                    parameters: {
                        baseUrl: this.baseUrl,
                        owner: this.ownerInfo.owner,
                        project: this.stackInfo.project,
                        stack: this.stack,
                        channel: this.channel,
                        minIntensity: this.minIntensity,
                        maxIntensity: this.maxIntensity,
                        maxTileSpecsToRender: this.maxTileSpecsToRender,
                        filter: this.filter,
                        dims: `${this.dims[0]}_${this.dims[1]}`,
                        level: e,
                        encoding: this.encoding
                    }
                });
                t.push([{
                    chunkSource: p,
                    chunkToMultiscaleTransform: n,
                    lowerClipBound: c,
                    upperClipBound: u
                }])
            }
            return Object(u.k)(t)
        }
    }
    function T(e, t) {
        let n = 0;
        for (let t = 0; t < 2; t++)
            n = n < e.upperVoxelBound[t] ? e.upperVoxelBound[t] : n;
        if (t >= n)
            return 1;
        let i = 0;
        for (; n > t; )
            n /= 2,
            i++;
        return i
    }
    function M(e, t, n) {
        return e.memoize.getUncounted({
            type: "render:getOwnerInfo",
            hostname: t,
            owner: n
        }, ()=>Object(p.c)(`${t}/render-ws/v1/owner/${n}/stacks`).then(e=>e.json()).then(S))
    }
    const D = /^([^\/?]+)(?:\/([^\/?]+))?(?:\/([^\/?]+))(?:\/([^\/?]*))?(?:\?(.*))?$/
      , L = /^((?:(?:(?:http|https):\/\/[^,\/]+)[^\/?]))\/(.*)$/;
    async function A(e, t, n) {
        const i = n.match(/^(?:([^\/]+)(?:\/([^\/]*))?(?:\/([^\/]*))?(\/.*?)?)?$/);
        if (null === i)
            throw null;
        if (void 0 === i[2])
            throw null;
        if (void 0 === i[3]) {
            let n = i[2] || "";
            const r = await M(e, t, i[1]);
            let s = Object(d.d)(n, r.projects, e=>e[0] + "/", ()=>{}
            );
            return {
                offset: i[1].length + 1,
                completions: s
            }
        }
        if (void 0 === i[4]) {
            let n = i[3] || "";
            let r = (await M(e, t, i[1])).projects.get(i[2]);
            if (void 0 === r)
                throw null;
            let s = Object(d.d)(n, r.stacks, e=>e[0] + "/", e=>e[1].project);
            return {
                offset: i[1].length + i[2].length + 2,
                completions: s
            }
        }
        let r = i[4].substr(1) || "";
        let s = (await M(e, t, i[1])).projects.get(i[2]);
        if (void 0 === s)
            throw null;
        let a = s.stacks.get(i[3]);
        if (void 0 === a)
            throw null;
        let o = a.channels;
        if (0 === o.length)
            throw null;
        let l = Object(d.d)(r, o, e=>e, ()=>{}
        );
        return {
            offset: i[1].length + i[2].length + i[3].length + 3,
            completions: l
        }
    }
    async function I(e, t) {
        let n = e.match(L);
        if (null === n)
            throw null;
        let i = n[1]
          , r = n[2];
        const s = await A(t, i, r);
        return Object(d.a)(n[1].length + 1, s)
    }
    class P extends a.a {
        get description() {
            return "Render"
        }
        get(e) {
            return function(e, t) {
                let n, r;
                {
                    let e = t.match(L);
                    if (null === e)
                        throw new Error(`Invalid render volume path: ${JSON.stringify(t)}`);
                    n = e[1],
                    r = e[2]
                }
                const a = r.match(D);
                if (null === a)
                    throw new Error(`Invalid volume path ${JSON.stringify(r)}`);
                const o = a[1]
                  , l = a[2]
                  , c = a[3]
                  , u = a[4]
                  , d = Object(f.f)(a[5] || "");
                return e.memoize.getUncounted({
                    type: "render:MultiscaleVolumeChunkSource",
                    hostname: n,
                    path: r
                }, async()=>{
                    const t = await M(e, n, o)
                      , r = new E(e,n,t,c,l,u,d)
                      , a = Object(s.z)({
                        rank: 3,
                        names: ["x", "y", "z"],
                        units: ["m", "m", "m"],
                        scales: Float64Array.from(r.stackInfo.voxelResolution, e=>e / 1e9),
                        boundingBoxes: [Object(s.B)({
                            lowerBounds: new Float64Array(r.stackInfo.lowerVoxelBound),
                            upperBounds: new Float64Array(r.stackInfo.upperVoxelBound)
                        })]
                    });
                    return {
                        modelTransform: Object(s.A)(a),
                        subsources: [{
                            id: "default",
                            default: !0,
                            subsource: {
                                volume: r
                            }
                        }, {
                            id: "bounds",
                            default: !0,
                            subsource: {
                                staticAnnotations: Object(i.n)(a.bounds)
                            }
                        }]
                    }
                }
                )
            }(e.chunkManager, e.providerUrl)
        }
        completeUrl(e) {
            return I(e.providerUrl, e.chunkManager)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i, r, s, a = n(8), o = n(54), l = n(14), c = n(4), u = n(33);
    !function(e) {
        e[e.RAW = 0] = "RAW",
        e[e.JPEG = 1] = "JPEG",
        e[e.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION"
    }(i || (i = {}));
    class d {
    }
    d.RPC_ID = "precomputed/VolumeChunkSource";
    class h {
    }
    h.RPC_ID = "precomputed/MeshSource",
    function(e) {
        e[e.RAW = 0] = "RAW",
        e[e.GZIP = 1] = "GZIP"
    }(r || (r = {})),
    function(e) {
        e[e.IDENTITY = 0] = "IDENTITY",
        e[e.MURMURHASH3_X86_128 = 1] = "MURMURHASH3_X86_128"
    }(s || (s = {}));
    class p {
    }
    p.RPC_ID = "precomputed/MultiscaleMeshSource";
    class f {
    }
    f.RPC_ID = "precomputed/SkeletonSource";
    class m {
    }
    m.RPC_ID = "precomputed/AnnotationSpatialIndexSource";
    class g {
    }
    g.RPC_ID = "precomputed/AnnotationSource";
    var v = n(63)
      , b = n(49)
      , y = n(56)
      , S = n(44)
      , w = n(9)
      , x = n(28)
      , C = n(6)
      , O = n(1)
      , k = n(83)
      , E = n(20)
      , T = n(0)
      , M = n(15);
    n.d(t, "PrecomputedAnnotationSource", (function() {
        return B
    }
    )),
    n.d(t, "PrecomputedDataSource", (function() {
        return se
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class D extends (Object(l.f)(x.c, d)) {
    }
    class L extends (Object(l.f)(b.b, h)) {
    }
    class A extends (Object(l.f)(b.d, p)) {
    }
    class I extends (Object(l.f)(y.d, f)) {
        get skeletonVertexCoordinatesInVoxels() {
            return !1
        }
        get vertexAttributes() {
            return this.parameters.metadata.vertexAttributes
        }
    }
    function P(e, t) {
        const n = e.split("/");
        for (const e of t.split("/"))
            ".." !== e || 0 === n.length ? n.push(e) : n.length = n.length - 1;
        return n.join("/")
    }
    class R {
        constructor(e, t) {
            Object(T.w)(e);
            const n = 1 === t ? 3 : 4
              , r = this.resolution = new Float64Array(n)
              , s = this.voxelOffset = new Float32Array(n)
              , a = this.size = new Float32Array(n);
            if (4 === n && (r[3] = 1,
            a[3] = t),
            Object(T.y)(e, "resolution", e=>Object(T.d)(r.subarray(0, 3), e, T.r)),
            Object(T.B)(e, "voxel_offset", e=>Object(T.d)(s.subarray(0, 3), e, T.u)),
            Object(T.y)(e, "size", e=>Object(T.d)(a.subarray(0, 3), e, T.D)),
            this.chunkSizes = Object(T.y)(e, "chunk_sizes", e=>Object(T.b)(e, e=>{
                const i = new Uint32Array(n);
                return 4 === n && (i[3] = t),
                Object(T.d)(i.subarray(0, 3), e, T.D),
                i
            }
            )),
            0 === this.chunkSizes.length)
                throw new Error("No chunk sizes specified.");
            if (this.sharding = Object(T.y)(e, "sharding", G),
            void 0 !== this.sharding && 1 !== this.chunkSizes.length)
                throw new Error("Sharding requires a single chunk size per scale");
            (this.encoding = Object(T.y)(e, "encoding", e=>Object(T.o)(e, i))) === i.COMPRESSED_SEGMENTATION && (this.compressedSegmentationBlockSize = Object(T.y)(e, "compressed_segmentation_block_size", e=>Object(T.d)(O.t.create(), e, T.D))),
            this.key = Object(T.y)(e, "key", T.E)
        }
    }
    class j extends x.a {
        constructor(e, t, n) {
            super(e),
            this.url = t,
            this.info = n
        }
        get dataType() {
            return this.info.dataType
        }
        get volumeType() {
            return this.info.volumeType
        }
        get rank() {
            return this.info.modelSpace.rank
        }
        getSources(e) {
            const t = this.info.scales[0].resolution
              , {rank: n} = this;
            return Object(C.k)(this.info.scales.map(i=>{
                const {resolution: r} = i
                  , s = n + 1
                  , a = new Float32Array(s * s);
                a[a.length - 1] = 1;
                for (let e = 0; e < 3; ++e) {
                    const o = r[e] / t[e];
                    a[s * e + e] = o,
                    a[s * n + e] = i.voxelOffset[e] * o
                }
                return 4 === n && (a[3 * s + 3] = 1),
                Object(w.c)({
                    rank: n,
                    dataType: this.dataType,
                    chunkToMultiscaleTransform: a,
                    upperVoxelBound: i.size,
                    volumeType: this.volumeType,
                    chunkDataSizes: i.chunkSizes,
                    baseVoxelOffset: i.voxelOffset,
                    compressedSegmentationBlockSize: i.compressedSegmentationBlockSize,
                    volumeSourceOptions: e
                }).map(e=>({
                    chunkSource: this.chunkManager.getChunkSource(D, {
                        spec: e,
                        parameters: {
                            url: P(this.url, i.key),
                            encoding: i.encoding,
                            sharding: i.sharding
                        }
                    }),
                    chunkToMultiscaleTransform: a
                }))
            }
            ))
        }
    }
    const N = Object(l.f)(o.b, g);
    class V extends (Object(l.f)(o.a, m)) {
    }
    class B extends N {
        constructor(e, t) {
            const {parameters: n} = t;
            super(e, {
                rank: n.rank,
                relationships: n.relationships.map(e=>e.name),
                properties: n.properties,
                parameters: n
            }),
            this.readonly = !0,
            this.metadata = t.metadata
        }
        getSources() {
            return [this.metadata.spatialIndices.map(e=>{
                const {spec: t} = e;
                return {
                    chunkSource: this.chunkManager.getChunkSource(V, {
                        parent: this,
                        spec: t,
                        parameters: e.parameters
                    }),
                    chunkToMultiscaleTransform: t.chunkToMultiscaleTransform
                }
            }
            )]
        }
    }
    function F(e, t) {
        return e.getChunkSource(L, {
            parameters: t
        })
    }
    function _(e) {
        return Object(T.y)(e, "transform", e=>{
            const t = O.l.create();
            return void 0 !== e && Object(T.d)(t.subarray(0, 12), e, T.p),
            O.l.transpose(t, t),
            t
        }
        )
    }
    async function U(e, t) {
        let n;
        try {
            n = await q(e, t)
        } catch (e) {
            if (e instanceof E.a && (404 === e.status || 403 === e.status))
                return;
            throw e
        }
        return function(e) {
            Object(T.w)(e);
            const t = Object(T.y)(e, "@type", T.E);
            if ("neuroglancer_legacy_mesh" === t)
                return;
            if ("neuroglancer_multilod_draco" !== t)
                throw new Error(`Unsupported mesh type: ${JSON.stringify(t)}`);
            const n = Object(T.y)(e, "lod_scale_multiplier", T.r)
              , i = Object(T.y)(e, "vertex_quantization_bits", T.D);
            return {
                lodScaleMultiplier: n,
                transform: _(e),
                sharding: Object(T.y)(e, "sharding", G),
                vertexQuantizationBits: i
            }
        }(n)
    }
    function z(e) {
        return void 0 === e ? r.RAW : Object(T.o)(e, r)
    }
    function G(e) {
        if (void 0 === e)
            return;
        Object(T.w)(e);
        const t = Object(T.y)(e, "@type", T.E);
        if ("neuroglancer_uint64_sharded_v1" !== t)
            throw new Error(`Unsupported sharding format: ${JSON.stringify(t)}`);
        return {
            hash: Object(T.y)(e, "hash", e=>Object(T.o)(e, s)),
            preshiftBits: Object(T.y)(e, "preshift_bits", T.u),
            shardBits: Object(T.y)(e, "shard_bits", T.u),
            minishardBits: Object(T.y)(e, "minishard_bits", T.u),
            minishardIndexEncoding: Object(T.y)(e, "minishard_index_encoding", z),
            dataEncoding: Object(T.y)(e, "data_encoding", z)
        }
    }
    async function $(e, t) {
        return function(e) {
            Object(T.w)(e);
            const t = Object(T.y)(e, "@type", T.E);
            if ("neuroglancer_skeletons" !== t)
                throw new Error(`Unsupported skeleton type: ${JSON.stringify(t)}`);
            const n = _(e)
              , i = new Map;
            Object(T.y)(e, "vertex_attributes", e=>{
                void 0 !== e && Object(T.b)(e, e=>{
                    Object(T.w)(e);
                    const t = Object(T.y)(e, "id", T.E);
                    if ("" === t)
                        throw new Error("vertex attribute id must not be empty");
                    if (i.has(t))
                        throw new Error(`duplicate vertex attribute id ${JSON.stringify(t)}`);
                    const n = Object(T.y)(e, "data_type", e=>Object(T.o)(e, w.a))
                      , r = Object(T.y)(e, "num_components", T.D);
                    i.set(t, {
                        dataType: n,
                        numComponents: r
                    })
                }
                )
            }
            );
            const r = Object(T.y)(e, "sharding", G);
            return {
                transform: n,
                vertexAttributes: i,
                sharding: r
            }
        }(await q(e, t))
    }
    function W() {
        return Object(c.z)({
            names: ["x", "y", "z"],
            units: ["m", "m", "m"],
            scales: Float64Array.of(1e-9, 1e-9, 1e-9)
        })
    }
    async function H(e, t) {
        const n = await U(e, t);
        if (void 0 === n)
            return {
                source: F(e, {
                    url: t,
                    lod: 0
                }),
                transform: O.l.create()
            };
        let i;
        const {vertexQuantizationBits: r} = n;
        if (10 === r)
            i = v.e.uint10;
        else {
            if (16 !== r)
                throw new Error(`Invalid vertex quantization bits: ${r}`);
            i = v.e.uint16
        }
        return {
            source: e.getChunkSource(A, {
                parameters: {
                    url: t,
                    metadata: n
                },
                format: {
                    fragmentRelativeVertices: !0,
                    vertexPositionFormat: i
                }
            }),
            transform: n.transform
        }
    }
    async function J(e, t) {
        const n = await $(e, t);
        return {
            source: e.getChunkSource(I, {
                parameters: {
                    url: t,
                    metadata: n
                }
            }),
            transform: n.transform
        }
    }
    function q(e, t) {
        return t = Object(E.d)(t),
        e.memoize.getUncounted({
            type: "precomputed:metadata",
            url: t
        }, async()=>(await Object(E.c)(`${t}/info`)).json())
    }
    function Y(e) {
        const t = O.l.create()
          , n = e.scales[0].resolution;
        for (let e = 0; e < 3; ++e)
            t[5 * e] = 1 / n[e];
        return t
    }
    async function X(e, t, n, i) {
        const r = function(e) {
            Object(T.w)(e);
            const t = Object(T.y)(e, "data_type", e=>Object(T.o)(e, w.a))
              , n = Object(T.y)(e, "num_channels", T.D)
              , i = Object(T.y)(e, "type", e=>Object(T.o)(e, w.b))
              , r = Object(T.y)(e, "mesh", T.C)
              , s = Object(T.y)(e, "skeletons", T.C)
              , a = Object(T.y)(e, "scales", e=>Object(T.b)(e, e=>new R(e,n)));
            if (0 === a.length)
                throw new Error("Expected at least one scale");
            const o = a[0]
              , l = 1 === n ? 3 : 4
              , u = new Float64Array(l)
              , d = new Float64Array(l)
              , h = new Float64Array(l)
              , p = ["x", "y", "z"]
              , f = ["m", "m", "m"];
            for (let e = 0; e < 3; ++e)
                u[e] = o.resolution[e] / 1e9,
                d[e] = o.voxelOffset[e],
                h[e] = d[e] + o.size[e];
            4 === l && (u[3] = 1,
            h[3] = n,
            p[3] = "c^",
            f[3] = "");
            const m = {
                lowerBounds: d,
                upperBounds: h
            };
            return {
                dataType: t,
                volumeType: i,
                mesh: r,
                skeletons: s,
                scales: a,
                modelSpace: Object(c.z)({
                    rank: l,
                    names: p,
                    units: f,
                    scales: u,
                    boundingBoxes: [Object(c.B)(m)]
                })
            }
        }(i)
          , s = new j(e.chunkManager,n,r)
          , {modelSpace: o} = r
          , l = [{
            id: "default",
            default: !0,
            subsource: {
                volume: s
            }
        }, {
            id: "bounds",
            default: !0,
            subsource: {
                staticAnnotations: Object(a.n)(o.bounds)
            }
        }];
        if (void 0 !== r.mesh) {
            const n = P(t, r.mesh)
              , {source: i, transform: s} = await H(e.chunkManager, Object(E.d)(n))
              , a = Y(r);
            O.l.multiply(a, a, s),
            l.push({
                id: "mesh",
                default: !0,
                subsource: {
                    mesh: i
                },
                subsourceToModelSubspaceTransform: a
            })
        }
        if (void 0 !== r.skeletons) {
            const n = P(t, r.skeletons)
              , {source: i, transform: s} = await J(e.chunkManager, Object(E.d)(n))
              , a = Y(r);
            O.l.multiply(a, a, s),
            l.push({
                id: "skeletons",
                default: !0,
                subsource: {
                    mesh: i
                },
                subsourceToModelSubspaceTransform: a
            })
        }
        return {
            modelTransform: Object(c.A)(o),
            subsources: l
        }
    }
    function K(e, t) {
        return Object(T.w)(t),
        {
            url: P(e, Object(T.y)(t, "key", T.E)),
            sharding: Object(T.y)(t, "sharding", G)
        }
    }
    function Z(e) {
        Object(T.w)(e);
        const t = Object(T.y)(e, "id", e=>{
            const t = Object(T.E)(e);
            if (null === t.match(/^[a-z][a-zA-Z0-9_]*$/))
                throw new Error(`Invalid property identifier: ${JSON.stringify(e)}`);
            return t
        }
        );
        return {
            type: Object(T.y)(e, "type", e=>{
                if (Object(T.E)(e),
                !Object.prototype.hasOwnProperty.call(a.g, e))
                    throw new Error("Unsupported property type: $JSON.stringify(tJson)}");
                return e
            }
            ),
            identifier: t,
            description: Object(T.B)(e, "description", T.E),
            default: 0
        }
    }
    function Q(e) {
        const t = Object(T.b)(e, Z)
          , n = new Set;
        for (const e of t) {
            if (n.has(e.identifier))
                throw new Error(`Duplicate property identifier: ${e.identifier}`);
            n.add(e.identifier)
        }
        return t
    }
    class ee {
        constructor(e, t) {
            this.url = e,
            Object(T.w)(t);
            const n = Object(T.y)(t, "dimensions", c.f)
              , {rank: i} = n
              , r = Object(T.y)(t, "lower_bound", e=>Object(T.d)(new Float64Array(i), e, T.p))
              , s = Object(T.y)(t, "upper_bound", e=>Object(T.d)(new Float64Array(i), e, T.p));
            this.coordinateSpace = Object(c.z)({
                rank: i,
                names: n.names,
                units: n.units,
                scales: n.scales,
                boundingBoxes: [Object(c.B)({
                    lowerBounds: r,
                    upperBounds: s
                })]
            }),
            this.parameters = {
                type: Object(T.y)(t, "annotation_type", e=>Object(T.o)(e, a.e)),
                rank: i,
                relationships: Object(T.y)(t, "relationships", t=>Object(T.b)(t, t=>{
                    const n = K(e, t)
                      , i = Object(T.y)(t, "id", T.E);
                    return Object.assign(Object.assign({}, n), {
                        name: i
                    })
                }
                )),
                properties: Object(T.y)(t, "properties", Q),
                byId: Object(T.y)(t, "by_id", t=>K(e, t))
            },
            this.spatialIndices = Object(T.y)(t, "spatial", t=>Object(T.b)(t, t=>{
                const n = K(e, t)
                  , s = Object(T.y)(t, "grid_shape", e=>Object(T.d)(new Float32Array(i), e, T.D))
                  , a = Object(T.y)(t, "chunk_size", e=>Object(T.d)(new Float32Array(i), e, T.r))
                  , o = Object(T.y)(t, "limit", T.D)
                  , l = new Float32Array(i);
                for (let e = 0; e < i; ++e)
                    l[e] = s[e] * a[e];
                const c = M.c(Float32Array, i + 1);
                for (let e = 0; e < i; ++e)
                    c[(i + 1) * i + e] = r[e];
                const u = Object.assign({
                    limit: o,
                    chunkToMultiscaleTransform: c
                }, Object(S.m)({
                    rank: i,
                    chunkDataSize: a,
                    upperVoxelBound: l
                }));
                return u.upperChunkBound = s,
                {
                    parameters: n,
                    spec: u,
                    limit: o
                }
            }
            )),
            this.spatialIndices.reverse()
        }
    }
    async function te(e, t) {
        const {source: n, transform: i} = await H(e.chunkManager, t);
        return {
            modelTransform: Object(c.A)(W()),
            subsources: [{
                id: "default",
                default: !0,
                subsource: {
                    mesh: n
                },
                subsourceToModelSubspaceTransform: i
            }]
        }
    }
    const ne = /^([^#]*)(?:#(.*))?$/;
    function ie(e) {
        let[,t,n] = e.match(ne);
        return t.endsWith("/") && (t = t.substring(0, t.length - 1)),
        {
            url: t,
            parameters: Object(T.f)(n || "")
        }
    }
    function re(e, t) {
        const n = Object(T.i)(t);
        return n && (e += `#${n}`),
        e
    }
    class se extends u.a {
        get description() {
            return "Precomputed file-backed data source"
        }
        normalizeUrl(e) {
            const {url: t, parameters: n} = ie(e.providerUrl);
            return e.providerProtocol + "://" + re(t, n)
        }
        convertLegacyUrl(e) {
            const {url: t, parameters: n} = ie(e.providerUrl);
            return "mesh" === e.type && (n.type = "mesh"),
            e.providerProtocol + "://" + re(t, n)
        }
        get(e) {
            const {url: t, parameters: n} = ie(e.providerUrl);
            return e.chunkManager.memoize.getUncounted({
                type: "precomputed:get",
                url: t
            }, async()=>{
                const i = Object(E.d)(t);
                let r;
                try {
                    r = await q(e.chunkManager, i)
                } catch (t) {
                    if (t instanceof E.a && 404 === t.status && "mesh" === n.type)
                        return await te(e, i);
                    throw t
                }
                Object(T.w)(r);
                const s = Object(T.B)(r, "redirect", T.E);
                if (void 0 !== s)
                    throw new u.d(s);
                const a = Object(T.B)(r, "@type", T.E);
                switch (a) {
                case "neuroglancer_skeletons":
                    return await async function(e, t) {
                        const {source: n, transform: i} = await J(e.chunkManager, t);
                        return {
                            modelTransform: Object(c.A)(W()),
                            subsources: [{
                                id: "default",
                                default: !0,
                                subsource: {
                                    mesh: n
                                },
                                subsourceToModelSubspaceTransform: i
                            }]
                        }
                    }(e, i);
                case "neuroglancer_multilod_draco":
                    return await te(e, i);
                case "neuroglancer_annotations_v1":
                    return await async function(e, t, n) {
                        const i = new ee(t,n);
                        return {
                            modelTransform: Object(c.A)(i.coordinateSpace),
                            subsources: [{
                                id: "default",
                                default: !0,
                                subsource: {
                                    annotation: e.chunkManager.getChunkSource(B, {
                                        metadata: i,
                                        parameters: i.parameters
                                    })
                                }
                            }]
                        }
                    }(e, i, r);
                case "neuroglancer_multiscale_volume":
                case void 0:
                    return await X(e, t, i, r);
                default:
                    throw new Error(`Invalid type: ${JSON.stringify(a)}`)
                }
            }
            )
        }
        completeUrl(e) {
            return Object(k.a)(e.providerUrl, e.cancellationToken)
        }
    }
}
, function(e, t, n) {
    var i = n(143)
      , r = "object" == typeof self && self && self.Object === Object && self
      , s = i || r || Function("return this")();
    e.exports = s
}
, function(e, t) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (n = window)
    }
    e.exports = n
}
, function(e, t, n) {
    var i = n(127).Symbol;
    e.exports = i
}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {
    !function(e) {
        "use strict";
        function t(t, n, r, s) {
            if (r && r.call) {
                var a = r;
                r = null
            } else
                a = i(t, r, "rangeFinder");
            "number" == typeof n && (n = e.Pos(n, 0));
            var o = i(t, r, "minFoldSize");
            function l(e) {
                var i = a(t, n);
                if (!i || i.to.line - i.from.line < o)
                    return null;
                for (var r = t.findMarksAt(i.from), l = 0; l < r.length; ++l)
                    if (r[l].__isFold && "fold" !== s) {
                        if (!e)
                            return null;
                        i.cleared = !0,
                        r[l].clear()
                    }
                return i
            }
            var c = l(!0);
            if (i(t, r, "scanUp"))
                for (; !c && n.line > t.firstLine(); )
                    n = e.Pos(n.line - 1, 0),
                    c = l(!1);
            if (c && !c.cleared && "unfold" !== s) {
                var u = function(e, t, n) {
                    var r = i(e, t, "widget");
                    if ("function" == typeof r && (r = r(n.from, n.to)),
                    "string" == typeof r) {
                        var s = document.createTextNode(r);
                        (r = document.createElement("span")).appendChild(s),
                        r.className = "CodeMirror-foldmarker"
                    } else
                        r && (r = r.cloneNode(!0));
                    return r
                }(t, r, c);
                e.on(u, "mousedown", (function(t) {
                    d.clear(),
                    e.e_preventDefault(t)
                }
                ));
                var d = t.markText(c.from, c.to, {
                    replacedWith: u,
                    clearOnEnter: i(t, r, "clearOnEnter"),
                    __isFold: !0
                });
                d.on("clear", (function(n, i) {
                    e.signal(t, "unfold", t, n, i)
                }
                )),
                e.signal(t, "fold", t, c.from, c.to)
            }
        }
        e.newFoldFunction = function(e, n) {
            return function(i, r) {
                t(i, r, {
                    rangeFinder: e,
                    widget: n
                })
            }
        }
        ,
        e.defineExtension("foldCode", (function(e, n, i) {
            t(this, e, n, i)
        }
        )),
        e.defineExtension("isFolded", (function(e) {
            for (var t = this.findMarksAt(e), n = 0; n < t.length; ++n)
                if (t[n].__isFold)
                    return !0
        }
        )),
        e.commands.toggleFold = function(e) {
            e.foldCode(e.getCursor())
        }
        ,
        e.commands.fold = function(e) {
            e.foldCode(e.getCursor(), null, "fold")
        }
        ,
        e.commands.unfold = function(e) {
            e.foldCode(e.getCursor(), null, "unfold")
        }
        ,
        e.commands.foldAll = function(t) {
            t.operation((function() {
                for (var n = t.firstLine(), i = t.lastLine(); n <= i; n++)
                    t.foldCode(e.Pos(n, 0), null, "fold")
            }
            ))
        }
        ,
        e.commands.unfoldAll = function(t) {
            t.operation((function() {
                for (var n = t.firstLine(), i = t.lastLine(); n <= i; n++)
                    t.foldCode(e.Pos(n, 0), null, "unfold")
            }
            ))
        }
        ,
        e.registerHelper("fold", "combine", (function() {
            var e = Array.prototype.slice.call(arguments, 0);
            return function(t, n) {
                for (var i = 0; i < e.length; ++i) {
                    var r = e[i](t, n);
                    if (r)
                        return r
                }
            }
        }
        )),
        e.registerHelper("fold", "auto", (function(e, t) {
            for (var n = e.getHelpers(t, "fold"), i = 0; i < n.length; i++) {
                var r = n[i](e, t);
                if (r)
                    return r
            }
        }
        ));
        var n = {
            rangeFinder: e.fold.auto,
            widget: "",
            minFoldSize: 0,
            scanUp: !1,
            clearOnEnter: !0
        };
        function i(e, t, i) {
            if (t && void 0 !== t[i])
                return t[i];
            var r = e.options.foldOptions;
            return r && void 0 !== r[i] ? r[i] : n[i]
        }
        e.defineOption("foldOptions", null),
        e.defineExtension("foldOption", (function(e, t) {
            return i(this, e, t)
        }
        ))
    }(n(57))
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="arrowUpIconTitle"><path d="M18 9l-6-6-6 6"></path><path d="M12 21V4"></path><path stroke-linecap="round" d="M12 3v1"></path></svg>'
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="closeIconTitle"><path d="M6.34314575 6.34314575L17.6568542 17.6568542M6.34314575 17.6568542L17.6568542 6.34314575"></path></svg>'
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="binIconTitle"><path d="M19 6L5 6M14 5L10 5M6 10L6 20C6 20.6666667 6.33333333 21 7 21 7.66666667 21 11 21 17 21 17.6666667 21 18 20.6666667 18 20 18 19.3333333 18 16 18 10"></path></svg>'
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="maximiseIconTitle"><polyline points="21 16 21 21 16 21"></polyline><polyline points="8 21 3 21 3 16"></polyline><polyline points="16 3 21 3 21 8"></polyline><polyline points="3 8 3 3 8 3"></polyline></svg>'
}
, function(e, t) {
    e.exports = '<svg role="img" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-labelledby="copyIconTitle"><rect width="12" height="14" x="8" y="7"></rect><polyline points="16 3 4 3 4 17"></polyline></svg>'
}
, , , , function(e, t, n) {
    n(118),
    n(204),
    n(151),
    n(123),
    n(206),
    n(152),
    n(124),
    n(153),
    n(125),
    n(154),
    n(126),
    n(155),
    n(121),
    n(156),
    n(122),
    n(157),
    n(120),
    n(158),
    n(203),
    n(117),
    n(176),
    n(205),
    e.exports = n(202)
}
, function(e, t, n) {
    var i = n(127);
    e.exports = function() {
        return i.Date.now()
    }
}
, function(e, t, n) {
    (function(t) {
        var n = "object" == typeof t && t && t.Object === Object && t;
        e.exports = n
    }
    ).call(this, n(128))
}
, function(e, t, n) {
    var i = n(119)
      , r = n(145)
      , s = /^\s+|\s+$/g
      , a = /^[-+]0x[0-9a-f]+$/i
      , o = /^0b[01]+$/i
      , l = /^0o[0-7]+$/i
      , c = parseInt;
    e.exports = function(e) {
        if ("number" == typeof e)
            return e;
        if (r(e))
            return NaN;
        if (i(e)) {
            var t = "function" == typeof e.valueOf ? e.valueOf() : e;
            e = i(t) ? t + "" : t
        }
        if ("string" != typeof e)
            return 0 === e ? e : +e;
        e = e.replace(s, "");
        var n = o.test(e);
        return n || l.test(e) ? c(e.slice(2), n ? 2 : 8) : a.test(e) ? NaN : +e
    }
}
, function(e, t, n) {
    var i = n(146)
      , r = n(149);
    e.exports = function(e) {
        return "symbol" == typeof e || r(e) && "[object Symbol]" == i(e)
    }
}
, function(e, t, n) {
    var i = n(129)
      , r = n(147)
      , s = n(148)
      , a = i ? i.toStringTag : void 0;
    e.exports = function(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : a && a in Object(e) ? r(e) : s(e)
    }
}
, function(e, t, n) {
    var i = n(129)
      , r = Object.prototype
      , s = r.hasOwnProperty
      , a = r.toString
      , o = i ? i.toStringTag : void 0;
    e.exports = function(e) {
        var t = s.call(e, o)
          , n = e[o];
        try {
            e[o] = void 0;
            var i = !0
        } catch (e) {}
        var r = a.call(e);
        return i && (t ? e[o] = n : delete e[o]),
        r
    }
}
, function(e, t) {
    var n = Object.prototype.toString;
    e.exports = function(e) {
        return n.call(e)
    }
}
, function(e, t) {
    e.exports = function(e) {
        return null != e && "object" == typeof e
    }
}
, function(e, t, n) {}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(118)
      , r = n(68)
      , s = n(50);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(s.b)("brainmaps", e=>new i.BrainmapsDataSource(i.productionInstance,e.credentialsManager.getCredentialsProvider(r.a)))
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(123)
      , r = n(50);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(r.b)("boss", e=>new i.BossDataSource(e.credentialsManager))
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(124)
      , r = n(50);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(r.b)("dvid", ()=>new i.DVIDDataSource)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(50)
      , r = n(125);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(i.b)("render", ()=>new r.RenderDataSource)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(126)
      , r = n(50);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(r.b)("precomputed", ()=>new i.PrecomputedDataSource)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(121)
      , r = n(50);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(r.b)("nifti", ()=>new i.NiftiDataSource)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(50)
      , r = n(122);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(i.b)("n5", ()=>new r.N5DataSource)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(50)
      , r = n(120);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    Object(i.b)("vtk", ()=>new r.VtkDataSource)
}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {
    !function(e) {
        "use strict";
        var t = "CodeMirror-lint-markers";
        function n(e) {
            e.parentNode && e.parentNode.removeChild(e)
        }
        function i(t, i, r) {
            var s = function(t, n) {
                var i = document.createElement("div");
                function r(t) {
                    if (!i.parentNode)
                        return e.off(document, "mousemove", r);
                    i.style.top = Math.max(0, t.clientY - i.offsetHeight - 5) + "px",
                    i.style.left = t.clientX + 5 + "px"
                }
                return i.className = "CodeMirror-lint-tooltip",
                i.appendChild(n.cloneNode(!0)),
                document.body.appendChild(i),
                e.on(document, "mousemove", r),
                r(t),
                null != i.style.opacity && (i.style.opacity = 1),
                i
            }(t, i);
            function a() {
                var t;
                e.off(r, "mouseout", a),
                s && ((t = s).parentNode && (null == t.style.opacity && n(t),
                t.style.opacity = 0,
                setTimeout((function() {
                    n(t)
                }
                ), 600)),
                s = null)
            }
            var o = setInterval((function() {
                if (s)
                    for (var e = r; ; e = e.parentNode) {
                        if (e && 11 == e.nodeType && (e = e.host),
                        e == document.body)
                            return;
                        if (!e) {
                            a();
                            break
                        }
                    }
                if (!s)
                    return clearInterval(o)
            }
            ), 400);
            e.on(r, "mouseout", a)
        }
        function r(e, t, n) {
            this.marked = [],
            this.options = t,
            this.timeout = null,
            this.hasGutter = n,
            this.onMouseOver = function(t) {
                !function(e, t) {
                    var n = t.target || t.srcElement;
                    if (/\bCodeMirror-lint-mark-/.test(n.className)) {
                        for (var r = n.getBoundingClientRect(), s = (r.left + r.right) / 2, a = (r.top + r.bottom) / 2, l = e.findMarksAt(e.coordsChar({
                            left: s,
                            top: a
                        }, "client")), c = [], u = 0; u < l.length; ++u) {
                            var d = l[u].__annotation;
                            d && c.push(d)
                        }
                        c.length && function(e, t) {
                            for (var n = t.target || t.srcElement, r = document.createDocumentFragment(), s = 0; s < e.length; s++) {
                                var a = e[s];
                                r.appendChild(o(a))
                            }
                            i(t, r, n)
                        }(c, t)
                    }
                }(e, t)
            }
            ,
            this.waitingFor = 0
        }
        function s(e) {
            var n = e.state.lint;
            n.hasGutter && e.clearGutter(t);
            for (var i = 0; i < n.marked.length; ++i)
                n.marked[i].clear();
            n.marked.length = 0
        }
        function a(t, n, r, s) {
            var a = document.createElement("div")
              , o = a;
            return a.className = "CodeMirror-lint-marker-" + n,
            r && ((o = a.appendChild(document.createElement("div"))).className = "CodeMirror-lint-marker-multiple"),
            0 != s && e.on(o, "mouseover", (function(e) {
                i(e, t, o)
            }
            )),
            a
        }
        function o(e) {
            var t = e.severity;
            t || (t = "error");
            var n = document.createElement("div");
            return n.className = "CodeMirror-lint-message-" + t,
            void 0 !== e.messageHTML ? n.innerHTML = e.messageHTML : n.appendChild(document.createTextNode(e.message)),
            n
        }
        function l(t) {
            var n = t.state.lint.options
              , i = n.options || n
              , r = n.getAnnotations || t.getHelper(e.Pos(0, 0), "lint");
            if (r)
                if (n.async || r.async)
                    !function(t, n, i) {
                        var r = t.state.lint
                          , s = ++r.waitingFor;
                        function a() {
                            s = -1,
                            t.off("change", a)
                        }
                        t.on("change", a),
                        n(t.getValue(), (function(n, i) {
                            t.off("change", a),
                            r.waitingFor == s && (i && n instanceof e && (n = i),
                            t.operation((function() {
                                c(t, n)
                            }
                            )))
                        }
                        ), i, t)
                    }(t, r, i);
                else {
                    var s = r(t.getValue(), i, t);
                    if (!s)
                        return;
                    s.then ? s.then((function(e) {
                        t.operation((function() {
                            c(t, e)
                        }
                        ))
                    }
                    )) : t.operation((function() {
                        c(t, s)
                    }
                    ))
                }
        }
        function c(e, n) {
            s(e);
            for (var i, r, l = e.state.lint, c = l.options, u = function(e) {
                for (var t = [], n = 0; n < e.length; ++n) {
                    var i = e[n]
                      , r = i.from.line;
                    (t[r] || (t[r] = [])).push(i)
                }
                return t
            }(n), d = 0; d < u.length; ++d) {
                var h = u[d];
                if (h) {
                    for (var p = null, f = l.hasGutter && document.createDocumentFragment(), m = 0; m < h.length; ++m) {
                        var g = h[m]
                          , v = g.severity;
                        v || (v = "error"),
                        r = v,
                        p = "error" == (i = p) ? i : r,
                        c.formatAnnotation && (g = c.formatAnnotation(g)),
                        l.hasGutter && f.appendChild(o(g)),
                        g.to && l.marked.push(e.markText(g.from, g.to, {
                            className: "CodeMirror-lint-mark-" + v,
                            __annotation: g
                        }))
                    }
                    l.hasGutter && e.setGutterMarker(d, t, a(f, p, h.length > 1, l.options.tooltips))
                }
            }
            c.onUpdateLinting && c.onUpdateLinting(n, u, e)
        }
        function u(e) {
            var t = e.state.lint;
            t && (clearTimeout(t.timeout),
            t.timeout = setTimeout((function() {
                l(e)
            }
            ), t.options.delay || 500))
        }
        e.defineOption("lint", !1, (function(n, i, a) {
            if (a && a != e.Init && (s(n),
            !1 !== n.state.lint.options.lintOnChange && n.off("change", u),
            e.off(n.getWrapperElement(), "mouseover", n.state.lint.onMouseOver),
            clearTimeout(n.state.lint.timeout),
            delete n.state.lint),
            i) {
                for (var o = n.getOption("gutters"), c = !1, d = 0; d < o.length; ++d)
                    o[d] == t && (c = !0);
                var h = n.state.lint = new r(n,(p = i)instanceof Function ? {
                    getAnnotations: p
                } : (p && !0 !== p || (p = {}),
                p),c);
                !1 !== h.options.lintOnChange && n.on("change", u),
                0 != h.options.tooltips && "gutter" != h.options.tooltips && e.on(n.getWrapperElement(), "mouseover", h.onMouseOver),
                l(n)
            }
            var p
        }
        )),
        e.defineExtension("performLint", (function() {
            this.state.lint && l(this)
        }
        ))
    }(n(57))
}
, function(e, t, n) {}
, function(e, t) {
    e.exports = function(e) {
        function t(e) {
            for (var t = {}, n = e.split(" "), i = 0; i < n.length; ++i)
                t[n[i]] = !0;
            return t
        }
        e.defineMode("glsl", (function(e, r) {
            var s, a = e.indentUnit, o = r.keywords || t(n), l = r.builtins || t(i), c = r.blockKeywords || t("case do else for if switch while struct"), u = r.atoms || t("null"), d = r.hooks || {}, h = r.multiLineStrings, p = /[+\-*&%=<>!?|\/]/;
            function f(e, t) {
                var n, i = e.next();
                if (d[i]) {
                    var r = d[i](e, t);
                    if (!1 !== r)
                        return r
                }
                if ('"' == i || "'" == i)
                    return t.tokenize = (n = i,
                    function(e, t) {
                        for (var i, r = !1, s = !1; null != (i = e.next()); ) {
                            if (i == n && !r) {
                                s = !0;
                                break
                            }
                            r = !r && "\\" == i
                        }
                        return (s || !r && !h) && (t.tokenize = f),
                        "string"
                    }
                    ),
                    t.tokenize(e, t);
                if (/[\[\]{}\(\),;\:\.]/.test(i))
                    return s = i,
                    "bracket";
                if (/\d/.test(i))
                    return e.eatWhile(/[\w\.]/),
                    "number";
                if ("/" == i) {
                    if (e.eat("*"))
                        return t.tokenize = m,
                        m(e, t);
                    if (e.eat("/"))
                        return e.skipToEnd(),
                        "comment"
                }
                if ("#" == i)
                    return e.eatWhile(/[\S]+/),
                    e.eatWhile(/[\s]+/),
                    e.eatWhile(/[\S]+/),
                    e.eatWhile(/[\s]+/),
                    "comment";
                if (p.test(i))
                    return e.eatWhile(p),
                    "operator";
                e.eatWhile(/[\w\$_]/);
                var a = e.current();
                return o.propertyIsEnumerable(a) ? (c.propertyIsEnumerable(a) && (s = "newstatement"),
                "keyword") : l.propertyIsEnumerable(a) ? "builtin" : u.propertyIsEnumerable(a) ? "atom" : "word"
            }
            function m(e, t) {
                for (var n, i = !1; n = e.next(); ) {
                    if ("/" == n && i) {
                        t.tokenize = f;
                        break
                    }
                    i = "*" == n
                }
                return "comment"
            }
            function g(e, t, n, i, r) {
                this.indented = e,
                this.column = t,
                this.type = n,
                this.align = i,
                this.prev = r
            }
            function v(e, t, n) {
                return e.context = new g(e.indented,t,n,null,e.context)
            }
            function b(e) {
                var t = e.context.type;
                return ")" != t && "]" != t && "}" != t || (e.indented = e.context.indented),
                e.context = e.context.prev
            }
            return {
                startState: function(e) {
                    return {
                        tokenize: null,
                        context: new g((e || 0) - a,0,"top",!1),
                        indented: 0,
                        startOfLine: !0
                    }
                },
                token: function(e, t) {
                    var n = t.context;
                    if (e.sol() && (null == n.align && (n.align = !1),
                    t.indented = e.indentation(),
                    t.startOfLine = !0),
                    e.eatSpace())
                        return null;
                    s = null;
                    var i = (t.tokenize || f)(e, t);
                    if ("comment" == i || "meta" == i)
                        return i;
                    if (null == n.align && (n.align = !0),
                    ";" != s && ":" != s || "statement" != n.type)
                        if ("{" == s)
                            v(t, e.column(), "}");
                        else if ("[" == s)
                            v(t, e.column(), "]");
                        else if ("(" == s)
                            v(t, e.column(), ")");
                        else if ("}" == s) {
                            for (; "statement" == n.type; )
                                n = b(t);
                            for ("}" == n.type && (n = b(t)); "statement" == n.type; )
                                n = b(t)
                        } else
                            s == n.type ? b(t) : ("}" == n.type || "top" == n.type || "statement" == n.type && "newstatement" == s) && v(t, e.column(), "statement");
                    else
                        b(t);
                    return t.startOfLine = !1,
                    i
                },
                indent: function(e, t) {
                    if (e.tokenize != f && null != e.tokenize)
                        return 0;
                    var n = t && t.charAt(0)
                      , i = e.context
                      , r = n == i.type;
                    return "statement" == i.type ? i.indented + ("{" == n ? 0 : a) : i.align ? i.column + (r ? 0 : 1) : i.indented + (r ? 0 : a)
                },
                electricChars: "{}"
            }
        }
        ));
        var n = "attribute const uniform varying break continue do for while if else in out inout float int void bool true false lowp mediump highp precision invariant discard return mat2 mat3 mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D samplerCube struct gl_FragCoord gl_FragColor"
          , i = "radians degrees sin cos tan asin acos atan pow exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not dFdx dFdy fwidth texture2D texture2DProj texture2DLod texture2DProjLod textureCube textureCubeLod require export";
        function r(e, t) {
            return !!t.startOfLine && (e.skipToEnd(),
            "meta")
        }
        e.defineMIME("text/x-glsl", {
            name: "glsl",
            keywords: t(n),
            builtins: t(i),
            blockKeywords: t("case do else for if switch while struct"),
            atoms: t("null"),
            hooks: {
                "#": r
            }
        })
    }
}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {
    "use strict";
    n.r(t),
    n.d(t, "SingleMeshUserLayer", (function() {
        return f
    }
    ));
    n(177);
    var i = n(22)
      , r = n(58)
      , s = n(97)
      , a = n(7)
      , o = n(2)
      , l = n(5)
      , c = n(78)
      , u = n(79)
      , d = n(80)
      , h = n(41)
      , p = n(81);
    class f extends i.j {
        constructor(e, t) {
            super(e, t),
            this.managedLayer = e,
            this.displayState = new s.a,
            this.vertexAttributes = new a.e(void 0),
            this.registerDisposer(this.displayState.shaderControlState.changed.add(this.specificationChanged.dispatch)),
            this.registerDisposer(this.displayState.fragmentMain.changed.add(this.specificationChanged.dispatch)),
            this.tabs.add("rendering", {
                label: "Rendering",
                order: -100,
                getter: ()=>new b(this)
            }),
            this.tabs.default = "rendering"
        }
        restoreState(e) {
            super.restoreState(e),
            this.displayState.fragmentMain.restoreState(e.shader),
            this.displayState.shaderControlState.restoreState(e.shaderControls)
        }
        activateDataSubsources(e) {
            let t = !1;
            for (const n of e) {
                const {subsourceEntry: e} = n
                  , {subsource: i} = e
                  , {singleMesh: r} = i;
                if (void 0 === r)
                    n.deactivate("Not compatible with image layer");
                else {
                    if (t) {
                        n.deactivate("Only one single-mesh source supported");
                        continue
                    }
                    t = !0,
                    n.activate(e=>{
                        n.addRenderLayer(new s.b(r,this.displayState,n.getRenderLayerTransform())),
                        this.vertexAttributes.value = r.info.vertexAttributes,
                        e.registerDisposer(()=>{
                            this.vertexAttributes.value = void 0
                        }
                        )
                    }
                    )
                }
            }
        }
        toJSON() {
            let e = super.toJSON();
            return e.shader = this.displayState.fragmentMain.toJSON(),
            e.shaderControls = this.displayState.shaderControlState.toJSON(),
            e
        }
    }
    function m(e) {
        return new d.a({
            fragmentMain: e.displayState.fragmentMain,
            shaderError: e.displayState.shaderError,
            shaderControlState: e.displayState.shaderControlState
        })
    }
    f.type = "mesh";
    class g extends o.a {
        constructor(e) {
            super(),
            this.attributes = e,
            this.element = document.createElement("div"),
            this.element.className = "neuroglancer-single-mesh-attribute-widget",
            this.updateView(),
            this.registerDisposer(e.changed.add(()=>{
                this.updateView()
            }
            ))
        }
        updateView() {
            const {element: e} = this
              , t = this.attributes.value;
            if (void 0 === t)
                return void Object(l.b)(e);
            const n = Object(s.e)(t.map(e=>e.name))
              , i = t.length;
            for (let r = 0; r < i; ++r) {
                const i = t[r]
                  , a = document.createElement("div");
                a.className = "neuroglancer-single-mesh-attribute";
                const o = document.createElement("div");
                o.className = "neuroglancer-single-mesh-attribute-type",
                o.textContent = Object(s.c)(i);
                const l = document.createElement("div");
                if (l.className = "neuroglancer-single-mesh-attribute-name",
                l.textContent = n[r],
                a.appendChild(o),
                a.appendChild(l),
                void 0 !== i.min && void 0 !== i.max) {
                    const e = document.createElement("neuroglancer-single-mesh-attribute-minmax");
                    e.className = "neuroglancer-single-mesh-attribute-range",
                    e.textContent = `[${i.min.toPrecision(6)}, ${i.max.toPrecision(6)}]`,
                    a.appendChild(e)
                }
                e.appendChild(a)
            }
        }
        disposed() {
            Object(l.c)(this.element)
        }
    }
    function v(e) {
        return new g(e.vertexAttributes)
    }
    class b extends h.b {
        constructor(e) {
            super(),
            this.layer = e,
            this.attributeWidget = this.registerDisposer(v(this.layer)),
            this.codeWidget = this.registerDisposer(m(this.layer));
            const {element: t} = this;
            t.classList.add("neuroglancer-single-mesh-dropdown");
            let n = document.createElement("div");
            n.className = "neuroglancer-single-mesh-dropdown-top-row";
            let i = document.createElement("div");
            i.style.flex = "1",
            n.appendChild(i),
            n.appendChild(Object(u.a)({
                title: "Show larger editor view",
                onClick: ()=>{
                    new y(this.layer)
                }
            })),
            n.appendChild(Object(c.a)({
                title: "Documentation on single mesh layer rendering",
                href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
            })),
            t.appendChild(n),
            t.appendChild(this.attributeWidget.element),
            t.appendChild(this.codeWidget.element),
            t.appendChild(this.registerDisposer(new p.a(e.displayState.shaderControlState)).element)
        }
    }
    class y extends r.a {
        constructor(e) {
            super(),
            this.layer = e,
            this.attributeWidget = this.registerDisposer(v(this.layer)),
            this.codeWidget = this.registerDisposer(m(this.layer)),
            this.content.classList.add("neuroglancer-single-mesh-layer-shader-overlay"),
            this.content.appendChild(this.attributeWidget.element),
            this.content.appendChild(this.codeWidget.element),
            this.codeWidget.textEditor.refresh()
        }
    }
    Object(i.q)("mesh", f),
    Object(i.r)(e=>{
        if (void 0 !== e.singleMesh)
            return f
    }
    )
}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {
    !function(e) {
        "use strict";
        e.defineMode("javascript", (function(t, n) {
            var i, r, s = t.indentUnit, a = n.statementIndent, o = n.jsonld, l = n.json || o, c = n.typescript, u = n.wordCharacters || /[\w$\xa1-\uffff]/, d = function() {
                function e(e) {
                    return {
                        type: e,
                        style: "keyword"
                    }
                }
                var t = e("keyword a")
                  , n = e("keyword b")
                  , i = e("keyword c")
                  , r = e("keyword d")
                  , s = e("operator")
                  , a = {
                    type: "atom",
                    style: "atom"
                };
                return {
                    if: e("if"),
                    while: t,
                    with: t,
                    else: n,
                    do: n,
                    try: n,
                    finally: n,
                    return: r,
                    break: r,
                    continue: r,
                    new: e("new"),
                    delete: i,
                    void: i,
                    throw: i,
                    debugger: e("debugger"),
                    var: e("var"),
                    const: e("var"),
                    let: e("var"),
                    function: e("function"),
                    catch: e("catch"),
                    for: e("for"),
                    switch: e("switch"),
                    case: e("case"),
                    default: e("default"),
                    in: s,
                    typeof: s,
                    instanceof: s,
                    true: a,
                    false: a,
                    null: a,
                    undefined: a,
                    NaN: a,
                    Infinity: a,
                    this: e("this"),
                    class: e("class"),
                    super: e("atom"),
                    yield: i,
                    export: e("export"),
                    import: e("import"),
                    extends: i,
                    await: i
                }
            }(), h = /[+\-*&%=<>!?|~^@]/, p = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
            function f(e, t, n) {
                return i = e,
                r = n,
                t
            }
            function m(e, t) {
                var n, i = e.next();
                if ('"' == i || "'" == i)
                    return t.tokenize = (n = i,
                    function(e, t) {
                        var i, r = !1;
                        if (o && "@" == e.peek() && e.match(p))
                            return t.tokenize = m,
                            f("jsonld-keyword", "meta");
                        for (; null != (i = e.next()) && (i != n || r); )
                            r = !r && "\\" == i;
                        return r || (t.tokenize = m),
                        f("string", "string")
                    }
                    ),
                    t.tokenize(e, t);
                if ("." == i && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
                    return f("number", "number");
                if ("." == i && e.match(".."))
                    return f("spread", "meta");
                if (/[\[\]{}\(\),;\:\.]/.test(i))
                    return f(i);
                if ("=" == i && e.eat(">"))
                    return f("=>", "operator");
                if ("0" == i && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
                    return f("number", "number");
                if (/\d/.test(i))
                    return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/),
                    f("number", "number");
                if ("/" == i)
                    return e.eat("*") ? (t.tokenize = g,
                    g(e, t)) : e.eat("/") ? (e.skipToEnd(),
                    f("comment", "comment")) : Je(e, t, 1) ? (function(e) {
                        for (var t, n = !1, i = !1; null != (t = e.next()); ) {
                            if (!n) {
                                if ("/" == t && !i)
                                    return;
                                "[" == t ? i = !0 : i && "]" == t && (i = !1)
                            }
                            n = !n && "\\" == t
                        }
                    }(e),
                    e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/),
                    f("regexp", "string-2")) : (e.eat("="),
                    f("operator", "operator", e.current()));
                if ("`" == i)
                    return t.tokenize = v,
                    v(e, t);
                if ("#" == i)
                    return e.skipToEnd(),
                    f("error", "error");
                if ("<" == i && e.match("!--") || "-" == i && e.match("->"))
                    return e.skipToEnd(),
                    f("comment", "comment");
                if (h.test(i))
                    return ">" == i && t.lexical && ">" == t.lexical.type || (e.eat("=") ? "!" != i && "=" != i || e.eat("=") : /[<>*+\-]/.test(i) && (e.eat(i),
                    ">" == i && e.eat(i))),
                    f("operator", "operator", e.current());
                if (u.test(i)) {
                    e.eatWhile(u);
                    var r = e.current();
                    if ("." != t.lastType) {
                        if (d.propertyIsEnumerable(r)) {
                            var s = d[r];
                            return f(s.type, s.style, r)
                        }
                        if ("async" == r && e.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1))
                            return f("async", "keyword", r)
                    }
                    return f("variable", "variable", r)
                }
            }
            function g(e, t) {
                for (var n, i = !1; n = e.next(); ) {
                    if ("/" == n && i) {
                        t.tokenize = m;
                        break
                    }
                    i = "*" == n
                }
                return f("comment", "comment")
            }
            function v(e, t) {
                for (var n, i = !1; null != (n = e.next()); ) {
                    if (!i && ("`" == n || "$" == n && e.eat("{"))) {
                        t.tokenize = m;
                        break
                    }
                    i = !i && "\\" == n
                }
                return f("quasi", "string-2", e.current())
            }
            function b(e, t) {
                t.fatArrowAt && (t.fatArrowAt = null);
                var n = e.string.indexOf("=>", e.start);
                if (!(n < 0)) {
                    if (c) {
                        var i = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n));
                        i && (n = i.index)
                    }
                    for (var r = 0, s = !1, a = n - 1; a >= 0; --a) {
                        var o = e.string.charAt(a)
                          , l = "([{}])".indexOf(o);
                        if (l >= 0 && l < 3) {
                            if (!r) {
                                ++a;
                                break
                            }
                            if (0 == --r) {
                                "(" == o && (s = !0);
                                break
                            }
                        } else if (l >= 3 && l < 6)
                            ++r;
                        else if (u.test(o))
                            s = !0;
                        else if (/["'\/`]/.test(o))
                            for (; ; --a) {
                                if (0 == a)
                                    return;
                                if (e.string.charAt(a - 1) == o && "\\" != e.string.charAt(a - 2)) {
                                    a--;
                                    break
                                }
                            }
                        else if (s && !r) {
                            ++a;
                            break
                        }
                    }
                    s && !r && (t.fatArrowAt = a)
                }
            }
            var y = {
                atom: !0,
                number: !0,
                variable: !0,
                string: !0,
                regexp: !0,
                this: !0,
                "jsonld-keyword": !0
            };
            function S(e, t, n, i, r, s) {
                this.indented = e,
                this.column = t,
                this.type = n,
                this.prev = r,
                this.info = s,
                null != i && (this.align = i)
            }
            function w(e, t) {
                for (var n = e.localVars; n; n = n.next)
                    if (n.name == t)
                        return !0;
                for (var i = e.context; i; i = i.prev)
                    for (n = i.vars; n; n = n.next)
                        if (n.name == t)
                            return !0
            }
            var x = {
                state: null,
                column: null,
                marked: null,
                cc: null
            };
            function C() {
                for (var e = arguments.length - 1; e >= 0; e--)
                    x.cc.push(arguments[e])
            }
            function O() {
                return C.apply(null, arguments),
                !0
            }
            function k(e, t) {
                for (var n = t; n; n = n.next)
                    if (n.name == e)
                        return !0;
                return !1
            }
            function E(e) {
                var t = x.state;
                if (x.marked = "def",
                t.context)
                    if ("var" == t.lexical.info && t.context && t.context.block) {
                        var i = function e(t, n) {
                            if (n) {
                                if (n.block) {
                                    var i = e(t, n.prev);
                                    return i ? i == n.prev ? n : new M(i,n.vars,!0) : null
                                }
                                return k(t, n.vars) ? n : new M(n.prev,new D(t,n.vars),!1)
                            }
                            return null
                        }(e, t.context);
                        if (null != i)
                            return void (t.context = i)
                    } else if (!k(e, t.localVars))
                        return void (t.localVars = new D(e,t.localVars));
                n.globalVars && !k(e, t.globalVars) && (t.globalVars = new D(e,t.globalVars))
            }
            function T(e) {
                return "public" == e || "private" == e || "protected" == e || "abstract" == e || "readonly" == e
            }
            function M(e, t, n) {
                this.prev = e,
                this.vars = t,
                this.block = n
            }
            function D(e, t) {
                this.name = e,
                this.next = t
            }
            var L = new D("this",new D("arguments",null));
            function A() {
                x.state.context = new M(x.state.context,x.state.localVars,!1),
                x.state.localVars = L
            }
            function I() {
                x.state.context = new M(x.state.context,x.state.localVars,!0),
                x.state.localVars = null
            }
            function P() {
                x.state.localVars = x.state.context.vars,
                x.state.context = x.state.context.prev
            }
            function R(e, t) {
                var n = function() {
                    var n = x.state
                      , i = n.indented;
                    if ("stat" == n.lexical.type)
                        i = n.lexical.indented;
                    else
                        for (var r = n.lexical; r && ")" == r.type && r.align; r = r.prev)
                            i = r.indented;
                    n.lexical = new S(i,x.stream.column(),e,null,n.lexical,t)
                };
                return n.lex = !0,
                n
            }
            function j() {
                var e = x.state;
                e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented),
                e.lexical = e.lexical.prev)
            }
            function N(e) {
                return function t(n) {
                    return n == e ? O() : ";" == e || "}" == n || ")" == n || "]" == n ? C() : O(t)
                }
            }
            function V(e, t) {
                return "var" == e ? O(R("vardef", t), be, N(";"), j) : "keyword a" == e ? O(R("form"), U, V, j) : "keyword b" == e ? O(R("form"), V, j) : "keyword d" == e ? x.stream.match(/^\s*$/, !1) ? O() : O(R("stat"), G, N(";"), j) : "debugger" == e ? O(N(";")) : "{" == e ? O(R("}"), I, se, j, P) : ";" == e ? O() : "if" == e ? ("else" == x.state.lexical.info && x.state.cc[x.state.cc.length - 1] == j && x.state.cc.pop()(),
                O(R("form"), U, V, j, Oe)) : "function" == e ? O(Me) : "for" == e ? O(R("form"), ke, V, j) : "class" == e || c && "interface" == t ? (x.marked = "keyword",
                O(R("form", "class" == e ? e : t), Pe, j)) : "variable" == e ? c && "declare" == t ? (x.marked = "keyword",
                O(V)) : c && ("module" == t || "enum" == t || "type" == t) && x.stream.match(/^\s*\w/, !1) ? (x.marked = "keyword",
                "enum" == t ? O(We) : "type" == t ? O(Le, N("operator"), ue, N(";")) : O(R("form"), ye, N("{"), R("}"), se, j, j)) : c && "namespace" == t ? (x.marked = "keyword",
                O(R("form"), F, V, j)) : c && "abstract" == t ? (x.marked = "keyword",
                O(V)) : O(R("stat"), Z) : "switch" == e ? O(R("form"), U, N("{"), R("}", "switch"), I, se, j, j, P) : "case" == e ? O(F, N(":")) : "default" == e ? O(N(":")) : "catch" == e ? O(R("form"), A, B, V, j, P) : "export" == e ? O(R("stat"), Ve, j) : "import" == e ? O(R("stat"), Fe, j) : "async" == e ? O(V) : "@" == t ? O(F, V) : C(R("stat"), F, N(";"), j)
            }
            function B(e) {
                if ("(" == e)
                    return O(Ae, N(")"))
            }
            function F(e, t) {
                return z(e, t, !1)
            }
            function _(e, t) {
                return z(e, t, !0)
            }
            function U(e) {
                return "(" != e ? C() : O(R(")"), F, N(")"), j)
            }
            function z(e, t, n) {
                if (x.state.fatArrowAt == x.stream.start) {
                    var i = n ? Y : q;
                    if ("(" == e)
                        return O(A, R(")"), ie(Ae, ")"), j, N("=>"), i, P);
                    if ("variable" == e)
                        return C(A, ye, N("=>"), i, P)
                }
                var r = n ? W : $;
                return y.hasOwnProperty(e) ? O(r) : "function" == e ? O(Me, r) : "class" == e || c && "interface" == t ? (x.marked = "keyword",
                O(R("form"), Ie, j)) : "keyword c" == e || "async" == e ? O(n ? _ : F) : "(" == e ? O(R(")"), G, N(")"), j, r) : "operator" == e || "spread" == e ? O(n ? _ : F) : "[" == e ? O(R("]"), $e, j, r) : "{" == e ? re(ee, "}", null, r) : "quasi" == e ? C(H, r) : "new" == e ? O(function(e) {
                    return function(t) {
                        return "." == t ? O(e ? K : X) : "variable" == t && c ? O(me, e ? W : $) : C(e ? _ : F)
                    }
                }(n)) : "import" == e ? O(F) : O()
            }
            function G(e) {
                return e.match(/[;\}\)\],]/) ? C() : C(F)
            }
            function $(e, t) {
                return "," == e ? O(F) : W(e, t, !1)
            }
            function W(e, t, n) {
                var i = 0 == n ? $ : W
                  , r = 0 == n ? F : _;
                return "=>" == e ? O(A, n ? Y : q, P) : "operator" == e ? /\+\+|--/.test(t) || c && "!" == t ? O(i) : c && "<" == t && x.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? O(R(">"), ie(ue, ">"), j, i) : "?" == t ? O(F, N(":"), r) : O(r) : "quasi" == e ? C(H, i) : ";" != e ? "(" == e ? re(_, ")", "call", i) : "." == e ? O(Q, i) : "[" == e ? O(R("]"), G, N("]"), j, i) : c && "as" == t ? (x.marked = "keyword",
                O(ue, i)) : "regexp" == e ? (x.state.lastType = x.marked = "operator",
                x.stream.backUp(x.stream.pos - x.stream.start - 1),
                O(r)) : void 0 : void 0
            }
            function H(e, t) {
                return "quasi" != e ? C() : "${" != t.slice(t.length - 2) ? O(H) : O(F, J)
            }
            function J(e) {
                if ("}" == e)
                    return x.marked = "string-2",
                    x.state.tokenize = v,
                    O(H)
            }
            function q(e) {
                return b(x.stream, x.state),
                C("{" == e ? V : F)
            }
            function Y(e) {
                return b(x.stream, x.state),
                C("{" == e ? V : _)
            }
            function X(e, t) {
                if ("target" == t)
                    return x.marked = "keyword",
                    O($)
            }
            function K(e, t) {
                if ("target" == t)
                    return x.marked = "keyword",
                    O(W)
            }
            function Z(e) {
                return ":" == e ? O(j, V) : C($, N(";"), j)
            }
            function Q(e) {
                if ("variable" == e)
                    return x.marked = "property",
                    O()
            }
            function ee(e, t) {
                return "async" == e ? (x.marked = "property",
                O(ee)) : "variable" == e || "keyword" == x.style ? (x.marked = "property",
                "get" == t || "set" == t ? O(te) : (c && x.state.fatArrowAt == x.stream.start && (n = x.stream.match(/^\s*:\s*/, !1)) && (x.state.fatArrowAt = x.stream.pos + n[0].length),
                O(ne))) : "number" == e || "string" == e ? (x.marked = o ? "property" : x.style + " property",
                O(ne)) : "jsonld-keyword" == e ? O(ne) : c && T(t) ? (x.marked = "keyword",
                O(ee)) : "[" == e ? O(F, ae, N("]"), ne) : "spread" == e ? O(_, ne) : "*" == t ? (x.marked = "keyword",
                O(ee)) : ":" == e ? C(ne) : void 0;
                var n
            }
            function te(e) {
                return "variable" != e ? C(ne) : (x.marked = "property",
                O(Me))
            }
            function ne(e) {
                return ":" == e ? O(_) : "(" == e ? C(Me) : void 0
            }
            function ie(e, t, n) {
                function i(r, s) {
                    if (n ? n.indexOf(r) > -1 : "," == r) {
                        var a = x.state.lexical;
                        return "call" == a.info && (a.pos = (a.pos || 0) + 1),
                        O((function(n, i) {
                            return n == t || i == t ? C() : C(e)
                        }
                        ), i)
                    }
                    return r == t || s == t ? O() : n && n.indexOf(";") > -1 ? C(e) : O(N(t))
                }
                return function(n, r) {
                    return n == t || r == t ? O() : C(e, i)
                }
            }
            function re(e, t, n) {
                for (var i = 3; i < arguments.length; i++)
                    x.cc.push(arguments[i]);
                return O(R(t, n), ie(e, t), j)
            }
            function se(e) {
                return "}" == e ? O() : C(V, se)
            }
            function ae(e, t) {
                if (c) {
                    if (":" == e)
                        return O(ue);
                    if ("?" == t)
                        return O(ae)
                }
            }
            function oe(e, t) {
                if (c && (":" == e || "in" == t))
                    return O(ue)
            }
            function le(e) {
                if (c && ":" == e)
                    return x.stream.match(/^\s*\w+\s+is\b/, !1) ? O(F, ce, ue) : O(ue)
            }
            function ce(e, t) {
                if ("is" == t)
                    return x.marked = "keyword",
                    O()
            }
            function ue(e, t) {
                return "keyof" == t || "typeof" == t || "infer" == t ? (x.marked = "keyword",
                O("typeof" == t ? _ : ue)) : "variable" == e || "void" == t ? (x.marked = "type",
                O(fe)) : "|" == t || "&" == t ? O(ue) : "string" == e || "number" == e || "atom" == e ? O(fe) : "[" == e ? O(R("]"), ie(ue, "]", ","), j, fe) : "{" == e ? O(R("}"), ie(he, "}", ",;"), j, fe) : "(" == e ? O(ie(pe, ")"), de, fe) : "<" == e ? O(ie(ue, ">"), ue) : void 0
            }
            function de(e) {
                if ("=>" == e)
                    return O(ue)
            }
            function he(e, t) {
                return "variable" == e || "keyword" == x.style ? (x.marked = "property",
                O(he)) : "?" == t || "number" == e || "string" == e ? O(he) : ":" == e ? O(ue) : "[" == e ? O(N("variable"), oe, N("]"), he) : "(" == e ? C(De, he) : void 0
            }
            function pe(e, t) {
                return "variable" == e && x.stream.match(/^\s*[?:]/, !1) || "?" == t ? O(pe) : ":" == e ? O(ue) : "spread" == e ? O(pe) : C(ue)
            }
            function fe(e, t) {
                return "<" == t ? O(R(">"), ie(ue, ">"), j, fe) : "|" == t || "." == e || "&" == t ? O(ue) : "[" == e ? O(ue, N("]"), fe) : "extends" == t || "implements" == t ? (x.marked = "keyword",
                O(ue)) : "?" == t ? O(ue, N(":"), ue) : void 0
            }
            function me(e, t) {
                if ("<" == t)
                    return O(R(">"), ie(ue, ">"), j, fe)
            }
            function ge() {
                return C(ue, ve)
            }
            function ve(e, t) {
                if ("=" == t)
                    return O(ue)
            }
            function be(e, t) {
                return "enum" == t ? (x.marked = "keyword",
                O(We)) : C(ye, ae, xe, Ce)
            }
            function ye(e, t) {
                return c && T(t) ? (x.marked = "keyword",
                O(ye)) : "variable" == e ? (E(t),
                O()) : "spread" == e ? O(ye) : "[" == e ? re(we, "]") : "{" == e ? re(Se, "}") : void 0
            }
            function Se(e, t) {
                return "variable" != e || x.stream.match(/^\s*:/, !1) ? ("variable" == e && (x.marked = "property"),
                "spread" == e ? O(ye) : "}" == e ? C() : "[" == e ? O(F, N("]"), N(":"), Se) : O(N(":"), ye, xe)) : (E(t),
                O(xe))
            }
            function we() {
                return C(ye, xe)
            }
            function xe(e, t) {
                if ("=" == t)
                    return O(_)
            }
            function Ce(e) {
                if ("," == e)
                    return O(be)
            }
            function Oe(e, t) {
                if ("keyword b" == e && "else" == t)
                    return O(R("form", "else"), V, j)
            }
            function ke(e, t) {
                return "await" == t ? O(ke) : "(" == e ? O(R(")"), Ee, j) : void 0
            }
            function Ee(e) {
                return "var" == e ? O(be, Te) : "variable" == e ? O(Te) : C(Te)
            }
            function Te(e, t) {
                return ")" == e ? O() : ";" == e ? O(Te) : "in" == t || "of" == t ? (x.marked = "keyword",
                O(F, Te)) : C(F, Te)
            }
            function Me(e, t) {
                return "*" == t ? (x.marked = "keyword",
                O(Me)) : "variable" == e ? (E(t),
                O(Me)) : "(" == e ? O(A, R(")"), ie(Ae, ")"), j, le, V, P) : c && "<" == t ? O(R(">"), ie(ge, ">"), j, Me) : void 0
            }
            function De(e, t) {
                return "*" == t ? (x.marked = "keyword",
                O(De)) : "variable" == e ? (E(t),
                O(De)) : "(" == e ? O(A, R(")"), ie(Ae, ")"), j, le, P) : c && "<" == t ? O(R(">"), ie(ge, ">"), j, De) : void 0
            }
            function Le(e, t) {
                return "keyword" == e || "variable" == e ? (x.marked = "type",
                O(Le)) : "<" == t ? O(R(">"), ie(ge, ">"), j) : void 0
            }
            function Ae(e, t) {
                return "@" == t && O(F, Ae),
                "spread" == e ? O(Ae) : c && T(t) ? (x.marked = "keyword",
                O(Ae)) : c && "this" == e ? O(ae, xe) : C(ye, ae, xe)
            }
            function Ie(e, t) {
                return "variable" == e ? Pe(e, t) : Re(e, t)
            }
            function Pe(e, t) {
                if ("variable" == e)
                    return E(t),
                    O(Re)
            }
            function Re(e, t) {
                return "<" == t ? O(R(">"), ie(ge, ">"), j, Re) : "extends" == t || "implements" == t || c && "," == e ? ("implements" == t && (x.marked = "keyword"),
                O(c ? ue : F, Re)) : "{" == e ? O(R("}"), je, j) : void 0
            }
            function je(e, t) {
                return "async" == e || "variable" == e && ("static" == t || "get" == t || "set" == t || c && T(t)) && x.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (x.marked = "keyword",
                O(je)) : "variable" == e || "keyword" == x.style ? (x.marked = "property",
                O(c ? Ne : Me, je)) : "number" == e || "string" == e ? O(c ? Ne : Me, je) : "[" == e ? O(F, ae, N("]"), c ? Ne : Me, je) : "*" == t ? (x.marked = "keyword",
                O(je)) : c && "(" == e ? C(De, je) : ";" == e || "," == e ? O(je) : "}" == e ? O() : "@" == t ? O(F, je) : void 0
            }
            function Ne(e, t) {
                if ("?" == t)
                    return O(Ne);
                if (":" == e)
                    return O(ue, xe);
                if ("=" == t)
                    return O(_);
                var n = x.state.lexical.prev;
                return C(n && "interface" == n.info ? De : Me)
            }
            function Ve(e, t) {
                return "*" == t ? (x.marked = "keyword",
                O(Ge, N(";"))) : "default" == t ? (x.marked = "keyword",
                O(F, N(";"))) : "{" == e ? O(ie(Be, "}"), Ge, N(";")) : C(V)
            }
            function Be(e, t) {
                return "as" == t ? (x.marked = "keyword",
                O(N("variable"))) : "variable" == e ? C(_, Be) : void 0
            }
            function Fe(e) {
                return "string" == e ? O() : "(" == e ? C(F) : C(_e, Ue, Ge)
            }
            function _e(e, t) {
                return "{" == e ? re(_e, "}") : ("variable" == e && E(t),
                "*" == t && (x.marked = "keyword"),
                O(ze))
            }
            function Ue(e) {
                if ("," == e)
                    return O(_e, Ue)
            }
            function ze(e, t) {
                if ("as" == t)
                    return x.marked = "keyword",
                    O(_e)
            }
            function Ge(e, t) {
                if ("from" == t)
                    return x.marked = "keyword",
                    O(F)
            }
            function $e(e) {
                return "]" == e ? O() : C(ie(_, "]"))
            }
            function We() {
                return C(R("form"), ye, N("{"), R("}"), ie(He, "}"), j, j)
            }
            function He() {
                return C(ye, xe)
            }
            function Je(e, t, n) {
                return t.tokenize == m && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - (n || 0)))
            }
            return P.lex = !0,
            j.lex = !0,
            {
                startState: function(e) {
                    var t = {
                        tokenize: m,
                        lastType: "sof",
                        cc: [],
                        lexical: new S((e || 0) - s,0,"block",!1),
                        localVars: n.localVars,
                        context: n.localVars && new M(null,null,!1),
                        indented: e || 0
                    };
                    return n.globalVars && "object" == typeof n.globalVars && (t.globalVars = n.globalVars),
                    t
                },
                token: function(e, t) {
                    if (e.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1),
                    t.indented = e.indentation(),
                    b(e, t)),
                    t.tokenize != g && e.eatSpace())
                        return null;
                    var n = t.tokenize(e, t);
                    return "comment" == i ? n : (t.lastType = "operator" != i || "++" != r && "--" != r ? i : "incdec",
                    function(e, t, n, i, r) {
                        var s = e.cc;
                        for (x.state = e,
                        x.stream = r,
                        x.marked = null,
                        x.cc = s,
                        x.style = t,
                        e.lexical.hasOwnProperty("align") || (e.lexical.align = !0); ; )
                            if ((s.length ? s.pop() : l ? F : V)(n, i)) {
                                for (; s.length && s[s.length - 1].lex; )
                                    s.pop()();
                                return x.marked ? x.marked : "variable" == n && w(e, i) ? "variable-2" : t
                            }
                    }(t, n, i, r, e))
                },
                indent: function(t, i) {
                    if (t.tokenize == g)
                        return e.Pass;
                    if (t.tokenize != m)
                        return 0;
                    var r, o = i && i.charAt(0), l = t.lexical;
                    if (!/^\s*else\b/.test(i))
                        for (var c = t.cc.length - 1; c >= 0; --c) {
                            var u = t.cc[c];
                            if (u == j)
                                l = l.prev;
                            else if (u != Oe)
                                break
                        }
                    for (; ("stat" == l.type || "form" == l.type) && ("}" == o || (r = t.cc[t.cc.length - 1]) && (r == $ || r == W) && !/^[,\.=+\-*:?[\(]/.test(i)); )
                        l = l.prev;
                    a && ")" == l.type && "stat" == l.prev.type && (l = l.prev);
                    var d = l.type
                      , p = o == d;
                    return "vardef" == d ? l.indented + ("operator" == t.lastType || "," == t.lastType ? l.info.length + 1 : 0) : "form" == d && "{" == o ? l.indented : "form" == d ? l.indented + s : "stat" == d ? l.indented + (function(e, t) {
                        return "operator" == e.lastType || "," == e.lastType || h.test(t.charAt(0)) || /[,.]/.test(t.charAt(0))
                    }(t, i) ? a || s : 0) : "switch" != l.info || p || 0 == n.doubleIndentSwitch ? l.align ? l.column + (p ? 0 : 1) : l.indented + (p ? 0 : s) : l.indented + (/^(?:case|default)\b/.test(i) ? s : 2 * s)
                },
                electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                blockCommentStart: l ? null : "/*",
                blockCommentEnd: l ? null : "*/",
                blockCommentContinue: l ? null : " * ",
                lineComment: l ? null : "//",
                fold: "brace",
                closeBrackets: "()[]{}''\"\"``",
                helperType: l ? "json" : "javascript",
                jsonldMode: o,
                jsonMode: l,
                expressionAllowed: Je,
                skipExpression: function(e) {
                    var t = e.cc[e.cc.length - 1];
                    t != F && t != _ || e.cc.pop()
                }
            }
        }
        )),
        e.registerHelper("wordChars", "javascript", /[\w$]/),
        e.defineMIME("text/javascript", "javascript"),
        e.defineMIME("text/ecmascript", "javascript"),
        e.defineMIME("application/javascript", "javascript"),
        e.defineMIME("application/x-javascript", "javascript"),
        e.defineMIME("application/ecmascript", "javascript"),
        e.defineMIME("application/json", {
            name: "javascript",
            json: !0
        }),
        e.defineMIME("application/x-json", {
            name: "javascript",
            json: !0
        }),
        e.defineMIME("application/ld+json", {
            name: "javascript",
            jsonld: !0
        }),
        e.defineMIME("text/typescript", {
            name: "javascript",
            typescript: !0
        }),
        e.defineMIME("application/typescript", {
            name: "javascript",
            typescript: !0
        })
    }(n(57))
}
, function(e, t, n) {
    !function(e) {
        "use strict";
        e.defineOption("foldGutter", !1, (function(t, i, r) {
            var s;
            r && r != e.Init && (t.clearGutter(t.state.foldGutter.options.gutter),
            t.state.foldGutter = null,
            t.off("gutterClick", l),
            t.off("changes", c),
            t.off("viewportChange", u),
            t.off("fold", d),
            t.off("unfold", d),
            t.off("swapDoc", c)),
            i && (t.state.foldGutter = new n((!0 === (s = i) && (s = {}),
            null == s.gutter && (s.gutter = "CodeMirror-foldgutter"),
            null == s.indicatorOpen && (s.indicatorOpen = "CodeMirror-foldgutter-open"),
            null == s.indicatorFolded && (s.indicatorFolded = "CodeMirror-foldgutter-folded"),
            s)),
            o(t),
            t.on("gutterClick", l),
            t.on("changes", c),
            t.on("viewportChange", u),
            t.on("fold", d),
            t.on("unfold", d),
            t.on("swapDoc", c))
        }
        ));
        var t = e.Pos;
        function n(e) {
            this.options = e,
            this.from = this.to = 0
        }
        function i(e, n) {
            for (var i = e.findMarks(t(n, 0), t(n + 1, 0)), r = 0; r < i.length; ++r)
                if (i[r].__isFold) {
                    var s = i[r].find(-1);
                    if (s && s.line === n)
                        return i[r]
                }
        }
        function r(e) {
            if ("string" == typeof e) {
                var t = document.createElement("div");
                return t.className = e + " CodeMirror-guttermarker-subtle",
                t
            }
            return e.cloneNode(!0)
        }
        function s(e, n, s) {
            var o = e.state.foldGutter.options
              , l = n - 1
              , c = e.foldOption(o, "minFoldSize")
              , u = e.foldOption(o, "rangeFinder")
              , d = "string" == typeof o.indicatorFolded && a(o.indicatorFolded)
              , h = "string" == typeof o.indicatorOpen && a(o.indicatorOpen);
            e.eachLine(n, s, (function(n) {
                ++l;
                var s = null
                  , a = n.gutterMarkers;
                if (a && (a = a[o.gutter]),
                i(e, l)) {
                    if (d && a && d.test(a.className))
                        return;
                    s = r(o.indicatorFolded)
                } else {
                    var p = t(l, 0)
                      , f = u && u(e, p);
                    if (f && f.to.line - f.from.line >= c) {
                        if (h && a && h.test(a.className))
                            return;
                        s = r(o.indicatorOpen)
                    }
                }
                (s || a) && e.setGutterMarker(n, o.gutter, s)
            }
            ))
        }
        function a(e) {
            return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
        }
        function o(e) {
            var t = e.getViewport()
              , n = e.state.foldGutter;
            n && (e.operation((function() {
                s(e, t.from, t.to)
            }
            )),
            n.from = t.from,
            n.to = t.to)
        }
        function l(e, n, r) {
            var s = e.state.foldGutter;
            if (s) {
                var a = s.options;
                if (r == a.gutter) {
                    var o = i(e, n);
                    o ? o.clear() : e.foldCode(t(n, 0), a)
                }
            }
        }
        function c(e) {
            var t = e.state.foldGutter;
            if (t) {
                var n = t.options;
                t.from = t.to = 0,
                clearTimeout(t.changeUpdate),
                t.changeUpdate = setTimeout((function() {
                    o(e)
                }
                ), n.foldOnChangeTimeSpan || 600)
            }
        }
        function u(e) {
            var t = e.state.foldGutter;
            if (t) {
                var n = t.options;
                clearTimeout(t.changeUpdate),
                t.changeUpdate = setTimeout((function() {
                    var n = e.getViewport();
                    t.from == t.to || n.from - t.to > 20 || t.from - n.to > 20 ? o(e) : e.operation((function() {
                        n.from < t.from && (s(e, n.from, t.from),
                        t.from = n.from),
                        n.to > t.to && (s(e, t.to, n.to),
                        t.to = n.to)
                    }
                    ))
                }
                ), n.updateViewportTimeSpan || 400)
            }
        }
        function d(e, t) {
            var n = e.state.foldGutter;
            if (n) {
                var i = t.line;
                i >= n.from && i < n.to && s(e, i, i + 1)
            }
        }
    }(n(57), n(132))
}
, function(e, t, n) {
    !function(e) {
        "use strict";
        e.registerHelper("fold", "brace", (function(t, n) {
            var i, r = n.line, s = t.getLine(r);
            function a(a) {
                for (var o = n.ch, l = 0; ; ) {
                    var c = o <= 0 ? -1 : s.lastIndexOf(a, o - 1);
                    if (-1 != c) {
                        if (1 == l && c < n.ch)
                            break;
                        if (i = t.getTokenTypeAt(e.Pos(r, c + 1)),
                        !/^(comment|string)/.test(i))
                            return c + 1;
                        o = c - 1
                    } else {
                        if (1 == l)
                            break;
                        l = 1,
                        o = s.length
                    }
                }
            }
            var o = "{"
              , l = "}"
              , c = a("{");
            if (null == c && (o = "[",
            l = "]",
            c = a("[")),
            null != c) {
                var u, d, h = 1, p = t.lastLine();
                e: for (var f = r; f <= p; ++f)
                    for (var m = t.getLine(f), g = f == r ? c : 0; ; ) {
                        var v = m.indexOf(o, g)
                          , b = m.indexOf(l, g);
                        if (v < 0 && (v = m.length),
                        b < 0 && (b = m.length),
                        (g = Math.min(v, b)) == m.length)
                            break;
                        if (t.getTokenTypeAt(e.Pos(f, g + 1)) == i)
                            if (g == v)
                                ++h;
                            else if (!--h) {
                                u = f,
                                d = g;
                                break e
                            }
                        ++g
                    }
                if (null != u && r != u)
                    return {
                        from: e.Pos(r, c),
                        to: e.Pos(u, d)
                    }
            }
        }
        )),
        e.registerHelper("fold", "import", (function(t, n) {
            function i(n) {
                if (n < t.firstLine() || n > t.lastLine())
                    return null;
                var i = t.getTokenAt(e.Pos(n, 1));
                if (/\S/.test(i.string) || (i = t.getTokenAt(e.Pos(n, i.end + 1))),
                "keyword" != i.type || "import" != i.string)
                    return null;
                for (var r = n, s = Math.min(t.lastLine(), n + 10); r <= s; ++r) {
                    var a = t.getLine(r).indexOf(";");
                    if (-1 != a)
                        return {
                            startCh: i.end,
                            end: e.Pos(r, a)
                        }
                }
            }
            var r, s = n.line, a = i(s);
            if (!a || i(s - 1) || (r = i(s - 2)) && r.end.line == s - 1)
                return null;
            for (var o = a.end; ; ) {
                var l = i(o.line + 1);
                if (null == l)
                    break;
                o = l.end
            }
            return {
                from: t.clipPos(e.Pos(s, a.startCh + 1)),
                to: o
            }
        }
        )),
        e.registerHelper("fold", "include", (function(t, n) {
            function i(n) {
                if (n < t.firstLine() || n > t.lastLine())
                    return null;
                var i = t.getTokenAt(e.Pos(n, 1));
                return /\S/.test(i.string) || (i = t.getTokenAt(e.Pos(n, i.end + 1))),
                "meta" == i.type && "#include" == i.string.slice(0, 8) ? i.start + 8 : void 0
            }
            var r = n.line
              , s = i(r);
            if (null == s || null != i(r - 1))
                return null;
            for (var a = r; null != i(a + 1); )
                ++a;
            return {
                from: e.Pos(r, s + 1),
                to: t.clipPos(e.Pos(a))
            }
        }
        ))
    }(n(57))
}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(35)
      , r = n(5)
      , s = n(30);
    function a(e) {
        e.registerEventListener(document, "paste", t=>{
            if (Object(r.a)(t.target))
                return;
            const {clipboardData: n} = t;
            if (null !== n) {
                const t = function(e, t) {
                    let n = String.raw`^[\[\]{}()\s,]*`;
                    for (let e = 0; e < t; ++e)
                        0 !== e && (n += String.raw`[,\s]+`),
                        n += String.raw`(\d+(?:\.\d+)?)`;
                    n += String.raw`[\[\]{}()\s,]*$`;
                    const i = e.match(n);
                    if (null === i)
                        return;
                    const r = new Float32Array(t);
                    for (let e = 0; e < t; ++e) {
                        const t = Number(i[e + 1]);
                        if (!Number.isFinite(t))
                            return;
                        r[e] = t
                    }
                    return r
                }(n.getData("text/plain"), e.coordinateSpace.value.rank);
                void 0 !== t && (e.navigationState.position.value = t)
            }
            t.preventDefault()
        }
        )
    }
    var o = n(13);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    let l, c, u, d;
    function h() {
        return void 0 === c && (c = o.a.fromObject({
            arrowleft: "x-",
            arrowright: "x+",
            arrowup: "y-",
            arrowdown: "y+",
            comma: "z-",
            period: "z+",
            bracketleft: "t-",
            bracketright: "t+",
            keyz: "snap",
            "control+equal": "zoom-in",
            "alt+equal": "depth-range-decrease",
            "control+shift+equal": "zoom-in",
            "alt+shift+equal": "depth-range-decrease",
            "control+minus": "zoom-out",
            "alt+minus": "depth-range-increase",
            keyr: "rotate-relative-z-",
            keye: "rotate-relative-z+",
            "shift+arrowdown": "rotate-relative-x-",
            "shift+arrowup": "rotate-relative-x+",
            "shift+arrowleft": "rotate-relative-y-",
            "shift+arrowright": "rotate-relative-y+",
            "control+wheel": {
                action: "zoom-via-wheel",
                preventDefault: !0
            },
            "alt+wheel": {
                action: "adjust-depth-range-via-wheel",
                preventDefault: !0
            },
            "at:wheel": {
                action: "z+1-via-wheel",
                preventDefault: !0
            },
            "at:shift+wheel": {
                action: "z+10-via-wheel",
                preventDefault: !0
            },
            "at:dblclick0": "select",
            "at:control+mousedown0": "annotate",
            "at:mousedown2": "move-to-mouse-position",
            "at:control+mousedown2": "select-annotation",
            "at:alt+mousedown0": "move-annotation",
            "at:control+alt+mousedown2": "delete-annotation",
            "at:touchpinch": "zoom-via-touchpinch",
            "at:touchrotate": "rotate-in-plane-via-touchrotate",
            "at:touchtranslate2": "translate-in-plane-via-touchtranslate",
            "at:touchhold1": "move-to-mouse-position",
            "at:touchtap1x2": "select",
            "at:touchtap2x3": "snap"
        }, {
            label: "All Data Panels"
        })),
        c
    }
    function p(e) {
        e.global.addParent(function() {
            if (void 0 === l) {
                const e = new o.a;
                e.set("keyl", "recolor"),
                e.set("keyx", "clear-segments"),
                e.set("keys", "toggle-show-slices"),
                e.set("keyb", "toggle-scale-bar"),
                e.set("shift+keyb", "toggle-default-annotations"),
                e.set("keya", "toggle-axis-lines"),
                e.set("keyo", "toggle-orthographic-projection");
                for (let t = 1; t <= 9; ++t)
                    e.set("digit" + t, "toggle-layer-" + t),
                    e.set("control+digit" + t, "select-layer-" + t);
                e.set("keyn", "add-layer"),
                e.set("keyh", "help"),
                e.set("space", "toggle-layout"),
                e.set("shift+space", "toggle-layout-alternative"),
                e.set("backslash", "toggle-show-statistics"),
                l = e
            }
            return l
        }(), Number.NEGATIVE_INFINITY),
        e.sliceView.addParent((void 0 === d && (d = o.a.fromObject({
            "at:mousedown0": {
                action: "translate-via-mouse-drag",
                stopPropagation: !0
            },
            "at:shift+mousedown0": {
                action: "rotate-via-mouse-drag",
                stopPropagation: !0
            },
            "at:touchtranslate1": "translate-z-via-touchtranslate"
        }, {
            parents: [[h(), Number.NEGATIVE_INFINITY]]
        })),
        d), Number.NEGATIVE_INFINITY),
        e.perspectiveView.addParent((void 0 === u && (u = o.a.fromObject({
            "at:mousedown0": {
                action: "rotate-via-mouse-drag",
                stopPropagation: !0
            },
            "at:shift+mousedown0": {
                action: "translate-via-mouse-drag",
                stopPropagation: !0
            },
            "at:touchtranslate1": "rotate-out-of-plane-via-touchtranslate"
        }, {
            parents: [[h(), Number.NEGATIVE_INFINITY]]
        })),
        u), Number.NEGATIVE_INFINITY)
    }
    n(179);
    var f = n(2);
    var m = n(28)
      , g = n(60);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const v = Symbol("SingleTextureVolumeChunk.textureUnit")
      , b = Symbol("SingleTextureVolumeChunk.textureLayout");
    class y extends f.a {
        constructor(e) {
            super(),
            this.shaderKey = e
        }
        defineShader(e, t) {
            e.addTextureSampler(this.shaderSamplerType, "uVolumeChunkSampler", v)
        }
        beginDrawing(e, t) {
            let n = t.textureUnit(v);
            e.activeTexture(WebGL2RenderingContext.TEXTURE0 + n),
            t[b] = null
        }
        endDrawing(e, t) {
            e.bindTexture(g.b[this.shaderSamplerType], null),
            t[b] = null
        }
        bindChunk(e, t, n, i, r, s, a) {
            let o = n.textureLayout;
            (t[b] !== o || a) && (t[b] = o,
            this.setupTextureLayout(e, t, o, i, r, s)),
            e.bindTexture(g.b[this.shaderSamplerType], n.texture)
        }
        beginSource(e, t) {}
    }
    class S extends m.b {
        constructor(e, t) {
            super(e, t),
            this.texture = null,
            this.data = t.data
        }
        copyToGPU(e) {
            super.copyToGPU(e);
            let t = this.texture = e.createTexture();
            const n = g.b[this.chunkFormat.shaderSamplerType];
            e.bindTexture(n, t),
            this.setTextureData(e),
            e.bindTexture(n, null)
        }
        freeGPUMemory(e) {
            super.freeGPUMemory(e),
            e.deleteTexture(this.texture),
            this.texture = null,
            this.textureLayout.dispose(),
            this.textureLayout = null
        }
    }
    var w = n(9)
      , x = n(21)
      , C = n(24)
      , O = n(32);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class k extends f.a {
        constructor(e, t) {
            super(),
            this.chunkDataSize = t,
            this.textureShape = new Uint32Array(3);
            const n = t.length;
            let i = 0;
            for (const e of t)
                1 !== e && ++i;
            const r = this.strides = new Uint32Array(3 * n)
              , {max3dTextureSize: s} = e;
            let a = 0
              , o = 1;
            const {textureShape: l} = this;
            l.fill(1);
            for (let e = 0; e < n; ++e) {
                const n = t[e];
                if (1 === n)
                    continue;
                const c = n * o;
                let u;
                c > s || 1 !== o && a + i < 3 ? (++a,
                o = n,
                u = 1) : (u = o,
                o = c),
                r[3 * e + a] = u,
                l[a] = o
            }
        }
        static get(e, t) {
            return e.memoize.get(`sliceview.UncompressedTextureLayout:${t.join()}`, ()=>new k(e,t))
        }
    }
    let E = new Uint32Array(15);
    class T extends y {
        constructor(e, t, n) {
            super(n),
            this.dataType = t,
            Object(O.d)(this, t),
            this.textureAccessHelper = new O.c("chunkData")
        }
        get shaderSamplerType() {
            return `${this.samplerPrefix}sampler3D`
        }
        static get(e, t) {
            const n = `sliceview.UncompressedChunkFormat:${t}`;
            return e.memoize.get(n, ()=>new T(e,t,n))
        }
        defineShader(e, t) {
            super.defineShader(e, t);
            let {textureAccessHelper: n} = this;
            const i = 3 * (4 + t);
            E.length < i && (E = new Uint32Array(i)),
            e.addUniform("highp ivec3", "uVolumeChunkStrides", 4 + t),
            e.addFragmentCode(n.getAccessor("readVolumeData", "uVolumeChunkSampler", this.dataType));
            let r = `\n${Object(C.b)(this.dataType)} getDataValue (`;
            0 === t && (r += "highp int ignoredChannel");
            for (let e = 0; e < t; ++e)
                0 !== e && (r += ", "),
                r += `highp int channelIndex${e}`;
            r += ") {\n  highp ivec3 p = getPositionWithinChunk();\n  highp ivec3 offset = uVolumeChunkStrides[0]\n                     + p.x * uVolumeChunkStrides[1]\n                     + p.y * uVolumeChunkStrides[2]\n                     + p.z * uVolumeChunkStrides[3];\n";
            for (let e = 0; e < t; ++e)
                r += `\n  offset += channelIndex${e} * uVolumeChunkStrides[${4 + e}];\n`;
            r += "\n  return readVolumeData(offset);\n}\n",
            e.addFragmentCode(r)
        }
        setupTextureLayout(e, t, n, i, r, s) {
            const a = E
              , o = s.length
              , {strides: l} = n
              , c = i.length;
            for (let e = 0; e < 3; ++e) {
                let t = 0;
                for (let n = 0; n < c; ++n)
                    t += i[n] * l[3 * n + e];
                a[e] = t
            }
            for (let e = 0; e < 3; ++e) {
                const t = r[e];
                if (!(t >= c))
                    for (let n = 0; n < 3; ++n)
                        a[3 * e + 3 + n] = l[3 * t + n]
            }
            for (let e = 0; e < o; ++e) {
                const t = s[e];
                if (-1 === t)
                    a.fill(3 * (4 + e), 3 * (4 + e + 1));
                else
                    for (let n = 0; n < 3; ++n)
                        a[3 * (4 + e) + n] = l[3 * t + n]
            }
            e.uniform3iv(t.uniform("uVolumeChunkStrides"), a, 0, 3 * (4 + o))
        }
        getTextureLayout(e, t) {
            return k.get(e, t)
        }
        setTextureData(e, t, n) {
            const {textureShape: i} = t;
            Object(O.g)(e, this, n, i[0], i[1], i[2])
        }
    }
    class M extends S {
        setTextureData(e) {
            let t, {source: n} = this, {chunkFormatHandler: i} = n, {chunkFormat: r} = i;
            this.chunkDataSize === n.spec.chunkDataSize ? this.textureLayout = t = i.textureLayout.addRef() : this.textureLayout = t = r.getTextureLayout(e, this.chunkDataSize),
            this.chunkFormat.setTextureData(e, t, this.data)
        }
        getValueAt(e) {
            let {chunkFormat: t} = this;
            const {chunkDataSize: n} = this;
            let i = 0
              , r = 1;
            const s = e.length;
            for (let t = 0; t < s; ++t)
                i += r * e[t],
                r *= n[t];
            let a = t.dataType
              , o = this.data;
            switch (a) {
            case w.a.UINT8:
            case w.a.FLOAT32:
            case w.a.UINT16:
            case w.a.UINT32:
                return o[i];
            case w.a.UINT64:
                {
                    let e = 2 * i;
                    return new x.a(o[e],o[e + 1])
                }
            }
            throw new Error("Invalid data type: " + a)
        }
    }
    class D extends f.a {
        constructor(e, t) {
            super(),
            this.chunkFormat = this.registerDisposer(T.get(e, t.dataType)),
            this.textureLayout = this.registerDisposer(this.chunkFormat.getTextureLayout(e, t.chunkDataSize))
        }
        getChunk(e, t) {
            return new M(e,t)
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function L(e, t, n, i, r, s) {
        let a = 0
          , o = 0
          , l = 1
          , c = 1;
        for (let e = 0; e < 3; ++e) {
            let t = r[e]
              , s = i[e]
              , u = t % s;
            a += Math.floor(t / s) * l,
            l *= Math.ceil(n[e] / s),
            o += u * c,
            c *= s
        }
        let u = t + 2 * a
          , d = e[u]
          , h = e[u + 1]
          , p = 16777215 & d
          , f = d >> 24 & 255;
        if (f > 0) {
            p += s * (e[(t + h & 16777215) + Math.floor(o * f / 32)] >> o * f % 32 & (1 << f) - 1)
        }
        return p
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function A(e, t, n, i, r) {
        return e[L(e, t, n, i, r, 1) + t]
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function I(e, t, n, i, r, s) {
        let a = L(t, n, i, r, s, 2) + n;
        return e.low = t[a],
        e.high = t[a + 1],
        e
    }
    Object(m.d)((e,t)=>null == t.compressedSegmentationBlockSize ? new D(e,t) : null);
    var P = n(1);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class R extends f.a {
        constructor(e, t) {
            super(),
            this.chunkDataSize = e,
            this.subchunkSize = t;
            const n = this.subchunkGridSize = P.t.create();
            for (let i = 0; i < 3; ++i)
                n[i] = Math.ceil(e[i] / t[i])
        }
        static get(e, t, n) {
            return e.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${Object(P.u)(t)},` + `${Object(P.u)(n)}`, ()=>new R(t,n))
        }
    }
    const j = Object(O.d)(new O.b, w.a.UINT32);
    let N = new Uint32Array(16);
    class V extends y {
        constructor(e, t, n, i) {
            super(i),
            this.dataType = e,
            this.subchunkSize = t,
            this.numChannels = n,
            this.textureAccessHelper = new O.a("chunkData")
        }
        static get(e, t, n, i) {
            let r = `sliceview.CompressedSegmentationChunkFormat:${t}:${i}`
              , s = `${r}:${Object(P.u)(n)}`;
            return e.memoize.get(s, ()=>new V(t,n,i,r))
        }
        get shaderSamplerType() {
            return "usampler2D"
        }
        defineShader(e, t) {
            super.defineShader(e, t);
            const n = 4 * (4 + t);
            N.length < n && (N = new Uint32Array(n));
            let {textureAccessHelper: i} = this;
            i.defineShader(e);
            let r = e=>"compressedSegmentationChunkFormat_" + e;
            e.addUniform("highp ivec3", "uSubchunkGridSize"),
            e.addUniform("highp ivec3", "uSubchunkSize"),
            e.addUniform("highp ivec4", "uVolumeChunkStrides", 4 + t),
            e.addFragmentCode(C.e);
            const {dataType: s} = this
              , a = Object(C.b)(s);
            s === w.a.UINT64 ? e.addFragmentCode(C.j) : e.addFragmentCode(C.i),
            e.addFragmentCode(i.getAccessor(r("readTextureValue"), "uVolumeChunkSampler", w.a.UINT32, 1));
            let o = `\nuint ${r("getChannelOffset")}(int channelIndex) {\n  if (channelIndex == 0) {\n    return ${this.numChannels}u;\n  }\n  return ${r("readTextureValue")}(uint(channelIndex)).value;\n}\n${a} getDataValue (`;
            0 === t && (o += "highp int ignoredChannel");
            for (let e = 0; e < t; ++e)
                0 !== e && (o += ", "),
                o += `highp int channelIndex${e}`;
            o += ") {\n  highp ivec3 p = getPositionWithinChunk();\n  highp ivec4 chunkPositionFull = uVolumeChunkStrides[0] +\n                     + p.x * uVolumeChunkStrides[1]\n                     + p.y * uVolumeChunkStrides[2]\n                     + p.z * uVolumeChunkStrides[3];\n";
            for (let e = 0; e < t; ++e)
                o += `\n  chunkPositionFull += channelIndex${e} * uVolumeChunkStrides[${4 + e}];\n`;
            o += `\n  highp ivec3 chunkPosition = chunkPositionFull.xyz;\n\n  // TODO: maybe premultiply this and store as uniform.\n  ivec3 subchunkGridPosition = chunkPosition / uSubchunkSize;\n  int subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);\n\n  int channelOffset = int(${r("getChannelOffset")}(chunkPositionFull[3]));\n\n  // TODO: Maybe just combine this offset into subchunkGridStrides.\n  int subchunkHeaderOffset = subchunkGridOffset * 2 + channelOffset;\n\n  highp uint subchunkHeader0 = ${r("readTextureValue")}(uint(subchunkHeaderOffset)).value;\n  highp uint subchunkHeader1 = ${r("readTextureValue")}(uint(subchunkHeaderOffset + 1)).value;\n  highp uint outputValueOffset = (subchunkHeader0 & 0xFFFFFFu) + uint(channelOffset);\n  highp uint encodingBits = subchunkHeader0 >> 24u;\n  if (encodingBits > 0u) {\n    ivec3 subchunkPosition = chunkPosition - subchunkGridPosition * uSubchunkSize;\n    int subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);\n    uint encodedValueBaseOffset = subchunkHeader1 + uint(channelOffset);\n    uint encodedValueOffset = encodedValueBaseOffset + uint(subchunkOffset) * encodingBits / 32u;\n    uint encodedValue = ${r("readTextureValue")}(encodedValueOffset).value;\n    uint wordOffset = uint(subchunkOffset) * encodingBits % 32u;\n    uint encodedValueShifted = encodedValue >> wordOffset;\n    uint decodedValue = encodedValueShifted - (encodedValueShifted >> encodingBits << encodingBits);\n    outputValueOffset += decodedValue * ${this.dataType === w.a.UINT64 ? "2u" : "1u"};\n  }\n  ${a} result;\n`,
            s === w.a.UINT64 ? o += `\n  result.value[0] = ${r("readTextureValue")}(outputValueOffset).value;\n  result.value[1] = ${r("readTextureValue")}(outputValueOffset+1u).value;\n` : o += `\n  result.value = ${r("readTextureValue")}(outputValueOffset).value;\n`,
            o += "\n  return result;\n}\n",
            e.addFragmentCode(o)
        }
        setupTextureLayout(e, t, n, i, r, s) {
            const {subchunkGridSize: a} = n;
            e.uniform3i(t.uniform("uSubchunkGridSize"), a[0], a[1], a[2]);
            const o = N
              , l = s.length;
            o.fill(0);
            for (let e = 0; e < 3; ++e) {
                o[e] = i[e];
                const t = r[e];
                -1 !== t && (o[4 * (e + 1) + t] = 1)
            }
            for (let e = 0; e < l; ++e) {
                const t = s[e];
                -1 !== t && (o[4 * (4 + e) + t] = 1)
            }
            e.uniform4iv(t.uniform("uVolumeChunkStrides"), o, 0, 4 * (l + 4))
        }
        setTextureData(e, t, n) {
            Object(O.f)(e, j, n)
        }
        getTextureLayout(e, t) {
            return R.get(e, t, this.subchunkSize)
        }
        beginSource(e, t) {
            super.beginSource(e, t);
            const {subchunkSize: n} = this;
            e.uniform3i(t.uniform("uSubchunkSize"), n[0], n[1], n[2])
        }
    }
    class B extends S {
        setTextureData(e) {
            let {data: t} = this
              , {chunkFormat: n} = this
              , i = this.textureLayout = n.getTextureLayout(e, this.chunkDataSize);
            n.setTextureData(e, i, t)
        }
        getValueAt(e) {
            let {chunkDataSize: t, chunkFormat: n} = this
              , {data: i} = this
              , r = i[e[3] || 0];
            if (n.dataType === w.a.UINT64) {
                let s = new x.a;
                return I(s, i, r, t, n.subchunkSize, e),
                s
            }
            return A(i, r, t, n.subchunkSize, e)
        }
    }
    class F extends f.a {
        constructor(e, t) {
            super();
            let {dataType: n} = t;
            if (n !== w.a.UINT64 && n !== w.a.UINT32)
                throw new Error(`Unsupported compressed segmentation data type: ${w.a[n]}`);
            this.chunkFormat = this.registerDisposer(V.get(e, t.dataType, t.compressedSegmentationBlockSize, t.chunkDataSize[3] || 1))
        }
        getChunk(e, t) {
            return new B(e,t)
        }
    }
    Object(m.d)((e,t)=>null != t.compressedSegmentationBlockSize ? new F(e,t) : null);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var _ = n(29)
      , U = n(3)
      , z = n(98);
    var G = n(77);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class $extends f.a {
        constructor(e, t, n) {
            super(),
            this.context = e,
            this.element = t,
            this.visibility = n,
            this.gl = e.gl,
            e.addPanel(this)
        }
        scheduleRedraw() {
            this.visible && this.context.scheduleRedraw()
        }
        setGLViewport() {
            let e = this.element;
            const t = e.getBoundingClientRect()
              , n = this.context.canvasRect
              , i = n.width / this.context.canvas.width
              , r = n.height / this.context.canvas.height;
            let s = (e.clientLeft + t.left - n.left) * i
              , a = e.clientWidth
              , o = (t.top - n.top + e.clientTop) * r
              , l = e.clientHeight
              , c = o + l
              , u = this.gl;
            u.enable(u.SCISSOR_TEST);
            let d = this.context.canvas.height - c;
            u.viewport(s, d, a, l),
            u.scissor(s, d, a, l)
        }
        disposed() {
            this.context.removePanel(this),
            super.disposed()
        }
        get visible() {
            return this.visibility.visible
        }
    }
    class W extends f.a {
        constructor(e) {
            super(),
            this.container = e,
            this.canvas = document.createElement("canvas"),
            this.updateStarted = new U.a,
            this.updateFinished = new U.a,
            this.changed = this.updateFinished,
            this.panels = new Set,
            this.frameNumber = 0,
            this.resizeObserver = new G.a(()=>this.scheduleRedraw()),
            this.scheduleRedraw = this.registerCancellable(Object(_.a)(()=>this.draw()));
            const {canvas: t, resizeObserver: n} = this;
            e.style.position = "relative",
            t.style.position = "absolute",
            t.style.top = "0px",
            t.style.left = "0px",
            t.style.width = "100%",
            t.style.height = "100%",
            t.style.zIndex = "0",
            n.observe(t),
            e.appendChild(t),
            this.gl = function(e) {
                let t = {
                    antialias: !1,
                    stencil: !0
                }
                  , n = e.getContext("webgl2", t);
                if (null == n)
                    throw new Error("WebGL not supported.");
                n.memoize = new z.a,
                n.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE),
                n.max3dTextureSize = n.getParameter(n.MAX_3D_TEXTURE_SIZE),
                n.maxTextureImageUnits = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
                n.tempTextureUnit = n.maxTextureImageUnits - 1;
                for (const e of ["EXT_color_buffer_float"])
                    if (!n.getExtension(e))
                        throw new Error(`${e} extension not available`);
                for (const e of ["EXT_float_blend"])
                    n.getExtension(e);
                return n
            }(t)
        }
        isReady() {
            for (const e of this.panels)
                if (e.visible && !e.isReady())
                    return !1;
            return !0
        }
        makeCanvasOverlayElement() {
            const e = document.createElement("div");
            return e.style.position = "absolute",
            e.style.top = "0px",
            e.style.left = "0px",
            e.style.width = "100%",
            e.style.height = "100%",
            e.style.zIndex = "2",
            this.container.appendChild(e),
            e
        }
        disposed() {
            this.resizeObserver.disconnect()
        }
        addPanel(e) {
            this.panels.add(e),
            this.resizeObserver.observe(e.element),
            this.scheduleRedraw()
        }
        removePanel(e) {
            this.resizeObserver.unobserve(e.element),
            this.panels.delete(e),
            this.scheduleRedraw()
        }
        draw() {
            ++this.frameNumber,
            this.updateStarted.dispatch();
            let e = this.gl
              , t = this.canvas;
            t.width = t.offsetWidth,
            t.height = t.offsetHeight,
            this.canvasRect = t.getBoundingClientRect(),
            this.gl.clearColor(0, 0, 0, 0),
            e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
            for (let e of this.panels) {
                let {element: t} = e;
                e.visible && 0 !== t.clientWidth && 0 !== t.clientHeight && 0 !== t.offsetWidth && 0 !== t.offsetHeight && (e.setGLViewport(),
                e.draw())
            }
            e.disable(e.SCISSOR_TEST),
            this.gl.clearColor(1, 1, 1, 1),
            this.gl.colorMask(!1, !1, !1, !0),
            e.clear(e.COLOR_BUFFER_BIT),
            this.gl.colorMask(!0, !0, !0, !0),
            this.updateFinished.dispatch()
        }
    }
    var H = n(16)
      , J = n.n(H)
      , q = n(14)
      , Y = n(4)
      , X = n(99);
    n(180);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function K(e, t) {
        return n=>{
            n.style.flex = e,
            t(n)
        }
    }
    function Z(e, t) {
        return n=>{
            n.style.display = "flex",
            n.style.flexDirection = e;
            for (let e of t) {
                let t = n.ownerDocument.createElement("div");
                n.appendChild(t),
                e(t)
            }
        }
    }
    var Q = n(18)
      , ee = (n(89),
    n(181),
    n(25))
      , te = n(107);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class ne extends f.a {
        constructor(e) {
            super(),
            this.gl = e,
            this.vertexBuffer = this.registerDisposer(ee.a.fromData(e, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]), e.ARRAY_BUFFER, e.STATIC_DRAW));
            this.colorBuffer = this.registerDisposer(ee.a.fromData(e, new Float32Array([1, 0, 0, .5, 1, 0, 0, .5, 0, 1, 0, .5, 0, 1, 0, .5, 0, 0, 1, .5, 0, 0, 1, .5]), e.ARRAY_BUFFER, e.STATIC_DRAW)),
            this.trivialColorShader = this.registerDisposer(Object(te.c)(e))
        }
        static get(e) {
            return e.memoize.get("SliceViewPanel:AxesLineHelper", ()=>new ne(e))
        }
        draw(e, t=!0) {
            let n = this.trivialColorShader
              , i = this.gl;
            n.bind(),
            i.uniformMatrix4fv(n.uniform("uProjectionMatrix"), !1, e);
            let r = n.attribute("aVertexPosition");
            this.vertexBuffer.bindToVertexAttrib(r, 4);
            let s = n.attribute("aColor");
            this.colorBuffer.bindToVertexAttrib(s, 4),
            t && (i.colorMask(!1, !1, !1, !0),
            i.clearColor(0, 0, 0, 0),
            i.clear(i.COLOR_BUFFER_BIT),
            i.colorMask(!0, !0, !0, !0),
            i.enable(i.BLEND),
            i.blendFunc(i.ONE_MINUS_DST_ALPHA, i.DST_ALPHA)),
            i.lineWidth(1),
            i.drawArrays(i.LINES, 0, 6),
            t && i.disable(i.BLEND),
            i.disableVertexAttribArray(r),
            i.disableVertexAttribArray(s)
        }
    }
    var ie = n(22);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var re = n(67)
      , se = n(75);
    n(182);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function ae(e, t) {
        if (!e.active)
            return;
        if (void 0 === e.pickedAnnotationId)
            return;
        const n = e.pickedRenderLayer;
        if (null === n)
            return;
        const i = e.pickedAnnotationLayer;
        if (void 0 === i)
            return;
        const r = t.renderLayerToManagedLayerMap.get(n);
        return void 0 !== r ? {
            layer: r,
            annotationLayer: i,
            id: e.pickedAnnotationId,
            partIndex: e.pickedOffset
        } : void 0
    }
    var oe = n(47);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class le {
        constructor() {
            this.renderLayers = [null],
            this.pickData = [null],
            this.values = [0, 0, 0],
            this.nextPickID = 1
        }
        clear() {
            this.renderLayers.length = 1,
            this.pickData.length = 1,
            this.values.length = 3,
            this.nextPickID = 1
        }
        registerUint64(e, t, n=1) {
            return this.register(e, n, t.low, t.high)
        }
        register(e, t=1, n=0, i=0, r=null) {
            let {renderLayers: s, values: a} = this
              , o = this.nextPickID;
            this.nextPickID += t;
            let l = s.length;
            s[l] = e;
            let c = 3 * l;
            return a[c] = o,
            a[c + 1] = n,
            a[c + 2] = i,
            this.pickData[l] = r,
            o
        }
        setMouseState(e, t) {
            const {renderLayers: n, values: i} = this;
            let r = 0
              , s = n.length - 1;
            for (; r < s; ) {
                const e = Math.ceil(r + (s - r) / 2);
                i[3 * e] > t ? s = e - 1 : r = e
            }
            const a = e.pickedRenderLayer = n[r]
              , o = 3 * r
              , l = e.pickedOffset = t - i[o];
            let {pickedValue: c} = e;
            c.low = i[o + 1],
            c.high = i[o + 2],
            e.pickedAnnotationId = void 0,
            e.pickedAnnotationLayer = void 0,
            null !== a && a.updateMouseState(e, c, l, this.pickData[r])
        }
    }
    var ce = n(38)
      , ue = n(84)
      , de = n(12)
      , he = n(15)
      , pe = n(51);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function fe(e, t, n) {
        const {document: i} = e.view;
        let r = e.clientX
          , s = e.clientY;
        const a = e=>{
            const n = e.clientX - r
              , i = e.clientY - s;
            r = e.clientX,
            s = e.clientY,
            t(e, n, i)
        }
          , o = e.button
          , l = e=>{
            i.removeEventListener("pointermove", a, !0),
            i.removeEventListener("pointerup", c, !1),
            void 0 !== n && n(e, e.clientX - r, e.clientY - s)
        }
          , c = e=>{
            e.button === o && l(e)
        }
        ;
        i.addEventListener("pointermove", a, !0),
        i.addEventListener("pointerup", c, !1),
        i.addEventListener("pointercancel", l, !1)
    }
    var me = n(115)
      , ge = n.n(me);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const ve = Math.PI / 20;
    function be(e, t) {
        return Math.sqrt(e * e + t * t)
    }
    function ye(e) {
        let[t,n] = e;
        t.identifier > n.identifier && ([n,t] = [t, n]);
        const i = t.clientX - n.clientX
          , r = t.clientY - n.clientY;
        return {
            distance: be(i, r),
            angle: Math.atan2(i, r)
        }
    }
    class Se extends f.a {
        constructor(e, t) {
            super(),
            this.target = e,
            this.eventMap = t,
            this.prevTouches = new Map,
            this.moved = !1,
            this.prevAngle = 0,
            this.rotated = !1,
            this.prevDistance = 0,
            this.pinched = !1,
            this.prevCenterX = 0,
            this.prevCenterY = 0,
            this.translated = !1,
            this.startHold = this.registerCancellable(ge()((e,t,n,i)=>{
                const r = {
                    event: e,
                    centerX: n,
                    centerY: i
                };
                this.dispatch(`touchhold${e.targetTouches.length}`, e, r, t)
            }
            , 1e3, {
                leading: !1,
                trailing: !0
            })),
            this.numPriorTaps = 0,
            this.priorTapNumTouches = 0,
            this.tapStartTime = 0,
            this.tapEndTime = 0,
            this.curTapNumTouches = 0,
            this.registerEventListener(e, "touchstart", e=>{
                this.handleTouchEvent(e)
            }
            ),
            this.registerEventListener(e, "touchmove", e=>{
                this.handleTouchEvent(e)
            }
            ),
            this.registerEventListener(e, "touchend", e=>{
                this.handleTouchEvent(e)
            }
            )
        }
        dispatch(e, t, n, i=t.eventPhase) {
            Object(o.b)(e, t, i, n, this.eventMap)
        }
        handleTouchEvent(e) {
            if (e.target !== this.target)
                return;
            e.preventDefault();
            const t = new Map
              , {prevTouches: n, prevEvent: i} = this;
            let r = 0
              , s = 0;
            for (const n of e.targetTouches)
                t.set(n.identifier, n),
                r += n.clientX,
                s += n.clientY;
            r /= t.size,
            s /= t.size;
            for (const [e,i] of n.entries()) {
                const r = t.get(e);
                if (void 0 === r)
                    n.delete(e);
                else {
                    const e = r.clientX - i.clientX
                      , t = r.clientY - i.clientY;
                    (Math.abs(e) >= 10 || Math.abs(t) >= 10) && (this.moved = !0)
                }
            }
            if (void 0 === i || i.targetTouches.length !== t.size || 0 == t.size) {
                if (this.moved = !1,
                "touchstart" === e.type)
                    this.startHold(e, e.eventPhase, r, s),
                    void 0 !== i && 0 !== i.targetTouches.length || (this.tapStartTime = Date.now(),
                    this.curTapNumTouches = 0),
                    this.curTapNumTouches = Math.max(this.curTapNumTouches, e.targetTouches.length);
                else {
                    if ("touchend" == e.type) {
                        const t = Date.now();
                        if (0 === e.targetTouches.length && t - this.tapStartTime < 400) {
                            (this.curTapNumTouches !== this.priorTapNumTouches || t - this.tapEndTime >= 500) && (this.numPriorTaps = 0),
                            ++this.numPriorTaps,
                            this.tapEndTime = t,
                            this.priorTapNumTouches = this.curTapNumTouches;
                            const n = {
                                event: e,
                                centerX: r,
                                centerY: s
                            };
                            this.dispatch(`touchtap${this.curTapNumTouches}x${this.numPriorTaps}`, e, n)
                        }
                    }
                    this.startHold.cancel()
                }
                if (this.prevTouches = t,
                this.prevEvent = e,
                this.prevCenterX = r,
                this.prevCenterY = s,
                this.translated = !1,
                2 === t.size) {
                    const {distance: e, angle: n} = ye(t.values());
                    this.prevDistance = e,
                    this.prevAngle = n,
                    this.rotated = !1,
                    this.pinched = !1
                }
                return
            }
            if (!this.moved)
                return;
            this.tapStartTime = 0,
            this.startHold.cancel(),
            this.prevTouches = t,
            this.prevEvent = e;
            let {prevCenterX: a, prevCenterY: o, translated: l} = this;
            const c = r - a
              , u = s - o;
            if (!1 === l && be(c, u) >= 10 && (l = this.translated = !0),
            !0 === l && (0 !== c || 0 !== u)) {
                this.prevCenterX = r,
                this.prevCenterY = s;
                const n = {
                    event: e,
                    deltaX: c,
                    deltaY: u,
                    centerX: r,
                    centerY: s
                };
                this.dispatch(`touchtranslate${t.size}`, e, n)
            }
            if (2 === t.size) {
                const {distance: n, angle: i} = ye(t.values());
                let {pinched: a, rotated: o, prevDistance: l, prevAngle: c} = this;
                !1 === a && Math.abs(n - l) >= 20 && (this.pinched = a = !0);
                const u = function(e, t) {
                    const n = 2 * Math.PI
                      , i = Math.abs(e - t) % n;
                    return Math.min(i, n - i)
                }(i, c);
                if (!1 === o && u >= ve && (this.rotated = o = !0),
                !0 === a && n != l) {
                    this.prevDistance = n;
                    const t = {
                        event: e,
                        distance: n,
                        prevDistance: l,
                        centerX: r,
                        centerY: s
                    };
                    this.dispatch("touchpinch", e, t)
                }
                !0 === o && i !== c && (this.prevAngle = i,
                this.dispatch("touchrotate", e, {
                    event: e,
                    centerX: r,
                    centerY: s,
                    angle: i,
                    prevAngle: c
                }))
            }
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function we(e) {
        let t = 0
          , {deltaMode: n} = e;
        switch (n) {
        case 0:
            t = .005;
            break;
        case 1:
            t = .1;
            break;
        case 2:
            t = 2
        }
        return Math.exp(e.deltaY * t)
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const xe = P.t.create();
    class Ce {
        constructor() {
            this.pickIDs = new le,
            this.viewportWidth = 0,
            this.viewportHeight = 0,
            this.invTransform = P.l.create(),
            this.frameNumber = -1
        }
    }
    class Oe {
        constructor() {
            this.buffer = null,
            this.glWindowX = 0,
            this.glWindowY = 0
        }
    }
    const ke = (()=>{
        const e = (e,t)=>(e - 5) ** 2 + (t - 5) ** 2;
        let t = new Uint32Array(121)
          , n = 0;
        for (let i = 0; i < 11; ++i)
            for (let r = 0; r < 11; ++r)
                e(i, r) > 25 || (t[n++] = 11 * r + i);
        return t = t.subarray(0, n),
        t.sort((t,n)=>{
            const i = t % 11
              , r = n % 11
              , s = (n - r) / 11;
            return e(i, (t - i) / 11) - e(r, s)
        }
        ),
        t
    }
    )();
    function Ee(e, t, n, i, r, s, a) {
        const o = i - 5
          , l = r - 5;
        if (!(o >= 0 && l >= 0 && o + 11 <= s && l + 11 <= a))
            for (let i = 0; i < 11; ++i)
                for (let r = 0; r < 11; ++r) {
                    const c = o + r
                      , u = l + i;
                    (c < 0 || u < 0 || c >= s || u >= a) && (e[t + (11 * u + c) * n] = 0)
                }
    }
    class Te extends $ {
        constructor(e, t, n) {
            super(e, t, n.visibility),
            this.viewer = n,
            this.mouseX = -1,
            this.mouseY = -1,
            this.pickRequestPending = !1,
            this.mouseStateForcer = ()=>this.blockOnPickRequest(),
            this.pickingData = [new Ce, new Ce],
            this.pickRequests = [new Oe, new Oe],
            this.pickBufferContents = new Float32Array(968),
            this.pickTimerId = -1,
            this.nextPickRequestTime = 0,
            this.pendingPickRequestTimerId = -1,
            this.pendingPickRequestTimerExpired = ()=>{
                this.pendingPickRequestTimerId = -1,
                this.pickRequestPending && this.attemptToIssuePickRequest()
            }
            ,
            this.inputEventMap = n.inputEventMap,
            t.classList.add("neuroglancer-rendered-data-panel"),
            t.classList.add("neuroglancer-panel"),
            t.classList.add("neuroglancer-noselect"),
            this.registerDisposer(new ue.a(t)),
            this.registerDisposer(new de.b(t,this.inputEventMap)),
            this.registerDisposer(new pe.b(t,this.inputEventMap)),
            this.registerDisposer(new Se(t,this.inputEventMap)),
            this.registerEventListener(t, "mousemove", this.onMousemove.bind(this)),
            this.registerEventListener(t, "touchstart", this.onTouchstart.bind(this)),
            this.registerEventListener(t, "mouseleave", ()=>this.onMouseout()),
            this.registerEventListener(t, "mouseover", e=>{
                e.target !== t && this.onMouseout()
            }
            , !0),
            Object(o.d)(t, "snap", ()=>{
                this.navigationState.pose.snap()
            }
            ),
            Object(o.d)(t, "zoom-in", ()=>{
                this.navigationState.zoomBy(.5)
            }
            ),
            Object(o.d)(t, "zoom-out", ()=>{
                this.navigationState.zoomBy(2)
            }
            ),
            Object(o.d)(t, "depth-range-decrease", ()=>{
                this.navigationState.depthRange.value *= .5
            }
            ),
            Object(o.d)(t, "depth-range-increase", ()=>{
                this.navigationState.depthRange.value *= 2
            }
            ),
            Object(o.d)(t, "highlight", ()=>{
                this.viewer.layerManager.invokeAction("highlight")
            }
            );
            for (let e = 0; e < 3; ++e) {
                let n = P.a[e];
                for (let i of [-1, 1]) {
                    let r = i < 0 ? "-" : "+";
                    Object(o.d)(t, `rotate-relative-${n}${r}`, ()=>{
                        this.navigationState.pose.rotateRelative(P.h[e], .1 * i)
                    }
                    );
                    let s = P.t.create();
                    Object(o.d)(t, `${n}${r}`, ()=>{
                        let {navigationState: t} = this
                          , n = s;
                        n[0] = 0,
                        n[1] = 0,
                        n[2] = 0,
                        n[e] = i,
                        t.pose.translateVoxelsRelative(n)
                    }
                    )
                }
            }
            Object(o.d)(t, "zoom-via-wheel", e=>{
                const t = e.detail;
                this.onMousemove(t, !1),
                this.zoomByMouse(we(t))
            }
            ),
            Object(o.d)(t, "adjust-depth-range-via-wheel", e=>{
                const t = e.detail;
                this.navigationState.depthRange.value *= we(t)
            }
            ),
            Object(o.d)(t, "translate-via-mouse-drag", e=>{
                fe(e.detail, (e,t,n)=>{
                    this.translateByViewportPixels(t, n)
                }
                )
            }
            ),
            Object(o.d)(t, "translate-in-plane-via-touchtranslate", e=>{
                const {detail: t} = e;
                this.translateByViewportPixels(t.deltaX, t.deltaY)
            }
            ),
            Object(o.d)(t, "translate-z-via-touchtranslate", e=>{
                const {detail: t} = e;
                let {navigationState: n} = this
                  , i = xe;
                i[0] = 0,
                i[1] = 0,
                i[2] = t.deltaY + t.deltaX,
                n.pose.translateVoxelsRelative(i)
            }
            );
            for (const e of [1, 10])
                Object(o.d)(t, `z+${e}-via-wheel`, t=>{
                    const n = t.detail;
                    let {navigationState: i} = this
                      , r = xe
                      , s = 0 !== n.deltaY ? n.deltaY : n.deltaX;
                    r[0] = 0,
                    r[1] = 0,
                    r[2] = (s > 0 ? -1 : 1) * e,
                    i.pose.translateVoxelsRelative(r)
                }
                );
            Object(o.d)(t, "move-to-mouse-position", ()=>{
                const {mouseState: e} = this.viewer;
                e.updateUnconditionally() && (this.navigationState.position.value = e.position)
            }
            ),
            Object(o.d)(t, "snap", ()=>this.navigationState.pose.snap()),
            Object(o.d)(t, "select-annotation", ()=>{
                const {mouseState: e, layerManager: t} = this.viewer
                  , n = ae(e, t);
                if (void 0 === n)
                    return;
                const i = n.layer.layer;
                null !== i && (this.viewer.selectedLayer.layer = n.layer,
                this.viewer.selectedLayer.visible = !0,
                i.tabs.value = "annotations",
                i.selectedAnnotation.value = {
                    id: n.id,
                    partIndex: n.partIndex,
                    sourceIndex: n.annotationLayer.sourceIndex,
                    subsource: n.annotationLayer.subsourceId
                })
            }
            ),
            Object(o.d)(t, "move-annotation", e=>{
                const {mouseState: t} = this.viewer
                  , n = t.pickedAnnotationId
                  , i = t.pickedAnnotationLayer;
                if (void 0 !== i && void 0 !== n) {
                    e.stopPropagation();
                    let r = i.source.getReference(n)
                      , s = r.value;
                    const a = Object(oe.b)(s.type)
                      , o = t.pickedOffset
                      , {chunkTransform: {value: l}} = i;
                    if (void 0 !== l.error)
                        return;
                    const {layerRank: c} = l
                      , u = new Float32Array(c);
                    a.getRepresentativePoint(u, s, t.pickedOffset);
                    let d = P.s.set(P.s.create(), 0, 0);
                    t.updateUnconditionally() && fe(e.detail, (e,t,n)=>{
                        P.s.add(d, d, [t, n]);
                        const h = new Float32Array(c);
                        he.i(h, l.chunkToLayerTransform, c + 1, u, c);
                        const p = xe
                          , {displayDimensionIndices: f} = this.navigationState.pose.displayDimensions.value;
                        Object(ce.h)(p, h, l.modelTransform, f),
                        this.translateDataPointByViewportPixels(p, p, d[0], d[1]),
                        Object(ce.a)(h, p, l.modelTransform, f);
                        const m = new Float32Array(c);
                        he.i(m, l.layerToChunkTransform, c + 1, h, c);
                        let g = a.updateViaRepresentativePoint(s, m, o);
                        i.source.update(r, g)
                    }
                    , e=>{
                        i.source.commit(r),
                        r.dispose()
                    }
                    )
                }
            }
            ),
            Object(o.d)(t, "delete-annotation", ()=>{
                const {mouseState: e} = this.viewer
                  , t = e.pickedAnnotationId
                  , n = e.pickedAnnotationLayer;
                if (void 0 !== n && !n.source.readonly && void 0 !== t) {
                    const e = n.source.getReference(t);
                    try {
                        n.source.delete(e)
                    } finally {
                        e.dispose()
                    }
                }
            }
            ),
            Object(o.d)(t, "zoom-via-touchpinch", e=>{
                const {detail: t} = e;
                this.handleMouseMove(t.centerX, t.centerY);
                const n = t.prevDistance / t.distance;
                n > .1 && n < 10 && this.zoomByMouse(n)
            }
            )
        }
        cancelPickRequests() {
            const {gl: e} = this;
            for (const t of this.pickRequests) {
                const {sync: n} = t;
                null !== n && e.deleteSync(n),
                t.sync = null
            }
            clearTimeout(this.pickTimerId),
            this.pickTimerId = -1
        }
        checkForResize() {
            const {clientWidth: e, clientHeight: t} = this.element;
            e === this.width && t === this.height || (this.width = e,
            this.height = t,
            this.panelSizeChanged())
        }
        issuePickRequestInternal(e) {
            const {gl: t} = this;
            let {buffer: n} = e;
            null === n ? (n = e.buffer = t.createBuffer(),
            t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, n),
            t.bufferData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 3872, WebGL2RenderingContext.STREAM_READ)) : t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, n);
            let i = this.mouseX
              , r = this.height - this.mouseY;
            this.issuePickRequest(i, r),
            e.sync = t.fenceSync(WebGL2RenderingContext.SYNC_GPU_COMMANDS_COMPLETE, 0),
            e.frameNumber = this.context.frameNumber,
            e.glWindowX = i,
            e.glWindowY = r,
            t.flush(),
            t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null),
            -1 === this.pickTimerId && this.scheduleCheckForPickRequestCompletion(),
            this.pickRequestPending = !1;
            const {pickRequests: s} = this;
            e !== s[0] && (s[1] = s[0],
            s[0] = e),
            this.nextPickRequestTime = Date.now() + 30
        }
        completePickInternal(e) {
            const {gl: t} = this
              , {pickBufferContents: n} = this;
            t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, e.buffer),
            t.getBufferSubData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 0, n),
            t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
            const {pickingData: i} = this
              , {frameNumber: r} = e;
            this.completePickRequest(e.glWindowX, e.glWindowY, n, i[0].frameNumber === r ? i[0] : i[1])
        }
        scheduleCheckForPickRequestCompletion() {
            this.pickTimerId = setTimeout(()=>{
                this.pickTimerId = -1,
                this.checkForPickRequestCompletion()
            }
            , 0)
        }
        checkForPickRequestCompletion(e=!1, t=!1) {
            let n = this.context.frameNumber
              , i = -1;
            e && (--n,
            i = n - 1);
            const {pickRequests: r} = this
              , {gl: s} = this;
            let a, o = !1, l = !1;
            for (const e of r) {
                const {sync: r} = e;
                if (null === r)
                    continue;
                const {frameNumber: c} = e;
                if (!l && c >= n - 1)
                    if (t || s.getSyncParameter(r, WebGL2RenderingContext.SYNC_STATUS) === WebGL2RenderingContext.SIGNALED)
                        this.completePickInternal(e),
                        l = !0;
                    else if (c !== i) {
                        o = !0;
                        continue
                    }
                s.deleteSync(r),
                e.sync = null,
                a = e
            }
            const {pickTimerId: c} = this;
            o && -1 === c ? this.scheduleCheckForPickRequestCompletion() : o || -1 === c || (clearTimeout(c),
            this.pickTimerId = -1),
            !e && void 0 !== a && this.pickRequestPending && this.canIssuePickRequest() && this.issuePickRequestInternal(a)
        }
        blockOnPickRequest() {
            this.pickRequestPending && (this.cancelPickRequests(),
            this.nextPickRequestTime = 0,
            this.attemptToIssuePickRequest()),
            this.checkForPickRequestCompletion(!1, !0)
        }
        draw() {
            this.checkForResize();
            const {width: e, height: t} = this;
            if (0 === e || 0 === t)
                return;
            this.checkForPickRequestCompletion(!0);
            const {pickingData: n} = this;
            n[0] = n[1];
            const i = this.context.frameNumber
              , r = n[1];
            r.frameNumber = i,
            r.viewportWidth = e,
            r.viewportHeight = t,
            r.pickIDs.clear(),
            this.drawWithPicking(r) ? (this.nextPickRequestTime = 0,
            this.mouseX > 0 && this.attemptToIssuePickRequest()) : r.frameNumber = -1
        }
        canIssuePickRequest() {
            const e = Date.now()
              , {nextPickRequestTime: t, pendingPickRequestTimerId: n} = this;
            return !(e < t) || (-1 == n && (this.pendingPickRequestTimerId = setTimeout(this.pendingPickRequestTimerExpired, t - e)),
            !1)
        }
        attemptToIssuePickRequest() {
            if (!this.canIssuePickRequest())
                return;
            const e = this.context.frameNumber
              , {gl: t} = this
              , {pickRequests: n} = this;
            for (const i of n) {
                let {sync: n} = i;
                if (null !== n) {
                    if (!(i.frameNumber < e - 1))
                        continue;
                    t.deleteSync(n)
                }
                return void this.issuePickRequestInternal(i)
            }
        }
        updateMousePosition(e, t) {
            if (e === this.mouseX && t === this.mouseY)
                return;
            if (this.mouseX = e,
            this.mouseY = t,
            e < 0)
                return this.pickRequestPending = !1,
                void this.cancelPickRequests();
            const n = this.context.frameNumber
              , i = this.pickingData[1];
            i.frameNumber === n && this.width === i.viewportWidth && this.height === i.viewportHeight && (this.pickRequestPending = !0,
            this.attemptToIssuePickRequest())
        }
        onMouseout() {
            this.updateMousePosition(-1, -1),
            this.viewer.mouseState.setForcer(void 0)
        }
        handleMouseMove(e, t) {
            let {element: n} = this;
            const i = n.getBoundingClientRect()
              , r = e - i.left
              , s = t - i.top
              , {mouseState: a} = this.viewer;
            a.pageX = e + window.scrollX,
            a.pageY = t + window.scrollY,
            a.setForcer(this.mouseStateForcer),
            this.updateMousePosition(r, s)
        }
        onMousemove(e, t=!0) {
            const {element: n} = this;
            t && e.target !== n || this.handleMouseMove(e.clientX, e.clientY)
        }
        onTouchstart(e) {
            let {element: t} = this;
            if (e.target !== t || 1 !== e.targetTouches.length)
                return;
            const {clientX: n, clientY: i} = e.targetTouches[0];
            this.handleMouseMove(n, i)
        }
        disposed() {
            let {mouseState: e} = this.viewer;
            e.removeForcer(this.mouseStateForcer);
            const {gl: t} = this;
            this.cancelPickRequests();
            const {pendingPickRequestTimerId: n} = this;
            -1 !== n && clearTimeout(n);
            for (const e of this.pickRequests)
                t.deleteBuffer(e.buffer);
            super.disposed()
        }
    }
    var Me, De = n(31), Le = n(52), Ae = n(17), Ie = n(100), Pe = n(26), Re = n(46), je = n(76), Ne = n(11);
    !function(e) {
        e[e.COLOR = 0] = "COLOR",
        e[e.Z = 1] = "Z",
        e[e.PICK = 2] = "PICK",
        e[e.NUM_TEXTURES = 3] = "NUM_TEXTURES"
    }(Me || (Me = {}));
    const Ve = ["\nfloat computeOITWeight(float alpha) {\n  float a = min(1.0, alpha) * 8.0 + 0.01;\n  float b = -gl_FragCoord.z * 0.95 + 1.0;\n  return a * a * a * b * b * b;\n}\n", "\nvoid emit(vec4 color, highp uint pickId) {\n  float weight = computeOITWeight(color.a);\n  vec4 accum = color * weight;\n  v4f_fragData0 = vec4(accum.rgb, color.a);\n  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);\n}\n"];
    function Be(e) {
        e.addOutputBuffer("vec4", "out_color", Me.COLOR),
        e.addOutputBuffer("highp vec4", "out_z", Me.Z),
        e.addOutputBuffer("highp vec4", "out_pickId", Me.PICK),
        e.addFragmentCode("\nvoid emit(vec4 color, highp uint pickId) {\n  out_color = color;\n  float zValue = 1.0 - gl_FragCoord.z;\n  out_z = vec4(zValue, zValue, zValue, 1.0);\n  float pickIdFloat = float(pickId);\n  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);\n}\n")
    }
    function Fe(e) {
        e.addOutputBuffer("vec4", "v4f_fragData0", 0),
        e.addOutputBuffer("vec4", "v4f_fragData1", 1),
        e.addFragmentCode(Ve)
    }
    const _e = P.t.create()
      , Ue = P.v.create()
      , ze = P.l.create();
    function Ge(e) {
        e.addOutputBuffer("vec4", "v4f_fragColor", null),
        e.setFragmentMain("\nvec4 v0 = getValue0();\nvec4 v1 = getValue1();\nvec4 accum = vec4(v0.rgb, v1.r);\nfloat revealage = v0.a;\n\nv4f_fragColor = vec4(accum.rgb / accum.a, revealage);\n")
    }
    const $e = Object(Pe.c)(Ne.b);
    class We extends $e {
        constructor(e) {
            super(),
            this.panel = e
        }
        initializeCounterpart(e, t) {
            this.sharedProjectionParameters = this.registerDisposer(new De.d(e,this.panel.projectionParameters)),
            t.projectionParameters = this.sharedProjectionParameters.rpcId,
            super.initializeCounterpart(e, t)
        }
    }
    class He extends Te {
        constructor(e, t, n) {
            super(e, t, n),
            this.sliceViews = this.registerDisposer(new Ie.a((e,t,n)=>{
                e.registerDisposer(n),
                e.registerDisposer(n.visibility.add(this.visibility))
            }
            )),
            this.axesLineHelper = this.registerDisposer(ne.get(this.gl)),
            this.sliceViewRenderHelper = this.registerDisposer(Le.e.get(this.gl, Be)),
            this.offscreenFramebuffer = this.registerDisposer(new Re.b(this.gl,{
                colorBuffers: [new Re.e(this.gl,WebGL2RenderingContext.RGBA8,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE), new Re.e(this.gl,WebGL2RenderingContext.R32F,WebGL2RenderingContext.RED,WebGL2RenderingContext.FLOAT), new Re.e(this.gl,WebGL2RenderingContext.R32F,WebGL2RenderingContext.RED,WebGL2RenderingContext.FLOAT)],
                depthBuffer: new Re.a(this.gl)
            })),
            this.offscreenCopyHelper = this.registerDisposer(Re.c.get(this.gl)),
            this.transparencyCopyHelper = this.registerDisposer(Re.c.get(this.gl, Ge, 2)),
            this.scaleBars = this.registerDisposer(new je.a(this.gl)),
            this.projectionParameters = this.registerDisposer(new De.a({
                navigationState: this.navigationState,
                update: (e,t)=>{
                    const {invViewMatrix: n, projectionMat: i, width: r, height: s} = e
                      , a = r / s
                      , o = Math.PI / 4;
                    let {relativeDepthRange: l} = t;
                    let c = t.zoomFactor.value / 2;
                    if (this.viewer.orthographicProjection.value) {
                        const e = Math.max(.1, 1 - l)
                          , t = 1 + l;
                        P.l.ortho(i, -a, a, -1, 1, e, t)
                    } else {
                        const e = 1 / Math.tan(o / 2);
                        l /= e;
                        const t = Math.max(.1, 1 - l)
                          , n = 1 + l;
                        c *= e,
                        P.l.perspective(i, o, a, t, n)
                    }
                    t.pose.toMat4(n, c),
                    P.l.scale(n, n, P.t.set(_e, 1, -1, -1)),
                    P.l.translate(n, n, P.h[2]),
                    Object(se.c)(e)
                }
            })),
            this.projectionParameters.changed.add(()=>this.context.scheduleRedraw());
            const i = this.sharedObject = this.registerDisposer(new We(this));
            if (i.RPC_TYPE_ID = "perspective_view/PerspectiveView",
            i.initializeCounterpart(n.rpc, {}),
            i.visibility.add(this.visibility),
            this.visibleLayerTracker = Object(ie.p)(this.viewer.layerManager, re.a, this.viewer.visibleLayerRoles, this),
            Object(o.d)(t, "rotate-via-mouse-drag", e=>{
                fe(e.detail, (e,t,n)=>{
                    this.navigationState.pose.rotateRelative(P.h[1], t / 4 * Math.PI / 180),
                    this.navigationState.pose.rotateRelative(P.h[0], -n / 4 * Math.PI / 180)
                }
                )
            }
            ),
            Object(o.d)(t, "rotate-in-plane-via-touchrotate", e=>{
                const {detail: t} = e;
                this.navigationState.pose.rotateRelative(P.h[2], t.angle - t.prevAngle)
            }
            ),
            Object(o.d)(t, "rotate-out-of-plane-via-touchtranslate", e=>{
                const {detail: t} = e;
                this.navigationState.pose.rotateRelative(P.h[1], t.deltaX / 4 * Math.PI / 180),
                this.navigationState.pose.rotateRelative(P.h[0], -t.deltaY / 4 * Math.PI / 180)
            }
            ),
            n.showSliceViewsCheckbox) {
                let e = this.registerDisposer(new Ae.c(n.showSliceViews));
                e.element.className = "perspective-panel-show-slice-views neuroglancer-noselect";
                let t = document.createElement("label");
                t.className = "perspective-panel-show-slice-views neuroglancer-noselect",
                t.appendChild(document.createTextNode("Sections")),
                t.appendChild(e.element),
                this.element.appendChild(t)
            }
            this.registerDisposer(n.orthographicProjection.changed.add(()=>{
                this.projectionParameters.update(),
                this.scheduleRedraw()
            }
            )),
            this.registerDisposer(n.showScaleBar.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.scaleBarOptions.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.showSliceViews.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.showAxisLines.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.crossSectionBackgroundColor.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.perspectiveViewBackgroundColor.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.wireFrame.changed.add(()=>this.scheduleRedraw())),
            this.sliceViews.changed.add(()=>this.scheduleRedraw())
        }
        get rpc() {
            return this.sharedObject.rpc
        }
        get rpcId() {
            return this.sharedObject.rpcId
        }
        get displayDimensionRenderInfo() {
            return this.navigationState.displayDimensionRenderInfo
        }
        flushBackendProjectionParameters() {
            this.sharedObject.sharedProjectionParameters.flush()
        }
        translateByViewportPixels(e, t) {
            const n = _e
              , {viewProjectionMat: i, invViewProjectionMat: r, width: s, height: a} = this.projectionParameters.value
              , {pose: o} = this.viewer.navigationState;
            o.updateDisplayPosition(o=>{
                P.t.transformMat4(n, o, i),
                n[0] = -2 * e / s,
                n[1] = 2 * t / a,
                P.t.transformMat4(o, n, r)
            }
            )
        }
        get navigationState() {
            return this.viewer.navigationState
        }
        isReady() {
            if (!this.visible)
                return !0;
            for (const [e,t] of this.sliceViews)
                if ((t || this.viewer.showSliceViews.value) && !e.isReady())
                    return !1;
            this.checkForResize();
            const {width: e, height: t} = this;
            if (0 === e || 0 === t)
                return !0;
            const n = {
                projectionParameters: this.projectionParameters.value
            }
              , {visibleLayers: i} = this.visibleLayerTracker;
            for (const [e,t] of i)
                if (!e.isReady(n, t))
                    return !1;
            return !0
        }
        panelSizeChanged() {
            this.projectionParameters.setViewportShape(this.width, this.height)
        }
        disposed() {
            this.sliceViews.clear(),
            super.disposed()
        }
        issuePickRequest(e, t) {
            const {offscreenFramebuffer: n} = this;
            n.readPixelFloat32IntoBuffer(Me.Z, e - 5, t - 5, 0, 11, 11),
            n.readPixelFloat32IntoBuffer(Me.PICK, e - 5, t - 5, 1936, 11, 11)
        }
        completePickRequest(e, t, n, i) {
            const {mouseState: r} = this.viewer;
            r.pickedRenderLayer = null,
            Ee(n, 0, 4, e, t, i.viewportWidth, i.viewportHeight);
            const s = ke.length;
            for (let a = 0; a < s; ++a) {
                const s = ke[a];
                let o = n[4 * s];
                if (0 === o)
                    continue;
                const l = s % 11
                  , c = (s - l) / 11;
                let u = 1 - o;
                _e[0] = 2 * (e + l - 5) / i.viewportWidth - 1,
                _e[1] = 2 * (t + c - 5) / i.viewportHeight - 1,
                _e[2] = 2 * u - 1,
                P.t.transformMat4(_e, _e, i.invTransform);
                let {position: d} = r;
                const {value: h} = this.navigationState.position
                  , p = h.length;
                d.length !== p && (d = r.position = new Float32Array(p)),
                d.set(h);
                const f = this.navigationState.pose.displayDimensions.value
                  , {displayDimensionIndices: m} = f;
                for (let e = 0, t = m.length; e < t; ++e)
                    d[m[e]] = _e[e];
                const g = n[484 + 4 * s];
                return i.pickIDs.setMouseState(r, g),
                r.displayDimensions = f,
                void r.setActive(!0)
            }
            r.setActive(!1)
        }
        translateDataPointByViewportPixels(e, t, n, i) {
            const r = _e
              , {viewProjectionMat: s, invViewProjectionMat: a, width: o, height: l} = this.projectionParameters.value;
            return P.t.transformMat4(r, t, s),
            r[0] += 2 * n / o,
            r[1] += -2 * i / l,
            P.t.transformMat4(e, r, a)
        }
        get transparentConfiguration() {
            let e = this.transparentConfiguration_;
            return void 0 === e && (e = this.transparentConfiguration_ = this.registerDisposer(new Re.b(this.gl,{
                colorBuffers: Object(Re.f)(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
                depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef()
            }))),
            e
        }
        drawWithPicking(e) {
            if (!this.navigationState.valid)
                return !1;
            const {width: t, height: n} = this
              , i = this.viewer.showSliceViews.value;
            for (const [e,t] of this.sliceViews)
                (t || i) && e.updateRendering();
            let r = this.gl;
            this.offscreenFramebuffer.bind(t, n),
            r.disable(r.SCISSOR_TEST);
            const s = this.viewer.perspectiveViewBackgroundColor.value;
            this.gl.clearColor(s[0], s[1], s[2], 0),
            r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT),
            r.enable(r.DEPTH_TEST);
            const a = this.projectionParameters.value;
            let o = P.t.create();
            P.t.transformQuat(o, P.h[2], this.navigationState.pose.orientation.orientation),
            P.t.scale(o, o, -1);
            const l = {
                wireFrame: this.viewer.wireFrame.value,
                projectionParameters: a,
                lightDirection: o,
                ambientLighting: .2,
                directionalLighting: .8,
                pickIDs: e.pickIDs,
                emitter: Be,
                emitColor: !0,
                emitPickID: !0,
                alreadyEmittedPickID: !1
            };
            P.l.copy(e.invTransform, a.invViewProjectionMat);
            const {visibleLayers: c} = this.visibleLayerTracker;
            let u = !1
              , d = !1;
            for (const [e,t] of c)
                e.isTransparent ? u = !0 : e.isAnnotation ? d = !0 : e.draw(l, t);
            if (this.drawSliceViews(l),
            d) {
                r.enable(WebGL2RenderingContext.BLEND),
                r.depthFunc(WebGL2RenderingContext.LEQUAL),
                r.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                for (const [e,t] of c)
                    e.isAnnotation && e.draw(l, t);
                r.depthFunc(WebGL2RenderingContext.LESS),
                r.disable(WebGL2RenderingContext.BLEND)
            }
            if (this.viewer.showAxisLines.value && this.drawAxisLines(),
            u) {
                r.depthMask(!1),
                r.enable(WebGL2RenderingContext.BLEND);
                const {transparentConfiguration: e} = this;
                e.bind(t, n),
                this.gl.clearColor(0, 0, 0, 1),
                r.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT),
                l.emitter = Fe,
                r.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA),
                l.emitPickID = !1;
                for (const [e,t] of c)
                    e.isTransparent && e.draw(l, t);
                r.disable(WebGL2RenderingContext.DEPTH_TEST),
                this.offscreenFramebuffer.bindSingle(Me.COLOR),
                r.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA),
                this.transparencyCopyHelper.draw(e.colorBuffers[0].texture, e.colorBuffers[1].texture),
                r.depthMask(!0),
                r.disable(WebGL2RenderingContext.BLEND),
                r.enable(WebGL2RenderingContext.DEPTH_TEST),
                this.offscreenFramebuffer.bind(t, n)
            }
            r.drawBuffers([r.NONE, r.COLOR_ATTACHMENT1, r.COLOR_ATTACHMENT2]),
            l.emitter = Be,
            l.emitPickID = !0,
            l.emitColor = !1,
            r.enable(WebGL2RenderingContext.POLYGON_OFFSET_FILL),
            r.polygonOffset(-1, -1);
            for (const [e,t] of c)
                e.isTransparent && e.draw(l, t);
            if (r.disable(WebGL2RenderingContext.POLYGON_OFFSET_FILL),
            this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
                r.drawBuffers([r.COLOR_ATTACHMENT0]),
                r.disable(WebGL2RenderingContext.DEPTH_TEST),
                r.enable(WebGL2RenderingContext.BLEND),
                r.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                const {scaleBars: e} = this
                  , n = this.viewer.scaleBarOptions.value;
                e.draw(t, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value / this.height, n),
                r.disable(WebGL2RenderingContext.BLEND)
            }
            return this.offscreenFramebuffer.unbind(),
            this.setGLViewport(),
            this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[Me.COLOR].texture),
            !0
        }
        drawSliceViews(e) {
            let {sliceViewRenderHelper: t} = this
              , {lightDirection: n, ambientLighting: i, directionalLighting: r, projectionParameters: {viewProjectionMat: s}} = e;
            const a = this.viewer.showSliceViews.value;
            for (const [e,o] of this.sliceViews) {
                if (!o && !a)
                    continue;
                const {width: l, height: c, invViewMatrix: u, viewportNormalInCanonicalCoordinates: d} = e.projectionParameters.value;
                if (0 === l || 0 === c || !e.valid)
                    continue;
                let h = i + Math.abs(P.t.dot(n, d)) * r
                  , p = ze;
                P.l.identity(p),
                p[0] = l / 2,
                p[5] = -c / 2,
                P.l.multiply(p, u, p),
                P.l.multiply(p, s, p);
                const f = Ue
                  , m = this.viewer.crossSectionBackgroundColor.value;
                f[0] = m[0],
                f[1] = m[1],
                f[2] = m[2],
                f[3] = 1,
                t.draw(e.offscreenFramebuffer.colorBuffers[0].texture, p, P.v.fromValues(h, h, h, 1), Ue, 0, 0, 1, 1)
            }
        }
        drawAxisLines() {
            const {position: {value: e}, zoomFactor: {value: t}, displayDimensionRenderInfo: {value: {canonicalVoxelFactors: n, displayDimensionIndices: i}}} = this.viewer.navigationState
              , r = t * (Math.min(this.width, this.height) / this.height / 4)
              , s = ze;
            P.l.identity(s);
            for (let t = 0; t < 3; ++t) {
                const a = i[t];
                s[12 + t] = -1 === a ? 0 : e[a],
                s[5 * t] = r / n[t]
            }
            P.l.multiply(s, this.projectionParameters.value.viewProjectionMat, s);
            const {gl: a} = this;
            a.drawBuffers([a.COLOR_ATTACHMENT0]),
            this.axesLineHelper.draw(s, !1)
        }
        zoomByMouse(e) {
            this.navigationState.zoomBy(e)
        }
    }
    var Je, qe = n(65);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function Ye(e) {
        e.addOutputBuffer("vec4", "out_fragColor", 0),
        e.addOutputBuffer("highp vec4", "out_pickId", 1),
        e.addFragmentCode("\nvoid emit(vec4 color, highp uint pickId) {\n  out_fragColor = color;\n  float pickIdFloat = float(pickId);\n  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);\n}\n")
    }
    function Xe(e) {
        e.addOutputBuffer("vec4", "out_fragColor", null),
        e.addFragmentCode("\nvoid emit(vec4 color, highp uint pickId) {\n  out_fragColor = color;\n}\n")
    }
    !function(e) {
        e[e.COLOR = 0] = "COLOR",
        e[e.PICK = 1] = "PICK",
        e[e.NUM_TEXTURES = 2] = "NUM_TEXTURES"
    }(Je || (Je = {}));
    const Ke = P.t.create()
      , Ze = P.t.create()
      , Qe = P.v.create();
    class et extends Te {
        constructor(e, t, n, i) {
            super(e, t, i),
            this.sliceView = n,
            this.axesLineHelper = this.registerDisposer(ne.get(this.gl)),
            this.sliceViewRenderHelper = this.registerDisposer(Le.e.get(this.gl, Xe)),
            this.colorFactor = P.v.fromValues(1, 1, 1, 1),
            this.pickIDs = new le,
            this.offscreenFramebuffer = this.registerDisposer(new Re.b(this.gl,{
                colorBuffers: [new Re.e(this.gl,WebGL2RenderingContext.RGBA8,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE), new Re.e(this.gl,WebGL2RenderingContext.R32F,WebGL2RenderingContext.RED,WebGL2RenderingContext.FLOAT)]
            })),
            this.offscreenCopyHelper = this.registerDisposer(Re.c.get(this.gl)),
            this.scaleBars = this.registerDisposer(new je.a(this.gl)),
            i.wireFrame.changed.add(()=>this.scheduleRedraw()),
            Object(o.d)(t, "rotate-via-mouse-drag", e=>{
                const {mouseState: t} = this.viewer;
                if (t.updateUnconditionally()) {
                    const n = Float32Array.from(t.position);
                    fe(e.detail, (e,t,i)=>{
                        const {pose: r} = this.navigationState
                          , s = P.t.transformQuat(Ke, P.h[0], r.orientation.orientation)
                          , a = P.t.transformQuat(Ze, P.h[1], r.orientation.orientation);
                        this.viewer.navigationState.pose.rotateAbsolute(a, -t / 4 * Math.PI / 180, n),
                        this.viewer.navigationState.pose.rotateAbsolute(s, -i / 4 * Math.PI / 180, n)
                    }
                    )
                }
            }
            ),
            Object(o.d)(t, "rotate-in-plane-via-touchrotate", e=>{
                const {detail: t} = e
                  , {mouseState: n} = this.viewer;
                this.handleMouseMove(t.centerX, t.centerY),
                n.updateUnconditionally() && this.navigationState.pose.rotateAbsolute(this.sliceView.projectionParameters.value.viewportNormalInCanonicalCoordinates, t.angle - t.prevAngle, n.position)
            }
            ),
            this.registerDisposer(n),
            this.visibleLayerTracker = Object(ie.p)(this.viewer.layerManager, qe.a, this.viewer.visibleLayerRoles, this),
            this.registerDisposer(i.crossSectionBackgroundColor.changed.add(()=>this.scheduleRedraw())),
            this.registerDisposer(n.visibility.add(this.visibility)),
            this.registerDisposer(n.viewChanged.add(()=>{
                this.visible && e.scheduleRedraw()
            }
            )),
            this.registerDisposer(i.showAxisLines.changed.add(()=>{
                this.visible && this.scheduleRedraw()
            }
            )),
            this.registerDisposer(i.showScaleBar.changed.add(()=>{
                this.visible && this.context.scheduleRedraw()
            }
            )),
            this.registerDisposer(i.scaleBarOptions.changed.add(()=>{
                this.visible && this.context.scheduleRedraw()
            }
            ))
        }
        flushBackendProjectionParameters() {
            this.sliceView.flushBackendProjectionParameters()
        }
        get displayDimensionRenderInfo() {
            return this.navigationState.displayDimensionRenderInfo
        }
        get rpc() {
            return this.sliceView.rpc
        }
        get rpcId() {
            return this.sliceView.rpcId
        }
        get navigationState() {
            return this.sliceView.navigationState
        }
        translateByViewportPixels(e, t) {
            const {pose: n} = this.viewer.navigationState;
            n.updateDisplayPosition(n=>{
                P.t.set(n, -e, -t, 0),
                P.t.transformMat4(n, n, this.sliceView.projectionParameters.value.invViewMatrix)
            }
            )
        }
        translateDataPointByViewportPixels(e, t, n, i) {
            const r = this.sliceView.projectionParameters.value;
            return P.t.transformMat4(e, t, r.viewMatrix),
            P.t.set(e, e[0] + n, e[1] + i, e[2]),
            P.t.transformMat4(e, e, r.invViewMatrix),
            e
        }
        isReady() {
            if (!this.visible)
                return !1;
            const {sliceView: e} = this;
            if (!e.isReady())
                return !1;
            const t = {
                projectionParameters: e.projectionParameters.value,
                sliceView: e
            };
            for (const [e,n] of this.visibleLayerTracker.visibleLayers)
                if (!e.isReady(t, n))
                    return !1;
            return !0
        }
        drawWithPicking(e) {
            const {sliceView: t} = this;
            if (!t.valid)
                return !1;
            t.projectionParameters.setViewportShape(this.width, this.height),
            t.updateRendering();
            const n = t.projectionParameters.value
              , {width: i, height: r, invViewMatrix: s, viewProjectionMat: a} = n;
            P.l.copy(e.invTransform, s);
            const {gl: o} = this;
            this.offscreenFramebuffer.bind(i, r),
            o.disable(WebGL2RenderingContext.SCISSOR_TEST),
            this.gl.clearColor(0, 0, 0, 0),
            o.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
            const l = Qe
              , c = this.viewer.crossSectionBackgroundColor.value;
            l[0] = c[0],
            l[1] = c[1],
            l[2] = c[2],
            l[3] = 1,
            this.offscreenFramebuffer.bindSingle(Je.COLOR),
            this.sliceViewRenderHelper.draw(t.offscreenFramebuffer.colorBuffers[0].texture, P.e, this.colorFactor, l, 0, 0, 1, 1);
            const {visibleLayers: u} = this.visibleLayerTracker;
            let {pickIDs: d} = this;
            d.clear();
            const {displayDimensionRenderInfo: h} = n
              , p = {
                wireFrame: this.viewer.wireFrame.value,
                projectionParameters: n,
                pickIDs: d,
                emitter: Ye,
                emitColor: !0,
                emitPickID: !0,
                sliceView: t
            };
            this.offscreenFramebuffer.bind(i, r),
            o.enable(WebGL2RenderingContext.BLEND),
            o.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            for (const [e,t] of u)
                e.draw(p, t);
            if (o.disable(WebGL2RenderingContext.BLEND),
            this.viewer.showAxisLines.value || this.viewer.showScaleBar.value) {
                let e = P.l.create();
                if (this.viewer.showAxisLines.value) {
                    P.l.copy(e, a);
                    for (let t = 0; t < 3; ++t)
                        e[12 + t] = 0;
                    for (let t = 0; t < 4; ++t)
                        e[2 + 4 * t] = 0;
                    const t = Math.min(i, r) / 4 * 1.5
                      , s = n.pixelSize
                      , {voxelPhysicalScales: o, displayRank: l} = h;
                    for (let n = 0; n < l; ++n)
                        for (let i = 0; i < 2; ++i)
                            e[4 * n + i] *= t * s / o[n]
                }
                this.offscreenFramebuffer.bindSingle(Je.COLOR),
                this.viewer.showAxisLines.value && this.axesLineHelper.draw(e),
                this.viewer.showScaleBar.value && (o.enable(WebGL2RenderingContext.BLEND),
                o.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA),
                this.scaleBars.draw(this.width, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value, this.viewer.scaleBarOptions.value),
                o.disable(WebGL2RenderingContext.BLEND))
            }
            return this.offscreenFramebuffer.unbind(),
            this.setGLViewport(),
            this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[Je.COLOR].texture),
            !0
        }
        panelSizeChanged() {
            this.sliceView.projectionParameters.setViewportShape(this.width, this.height)
        }
        issuePickRequest(e, t) {
            const {offscreenFramebuffer: n} = this;
            n.readPixelFloat32IntoBuffer(Je.PICK, e - 5, t - 5, 0, 11, 11)
        }
        completePickRequest(e, t, n, i) {
            const {mouseState: r} = this.viewer;
            r.pickedRenderLayer = null,
            Ee(n, 0, 4, e, t, i.viewportWidth, i.viewportHeight);
            const {viewportWidth: s, viewportHeight: a} = i
              , o = ke.length
              , l = (n,o)=>{
                const l = n % 11
                  , c = (n - l) / 11
                  , u = i.viewportHeight - (t + c - 5);
                P.t.set(Ke, e + l - 5 - s / 2, u - a / 2, 0),
                P.t.transformMat4(Ke, Ke, i.invTransform);
                let {position: d} = r;
                const {value: h} = this.navigationState.position
                  , p = h.length;
                d.length !== p && (d = r.position = new Float32Array(p)),
                d.set(h);
                const f = this.navigationState.pose.displayDimensions.value
                  , {displayRank: m, displayDimensionIndices: g} = f;
                for (let e = 0; e < m; ++e)
                    d[g[e]] = Ke[e];
                this.pickIDs.setMouseState(r, o),
                r.displayDimensions = f,
                r.setActive(!0)
            }
            ;
            for (let e = 0; e < o; ++e) {
                const t = ke[e]
                  , i = n[4 * e];
                if (0 !== i)
                    return void l(t, i)
            }
            l(0, 0)
        }
        zoomByMouse(e) {
            const {navigationState: t} = this;
            if (!t.valid)
                return;
            const {sliceView: n} = this
              , {width: i, height: r, invViewMatrix: s, displayDimensionRenderInfo: {displayDimensionIndices: a, displayRank: o}} = n.projectionParameters.value;
            let {mouseX: l, mouseY: c} = this;
            l -= i / 2,
            c -= r / 2;
            const u = this.navigationState.position.value;
            for (let t = 0; t < o; ++t) {
                const n = a[t]
                  , i = s[t] * l + s[4 + t] * c;
                u[n] += i * (1 - e)
            }
            this.navigationState.position.changed.dispatch(),
            t.zoomBy(e)
        }
    }
    var tt = n(7)
      , nt = n(0)
      , it = (n(183),
    n(6))
      , rt = n(116)
      , st = n(37);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const at = ["#f00", "#0f0", "#00f"]
      , ot = pe.a.fromObject({
        arrowup: {
            action: "move-up"
        },
        arrowdown: {
            action: "move-down"
        },
        wheel: {
            action: "adjust-via-wheel"
        },
        enter: {
            action: "commit"
        },
        escape: {
            action: "cancel"
        }
    });
    function lt(e) {
        if (e < 1 || e > 1024) {
            const t = 0 | Math.log2(e)
              , n = e / 2 ** t;
            return `${Object(rt.a)(n, 1)}p${t}`
        }
        return e.toString()
    }
    const ct = [e=>e.name, e=>e.scaleFactor];
    class ut extends f.a {
        constructor(e, t, n, i="px") {
            super(),
            this.displayDimensionRenderInfo = e,
            this.zoom = t,
            this.depthRange = n,
            this.displayUnit = i,
            this.element = document.createElement("div"),
            this.dimensionGridContainer = document.createElement("div"),
            this.depthGridContainer = document.createElement("div"),
            this.defaultCheckbox = document.createElement("input"),
            this.dimensionElements = Array.from(Array(3), (e,t)=>{
                const n = document.createElement("div");
                n.classList.add("neuroglancer-display-dimensions-widget-dimension"),
                n.style.display = "contents",
                Object(de.c)(n, "adjust-via-wheel", e=>{
                    const n = e.detail
                      , {deltaY: i} = n;
                    0 !== i && this.zoomDimension(t, Math.sign(i))
                }
                );
                const i = document.createElement("input");
                i.classList.add("neuroglancer-display-dimensions-widget-name"),
                i.title = "Change display dimensions",
                i.spellcheck = !1,
                i.autocomplete = "off",
                i.style.color = at[t],
                i.style.gridColumn = "1",
                i.style.gridRow = `${t + 1}`,
                i.addEventListener("focus", ()=>{
                    i.select()
                }
                ),
                n.appendChild(i);
                const s = document.createElement("span");
                s.classList.add("neuroglancer-display-dimensions-widget-scale-factor");
                const a = document.createElement("input");
                a.spellcheck = !1,
                a.title = "Change relative scale at which dimension is displayed",
                a.autocomplete = "off",
                s.style.gridColumn = "2",
                s.style.gridRow = `${t + 1}`,
                a.addEventListener("focus", ()=>{
                    a.select()
                }
                ),
                s.appendChild(a),
                n.appendChild(s);
                const o = document.createElement("span");
                o.classList.add("neuroglancer-display-dimensions-widget-scale"),
                o.style.gridColumn = "3",
                o.style.gridRow = `${t + 1}`,
                n.appendChild(o),
                this.dimensionGridContainer.appendChild(n);
                const l = {
                    name: i,
                    container: n,
                    scaleFactor: a,
                    scale: o,
                    scaleFactorModified: !1
                };
                i.addEventListener("input", ()=>{
                    Object(r.e)(i),
                    this.updateNameValidity()
                }
                ),
                Object(de.c)(i, "commit", ()=>{
                    this.updateNames()
                }
                ),
                i.addEventListener("blur", e=>{
                    const {relatedTarget: t} = e;
                    this.dimensionElements.some(e=>e.name === t) || this.updateNames() || this.updateView()
                }
                ),
                s.addEventListener("click", e=>{
                    const {target: t} = e;
                    t !== a && (a.focus(),
                    e.preventDefault())
                }
                ),
                a.addEventListener("input", ()=>{
                    Object(r.e)(a),
                    l.scaleFactorModified = !0
                }
                ),
                Object(de.c)(a, "commit", ()=>{
                    this.updateScaleFactors()
                }
                ),
                a.addEventListener("blur", ()=>{
                    this.updateScaleFactors() || this.updateView()
                }
                );
                for (const e of ct)
                    Object(de.c)(e(l), "move-up", ()=>{
                        0 !== t && e(this.dimensionElements[t - 1]).focus()
                    }
                    ),
                    Object(de.c)(e(l), "move-down", ()=>{
                        2 !== t && e(this.dimensionElements[t + 1]).focus()
                    }
                    );
                return l
            }
            ),
            this.scheduleUpdateView = Object(_.a)(()=>this.updateView());
            const {element: s, dimensionGridContainer: a, defaultCheckbox: o} = this
              , l = document.createElement("label")
              , c = this.registerCancellable(J()(()=>{
                s.dataset.active = "false"
            }
            , 2e3))
              , u = ()=>{
                s.dataset.active = "true",
                c()
            }
            ;
            this.registerDisposer(t.changed.add(u)),
            this.registerDisposer(e.relativeDisplayScales.changed.add(u)),
            this.registerDisposer(n.changed.add(u)),
            s.classList.add("neuroglancer-display-dimensions-widget"),
            s.appendChild(a),
            a.classList.add("neuroglancer-display-dimensions-widget-dimension-grid"),
            s.addEventListener("pointerleave", ()=>{
                const e = document.activeElement;
                e instanceof HTMLElement && s.contains(e) && e.blur()
            }
            ),
            o.type = "checkbox",
            l.appendChild(o),
            l.appendChild(document.createTextNode("Default")),
            l.title = "Display first 3 dimensions",
            l.classList.add("neuroglancer-display-dimensions-widget-default"),
            o.addEventListener("change", ()=>{
                this.updateDefault()
            }
            ),
            a.appendChild(l),
            this.registerDisposer(e),
            this.registerDisposer(n),
            this.registerDisposer(t.changed.add(this.scheduleUpdateView)),
            this.registerDisposer(e.changed.add(this.scheduleUpdateView)),
            this.registerDisposer(new de.b(s,ot)).allShortcutsAreGlobal = !0,
            this.registerDisposer(new pe.b(s,ot)),
            Object(de.c)(a, "cancel", ()=>{
                this.updateView();
                const e = document.activeElement;
                e instanceof HTMLElement && s.contains(e) && e.blur()
            }
            );
            const {depthGridContainer: d} = this;
            d.classList.add("neuroglancer-depth-range-widget-grid"),
            s.appendChild(d);
            const h = document.createElement("label")
              , p = document.createElement("input");
            p.type = "checkbox",
            h.classList.add("neuroglancer-depth-range-relative-checkbox-label"),
            p.classList.add("neuroglancer-depth-range-relative-checkbox"),
            h.appendChild(p),
            h.appendChild(document.createTextNode("Zoom-relative")),
            p.addEventListener("change", ()=>{
                const e = p.checked;
                let t = this.depthRange.value;
                e !== t < 0 && (t = e ? -t / this.zoom.value : -t * this.zoom.value,
                this.depthRange.value = t)
            }
            ),
            h.title = "Depth range is multiplied by scale",
            s.appendChild(h),
            Object(de.c)(d, "adjust-via-wheel", e=>{
                const t = e.detail
                  , {deltaY: n} = t;
                if (0 === n)
                    return;
                const i = this.depthRange.value;
                this.depthRange.value = i * 2 ** Math.sign(n)
            }
            ),
            this.registerDisposer(Object(tt.j)((e,t,{factors: n})=>{
                Object(r.b)(d);
                const {displayRank: i, globalDimensionNames: s, displayDimensionIndices: a, displayDimensionUnits: o, canonicalVoxelFactors: l, canonicalVoxelPhysicalSize: c} = t
                  , u = []
                  , h = ()=>{
                    p.checked = this.depthRange.value < 0;
                    let e = this.depthRange.value;
                    e < 0 && (e *= -this.zoom.value);
                    for (const t of u) {
                        const {input: n} = t;
                        n.value = Object(st.b)(e * t.scale, t.unit, {
                            precision: 2,
                            elide1: !1
                        }),
                        Object(r.e)(n)
                    }
                }
                  , f = e=>{
                    const t = Object(st.c)(e.input.value);
                    if (void 0 === t || t.unit !== e.unit)
                        return !1;
                    let n = t.scale / e.scale;
                    return this.depthRange.value < 0 && (n = -n / this.zoom.value),
                    this.depthRange.value = n,
                    !0
                }
                ;
                for (let e = 0; e < i; ++e) {
                    const t = a[e]
                      , i = s[t]
                      , p = o[e]
                      , m = n[t];
                    let g = u.find(e=>e.unit === p && e.factor === m);
                    if (void 0 === g) {
                        const t = document.createElement("div");
                        t.title = "Visible depth range",
                        t.style.display = "contents",
                        d.appendChild(t);
                        const n = document.createElement("span");
                        n.textContent = "",
                        t.appendChild(n);
                        const i = document.createElement("input");
                        i.spellcheck = !1,
                        i.autocomplete = "off",
                        i.addEventListener("focus", ()=>{
                            i.select()
                        }
                        ),
                        Object(de.c)(i, "commit", ()=>{
                            f(g)
                        }
                        ),
                        i.addEventListener("change", ()=>{
                            f(g) || h()
                        }
                        ),
                        i.addEventListener("input", ()=>{
                            Object(r.e)(i)
                        }
                        ),
                        t.appendChild(i);
                        const s = document.createElement("span");
                        s.classList.add("neuroglancer-depth-range-widget-dimension-names"),
                        t.appendChild(s),
                        g = {
                            unit: p,
                            factor: m,
                            dimensionNames: [],
                            input: i,
                            label: s,
                            scale: c * l[e]
                        },
                        u.push(g)
                    }
                    g.dimensionNames.push(i)
                }
                for (const e of u)
                    e.dimensionNames.length !== i && (e.label.textContent = e.dimensionNames.join(" "));
                e.registerDisposer(Object(de.c)(d, "cancel", ()=>{
                    h();
                    const e = document.activeElement;
                    e instanceof HTMLElement && d.contains(e) && e.blur()
                }
                ));
                const m = e.registerCancellable(Object(_.a)(h));
                e.registerDisposer(this.depthRange.changed.add(m)),
                e.registerDisposer(this.zoom.changed.add(m)),
                h()
            }
            , e, this.relativeDisplayScales)),
            this.updateView()
        }
        zoomDimension(e, t) {
            this.updateScaleFactors();
            const {displayDimensions: n} = this
              , {relativeDisplayScales: i} = this
              , {displayDimensionIndices: r} = n.value
              , s = r[e];
            if (-1 === s)
                return;
            const {factors: a} = i.value
              , o = new Float64Array(a);
            o[s] *= 2 ** -t,
            i.setFactors(o)
        }
        updateNameValidity() {
            const {dimensionElements: e} = this
              , {displayDimensionIndices: t} = this.displayDimensions.value
              , n = e.map(e=>e.name.value)
              , i = Object(Y.r)(n)
              , r = this.displayDimensions.coordinateSpace.value
              , {names: s} = r
              , a = n.length;
            for (let r = 0; r < a; ++r) {
                let a = i[r];
                const o = n[r];
                let l = -1;
                0 === o.length ? a = !0 : (l = s.indexOf(o),
                -1 === l && (a = !1));
                const c = e[r];
                c.name.dataset.isValid = a.toString(),
                c.container.dataset.isModified = (l !== t[r]).toString()
            }
        }
        get displayDimensions() {
            return this.displayDimensionRenderInfo.displayDimensions
        }
        get relativeDisplayScales() {
            return this.displayDimensionRenderInfo.relativeDisplayScales
        }
        updateNames() {
            const e = this.dimensionElements.map(e=>e.name.value).filter(e=>e.length > 0);
            if (!Object(Y.F)(e))
                return !1;
            const {displayDimensions: t} = this.displayDimensionRenderInfo;
            if (0 === e.length)
                return t.reset(),
                !0;
            const n = new Int32Array(3);
            n.fill(-1);
            const i = t.coordinateSpace.value
              , {names: r} = i
              , s = e.length;
            for (let t = 0; t < s; ++t) {
                const i = r.indexOf(e[t]);
                if (-1 === i)
                    return !1;
                n[t] = i
            }
            return !!Object(it.a)(n, t.value.displayDimensionIndices) || (t.setDimensionIndices(s, n),
            !0)
        }
        updateDefault() {
            this.displayDimensions.default = this.defaultCheckbox.checked
        }
        updateScaleFactors() {
            const {displayDimensions: e} = this
              , {relativeDisplayScales: t} = this
              , {displayDimensionIndices: n, displayRank: i} = e.value
              , {factors: r} = t.value
              , {dimensionElements: s} = this
              , a = new Float64Array(r);
            for (let e = 0; e < i; ++e) {
                const t = s[e];
                if (!t.scaleFactorModified)
                    continue;
                const i = Number(t.scaleFactor.value)
                  , r = n[e];
                !Number.isFinite(i) || i <= 0 || (a[r] = i)
            }
            return Object(it.a)(a, r) || t.setFactors(a),
            !0
        }
        updateView() {
            const {dimensionElements: e, displayDimensions: {default: t}} = this
              , {displayDimensionIndices: n, canonicalVoxelFactors: i, displayDimensionUnits: s, displayDimensionScales: a, globalDimensionNames: o} = this.displayDimensionRenderInfo.value
              , {factors: l} = this.relativeDisplayScales.value;
            this.defaultCheckbox.checked = t;
            const c = this.zoom.value
              , u = n[0];
            let d = !0;
            if (-1 !== u) {
                const e = s[0]
                  , t = l[u];
                for (let i = 1; i < 3; ++i) {
                    const r = n[i];
                    if (-1 !== r && (s[i] !== e || l[r] !== t)) {
                        d = !1;
                        break
                    }
                }
            }
            for (let t = 0; t < 3; ++t) {
                const u = n[t]
                  , h = e[t];
                if (delete h.name.dataset.isValid,
                h.container.dataset.isModified = (-1 === u).toString(),
                -1 === u)
                    h.name.value = "",
                    h.scale.textContent = "",
                    h.scaleFactor.value = "";
                else {
                    h.name.value = o[u];
                    const e = a[t] * c / i[t];
                    if (0 !== t && d)
                        h.scale.textContent = "";
                    else {
                        const n = Object(st.b)(e, s[t], {
                            precision: 2,
                            elide1: !1
                        });
                        h.scale.textContent = `${n}/${this.displayUnit}`
                    }
                    h.scaleFactor.value = lt(l[u])
                }
                Object(r.e)(h.name),
                Object(r.e)(h.scaleFactor)
            }
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const dt = new Map([["xy", void 0], ["xz", P.o.rotateX(P.o.create(), P.o.create(), Math.PI / 2)], ["yz", P.o.rotateY(P.o.create(), P.o.create(), Math.PI / 2)]])
      , ht = new Map([["4panel", ""], ["3d", ""]]);
    function pt(e, t) {
        return function(e, t) {
            let n;
            return n = void 0 === t ? e.navigationState.addRef() : new Q.i(new Q.a(e.navigationState.pose.position.addRef(),e.navigationState.pose.displayDimensionRenderInfo.addRef(),Q.j.makeRelative(e.navigationState.pose.orientation, t)),e.navigationState.zoomFactor.addRef(),e.navigationState.depthRange.addRef()),
            new Le.b(e.chunkManager,e.layerManager,n,e.wireFrame)
        }(e, dt.get(t))
    }
    function ft(e) {
        return {
            crossSectionBackgroundColor: e.crossSectionBackgroundColor,
            perspectiveViewBackgroundColor: e.perspectiveViewBackgroundColor,
            mouseState: e.mouseState,
            layerManager: e.layerManager,
            showAxisLines: e.showAxisLines,
            wireFrame: e.wireFrame,
            visibleLayerRoles: e.visibleLayerRoles,
            selectedLayer: e.selectedLayer,
            visibility: e.visibility,
            scaleBarOptions: e.scaleBarOptions
        }
    }
    function mt(e) {
        const {viewer: t} = e;
        return Object.assign(Object.assign({}, ft(t)), {
            navigationState: t.perspectiveNavigationState,
            inputEventMap: t.inputEventBindings.perspectiveView,
            orthographicProjection: e.specification.orthographicProjection,
            showScaleBar: t.showScaleBar,
            rpc: t.chunkManager.rpc
        })
    }
    function gt(e) {
        return Object.assign(Object.assign({}, ft(e)), {
            navigationState: e.navigationState,
            inputEventMap: e.inputEventBindings.sliceView
        })
    }
    function vt(e, t) {
        const {navigationState: n} = t;
        t.element.appendChild(e.registerDisposer(new ut(n.pose.displayDimensionRenderInfo.addRef(),n.zoomFactor,n.depthRange.addRef(),t instanceof et ? "px" : "vh")).element)
    }
    function bt(e, t, n) {
        const i = document.createElement("div");
        i.className = "neuroglancer-data-panel-layout-controls",
        e.registerDisposer(()=>Object(r.c)(i));
        for (let i = 0; i < 2; ++i) {
            const r = n[Math.min(n.length - 1, i)];
            e.registerDisposer(Object(o.d)(t.element, 0 === i ? "toggle-layout" : "toggle-layout-alternative", t=>{
                e.container.name = r,
                t.stopPropagation()
            }
            ))
        }
        for (const t of n) {
            const n = document.createElement("button")
              , r = document.createElement("div");
            n.appendChild(r),
            r.textContent = ht.get(t),
            n.title = `Switch to ${t} layout.`,
            n.addEventListener("click", ()=>{
                e.container.name = t
            }
            ),
            i.appendChild(n)
        }
        t.element.appendChild(i)
    }
    function yt(e, t) {
        const n = new Le.b(e.chunkManager,e.layerManager,t.navigationState.addRef(),e.wireFrame)
          , i = ()=>{
            n.projectionParameters.setViewportShape(t.width.value, t.height.value)
        }
        ;
        return n.registerDisposer(t.width.changed.add(i)),
        n.registerDisposer(t.height.changed.add(i)),
        i(),
        n
    }
    function St(e, t, n) {
        const i = new Map;
        (()=>{
            const r = new Set;
            for (const s of n.values()) {
                if (r.add(s),
                i.has(s))
                    continue;
                const n = yt(e, s);
                t.sliceViews.set(n, !0),
                i.set(s, n)
            }
            for (const [e,n] of i)
                r.has(e) || t.sliceViews.delete(n)
        }
        )()
    }
    class wt extends f.a {
        constructor(e, t, n, i) {
            super(),
            this.container = e,
            this.rootElement = t,
            this.viewer = n;
            let r = (s = n,
            new Map([["xy", pt(s, "xy")], ["xz", pt(s, "xz")], ["yz", pt(s, "yz")]]));
            var s;
            let {display: a} = n;
            const o = Object.assign(Object.assign({}, mt(e)), {
                showSliceViews: n.showPerspectiveSliceViews,
                showSliceViewsCheckbox: !0
            })
              , l = Object.assign(Object.assign({}, gt(n)), {
                showScaleBar: n.showScaleBar
            })
              , c = Object.assign(Object.assign({}, gt(n)), {
                showScaleBar: new Ae.b(!1,!1)
            })
              , u = (e,t,n,i)=>{
                const s = this.registerDisposer(new et(a,t,r.get(e),n));
                return i && vt(this, s),
                bt(this, s, [e, `${e}-3d`]),
                s
            }
            ;
            let d = [K(1, Z("column", [K(1, Z("row", [K(1, e=>{
                u("xy", e, l, !0)
            }
            ), K(1, e=>{
                u("xz", e, c, !1)
            }
            )])), K(1, Z("row", [K(1, e=>{
                let t = this.registerDisposer(new He(a,e,o));
                for (let e of r.values())
                    t.sliceViews.set(e.addRef(), !1);
                vt(this, t),
                St(n, t, i),
                bt(this, t, ["3d"])
            }
            ), K(1, e=>{
                u("yz", e, c, !1)
            }
            )]))]))];
            Z("row", d)(t)
        }
        disposed() {
            Object(r.b)(this.rootElement),
            super.disposed()
        }
    }
    class xt extends f.a {
        constructor(e, t, n, i, r, s) {
            super(),
            this.container = e,
            this.rootElement = t,
            this.viewer = n,
            this.direction = i;
            let a = pt(n, r)
              , {display: o} = n;
            const l = Object.assign(Object.assign({}, mt(e)), {
                showSliceViews: n.showPerspectiveSliceViews,
                showSliceViewsCheckbox: !0
            })
              , c = Object.assign(Object.assign({}, gt(n)), {
                showScaleBar: n.showScaleBar
            });
            K(1, Z(i, [K(1, e=>{
                const t = this.registerDisposer(new et(o,e,a,c));
                vt(this, t),
                bt(this, t, [r, "4panel"])
            }
            ), K(1, e=>{
                let t = this.registerDisposer(new He(o,e,l));
                t.sliceViews.set(a.addRef(), !1),
                St(n, t, s),
                vt(this, t),
                bt(this, t, ["3d", "4panel"])
            }
            )]))(t)
        }
        disposed() {
            Object(r.b)(this.rootElement),
            super.disposed()
        }
    }
    class Ct extends f.a {
        constructor(e, t, n, i) {
            super(),
            this.container = e,
            this.rootElement = t,
            this.viewer = n;
            let r = pt(n, i);
            const s = Object.assign(Object.assign({}, gt(n)), {
                showScaleBar: n.showScaleBar
            });
            Z("row", [K(1, e=>{
                const t = this.registerDisposer(new et(n.display,e,r,s));
                vt(this, t),
                bt(this, t, ["4panel", `${i}-3d`])
            }
            )])(t)
        }
        disposed() {
            Object(r.b)(this.rootElement),
            super.disposed()
        }
    }
    class Ot extends f.a {
        constructor(e, t, n, i) {
            super(),
            this.container = e,
            this.rootElement = t,
            this.viewer = n;
            let r = Object.assign(Object.assign({}, mt(e)), {
                showSliceViews: new Ae.b(!1,!1)
            });
            Z("row", [K(1, e=>{
                const t = this.registerDisposer(new He(n.display,e,r));
                St(n, t, i),
                vt(this, t),
                bt(this, t, ["4panel"])
            }
            )])(t)
        }
        disposed() {
            Object(r.b)(this.rootElement),
            super.disposed()
        }
    }
    const kt = new Map([["4panel", {
        factory: (e,t,n,i)=>new wt(e,t,n,i)
    }], ["3d", {
        factory: (e,t,n,i)=>new Ot(e,t,n,i)
    }]]);
    for (const e of dt.keys()) {
        kt.set(e, {
            factory: (t,n,i)=>new Ct(t,n,i,e)
        });
        const t = `${e}-3d`;
        ht.set(e, ""),
        ht.set(t, ""),
        kt.set(t, {
            factory: (t,n,i,r)=>new xt(t,n,i,"row",e,r)
        })
    }
    function Et(e) {
        let t = kt.get(e);
        if (void 0 === t)
            throw new Error(`Invalid layout name: ${JSON.stringify(e)}.`);
        return t
    }
    function Tt(e) {
        return Et(e),
        e
    }
    class Mt extends f.a {
        constructor(e) {
            super(),
            this.width = new tt.c(1e3,nt.D),
            this.height = new tt.c(1e3,nt.D),
            this.changed = new U.a,
            this.position = new Q.e(e.position.addRef()),
            this.position.changed.add(this.changed.dispatch),
            this.orientation = new Q.d(e.pose.orientation.addRef()),
            this.orientation.changed.add(this.changed.dispatch),
            this.width.changed.add(this.changed.dispatch),
            this.height.changed.add(this.changed.dispatch),
            this.scale = new Q.g(e.zoomFactor.addRef(),e.zoomFactor.displayDimensionRenderInfo.addRef()),
            this.scale.changed.add(this.changed.dispatch),
            this.navigationState = this.registerDisposer(new Q.i(new Q.a(this.position.value,e.pose.displayDimensionRenderInfo.addRef(),this.orientation.value),this.scale.value,e.depthRange.addRef()))
        }
        restoreState(e) {
            Object(nt.w)(e),
            Object(s.c)(e, "width", this.width),
            Object(s.c)(e, "height", this.height),
            Object(s.c)(e, "position", Object(Q.r)(this.position)),
            Object(s.c)(e, "orientation", this.orientation),
            Object(s.c)(e, "scale", this.scale),
            Object(s.c)(e, "zoom", Object(Q.r)(this.scale))
        }
        reset() {
            this.width.reset(),
            this.height.reset(),
            this.position.reset(),
            this.orientation.reset(),
            this.scale.reset()
        }
        toJSON() {
            return {
                width: this.width.toJSON(),
                height: this.height.toJSON(),
                position: this.position.toJSON(),
                orientation: this.orientation.toJSON(),
                scale: this.scale.toJSON()
            }
        }
    }
    class Dt extends Ie.a {
        constructor(e) {
            super((e,t)=>e.registerDisposer(e.registerDisposer(t).changed.add(this.changed.dispatch))),
            this.parentNavigationState = e,
            this.registerDisposer(e)
        }
        restoreState(e) {
            Object(nt.w)(e);
            for (const t of Object.keys(e)) {
                const n = new Mt(this.parentNavigationState);
                try {
                    this.set(t, n.addRef()),
                    n.restoreState(e[t])
                } finally {
                    n.dispose()
                }
            }
        }
        reset() {
            this.clear()
        }
        toJSON() {
            if (0 === this.size)
                return;
            const e = {};
            for (const [t,n] of this)
                e[t] = n.toJSON();
            return e
        }
    }
    class Lt extends f.a {
        constructor(e, t) {
            super(),
            this.changed = new U.a,
            this.orthographicProjection = new Ae.b(!1),
            this.type = new tt.c(t,Tt),
            this.type.changed.add(this.changed.dispatch),
            this.crossSections = this.registerDisposer(new Dt(e.addRef())),
            this.crossSections.changed.add(this.changed.dispatch),
            this.orthographicProjection.changed.add(this.changed.dispatch),
            this.registerDisposer(e)
        }
        reset() {
            this.crossSections.clear(),
            this.orthographicProjection.reset(),
            this.type.reset()
        }
        restoreState(e) {
            this.crossSections.clear(),
            this.orthographicProjection.reset(),
            "string" == typeof e ? this.type.restoreState(e) : (Object(nt.w)(e),
            Object(nt.y)(e, "type", e=>this.type.restoreState(e)),
            Object(nt.y)(e, "orthographicProjection", e=>this.orthographicProjection.restoreState(e)),
            Object(nt.y)(e, "crossSections", e=>void 0 !== e && this.crossSections.restoreState(e)))
        }
        toJSON() {
            const {type: e, crossSections: t, orthographicProjection: n} = this
              , i = n.toJSON();
            return 0 === t.size && void 0 === i ? e.value : {
                type: e.value,
                crossSections: t.toJSON(),
                orthographicProjection: i
            }
        }
    }
    class At extends f.a {
        constructor(e, t) {
            super(),
            this.viewer = e,
            this.element = document.createElement("div"),
            this.specification = this.registerDisposer(new Lt(this.viewer.navigationState.addRef(),t)),
            this.element.style.flex = "1";
            const n = this.registerCancellable(J()(()=>this.updateLayout(), 0));
            this.specification.type.changed.add(n),
            Object(o.d)(this.element, "toggle-orthographic-projection", ()=>this.specification.orthographicProjection.toggle()),
            this.registerDisposer(this.viewer.display.updateStarted.add(()=>n.flush())),
            n()
        }
        get name() {
            return this.specification.type.value
        }
        set name(e) {
            this.specification.type.value = e
        }
        get changed() {
            return this.specification.changed
        }
        toJSON() {
            return this.specification.toJSON()
        }
        restoreState(e) {
            this.specification.restoreState(e)
        }
        reset() {
            this.specification.reset()
        }
        disposeLayout() {
            let {layout: e} = this;
            void 0 !== e && (e.dispose(),
            this.layout = void 0)
        }
        updateLayout() {
            this.disposeLayout(),
            this.layout = Et(this.name).factory(this, this.element, this.viewer, this.specification.crossSections)
        }
        disposed() {
            this.disposeLayout(),
            super.disposed()
        }
    }
    var It = n(50)
      , Pt = n(58);
    n(184);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function Rt(e) {
        return e.startsWith("key") ? e.substring(3) : e.startsWith("digit") ? e.substring(5) : e.startsWith("arrow") ? e.substring(5) : e
    }
    class jt extends Pt.a {
        constructor(e) {
            super();
            let {content: t} = this;
            t.classList.add("describe-key-bindings");
            let n = document.createElement("div");
            n.classList.add("describe-key-bindings-container");
            const i = new Map;
            function r(e, t) {
                if (i.has(t))
                    return;
                const n = {
                    label: e,
                    entries: new Map
                };
                !function e(t, n) {
                    for (const i of t.parents)
                        void 0 !== i.label ? r(i.label, i) : e(i, n);
                    for (const [e,i] of t.bindings.entries()) {
                        const t = e.indexOf(":")
                          , r = e.substring(t + 1);
                        n.set(r, i.action)
                    }
                }(t, n.entries),
                i.set(t, n)
            }
            for (const [t,n] of e)
                r(t, n);
            for (const e of i.values()) {
                let t = document.createElement("h2");
                t.textContent = e.label,
                n.appendChild(t);
                for (const [t,i] of e.entries) {
                    let e = document.createElement("div");
                    e.className = "dt",
                    e.textContent = t.split("+").map(Rt).join("+");
                    let r = document.createElement("div");
                    r.className = "dd",
                    r.textContent = i,
                    n.appendChild(e),
                    n.appendChild(r)
                }
            }
            t.appendChild(n)
        }
    }
    n(185),
    n(186),
    n(187);
    var Nt = n(94)
      , Vt = n.n(Nt)
      , Bt = n(106);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function Ft(e) {
        return Object(Bt.b)((new TextEncoder).encode(e))
    }
    function _t(e, t) {
        var n;
        if (e.startsWith(t))
            try {
                const i = (n = e.substring(t.length),
                (new TextDecoder).decode(Object(Bt.a)(n)));
                return JSON.parse(i)
            } catch (e) {
                return
            }
    }
    let Ut;
    function zt(e, t) {
        return e.dataTransfer.dropEffect = t,
        Ut = t,
        t
    }
    function Gt() {
        return Ut
    }
    let $t;
    function Wt(e, t) {
        var n, i;
        let r;
        e.dataTransfer.setData((n = "neuroglancer-layer\0",
        i = t.layers.map(e=>({
            name: e.name,
            visible: e.visible
        })),
        n + Ft(JSON.stringify(i))), JSON.stringify({
            layers: t.layers.map(e=>e.toJSON()),
            layout: t.layoutSpec
        })),
        void 0 !== $t && $t.disposer();
        let s = ()=>{
            t.manager.unregisterDisposer(s);
            for (const e of t.layers)
                e.dispose();
            t.manager.dispose(),
            $t === r && ($t = void 0)
        }
        ;
        $t = r = {
            manager: t.manager.addRef(),
            layers: t.layers.map(e=>e.addRef()),
            layoutSpec: t.layoutSpec,
            disposer: s
        }
    }
    function Ht(e) {
        if (void 0 !== $t) {
            if (e && "move" === e.dataTransfer.dropEffect) {
                const e = new Set($t.layers);
                $t.manager.layerManager.filter(t=>!e.has(t))
            }
            $t.disposer()
        }
    }
    function Jt(e) {
        return function(e, t) {
            for (const n of e) {
                const e = _t(n, t);
                if (void 0 !== e)
                    return {
                        parameters: e,
                        dragType: n
                    }
            }
        }(e.dataTransfer.types, "neuroglancer-layer\0")
    }
    function qt(e) {
        if (void 0 !== $t && $t.manager.rootLayers === e.rootLayers)
            return $t
    }
    class Yt {
        finalize(e) {
            const {dragType: t} = this;
            if (void 0 !== t)
                try {
                    const {layers: n, layout: i} = JSON.parse(e.dataTransfer.getData(t));
                    if (!Array.isArray(n) || this.numSourceLayers !== n.length)
                        throw new Error("Invalid layer drop data");
                    this.layoutSpec = i;
                    for (const [e,t] of this.layers)
                        this.manager.initializeLayerFromSpec(e, n[t]);
                    return !0
                } catch (e) {
                    return !1
                }
            return !0
        }
        get method() {
            return void 0 !== this.sourceManager ? this.manager === this.sourceManager ? "move" : "link" : "copy"
        }
        compatibleWithMethod(e) {
            return this.method === e || !this.moveSupported && "move" === e
        }
    }
    function Xt(e, t, n=!1) {
        return e.shiftKey ? "copy" : e.ctrlKey ? "move" : function(e, t=!1) {
            const n = qt(e);
            return void 0 === n ? "copy" : t || n.manager !== e ? "link" : "move"
        }(t, n)
    }
    function Kt(e, t, n, i, r) {
        const s = qt(t)
          , a = !r && void 0 !== s && s.manager === t;
        if (!n && void 0 !== s) {
            const e = new Yt;
            if (e.manager = t,
            e.numSourceLayers = s.layers.length,
            e.sourceManager = s.manager,
            e.moveSupported = a,
            e.layers = new Map,
            e.layoutSpec = s.layoutSpec,
            !r && s.manager === t) {
                if (!i)
                    return;
                s.layers.forEach((t,n)=>{
                    e.layers.set(t, n)
                }
                )
            }
            return s.layers.forEach((n,i)=>{
                !r && t.layerManager.has(n) || e.layers.set(n.addRef(), i)
            }
            ),
            e
        }
        const o = Jt(e);
        if (void 0 !== o)
            try {
                const e = Object(nt.b)(o.parameters, (e,n)=>{
                    const i = Object(nt.y)(e, "name", nt.E)
                      , r = Object(nt.y)(e, "visible", nt.n)
                      , s = new ie.e(i,null,t);
                    return s.visible = r,
                    [s, n]
                }
                )
                  , n = new Yt;
                return n.numSourceLayers = e.length,
                n.moveSupported = a,
                n.manager = t,
                n.dragType = o.dragType,
                n.layers = new Map(e),
                n
            } catch (e) {}
    }
    var Zt = n(101)
      , Qt = n(36);
    n(188);
    var en = n(137)
      , tn = n.n(en);
    /**
 * @license
 * Copyright 2017-2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const nn = pe.a.fromObject({
        arrowup: {
            action: "adjust-up"
        },
        arrowdown: {
            action: "adjust-down"
        },
        arrowleft: {
            action: "maybe-tab-backward",
            preventDefault: !1
        },
        arrowright: {
            action: "maybe-tab-forward",
            preventDefault: !1
        },
        tab: {
            action: "tab-forward"
        },
        "shift+tab": {
            action: "tab-backward"
        },
        wheel: {
            action: "adjust-via-wheel"
        },
        backspace: {
            action: "delete-backward",
            preventDefault: !1
        },
        enter: {
            action: "commit"
        },
        escape: {
            action: "cancel"
        }
    })
      , rn = [e=>e.nameElement, e=>e.coordinate, e=>e.scaleElement];
    class sn {
        constructor(e) {
            this.coordinateSpace = e,
            this.container = document.createElement("div"),
            this.nameContainer = document.createElement("span"),
            this.nameElement = document.createElement("input"),
            this.scaleContainer = document.createElement("span"),
            this.scaleElement = document.createElement("input"),
            this.coordinate = document.createElement("input"),
            this.dropdownOwner = void 0,
            this.modified = !1,
            this.draggingPosition = !1,
            this.hasFocus = !1;
            const {container: t, scaleElement: n, scaleContainer: i, coordinate: r, nameElement: s, nameContainer: a} = this;
            t.title = "",
            t.classList.add("neuroglancer-position-dimension"),
            t.draggable = !0,
            t.tabIndex = -1,
            t.appendChild(a),
            t.appendChild(n),
            a.appendChild(s),
            a.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).",
            i.appendChild(n),
            s.classList.add("neuroglancer-position-dimension-name"),
            s.disabled = !0,
            s.spellcheck = !1,
            s.autocomplete = "off",
            s.required = !0,
            s.placeholder = " ",
            i.classList.add("neuroglancer-position-dimension-scale-container"),
            n.classList.add("neuroglancer-position-dimension-scale"),
            n.disabled = !0,
            n.spellcheck = !1,
            n.autocomplete = "off",
            i.title = "Drag to reorder, double click to change scale",
            t.appendChild(i),
            t.appendChild(r),
            r.type = "text",
            r.classList.add("neuroglancer-position-dimension-coordinate"),
            r.spellcheck = !1,
            r.autocomplete = "off",
            r.pattern = String.raw`(-?\d+(?:\.(?:\d+)?)?)`,
            r.required = !0,
            r.placeholder = " "
        }
    }
    function an(e, t, n, i) {
        return Math.floor((e - t) * (i - 1) / (n - t))
    }
    function on(e, t) {
        Object(r.e)(e, t.length + 1)
    }
    function ln(e) {
        const {value: t} = e;
        Object(r.e)(e),
        e.parentElement.dataset.isEmpty = "" === t ? "true" : "false"
    }
    class cn extends f.a {
        constructor(e, t, {copyButton: n=!0}={}) {
            super(),
            this.position = e,
            this.combiner = t,
            this.element = document.createElement("div"),
            this.dimensionContainer = document.createElement("div"),
            this.coordinateSpace = void 0,
            this.dimensionWidgets = new Map,
            this.dimensionWidgetList = [],
            this.dragSource = void 0;
            const {element: r, dimensionContainer: s} = this;
            if (this.registerDisposer(e.coordinateSpace.changed.add(this.registerCancellable(Object(_.a)(()=>this.updateDimensions())))),
            r.className = "neuroglancer-position-widget",
            s.style.display = "contents",
            r.appendChild(s),
            n) {
                const t = /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                function(e={}) {
                    return Object(Qt.a)(Object.assign({
                        svg: tn.a
                    }, e))
                }({
                    title: "Copy position to clipboard",
                    onClick: ()=>{
                        const e = /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                        function(e, t="text/plain") {
                            let n = !1;
                            const i = Object(f.e)(document, "copy", i=>{
                                const {clipboardData: r} = i;
                                null !== r && (r.setData(t, e),
                                n = !0),
                                i.stopPropagation(),
                                i.preventDefault()
                            }
                            , !0);
                            try {
                                document.execCommand("copy")
                            } finally {
                                i()
                            }
                            return n
                        }(this.getPositionText());
                        i.a.showTemporaryMessage(e ? "Position copied to clipboard" : "Failed to copy position to clipboard")
                    }
                });
                t.addEventListener("dragstart", t=>{
                    t.dataTransfer.setData("neuroglancer-position", JSON.stringify({
                        position: e.toJSON(),
                        dimensions: e.coordinateSpace.value.names
                    })),
                    t.dataTransfer.setData("text", this.getPositionText()),
                    t.stopPropagation()
                }
                ),
                t.draggable = !0,
                r.appendChild(t)
            }
            this.registerDisposer(e.changed.add(this.registerCancellable(Object(_.a)(()=>this.updateView())))),
            this.registerDisposer(new de.b(r,nn)).allShortcutsAreGlobal = !0,
            this.registerDisposer(new pe.b(r,nn)),
            this.registerDisposer(Object(de.c)(r, "cancel", e=>{
                this.coordinateSpace = void 0,
                this.updateView(),
                this.closeDropdown();
                const {target: t} = e;
                t instanceof HTMLElement && t.blur()
            }
            )),
            this.updateView()
        }
        openDropdown(e) {
            if (void 0 !== e.dropdownOwner)
                return;
            this.closeDropdown();
            const t = e.dropdownOwner = new f.a
              , n = document.createElement("div");
            n.draggable = !0,
            n.addEventListener("dragstart", e=>{
                e.stopPropagation(),
                e.preventDefault()
            }
            ),
            n.addEventListener("pointerenter", ()=>{
                e.hasFocus = !0
            }
            ),
            n.tabIndex = -1,
            n.classList.add("neuroglancer-position-dimension-dropdown");
            const i = document.createElement("canvas")
              , s = i.getContext("2d")
              , a = document.createElement("div")
              , o = document.createElement("div");
            o.appendChild(a);
            const l = document.createTextNode("");
            a.appendChild(l);
            const c = document.createElement("div")
              , u = document.createElement("div");
            o.classList.add("neuroglancer-position-dimension-dropdown-lowerbound"),
            c.classList.add("neuroglancer-position-dimension-dropdown-upperbound"),
            u.classList.add("neuroglancer-position-dimension-dropdown-hoverposition"),
            n.appendChild(o),
            n.appendChild(c),
            n.appendChild(u),
            n.appendChild(i),
            e.container.appendChild(n);
            let d, h;
            i.width = 35,
            i.height = 100,
            c.style.marginTop = "99px";
            let p = void 0;
            const m = ()=>{
                const t = this.dimensionWidgetList.indexOf(e);
                if (-1 === t)
                    return;
                const {coordinateSpace: r} = e
                  , o = function(e, t, n) {
                    const {boundingBoxes: i, bounds: r} = e
                      , s = Math.floor(r.lowerBounds[t])
                      , a = Math.ceil(r.upperBounds[t] - 1);
                    if (!Number.isFinite(s) || !Number.isFinite(a))
                        return;
                    const o = []
                      , l = e=>an(e, s, a, n)
                      , {rank: c} = e;
                    for (const e of i) {
                        const n = Object(Y.e)(e, t, c);
                        void 0 !== n && (n.lower = l(n.lower),
                        n.upper = l(Math.ceil(n.upper - 1)),
                        o.push(n))
                    }
                    return o.sort((e,t)=>{
                        const n = e.lower - t.lower;
                        return 0 !== n ? n : t.upper - t.upper
                    }
                    ),
                    Object(it.d)(o, (e,t)=>{
                        if (0 === t)
                            return !0;
                        const n = o[t - 1];
                        return n.lower !== e.lower || n.upper !== e.upper
                    }
                    ),
                    {
                        lowerBound: s,
                        upperBound: a,
                        normalizedBounds: o
                    }
                }(r, t, 100);
                if (void 0 === o || r.bounds.lowerBounds[t] + 1 === r.bounds.upperBounds[t])
                    return n.style.display = "none",
                    void (e.container.dataset.dropdownVisible = void 0);
                e.container.dataset.dropdownVisible = "true",
                n.style.display = "";
                const {lowerBound: f, upperBound: m} = o;
                d = f,
                h = m,
                l.textContent = f.toString(),
                c.textContent = m.toString(),
                function(e, t, n) {
                    t.clearRect(0, 0, e.width, e.height);
                    const {normalizedBounds: i} = n;
                    function r(e) {
                        t.fillRect(0, e, 10, 1)
                    }
                    t.fillStyle = "#fff";
                    for (const {lower: e, upper: t} of i)
                        r(e),
                        r(t);
                    const s = i.length;
                    t.fillStyle = "#ccc";
                    for (let e = 0; e < s; ++e) {
                        const {lower: n, upper: r} = i[e]
                          , a = Math.floor(15 * e / s)
                          , o = Math.max(1, 15 / s);
                        t.fillRect(a + 10, n, o, r + 1 - n)
                    }
                }(i, s, o);
                const g = this.position.value[t];
                if (g >= f && g <= m && (s.fillStyle = "#f66",
                s.fillRect(0, an(g, f, m, 100), 35, 1)),
                void 0 !== p && p >= f && p <= m) {
                    s.fillStyle = "#66f";
                    const e = an(p, f, m, 100);
                    s.fillRect(0, e, 35, 1),
                    u.textContent = p.toString();
                    const t = a.clientHeight;
                    a.style.visibility = e > t ? "" : "hidden",
                    c.style.visibility = e < 100 - t ? "" : "hidden",
                    u.style.display = "",
                    u.style.visibility = "visible",
                    u.style.marginTop = `${e}px`
                } else
                    a.style.visibility = "",
                    u.style.display = "none",
                    c.style.visibility = ""
            }
              , g = t.registerCancellable(Object(_.a)(m));
            t.registerDisposer(this.position.changed.add(g));
            const v = e=>{
                if (void 0 === d || void 0 === h)
                    return;
                const t = i.getBoundingClientRect();
                let n = (e.clientY - t.top) / t.height;
                return n = Math.max(0, n),
                n = Math.min(1, n),
                Math.round(n * (h - d)) + d
            }
              , b = t=>{
                const n = this.dimensionWidgetList.indexOf(e);
                if (-1 === n)
                    return;
                const i = v(t);
                if (void 0 === i)
                    return;
                const {position: r} = this
                  , s = r.value;
                s[n] = i,
                e.modified = !1,
                r.value = s
            }
            ;
            i.addEventListener("pointermove", e=>{
                const t = v(e);
                p = t,
                g()
            }
            ),
            i.addEventListener("pointerleave", ()=>{
                p = void 0,
                g()
            }
            ),
            i.addEventListener("pointerdown", t=>{
                t.preventDefault(),
                t.stopPropagation(),
                t.ctrlKey || t.altKey || t.shiftKey || t.metaKey || (fe(t, t=>{
                    void 0 !== e.dropdownOwner && (p = void 0,
                    b(t),
                    g(),
                    e.draggingPosition = !0)
                }
                , ()=>{
                    e.draggingPosition = !1,
                    this.updateDropdownVisibility(e)
                }
                ),
                b(t))
            }
            ),
            m(),
            this.widgetWithOpenDropdown = e,
            t.registerDisposer(()=>{
                Object(r.c)(n),
                e.dropdownOwner = void 0,
                delete e.container.dataset.dropdownVisible,
                this.widgetWithOpenDropdown = void 0
            }
            ),
            t.registerEventListener(document, "pointerdown", t=>{
                const {target: n} = t;
                n instanceof Node && e.container.contains(n) || this.closeDropdown(e)
            }
            , {
                capture: !0
            })
        }
        closeDropdown(e=this.widgetWithOpenDropdown) {
            if (void 0 === e)
                return;
            const {dropdownOwner: t} = e;
            void 0 !== t && t.dispose()
        }
        pasteString(e, t) {
            for (; ; ) {
                e.coordinate.focus();
                const n = t.match(/^\s*(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))?/);
                if (null === n)
                    break;
                if (void 0 !== n[1] && document.execCommand("insertText", void 0, n[1]),
                void 0 === n[2])
                    break;
                {
                    const {dimensionWidgetList: i} = this
                      , r = i.indexOf(e);
                    if (-1 === r || r + 1 === i.length)
                        break;
                    const s = t.substring(n[0].length);
                    e = i[r + 1],
                    t = s
                }
            }
        }
        reorderDimensionTo(e, t) {
            if (e === t)
                return;
            const {coordinateSpace: n} = this.position;
            n.value = Object(Y.u)(n.value, e, t)
        }
        updateDropdownVisibility(e) {
            e.hasFocus || e.draggingPosition ? this.openDropdown(e) : this.closeDropdown(e)
        }
        newDimension(e) {
            const t = new sn(e);
            t.container.addEventListener("dragstart", e=>{
                this.dragSource = t,
                e.stopPropagation(),
                e.dataTransfer.setData("neuroglancer-dimension", "")
            }
            ),
            t.container.addEventListener("dragenter", e=>{
                const {dragSource: n} = this;
                if (void 0 === n || n === t)
                    return;
                const {dimensionWidgetList: i} = this
                  , r = i.indexOf(n)
                  , s = i.indexOf(t);
                -1 !== r && -1 !== s && (e.preventDefault(),
                this.reorderDimensionTo(s, r))
            }
            ),
            t.container.addEventListener("dragend", e=>{
                this.dragSource === t && (this.dragSource = void 0)
            }
            ),
            t.nameContainer.addEventListener("dblclick", ()=>{
                t.nameElement.disabled = !1,
                t.nameElement.focus(),
                t.nameElement.select()
            }
            ),
            t.scaleContainer.addEventListener("dblclick", ()=>{
                t.scaleElement.disabled = !1,
                t.scaleElement.focus(),
                t.scaleElement.select()
            }
            ),
            t.coordinate.addEventListener("focus", ()=>{
                t.coordinate.select()
            }
            ),
            t.container.addEventListener("focusin", ()=>{
                t.hasFocus = !0,
                this.updateDropdownVisibility(t)
            }
            ),
            t.container.addEventListener("focusout", e=>{
                const {relatedTarget: n} = e;
                n instanceof Node && t.container.contains(n) || (t.hasFocus = !1,
                this.updateDropdownVisibility(t))
            }
            ),
            t.container.addEventListener("click", e=>{
                e.target instanceof HTMLInputElement && !e.target.disabled || t.coordinate.focus()
            }
            ),
            t.coordinate.addEventListener("paste", e=>{
                const n = t.coordinate
                  , i = n.value
                  , {clipboardData: r} = e;
                if (null === r)
                    return;
                let s = r.getData("text")
                  , {selectionEnd: a, selectionStart: o} = n;
                if (0 !== o || a !== i.length) {
                    null == o && (o = 0),
                    null == a && (a = 0);
                    const e = s.match(/[^\-0-9\.]/);
                    null !== e && (s = s.substring(0, e.index)),
                    s.length > 0 && document.execCommand("insertText", void 0, s)
                } else
                    this.pasteString(t, s);
                e.preventDefault(),
                e.stopPropagation()
            }
            ),
            t.coordinate.addEventListener("input", ()=>{
                t.modified = !0;
                const e = t.coordinate
                  , n = e.value;
                let {selectionDirection: i, selectionEnd: r, selectionStart: s} = e;
                null === s && (s = 0),
                null === r && (r = s);
                let a = "";
                const o = /[^\-0-9\.]/g;
                a += n.substring(0, s).replace(o, "");
                const l = a.length;
                a += n.substring(s, r).replace(o, "");
                const c = a.length;
                a += n.substring(r).replace(o, ""),
                e.value = a,
                e.selectionStart = l,
                e.selectionEnd = c,
                e.selectionDirection = i,
                on(e, a),
                r === s && r === n.length && n.match(/^(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))$/) && this.selectAdjacentCoordinate(t, 1)
            }
            ),
            t.nameElement.addEventListener("input", ()=>{
                const {nameElement: e} = t;
                Object(r.e)(e),
                this.updateNameValidity()
            }
            ),
            t.scaleElement.addEventListener("input", ()=>{
                const {scaleElement: e} = t;
                ln(e),
                this.updateScaleValidity(t)
            }
            ),
            t.coordinate.addEventListener("blur", e=>{
                const {relatedTarget: n} = e;
                this.dimensionWidgetList.some(e=>e.coordinate === n) || t.modified && this.updatePosition()
            }
            ),
            t.nameElement.addEventListener("blur", e=>{
                t.nameElement.disabled = !0;
                const {relatedTarget: n} = e;
                this.dimensionWidgetList.some(e=>e.nameElement === n) || this.updateNames() || this.forceUpdateDimensions()
            }
            ),
            t.scaleElement.addEventListener("blur", e=>{
                t.scaleElement.disabled = !0;
                const {relatedTarget: n} = e;
                this.dimensionWidgetList.some(e=>e.scaleElement === n) || this.updateScales() || this.forceUpdateDimensions()
            }
            ),
            Object(de.c)(t.container, "adjust-via-wheel", e=>{
                const n = e.detail
                  , {deltaY: i} = n;
                0 !== i && this.adjustDimension(t, Math.sign(i))
            }
            ),
            Object(de.c)(t.container, "adjust-up", ()=>{
                this.adjustDimension(t, -1)
            }
            ),
            Object(de.c)(t.container, "adjust-down", ()=>{
                this.adjustDimension(t, 1)
            }
            );
            for (const e of rn) {
                const n = e(t);
                Object(de.c)(n, "maybe-tab-forward", n=>{
                    this.handleLeftRightMovement(n, t, 1, e)
                }
                ),
                Object(de.c)(n, "maybe-tab-backward", n=>{
                    this.handleLeftRightMovement(n, t, -1, e)
                }
                ),
                Object(de.c)(n, "tab-forward", ()=>{
                    this.selectAdjacentField(t, 1, e)
                }
                ),
                Object(de.c)(n, "tab-backward", ()=>{
                    this.selectAdjacentField(t, -1, e)
                }
                )
            }
            return Object(de.c)(t.coordinate, "commit", ()=>{
                this.updatePosition()
            }
            ),
            Object(de.c)(t.nameElement, "commit", ()=>{
                this.updateNames()
            }
            ),
            Object(de.c)(t.scaleElement, "commit", ()=>{
                this.updateScales()
            }
            ),
            Object(de.c)(t.coordinate, "delete-backward", e=>{
                e.stopPropagation();
                const {coordinate: n} = t;
                n.selectionStart === n.selectionEnd && 0 === n.selectionStart && (e.preventDefault(),
                this.selectAdjacentCoordinate(t, -1))
            }
            ),
            t
        }
        forceUpdateDimensions() {
            let {position: {coordinateSpace: {value: e}}} = this;
            e.valid || (e = Y.l),
            this.coordinateSpace = e;
            const {dimensionWidgets: t, dimensionWidgetList: n} = this;
            n.length = 0;
            const {names: i, ids: s, scales: a, units: o} = e;
            Object(r.d)(this.dimensionContainer, s.map((s,l)=>{
                let c = t.get(s);
                void 0 === c ? (c = this.newDimension(e),
                t.set(s, c)) : c.coordinateSpace = e;
                const u = i[l];
                c.nameElement.value = u,
                delete c.nameElement.dataset.isValid,
                Object(r.e)(c.nameElement);
                const {scale: d, prefix: h, unit: p} = Object(st.a)(a[l], o[l])
                  , f = `${d}${h}${p}`;
                return c.scaleElement.value = f,
                delete c.scaleElement.dataset.isValid,
                ln(c.scaleElement),
                n.push(c),
                c.container
            }
            ));
            for (const [n,i] of t)
                i.coordinateSpace !== e && (this.closeDropdown(i),
                t.delete(n))
        }
        updateDimensions() {
            const {position: {coordinateSpace: {value: e}}} = this;
            e !== this.coordinateSpace && this.forceUpdateDimensions()
        }
        selectAdjacentField(e, t, n) {
            const {dimensionWidgetList: i} = this
              , r = i.indexOf(e);
            if (-1 === r)
                return;
            const s = r + t;
            if (s < 0 || s >= i.length)
                return !1;
            const a = n(i[s]);
            return a.disabled = !1,
            a.focus(),
            a.selectionStart = 0,
            a.selectionEnd = a.value.length,
            a.selectionDirection = 1 === t ? "forward" : "backward",
            !0
        }
        selectAdjacentCoordinate(e, t) {
            return this.selectAdjacentField(e, t, e=>e.coordinate)
        }
        handleLeftRightMovement(e, t, n, i) {
            e.stopPropagation();
            const r = i(t);
            r.selectionStart === r.selectionEnd && r.selectionStart === (1 === n ? r.value.length : 0) && this.selectAdjacentField(t, n, i) && e.preventDefault()
        }
        updateNameValidity() {
            const {dimensionWidgetList: e} = this
              , t = e.map(e=>e.nameElement.value)
              , n = t.length
              , i = this.combiner.getRenameValidity(t);
            for (let t = 0; t < n; ++t)
                e[t].nameElement.dataset.isValid = !1 === i[t] ? "false" : "true"
        }
        updateScaleValidity(e) {
            const t = void 0 !== Object(st.c)(e.scaleElement.value);
            e.scaleElement.dataset.isValid = t.toString()
        }
        adjustDimension(e, t) {
            const n = this.dimensionWidgetList.indexOf(e);
            if (-1 === n)
                return;
            this.updatePosition();
            const {position: i} = this;
            if (!i.valid)
                return;
            const r = i.coordinateSpace.value
              , {bounds: s} = r
              , a = Float32Array.from(i.value);
            let o = a[n] + t;
            if (t > 0) {
                const e = s.upperBounds[n];
                Number.isFinite(e) && (o = Math.min(o, Math.ceil(e - 1)))
            } else {
                const e = s.lowerBounds[n];
                Number.isFinite(e) && (o = Math.max(o, Math.floor(e)))
            }
            a[n] = o,
            this.position.value = a,
            this.updateView()
        }
        updatePosition() {
            const {dimensionWidgetList: e} = this
              , {position: t} = this
              , {value: n} = t;
            if (void 0 === n)
                return;
            const i = e.length;
            for (let t = 0; t < i; ++t) {
                const i = e[t];
                i.modified = !1;
                const r = Number(i.coordinate.value);
                Number.isFinite(r) && (n[t] = r)
            }
            t.value = n
        }
        updateNames() {
            const {dimensionWidgetList: e} = this
              , {position: {coordinateSpace: t}} = this
              , n = t.value
              , i = e.map(e=>e.nameElement.value);
            if (this.combiner.getRenameValidity(i).includes(!1))
                return !1;
            const r = n.names;
            if (Object(it.a)(r, i))
                return !1;
            const s = n.timestamps.map((e,t)=>r[t] === i[t] ? e : Date.now())
              , a = Object.assign(Object.assign({}, n), {
                names: i,
                timestamps: s
            });
            return t.value = a,
            !0
        }
        updateScales() {
            const {dimensionWidgetList: e} = this
              , {position: {coordinateSpace: t}} = this
              , n = t.value
              , i = e.map(e=>Object(st.c)(e.scaleElement.value));
            if (i.includes(void 0))
                return !1;
            const r = Float64Array.from(i, e=>e.scale)
              , s = Array.from(i, e=>e.unit)
              , {scales: a, units: o} = n;
            if (Object(it.a)(a, r) && Object(it.a)(o, s))
                return !1;
            const l = n.timestamps.map((e,t)=>r[t] === a[t] && s[t] === o[t] ? e : Date.now())
              , c = Object(Y.z)({
                valid: n.valid,
                rank: n.rank,
                scales: r,
                units: s,
                timestamps: l,
                ids: n.ids,
                names: n.names,
                boundingBoxes: n.boundingBoxes
            });
            return t.value = c,
            !0
        }
        getPositionText() {
            const {position: e} = this;
            return e.valid ? e.value.map(e=>Math.floor(e)).join(", ") : ""
        }
        updateView() {
            this.updateDimensions();
            const {position: {value: e}, dimensionWidgetList: t} = this
              , n = t.length;
            if (void 0 !== e)
                for (let i = 0; i < n; ++i) {
                    const n = t[i].coordinate
                      , r = Math.floor(e[i]).toString();
                    on(n, r),
                    n.value = r
                }
        }
        disposed() {
            this.closeDropdown(),
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    class un extends f.a {
        constructor(e, t, n) {
            super(),
            this.element = e,
            this.mouseState = t,
            this.coordinateSpace = n,
            this.tempPosition = P.t.create(),
            e.className = "neuroglancer-mouse-position-widget";
            const i = this.registerCancellable(Object(_.a)(()=>this.updateView()));
            this.registerDisposer(t.changed.add(i)),
            this.registerDisposer(n.changed.add(i))
        }
        updateView() {
            let e = "";
            const {mouseState: t, coordinateSpace: {value: n}} = this;
            if (t.active && void 0 !== n) {
                const i = t.position
                  , {rank: r, names: s} = n;
                for (let t = 0; t < r; ++t)
                    0 !== t && (e += "  "),
                    e += `${s[t]} ${Math.floor(i[t])}`
            }
            this.element.textContent = e
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function dn(e, t) {
        return "move" !== e.method && (e.manager.layerManager.filter(t=>!e.layers.has(t)),
        void 0 !== t && e.layers.has(t))
    }
    function hn(e, t, n) {
        function i(t, i) {
            let r = e.dropLayers;
            const s = i ? Xt(t, e.manager) : Gt();
            let a = !0;
            if (void 0 === r || (i && zt(t, s),
            r.compatibleWithMethod(s) || (e.dropLayers = void 0,
            !dn(r, n)))) {
                if (void 0 === r) {
                    if (r = e.dropLayers = Kt(t, e.manager, "copy" === s, !0, !1),
                    void 0 === r)
                        return;
                    a = "move" === r.method
                }
                if (void 0 !== n && r.layers.has(n))
                    return r;
                if (a) {
                    const {layerManager: t} = e.manager
                      , i = new Set;
                    let s = Number.POSITIVE_INFINITY;
                    const a = t.managedLayers = t.managedLayers.filter((e,t)=>!r.layers.has(e) || (s === Number.POSITIVE_INFINITY && (s = t),
                    i.add(e),
                    !1));
                    let o;
                    void 0 !== n ? (o = a.indexOf(n),
                    s <= o && ++o) : o = a.length;
                    for (const e of r.layers.keys())
                        i.has(e) || r.layers.delete(e);
                    a.splice(o, 0, ...r.layers.keys()),
                    t.layersChanged.dispatch()
                } else {
                    let t;
                    void 0 !== n && (t = e.manager.layerManager.managedLayers.indexOf(n));
                    for (const n of r.layers.keys())
                        e.manager.add(n, t)
                }
                return r
            }
        }
        const r = Object(f.e)(t, "dragenter", e=>{
            void 0 !== i(e, !0) && e.preventDefault()
        }
        )
          , s = Object(f.e)(t, "drop", t=>{
            t.preventDefault();
            const n = i(t, !1);
            void 0 !== n && (n.finalize(t) ? (t.dataTransfer.dropEffect = Gt(),
            Ht("move" === n.method ? void 0 : t)) : dn(n)),
            e.dropLayers = void 0
        }
        )
          , a = Object(f.e)(t, "dragover", e=>{
            void 0 !== i(e, !0) && (e.preventDefault(),
            e.stopPropagation())
        }
        );
        return ()=>{
            a(),
            s(),
            r()
        }
    }
    class pn extends f.a {
        constructor(e, t) {
            super(),
            this.layer = e,
            this.panel = t,
            this.maxLength = 0,
            this.prevValueText = "";
            let n = this.element = document.createElement("div");
            n.title = "Control+click for layer options, drag to move/copy.",
            n.className = "neuroglancer-layer-item neuroglancer-noselect";
            let i = this.labelElement = document.createElement("span");
            i.className = "neuroglancer-layer-item-label";
            let r = this.layerNumberElement = document.createElement("span");
            r.className = "neuroglancer-layer-item-number";
            let s = this.valueElement = document.createElement("span");
            s.className = "neuroglancer-layer-item-value";
            const a = Object(Zt.a)();
            a.title = "Remove layer from this layer group",
            this.registerEventListener(a, "click", e=>{
                this.panel.layerManager.removeManagedLayer(this.layer),
                e.stopPropagation()
            }
            ),
            n.appendChild(r),
            n.appendChild(i),
            n.appendChild(s);
            const o = this.registerDisposer(new cn(e.localPosition,e.localCoordinateSpaceCombiner,{
                copyButton: !1
            }));
            n.appendChild(o.element),
            o.element.addEventListener("click", e=>{
                e.stopPropagation()
            }
            ),
            o.element.addEventListener("dblclick", e=>{
                e.stopPropagation()
            }
            ),
            n.appendChild(a),
            this.registerEventListener(n, "click", n=>{
                n.ctrlKey ? (t.selectedLayer.layer = e,
                t.selectedLayer.visible = !0) : e.setVisible(!e.visible)
            }
            ),
            this.registerEventListener(n, "contextmenu", n=>{
                t.selectedLayer.layer = e,
                t.selectedLayer.visible = !0,
                n.stopPropagation(),
                n.preventDefault()
            }
            ),
            n.draggable = !0,
            this.registerEventListener(n, "dragstart", e=>{
                Wt(e, {
                    manager: t.manager,
                    layers: [this.layer],
                    layoutSpec: t.getLayoutSpecForDrag()
                }),
                e.stopPropagation()
            }
            ),
            this.registerEventListener(n, "dragend", e=>{
                Ht(e)
            }
            ),
            this.registerDisposer(hn(this.panel, n, this.layer))
        }
        update() {
            let {layer: e} = this;
            this.labelElement.textContent = e.name,
            this.element.setAttribute("layer-visible", e.visible.toString()),
            this.element.setAttribute("layer-selected", (e === this.panel.selectedLayer.layer).toString())
        }
        disposed() {
            this.element.parentElement.removeChild(this.element),
            super.disposed()
        }
    }
    class fn extends f.a {
        constructor(e, t, n, i, r, s) {
            super(),
            this.display = e,
            this.manager = t,
            this.viewerNavigationState = n,
            this.selectedLayer = i,
            this.getLayoutSpecForDrag = r,
            this.showLayerHoverValues = s,
            this.layerWidgets = new Map,
            this.element = document.createElement("div"),
            this.layerUpdateNeeded = !0,
            this.valueUpdateNeeded = !1,
            this.layerWidgetInsertionPoint = document.createElement("div"),
            this.positionWidget = this.registerDisposer(new cn(this.viewerNavigationState.position.value,this.manager.root.coordinateSpaceCombiner)),
            this.scheduleUpdate = this.registerCancellable(Object(_.a)(()=>this.update())),
            this.registerDisposer(i);
            const {element: a} = this;
            a.className = "neuroglancer-layer-panel",
            this.registerDisposer(t.layerSelectedValues.changed.add(()=>{
                this.handleLayerValuesChanged()
            }
            )),
            this.registerDisposer(t.layerManager.layersChanged.add(()=>{
                this.handleLayersChanged()
            }
            )),
            this.registerDisposer(i.changed.add(()=>{
                this.handleLayersChanged()
            }
            )),
            this.registerDisposer(s.changed.add(()=>{
                this.handleLayerItemValueChanged()
            }
            )),
            this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString(),
            this.layerWidgetInsertionPoint.style.display = "none",
            this.element.appendChild(this.layerWidgetInsertionPoint);
            let o = Object(Qt.a)({
                svg: Vt.a,
                title: "Click to add layer, control+click/right click/+click to add local annotation layer."
            });
            o.classList.add("neuroglancer-layer-add-button");
            let l = this.dropZone = document.createElement("div");
            l.className = "neuroglancer-layer-panel-drop-zone";
            const c = e=>{
                if (e.ctrlKey || e.metaKey || "contextmenu" === e.type) {
                    const e = new ie.e("annotation",{},this.manager);
                    this.manager.initializeLayerFromSpec(e, {
                        type: "annotation",
                        source: "local://annotations"
                    }),
                    this.manager.add(e),
                    this.selectedLayer.layer = e,
                    this.selectedLayer.visible = !0
                } else
                    this.addLayerMenu()
            }
            ;
            this.registerEventListener(o, "click", c),
            this.registerEventListener(o, "contextmenu", c),
            a.appendChild(o),
            a.appendChild(l),
            this.registerDisposer(function(e) {
                return e.draggable = !0,
                Object(f.e)(e, "dragstart", e=>{
                    e.stopPropagation(),
                    e.preventDefault()
                }
                )
            }/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
            (o)),
            a.appendChild(this.positionWidget.element);
            const u = ()=>{
                const e = this.viewerNavigationState.position.link.value;
                this.positionWidget.element.style.display = e === Q.h.LINKED ? "none" : ""
            }
            ;
            this.registerDisposer(this.viewerNavigationState.position.link.changed.add(u)),
            u(),
            this.update(),
            this.registerEventListener(a, "dragleave", e=>{
                if (e.relatedTarget && a.contains(e.relatedTarget))
                    return;
                const {dropLayers: t} = this;
                void 0 !== t && (dn(t),
                this.dropLayers = void 0)
            }
            ),
            this.registerDisposer(hn(this, o, void 0)),
            this.registerDisposer(hn(this, l, void 0)),
            this.registerDisposer(e.updateStarted.add(()=>this.updateLayers()))
        }
        get layerManager() {
            return this.manager.layerManager
        }
        disposed() {
            this.layerWidgets.forEach(e=>e.dispose()),
            this.layerWidgets = void 0,
            Object(r.c)(this.element),
            super.disposed()
        }
        handleLayersChanged() {
            this.layerUpdateNeeded = !0,
            this.handleLayerValuesChanged()
        }
        handleLayerValuesChanged() {
            this.valueUpdateNeeded || (this.valueUpdateNeeded = !0,
            this.scheduleUpdate())
        }
        handleLayerItemValueChanged() {
            this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString()
        }
        update() {
            if (this.valueUpdateNeeded = !1,
            this.updateLayers(),
            !1 === this.showLayerHoverValues.value)
                return;
            let e = this.manager.layerSelectedValues;
            for (let[t,n] of this.layerWidgets) {
                let i = t.layer
                  , r = "";
                if (null !== i) {
                    let t = e.get(i);
                    void 0 !== t && (r = t.toString())
                }
                if (r !== n.prevValueText) {
                    if (n.prevValueText = r,
                    r.length > n.maxLength) {
                        const e = n.maxLength = r.length;
                        n.valueElement.style.width = `${e}ch`
                    }
                    n.valueElement.textContent = r
                }
            }
        }
        updateLayers() {
            if (!this.layerUpdateNeeded)
                return;
            this.layerUpdateNeeded = !1;
            let e = this.element
              , t = new Set
              , n = this.layerWidgetInsertionPoint.nextElementSibling;
            this.manager.layerManager.managedLayers.forEach(i=>{
                t.add(i);
                let r = this.layerWidgets.get(i);
                const s = this.manager.rootLayers.managedLayers.indexOf(i);
                void 0 === r && (r = new pn(i,this),
                this.layerWidgets.set(i, r)),
                r.layerNumberElement.textContent = "" + (1 + s),
                r.update();
                let {element: a} = r;
                a !== n && e.insertBefore(r.element, n),
                n = a.nextElementSibling
            }
            );
            for (let[e,n] of this.layerWidgets)
                t.has(e) || (this.layerWidgets.delete(e),
                n.dispose())
        }
        addLayerMenu() {
            Object(ie.k)(this.manager, this.selectedLayer)
        }
    }
    n(189);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class mn extends f.a {
        constructor(e) {
            super(),
            this.element = document.createElement("div"),
            this.parentDisposers = new Map,
            this.disabledValue = !1,
            this.opened = new U.a,
            this.closed = new U.a;
            const {element: t} = this;
            t.className = "neuroglancer-context-menu",
            t.style.display = "none",
            t.tabIndex = -1,
            document.body.appendChild(t),
            void 0 !== e && this.registerParent(e)
        }
        get disabled() {
            return this.disabledValue
        }
        set disabled(e) {
            this.disabledValue !== e && (this.disabledValue = e,
            e && this.hide())
        }
        get open() {
            return void 0 !== this.menuDisposer
        }
        registerParent(e) {
            const {parentDisposers: t} = this;
            t.has(e) || t.set(e, Object(f.e)(e, "contextmenu", e=>{
                this.show(e),
                e.stopPropagation(),
                e.preventDefault()
            }
            ))
        }
        show(e) {
            if (this.disabledValue)
                return;
            this.hide();
            const {element: t} = this
              , n = Object(f.e)(document, "mousedown", e=>{
                e.target instanceof Node && !t.contains(e.target) && this.hide()
            }
            , !0)
              , i = Object(f.e)(document, "keydown", e=>{
                "Escape" === e.code && this.hide()
            }
            , !0);
            this.opened.dispatch(),
            function(e, t) {
                e.style.display = "block";
                const {offsetWidth: n, offsetHeight: i} = e
                  , r = document.documentElement.clientWidth
                  , s = document.documentElement.clientHeight
                  , a = document.documentElement.scrollLeft + Math.min(r - n, t.clientX)
                  , o = document.documentElement.scrollTop + Math.min(s - i, t.clientY);
                e.style.left = a + "px",
                e.style.top = o + "px"
            }(t, e),
            this.menuDisposer = ()=>{
                i(),
                n(),
                t.style.display = "none"
            }
        }
        unregisterParent(e) {
            const {parentDisposers: t} = this
              , n = t.get(e);
            void 0 !== n && (n(),
            t.delete(e))
        }
        disposed() {
            const {parentDisposers: e} = this;
            for (const t of e.values())
                t();
            e.clear(),
            Object(r.c)(this.element)
        }
        hide() {
            void 0 !== this.menuDisposer && (this.menuDisposer(),
            this.menuDisposer = void 0,
            this.closed.dispatch())
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function gn(e, t) {
        const n = Object(f.e)(e, "drop", e=>{
            if (e.preventDefault(),
            -1 !== e.dataTransfer.types.indexOf("neuroglancer-position")) {
                e.stopPropagation();
                const n = Object(nt.w)(JSON.parse(e.dataTransfer.getData("neuroglancer-position")))
                  , i = Object(nt.y)(n, "dimensions", Y.k)
                  , r = Object(nt.y)(n, "position", e=>Object(nt.b)(e, nt.p));
                if (r.length !== i.length)
                    throw new Error("length mismatch between position and dimensions");
                const s = r.length
                  , {coordinateSpace: {value: {names: a}}, value: o} = t;
                for (let e = 0; e < s; ++e) {
                    const t = a.indexOf(i[e]);
                    -1 !== t && (o[t] = r[e])
                }
                t.changed.dispatch()
            }
        }
        )
          , i = e=>{
            -1 !== e.dataTransfer.types.indexOf("neuroglancer-position") && (e.dataTransfer.dropEffect = "link",
            e.preventDefault(),
            e.stopPropagation())
        }
          , r = Object(f.e)(e, "dragenter", i)
          , s = Object(f.e)(e, "dragover", i);
        return ()=>{
            r(),
            s(),
            n()
        }
    }
    var vn = n(102);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const bn = "neuroglancer-layer-group-viewer";
    function yn(e) {
        return -1 !== e.dataTransfer.types.indexOf(bn)
    }
    let Sn;
    function wn(e) {
        return void 0 !== function(e) {
            return Sn && Sn.viewer.layerSpecification.rootLayers === e.rootLayers ? Sn.viewer : void 0
        }(e) ? "move" : "copy"
    }
    class xn extends f.a {
        constructor(e) {
            super(),
            this.relativeDisplayScales = new Q.f(e.navigationState.pose.relativeDisplayScales.addRef()),
            this.displayDimensions = new Q.c(e.navigationState.pose.displayDimensions.addRef()),
            this.position = new Q.e(e.navigationState.position.addRef()),
            this.crossSectionOrientation = new Q.d(e.navigationState.pose.orientation.addRef()),
            this.displayDimensionRenderInfo = this.registerDisposer(new Q.q(this.relativeDisplayScales.value,this.displayDimensions.value)),
            this.crossSectionScale = new Q.g(e.navigationState.zoomFactor.addRef(),this.displayDimensionRenderInfo.addRef()),
            this.crossSectionDepthRange = new Q.b(e.navigationState.depthRange.addRef(),this.displayDimensionRenderInfo),
            this.projectionDepthRange = new Q.b(e.perspectiveNavigationState.depthRange.addRef(),this.displayDimensionRenderInfo),
            this.navigationState = this.registerDisposer(new Q.i(new Q.a(this.position.value,this.displayDimensionRenderInfo.addRef(),this.crossSectionOrientation.value),this.crossSectionScale.value,this.crossSectionDepthRange.value)),
            this.projectionOrientation = new Q.d(e.perspectiveNavigationState.pose.orientation.addRef()),
            this.projectionScale = new Q.g(e.perspectiveNavigationState.zoomFactor.addRef(),this.displayDimensionRenderInfo.addRef()),
            this.projectionNavigationState = this.registerDisposer(new Q.i(new Q.a(this.position.value.addRef(),this.displayDimensionRenderInfo.addRef(),this.projectionOrientation.value),this.projectionScale.value,this.projectionDepthRange.value))
        }
        copyToParent() {
            for (const e of [this.relativeDisplayScales, this.displayDimensions, this.position, this.crossSectionOrientation, this.crossSectionScale, this.projectionOrientation, this.projectionScale])
                e.copyToPeer()
        }
        register(e) {
            e.add("dimensionRenderScales", this.relativeDisplayScales),
            e.add("displayDimensions", this.displayDimensions),
            e.add("position", Object(Q.r)(this.position)),
            e.add("crossSectionOrientation", this.crossSectionOrientation),
            e.add("crossSectionScale", this.crossSectionScale),
            e.add("crossSectionDepth", this.crossSectionDepthRange),
            e.add("projectionOrientation", this.projectionOrientation),
            e.add("projectionScale", this.projectionScale),
            e.add("projectionDepth", this.projectionDepthRange)
        }
    }
    class Cn extends f.a {
        constructor(e, t, n={}) {
            super(),
            this.element = e,
            this.viewerState = t,
            this.state = new s.a,
            this.options = Object.assign({
                showLayerPanel: new Ae.b(!0),
                showViewerMenu: !1,
                showLayerHoverValues: new Ae.b(!0)
            }, n),
            this.layerSpecification = this.registerDisposer(t.layerSpecification),
            this.viewerNavigationState = this.registerDisposer(new xn(t)),
            this.viewerNavigationState.register(this.state),
            this.layerSpecification instanceof ie.d ? this.state.add("layers", this.layerSpecification) : this.state.add("layers", {
                changed: this.layerSpecification.changed,
                toJSON: ()=>this.layerSpecification.layerManager.managedLayers.map(e=>e.name),
                reset: ()=>{
                    throw new Error("not implemented")
                }
                ,
                restoreState: ()=>{
                    throw new Error("not implemented")
                }
            }),
            e.classList.add("neuroglancer-layer-group-viewer"),
            this.registerDisposer(new ue.a(e)),
            this.layout = this.registerDisposer(new At(this,"xy")),
            this.state.add("layout", this.layout),
            this.registerActionBindings(),
            this.registerDisposer(this.layerManager.useDirectly()),
            this.registerDisposer(gn(e, this.navigationState.position)),
            this.registerDisposer(this.options.showLayerPanel.changed.add(this.registerCancellable(J()(()=>this.updateUI(), 0)))),
            this.makeUI()
        }
        get perspectiveNavigationState() {
            return this.viewerNavigationState.projectionNavigationState
        }
        get navigationState() {
            return this.viewerNavigationState.navigationState
        }
        get display() {
            return this.viewerState.display
        }
        get selectedLayer() {
            return this.viewerState.selectedLayer
        }
        get layerManager() {
            return this.layerSpecification.layerManager
        }
        get chunkManager() {
            return this.layerSpecification.chunkManager
        }
        get mouseState() {
            return this.viewerState.mouseState
        }
        get showAxisLines() {
            return this.viewerState.showAxisLines
        }
        get wireFrame() {
            return this.viewerState.wireFrame
        }
        get showScaleBar() {
            return this.viewerState.showScaleBar
        }
        get showPerspectiveSliceViews() {
            return this.viewerState.showPerspectiveSliceViews
        }
        get inputEventBindings() {
            return this.viewerState.inputEventBindings
        }
        get visibility() {
            return this.viewerState.visibility
        }
        get visibleLayerRoles() {
            return this.viewerState.visibleLayerRoles
        }
        get crossSectionBackgroundColor() {
            return this.viewerState.crossSectionBackgroundColor
        }
        get perspectiveViewBackgroundColor() {
            return this.viewerState.perspectiveViewBackgroundColor
        }
        get scaleBarOptions() {
            return this.viewerState.scaleBarOptions
        }
        get changed() {
            return this.state.changed
        }
        bindAction(e, t) {
            this.registerDisposer(Object(o.d)(this.element, e, t))
        }
        registerActionBindings() {
            this.bindAction("add-layer", ()=>{
                this.layerPanel && this.layerPanel.addLayerMenu()
            }
            ),
            this.bindAction("t-", ()=>{
                this.navigationState.pose.translateNonDisplayDimension(0, -1)
            }
            ),
            this.bindAction("t+", ()=>{
                this.navigationState.pose.translateNonDisplayDimension(0, 1)
            }
            )
        }
        toJSON() {
            return Object.assign({
                type: "viewer"
            }, this.state.toJSON())
        }
        reset() {
            this.state.reset()
        }
        restoreState(e) {
            this.state.restoreState(e),
            Object(s.c)(e, "crossSectionZoom", Object(Q.r)(this.viewerNavigationState.crossSectionScale)),
            Object(s.c)(e, "perspectiveZoom", Object(Q.r)(this.viewerNavigationState.projectionScale)),
            Object(s.c)(e, "perspectiveOrientation", this.viewerNavigationState.projectionOrientation)
        }
        makeUI() {
            this.element.style.flex = "1",
            this.element.style.display = "flex",
            this.element.style.flexDirection = "column",
            this.element.appendChild(this.layout.element),
            this.updateUI()
        }
        updateUI() {
            const {options: e} = this
              , t = e.showLayerPanel.value;
            if (void 0 !== this.layerPanel && !t)
                return this.layerPanel.dispose(),
                void (this.layerPanel = void 0);
            if (t && void 0 === this.layerPanel) {
                const t = this.layerPanel = new fn(this.display,this.layerSpecification,this.viewerNavigationState,this.viewerState.selectedLayer.addRef(),()=>this.layout.toJSON(),this.options.showLayerHoverValues);
                e.showViewerMenu ? (t.registerDisposer(function(e, t) {
                    const n = new mn(e)
                      , i = n.element;
                    i.classList.add("neuroglancer-layer-group-viewer-context-menu");
                    const r = document.createElement("button");
                    r.textContent = "Remove layer group",
                    i.appendChild(r),
                    n.registerEventListener(r, "click", ()=>{
                        t.layerSpecification.layerManager.clear()
                    }
                    );
                    const {viewerNavigationState: s} = t;
                    for (const [e,t] of [["Render scale factors", s.relativeDisplayScales.link], ["Render dimensions", s.displayDimensions.link], ["Position", s.position.link], ["Cross-section orientation", s.crossSectionOrientation.link], ["Cross-section zoom", s.crossSectionScale.link], ["Cross-section depth range", s.crossSectionDepthRange.link], ["3-D projection orientation", s.projectionOrientation.link], ["3-D projection zoom", s.projectionScale.link], ["3-D projection depth range", s.projectionDepthRange.link]]) {
                        const r = n.registerDisposer(new vn.a(t))
                          , s = document.createElement("label");
                        s.style.display = "flex",
                        s.style.flexDirection = "row",
                        s.style.whiteSpace = "nowrap",
                        s.textContent = e,
                        s.appendChild(r.element),
                        i.appendChild(s)
                    }
                    return n
                }(t.element, this)),
                t.element.title = "Right click for options, drag to move/copy layer group.") : t.element.title = "Drag to move/copy layer group.",
                t.element.draggable = !0,
                this.registerEventListener(t.element, "dragstart", e=>{
                    Wt(e, {
                        manager: this.layerSpecification,
                        layers: this.layerManager.managedLayers,
                        layoutSpec: this.layout.toJSON()
                    });
                    const t = ()=>{
                        Sn && Sn.viewer === this && (Sn = void 0),
                        this.unregisterDisposer(t)
                    }
                    ;
                    Sn = {
                        viewer: this,
                        disposer: t
                    },
                    this.registerDisposer(t);
                    const n = this.toJSON();
                    delete n.layers,
                    e.dataTransfer.setData(bn, JSON.stringify(n))
                }
                ),
                this.registerEventListener(t.element, "dragend", e=>{
                    Ht(e),
                    void 0 !== Sn && Sn.viewer === this && Sn.disposer()
                }
                ),
                this.element.insertBefore(t.element, this.element.firstChild)
            }
        }
        disposed() {
            Object(r.b)(this.element);
            const {layerPanel: e} = this;
            void 0 !== e && (e.dispose(),
            this.layerPanel = void 0),
            super.disposed()
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const On = Symbol("layoutComponentContainer");
    class kn extends f.a {
        constructor(e, t, n) {
            super(),
            this.viewer = e,
            this.parent = n,
            this.changed = new U.a,
            this.element = document.createElement("div");
            const {element: i} = this;
            i.style.display = "flex",
            i.style.flex = "1",
            i.style.position = "relative",
            i.style.alignItems = "stretch",
            i.foo = "hello",
            i[On] = this,
            this.setSpecification(t);
            const r = []
              , s = e=>{
                const t = document.createElement("div");
                let n;
                switch (t.className = "neuroglancer-layout-split-drop-zone",
                t.style[e] = "0",
                e) {
                case "left":
                case "right":
                    n = "row",
                    t.style.width = "10px",
                    t.style.height = "100%";
                    break;
                case "top":
                case "bottom":
                    n = "column",
                    t.style.height = "10px",
                    t.style.width = "100%"
                }
                t.style.display = "none",
                r.push({
                    element: t,
                    direction: n,
                    orientation: e
                }),
                i.appendChild(t),
                this.registerDisposer(Mn(t, this.viewer.layerSpecification, ()=>this.split(e).newContainer.component))
            }
            ;
            s("left"),
            s("right"),
            s("top"),
            s("bottom");
            let a = !1;
            this.registerEventListener(i, "dragenter", e=>{
                if (!a && void 0 !== Jt(e)) {
                    a = !0;
                    for (const {element: e, direction: t, orientation: i} of r) {
                        if (void 0 !== n && t === n.direction && (("left" === i || "top" === i) && n.get(0) !== this || ("bottom" === i || "right" === i) && n.get(n.length - 1) !== this))
                            continue;
                        const {component: r} = this;
                        r instanceof Dn && r.direction === t || (e.style.display = "block")
                    }
                }
            }
            , !0),
            this.registerEventListener(i, "drop", e=>{
                if (a) {
                    a = !1;
                    for (const {element: e} of r)
                        e.style.display = "none"
                }
            }
            , !0),
            this.registerEventListener(i, "dragleave", e=>{
                const {relatedTarget: t} = e;
                if (a && !(t instanceof HTMLElement && this.element.contains(t))) {
                    a = !1;
                    for (const {element: e} of r)
                        e.style.display = "none"
                }
            }
            , !0)
        }
        unsetComponent() {
            const e = this.componentValue;
            void 0 !== e && (e.changed.remove(this.changed.dispatch),
            this.element.removeChild(e.element),
            e.dispose())
        }
        get component() {
            return this.componentValue
        }
        setComponent(e) {
            if (this.unsetComponent(),
            this.componentValue = e,
            e.changed.add(this.changed.dispatch),
            this.element.appendChild(e.element),
            e instanceof Cn) {
                const {layerManager: t} = e
                  , n = e.registerCancellable(J()(()=>{
                    0 === t.managedLayers.length && this.dispose()
                }
                , 0));
                e.registerDisposer(t.layersChanged.add(()=>{
                    0 === t.managedLayers.length && n()
                }
                )),
                n()
            } else if (e instanceof Dn) {
                const t = e.registerCancellable(J()(()=>{
                    const {length: t} = e;
                    if (0 === t && void 0 !== this.parent)
                        this.dispose();
                    else if (1 === t) {
                        const t = e.get(0).component;
                        let n;
                        if (void 0 === this.parent && t instanceof Cn) {
                            n = t.layout.specification.toJSON(),
                            t.viewerNavigationState.copyToParent();
                            const e = new Set(t.layerManager.managedLayers)
                              , {layerSpecification: i} = t;
                            i.rootLayers.filter(t=>e.has(t)),
                            i.rootLayers.managedLayers = Array.from(t.layerManager.managedLayers),
                            i.rootLayers.layersChanged.dispatch()
                        } else
                            n = t.toJSON();
                        this.setSpecification(n)
                    }
                }
                , 0));
                e.registerDisposer(e.changed.add(()=>{
                    e.length < 2 && t()
                }
                )),
                t()
            }
            this.changed.dispatch()
        }
        toJSON() {
            return this.component.toJSON()
        }
        setSpecification(e) {
            this.setComponent(function(e, t) {
                const n = document.createElement("div");
                if (n.style.flex = "1",
                n.style.width = "0px",
                "string" == typeof t) {
                    if (void 0 !== e.parent)
                        throw new Error(`Invalid layout component specification: ${JSON.stringify(t)}`);
                    return new Tn(n,t,e.viewer)
                }
                Object(nt.w)(t);
                const i = Object(nt.y)(t, "type", nt.E);
                switch (i) {
                case "row":
                case "column":
                    return new Dn(n,i,Object(nt.y)(t, "children", t=>{
                        const n = Object(nt.b)(t, e=>e);
                        if (void 0 === e.parent && 0 === n.length)
                            throw new Error("Stack layout requires at least one child.");
                        return n
                    }
                    ),e);
                case "viewer":
                    {
                        const i = e.viewer
                          , r = new ie.d(i.layerSpecification.addRef())
                          , s = new Cn(n,Object.assign({
                            display: i.display,
                            layerSpecification: r
                        }, En(i)),{
                            showLayerPanel: i.uiControlVisibility.showLayerPanel,
                            showViewerMenu: !0,
                            showLayerHoverValues: i.uiControlVisibility.showLayerHoverValues
                        });
                        try {
                            s.restoreState(t)
                        } catch (e) {
                            throw s.dispose(),
                            e
                        }
                        return s
                    }
                default:
                    return new Tn(n,t,e.viewer)
                }
            }(this, e))
        }
        static getFromElement(e) {
            return e[On]
        }
        disposed() {
            this.unsetComponent(),
            this.componentValue = void 0,
            super.disposed()
        }
        split(e) {
            const t = {
                type: "viewer"
            }
              , {parent: n} = this;
            if (void 0 !== n) {
                if ("left" === e && "row" === n.direction || "top" === e && "column" === n.direction)
                    return {
                        newContainer: n.insertChild(t, this),
                        existingContainer: this
                    };
                if ("right" === e && "row" === n.direction || "bottom" === e && "column" === n.direction)
                    return {
                        newContainer: n.insertChild(t),
                        existingContainer: this
                    }
            }
            let i;
            const r = this.component;
            let s, a;
            i = r instanceof Tn ? r.layerGroupViewer.toJSON() : r.toJSON();
            const o = "left" === e || "right" === e ? "row" : "column";
            switch (e) {
            case "left":
            case "top":
                s = {
                    type: o,
                    children: [t, i]
                },
                a = 0;
                break;
            case "right":
            case "bottom":
                s = {
                    type: o,
                    children: [i, t]
                },
                a = 1
            }
            this.setSpecification(s);
            const l = this.component;
            return {
                newContainer: l.get(a),
                existingContainer: l.get(1 - a)
            }
        }
    }
    function En(e) {
        return {
            mouseState: e.mouseState,
            showAxisLines: e.showAxisLines,
            wireFrame: e.wireFrame,
            showScaleBar: e.showScaleBar,
            scaleBarOptions: e.scaleBarOptions,
            showPerspectiveSliceViews: e.showPerspectiveSliceViews,
            inputEventBindings: e.inputEventBindings,
            visibility: e.visibility,
            selectedLayer: e.selectedLayer,
            visibleLayerRoles: e.visibleLayerRoles,
            navigationState: e.navigationState.addRef(),
            perspectiveNavigationState: e.perspectiveNavigationState.addRef(),
            crossSectionBackgroundColor: e.crossSectionBackgroundColor,
            perspectiveViewBackgroundColor: e.perspectiveViewBackgroundColor
        }
    }
    class Tn extends f.a {
        constructor(e, t, n) {
            super(),
            this.element = e,
            this.layerGroupViewer = this.registerDisposer(new Cn(e,Object.assign({
                display: n.display,
                layerSpecification: n.layerSpecification.addRef()
            }, En(n)),{
                showLayerPanel: n.uiControlVisibility.showLayerPanel,
                showViewerMenu: !1,
                showLayerHoverValues: n.uiControlVisibility.showLayerHoverValues
            })),
            this.layerGroupViewer.layout.restoreState(t)
        }
        toJSON() {
            return this.layerGroupViewer.layout.specification.toJSON()
        }
        get changed() {
            return this.layerGroupViewer.layout.changed
        }
    }
    function Mn(e, t, n) {
        const i = Object(f.e)(e, "dragenter", t=>{
            void 0 !== Jt(t) && e.classList.add("neuroglancer-drag-over")
        }
        )
          , r = Object(f.e)(e, "dragleave", ()=>{
            e.classList.remove("neuroglancer-drag-over")
        }
        )
          , s = Object(f.e)(e, "dragover", e=>yn(e) ? (zt(e, function(e, t) {
            return e.shiftKey ? "copy" : e.ctrlKey ? "move" : wn(t)
        }(e, t)),
        e.stopPropagation(),
        void e.preventDefault()) : void 0 !== Jt(e) ? (function(e, t, n=!1) {
            zt(e, Xt(e, t, n))
        }(e, t, !0),
        e.stopPropagation(),
        void e.preventDefault()) : void 0)
          , a = Object(f.e)(e, "drop", i=>{
            if (e.classList.remove("neuroglancer-drag-over"),
            yn(i)) {
                let e;
                i.stopPropagation();
                try {
                    e = JSON.parse(i.dataTransfer.getData(bn))
                } catch (e) {
                    return
                }
                const r = Kt(i, t, !1, !1, !0);
                if (void 0 !== r && r.finalize(i)) {
                    i.preventDefault(),
                    i.dataTransfer.dropEffect = Gt(),
                    Ht(i);
                    const t = n();
                    for (const e of r.layers.keys())
                        t.layerSpecification.add(e);
                    try {
                        t.restoreState(e)
                    } catch (e) {}
                }
            } else {
                const e = Kt(i, t, "copy" === Gt(), !1, !0);
                if (void 0 !== e && e.finalize(i)) {
                    i.preventDefault(),
                    i.dataTransfer.dropEffect = Gt(),
                    Ht(i);
                    const t = n();
                    for (const n of e.layers.keys())
                        t.layerSpecification.add(n);
                    try {
                        t.layout.restoreState(e.layoutSpec)
                    } catch (e) {
                        t.layout.reset()
                    }
                    return
                }
            }
        }
        );
        return ()=>{
            a(),
            s(),
            r(),
            i()
        }
    }
    class Dn extends f.a {
        constructor(e, t, n, i) {
            super(),
            this.element = e,
            this.direction = t,
            this.container = i,
            this.changed = new U.a,
            e.classList.add("neuroglancer-stack-layout"),
            e.classList.add(`neuroglancer-stack-layout-${t}`),
            e.style.display = "flex",
            e.style.flexDirection = t,
            e.appendChild(this.makeDropPlaceholder(this));
            for (const e of n)
                this.insertChild(e)
        }
        get length() {
            return (this.element.childElementCount - 1) / 2
        }
        makeDropPlaceholder(e) {
            const t = document.createElement("div");
            return t.className = "neuroglancer-stack-layout-drop-placeholder",
            e.registerDisposer(Mn(t, this.viewer.layerSpecification, ()=>{
                const e = t.nextElementSibling;
                let n;
                return null !== e && (n = kn.getFromElement(e)),
                this.insertChild({
                    type: "viewer",
                    layers: []
                }, n).component
            }
            )),
            e.registerDisposer(()=>{
                Object(r.c)(t)
            }
            ),
            t
        }
        get viewer() {
            return this.container.viewer
        }
        get(e) {
            return kn.getFromElement(this.element.children[2 * e + 1])
        }
        insertChild(e, t) {
            const n = new kn(this.viewer,e,this)
              , i = this.makeDropPlaceholder(n);
            n.element.classList.add("neuroglancer-stack-layout-child"),
            n.registerDisposer(n.changed.add(this.changed.dispatch)),
            n.registerDisposer(()=>{
                this.element.removeChild(n.element),
                this.changed.dispatch()
            }
            );
            const r = void 0 !== t ? t.element : null;
            return this.element.insertBefore(n.element, r),
            this.element.insertBefore(i, r),
            this.changed.dispatch(),
            n
        }
        disposed() {
            this.clear(),
            super.disposed()
        }
        clear() {
            for (; 0 !== this.length; )
                this.get(0).dispose()
        }
        *[Symbol.iterator]() {
            const {length: e} = this;
            for (let t = 0; t < e; ++t)
                yield this.get(t)
        }
        toJSON() {
            return {
                type: this.direction,
                children: Array.from(this).map(e=>e.toJSON())
            }
        }
    }
    class Ln extends f.a {
        constructor(e, t) {
            super(),
            this.viewer = e,
            this.defaultSpecification = t,
            this.container = this.registerDisposer(new kn(this.viewer,this.defaultSpecification,void 0))
        }
        get changed() {
            return this.container.changed
        }
        get element() {
            return this.container.element
        }
        reset() {
            this.container.setSpecification(this.defaultSpecification)
        }
        restoreState(e) {
            this.container.setSpecification(e)
        }
        disposed() {
            super.disposed()
        }
        toJSON() {
            return this.container.toJSON()
        }
    }
    n(190);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class An extends f.a {
        constructor(e, t, n, i, r=0) {
            super(),
            this.element = e,
            this.visible = t,
            this.size = n,
            this.direction = i,
            this.minSize = r,
            this.gutter = document.createElement("div"),
            this.sizeProp = "horizontal" === this.direction ? "width" : "height";
            const {gutter: s} = this;
            s.className = `neuroglancer-resize-gutter-${i}`,
            e.insertAdjacentElement("beforebegin", s),
            this.registerDisposer(t.changed.add(()=>this.updateView())),
            this.registerDisposer(n.changed.add(()=>this.updateView()));
            this.registerEventListener(s, "pointerdown", t=>{
                if ("button"in t && 0 !== t.button)
                    return;
                t.preventDefault();
                let n = e.getBoundingClientRect()[this.sizeProp];
                const r = this.minSize / 2;
                fe(t, (e,t,s)=>{
                    n -= "horizontal" === i ? t : s,
                    n < r ? this.visible.value = !1 : !1 === this.visible.value && n > r && (this.visible.value = !0),
                    this.size.value = Math.max(this.minSize, n)
                }
                )
            }
            ),
            this.updateView()
        }
        updateView() {
            const {element: e, gutter: t} = this
              , {visible: n} = this;
            if (!n.value)
                return e.style.display = "none",
                void (t.style.display = "none");
            e.style.display = "",
            t.style.display = "",
            e.style[this.sizeProp] = Math.max(this.minSize, this.size.value) + "px"
        }
        disposed() {
            Object(r.c)(this.gutter),
            super.disposed()
        }
    }
    n(191);
    var In = n(109)
      , Pn = n(41);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class Rn extends Pn.b {
        constructor(e) {
            super(),
            this.layer = e,
            this.tabView = new Pn.d(this.layer.tabs.addRef(),this.visibility),
            this.element.appendChild(this.tabView.element),
            this.element.classList.add("neuroglancer-layer-side-panel-info-panel"),
            this.tabView.element.style.flex = "1"
        }
    }
    const jn = pe.a.fromObject({
        escape: {
            action: "cancel"
        }
    });
    class Nn extends Pn.b {
        get layer() {
            return null
        }
        constructor() {
            super(),
            this.element.classList.add("neuroglancer-layer-side-panel-info-panel-empty"),
            this.element.textContent = "Information about this layer will be available once it finishes loading."
        }
    }
    class Vn extends Pn.b {
        constructor(e, t, n) {
            super(),
            this.layer = e,
            this.layerManager = t,
            this.collapse = n,
            this.element = document.createElement("div"),
            this.typeSelect = document.createElement("select"),
            this.typeSelectMeasure = document.createElement("div"),
            this.title = document.createElement("div"),
            this.layerName = document.createElement("input"),
            this.stack = this.registerDisposer(new Pn.a(e=>null === e ? new Nn : new Rn(e),(()=>{
                const {layer: e} = this;
                return {
                    changed: e.layerChanged,
                    get value() {
                        return e.layer
                    }
                }
            }
            )(),this.visibility,!0));
            const {element: i, title: r, layerName: s, stack: a, typeSelect: o, typeSelectMeasure: l} = this;
            i.className = "neuroglancer-managed-user-layer-info-panel",
            r.className = "neuroglancer-layer-side-panel-title",
            a.element.classList.add("neuroglancer-layer-side-panel-content-container"),
            r.appendChild(o),
            i.appendChild(r),
            i.appendChild(a.element),
            document.body.appendChild(l),
            o.classList.add("neuroglancer-layer-side-panel-type"),
            l.classList.add("neuroglancer-layer-side-panel-type-measure"),
            o.title = "Change layer type";
            for (const [e,t] of ie.o) {
                if (t.type !== e)
                    continue;
                const n = document.createElement("option");
                n.textContent = e,
                n.value = e,
                o.appendChild(n)
            }
            o.addEventListener("change", ()=>{
                if (null === this.layer.layer)
                    return void this.handleLayerNameModelChanged();
                const e = o.value
                  , t = ie.o.get(e);
                Object(ie.m)(this.layer, t)
            }
            ),
            r.appendChild(s),
            s.spellcheck = !1,
            s.autocomplete = "off",
            s.addEventListener("focus", ()=>{
                s.select()
            }
            ),
            this.registerDisposer(new de.b(s,jn)).allShortcutsAreGlobal = !0,
            Object(de.c)(s, "cancel", e=>{
                this.handleLayerNameModelChanged(),
                s.blur(),
                e.stopPropagation(),
                e.preventDefault()
            }
            ),
            s.title = "Rename layer",
            r.appendChild(Object(In.a)({
                title: "Delete layer",
                onClick: ()=>{
                    Object(ie.n)(this.layer)
                }
            })),
            r.appendChild(Object(Zt.a)({
                title: "Close side panel",
                onClick: ()=>{
                    this.collapse()
                }
            })),
            s.addEventListener("change", ()=>this.handleLayerNameViewChanged()),
            s.addEventListener("blur", ()=>this.handleLayerNameViewChanged()),
            this.registerDisposer(e.layerChanged.add(()=>this.handleLayerNameModelChanged())),
            this.handleLayerNameModelChanged()
        }
        handleLayerNameModelChanged() {
            const e = this.layer.layer
              , t = null !== e ? e.type : "auto"
              , {typeSelect: n, typeSelectMeasure: i} = this;
            i.textContent = t,
            n.value = t,
            n.style.width = `${i.offsetWidth}px`,
            this.layerName.value = this.layer.name
        }
        handleLayerNameViewChanged() {
            Object(ie.l)(this.layer, this.layerName.value)
        }
    }
    class Bn extends f.a {
        constructor(e) {
            super(),
            this.state = e,
            this.element = document.createElement("div"),
            this.stack = this.registerDisposer(new Pn.a(e=>new Vn(e,this.state.layerManager,this.collapse.bind(this)),(()=>{
                const {state: e} = this;
                return {
                    changed: e.changed,
                    get value() {
                        return e.layer
                    }
                }
            }
            )())),
            this.debouncedUpdateView = this.registerCancellable(Object(_.a)(()=>this.handleStateChanged())),
            this.debouncedUpdateLayers = this.registerCancellable(Object(_.a)(()=>this.handleLayersChanged()));
            const {element: t, stack: n} = this;
            t.className = "neuroglancer-layer-side-panel",
            n.element.classList.add("neuroglancer-layer-info-panel-container"),
            t.appendChild(n.element),
            this.registerDisposer(e.changed.add(()=>this.handleStateChanged())),
            this.registerDisposer(e.layerManager.layersChanged.add(this.debouncedUpdateLayers)),
            this.debouncedUpdateView()
        }
        handleLayersChanged() {
            const {layerManager: e} = this.state
              , {stack: t} = this;
            for (const n of t.tabs.keys())
                e.has(n) || t.invalidate(n)
        }
        collapse() {
            const {state: e} = this;
            !0 === e.visible && (this.state.visible = !1,
            this.state.changed.dispatch())
        }
        handleStateChanged() {
            const {state: e} = this
              , {visible: t} = e;
            this.element.style.display = t ? "" : "none",
            this.stack.visibility.value = t ? Pe.b.VISIBLE : Pe.b.IGNORED
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    n(192);
    var Fn = n(8)
      , _n = n(82);
    n(193);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class Un extends f.a {
        constructor() {
            super(),
            this.element = document.createElement("div");
            const {element: e} = this;
            e.className = "neuroglancer-tooltip",
            e.style.visibility = "hidden",
            document.body.appendChild(e)
        }
        updatePosition(e, t) {
            const {element: n} = this;
            n.style.left = e + "px",
            n.style.top = t + "px",
            n.style.visibility = "inherit"
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const zn = new Map([[Fn.e.AXIS_ALIGNED_BOUNDING_BOX, (e,t,n)=>{
        const i = document.createElement("div");
        i.className = "neuroglancer-annotation-details-volume",
        t.appendChild(i)
    }
    ]]);
    class Gn extends f.a {
        constructor(e, t, n) {
            super(),
            this.mouseState = e,
            this.layerManager = t,
            this.coordinateSpace = n,
            this.tooltip = void 0,
            this.debouncedShowTooltip = this.registerCancellable(J()(()=>this.doCreateTooltip(), 500)),
            this.debouncedShowTooltip0 = this.registerCancellable(J()(()=>this.doCreateTooltip(), 0)),
            this.doCreateTooltip = ()=>{
                this.debouncedShowTooltip.cancel(),
                this.debouncedShowTooltip0.cancel();
                const {mouseState: e} = this;
                if (!this.maybeCreateTooltip()) {
                    const {tooltip: e} = this;
                    return void 0 !== e && (e.dispose(),
                    this.tooltip = void 0),
                    void this.setReference(void 0)
                }
                this.tooltip.updatePosition(e.pageX, e.pageY)
            }
            ,
            this.registerDisposer(e.changed.add(()=>this.mouseStateChanged()))
        }
        setReference(e) {
            const t = this.reference;
            void 0 !== t && (t.changed.remove(this.debouncedShowTooltip0),
            t.dispose(),
            this.reference = void 0),
            this.reference = e,
            void 0 !== e && e.changed.add(this.debouncedShowTooltip0)
        }
        maybeCreateTooltip() {
            const e = ae(this.mouseState, this.layerManager);
            if (void 0 === e)
                return !1;
            const {coordinateSpace: {value: t}} = this;
            if (void 0 === t)
                return !1;
            let {tooltip: n} = this;
            void 0 === n && (n = this.tooltip = new Un,
            n.element.classList.add("neuroglancer-mouse-selection-tooltip"));
            const i = e.annotationLayer.source.getReference(e.id);
            if (this.setReference(i),
            this.annotationLayer = e.annotationLayer,
            null === i.value)
                return !1;
            Object(r.b)(n.element);
            const s = document.createElement("div");
            s.className = "neuroglancer-mouse-selection-tooltip-title",
            s.textContent = `${e.layer.name}`;
            const a = document.createElement("div");
            a.className = "neuroglancer-mouse-selection-tooltip-description";
            const o = i.value;
            if (a.textContent = void 0 === o ? "Loading..." : o.description || "",
            n.element.appendChild(s),
            n.element.appendChild(a),
            null != o) {
                const {relatedSegments: t} = o;
                if (void 0 !== t && t.length > 0)
                    for (let i = 0, r = t.length; i < r; ++i) {
                        const r = t[i];
                        if (void 0 === r || 0 === r.length)
                            continue;
                        const s = document.createElement("div")
                          , a = e.annotationLayer.source.relationships[i]
                          , o = document.createElement("span");
                        o.textContent = a,
                        o.classList.add("neuroglancer-annotation-tooltip-relationship-label"),
                        s.appendChild(o),
                        s.className = "neuroglancer-annotation-segment-list";
                        const l = e.annotationLayer.displayState.relationshipStates.get(a).segmentationState.value
                          , c = l ? l.segmentColorHash : void 0;
                        r.forEach((e,t)=>{
                            0 !== t && s.appendChild(document.createTextNode(" "));
                            const n = document.createElement("span");
                            n.className = "neuroglancer-annotation-tooltip-segment-item",
                            n.textContent = e.toString(),
                            void 0 !== c && (n.style.backgroundColor = c.computeCssColor(e)),
                            s.appendChild(n)
                        }
                        ),
                        n.element.appendChild(s)
                    }
                const i = o.properties
                  , {properties: r} = e.annotationLayer.source;
                for (let e = 0, t = r.length; e < t; ++e) {
                    const t = document.createElement("div");
                    t.classList.add("neuroglancer-annotation-tooltip-property");
                    const s = r[e]
                      , a = document.createElement("span");
                    a.classList.add("neuroglancer-annotation-tooltip-property-label"),
                    a.textContent = s.identifier,
                    t.appendChild(a);
                    const o = document.createElement("span");
                    a.classList.add("neuroglancer-annotation-tooltip-property-value"),
                    o.textContent = i[e].toString(),
                    t.appendChild(o),
                    n.element.appendChild(t)
                }
                const s = e.annotationLayer.chunkTransform.value
                  , a = Object(Fn.k)(o.type)
                  , l = document.createElement("div");
                l.appendChild(document.createTextNode(a.icon)),
                Object(_n.b)(l, o, s),
                l.className = "neuroglancer-mouse-selection-tooltip-annotation-corners",
                n.element.appendChild(l);
                const c = zn.get(o.type);
                void 0 !== c && c(o, n.element, s)
            }
            return !0
        }
        mouseStateChanged() {
            const {tooltip: e} = this;
            if (void 0 !== e) {
                const t = ae(this.mouseState, this.layerManager)
                  , {reference: n} = this;
                if (void 0 !== t && void 0 !== n && this.annotationLayer === t.annotationLayer && t.id === n.id)
                    return;
                e.dispose(),
                this.tooltip = void 0
            }
            this.setReference(void 0),
            this.debouncedShowTooltip()
        }
        disposed() {
            const {tooltip: e} = this;
            void 0 !== e && (e.dispose(),
            this.tooltip = void 0),
            this.setReference(void 0),
            super.disposed()
        }
    }
    n(130),
    n(194),
    n(132),
    n(195),
    n(196),
    n(197),
    n(131),
    n(198);
    var $n = n(57)
      , Wn = n.n($n);
    class Hn extends Pt.a {
        constructor(e) {
            super(),
            this.viewer = e,
            this.parsedValue = null,
            this.debouncedValueUpdater = J()(()=>{
                const e = this.textEditor.getValue();
                try {
                    const t = JSON.parse(e);
                    this.parsedValue = t,
                    this.applyButton.disabled = !1,
                    this.textEditor.setOption("lint", void 0)
                } catch (t) {
                    this.parsedValue = null,
                    this.applyButton.disabled = !0;
                    let n = 0
                      , i = 0
                      , r = "Unknown parse error";
                    if (t instanceof Error) {
                        const s = t.message.match(/^((?:.|\n)*) in JSON at position ([0-9]+)$/);
                        if (null !== s) {
                            r = s[1];
                            const t = parseInt(s[2], 10)
                              , a = e.substring(0, t).split("\n");
                            n = a.length - 1,
                            i = a[a.length - 1].length
                        } else
                            r = t.message
                    }
                    this.textEditor.setOption("lint", {
                        getAnnotations: ()=>[{
                            message: r,
                            severity: "error",
                            from: Wn.a.Pos(n, i)
                        }]
                    })
                }
            }
            , 100),
            this.content.classList.add("neuroglancer-state-editor");
            const t = this.applyButton = document.createElement("button");
            t.textContent = "Apply changes",
            this.content.appendChild(t),
            t.addEventListener("click", ()=>this.applyChanges()),
            t.disabled = !0;
            const n = this.exportButton = document.createElement("button");
            n.textContent = "Export",
            this.content.appendChild(n),
            n.addEventListener("click", ()=>this.exportState()),
            this.textEditor = Wn()(e=>{}
            , {
                value: "",
                mode: {
                    name: "javascript",
                    json: !0
                },
                foldGutter: !0,
                gutters: ["CodeMirror-lint-markers", "CodeMirror-foldgutter"]
            }),
            this.updateView(),
            this.textEditor.on("change", ()=>{
                this.debouncedValueUpdater()
            }
            ),
            this.content.appendChild(this.textEditor.getWrapperElement()),
            this.textEditor.refresh()
        }
        exportState() {
            var e = document.createElement("a")
              , t = new Blob([this.getJson()],{
                type: "text/json"
            })
              , n = URL.createObjectURL(t);
            e.href = n,
            e.download = "state.json",
            e.click(),
            document.body.removeChild(e)
        }
        applyChanges() {
            null !== this.parsedValue && (this.viewer.state.reset(),
            this.viewer.state.restoreState(this.parsedValue)),
            this.applyButton.disabled = !0
        }
        updateView() {
            this.textEditor.setValue(this.getJson()),
            this.textEditor.execCommand("foldAll"),
            this.textEditor.execCommand("unfold")
        }
        getJson() {
            return JSON.stringify(Object(s.b)(this.viewer.state).value, null, "  ")
        }
    }
    n(199);
    var Jn = n(10);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class qn {
        constructor() {
            this.tracker = new s.a,
            this.visible = new Ae.b(!1),
            this.size = new tt.c(100,nt.D),
            this.tracker.add("visible", this.visible),
            this.tracker.add("size", this.size)
        }
        get changed() {
            return this.tracker.changed
        }
        restoreState(e) {
            this.tracker.restoreState(e)
        }
        reset() {
            this.tracker.reset()
        }
        toJSON() {
            const e = this.tracker.toJSON();
            for (const t of Object.keys(e))
                if (void 0 !== e[t])
                    return e
        }
    }
    function Yn(e) {
        const t = new Map;
        return function e(n, i) {
            if ("object" == typeof n)
                for (const t of Object.keys(n))
                    e(n[t], i + "." + t);
            else
                t.set(i, "" + n)
        }(e, ""),
        t
    }
    function Xn(e) {
        const t = e.map(Yn)
          , n = function(e) {
            const t = new Set;
            t.add(".type");
            const n = new Set;
            function i(n, i) {
                for (const r of t)
                    if (e[n].get(r) !== e[i].get(r))
                        return !0;
                return !1
            }
            for (let r = 0, s = e.length; r < s; ++r) {
                for (const t of e[r].keys())
                    n.add(t);
                let s = [];
                for (let e = 0; e < r; ++e)
                    i(r, e) || s.push(e);
                for (; s.length > 0; ) {
                    let i = s
                      , a = void 0;
                    for (const o of n) {
                        if (t.has(o))
                            continue;
                        const n = [];
                        for (const t of s)
                            e[t].get(o) === e[r].get(o) && n.push(t);
                        if (n.length < i.length && (i = n,
                        a = o),
                        0 === n.length)
                            break
                    }
                    if (void 0 === a)
                        break;
                    s = i,
                    t.add(a)
                }
            }
            return Array.from(t)
        }(t);
        return t.map(e=>function(e, t) {
            const n = {};
            for (const i of t) {
                const t = e.get(i);
                if (void 0 !== t) {
                    if ("" === i)
                        return t;
                    n[i] = t
                }
            }
            return JSON.stringify(n)
        }(e, n))
    }
    class Kn extends f.a {
        constructor(e, t) {
            super(),
            this.chunkQueueManager = e,
            this.displayState = t,
            this.element = document.createElement("div"),
            this.columns = new Map,
            this.data = void 0,
            this.requestDataTimerId = -1,
            this.dataRequested = !1,
            this.debouncedUpdateView = this.registerCancellable(J()(()=>this.updateView(), 0));
            const {element: n} = this;
            n.className = "neuroglancer-statistics-panel",
            this.registerDisposer(this.displayState.changed.add(this.debouncedUpdateView)),
            this.registerDisposer(this.displayState.visible.changed.add(()=>this.requestData())),
            this.requestData();
            const {columns: i} = this;
            i.set("Visible chunks/T", e=>{
                let t = 0;
                for (let n = 0; n < Jn.l; ++n)
                    t += e[Object(Jn.j)(n, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks];
                return t
            }
            ),
            i.set("Visible chunks/D", e=>e[Object(Jn.j)(Jn.g.DOWNLOADING, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks]),
            i.set("Visible chunks/M", e=>e[Object(Jn.j)(Jn.g.SYSTEM_MEMORY, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks] + e[Object(Jn.j)(Jn.g.SYSTEM_MEMORY_WORKER, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks]),
            i.set("Visible chunks/G", e=>e[Object(Jn.j)(Jn.g.GPU_MEMORY, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks]),
            i.set("Visible chunks/F", e=>e[Object(Jn.j)(Jn.g.FAILED, Jn.f.VISIBLE) * Jn.k + Jn.e.numChunks]),
            i.set("Visible memory", e=>e[Object(Jn.j)(Jn.g.GPU_MEMORY, Jn.f.VISIBLE) * Jn.k + Jn.e.gpuMemoryBytes]),
            i.set("Download latency", e=>e[Object(Jn.i)(Jn.d.totalTime)] / e[Object(Jn.i)(Jn.d.totalChunks)])
        }
        disposed() {
            clearTimeout(this.requestDataTimerId),
            Object(r.c)(this.element),
            super.disposed()
        }
        requestData() {
            if (!this.displayState.visible.value)
                return;
            if (this.dataRequested)
                return;
            const {chunkQueueManager: e} = this
              , t = e.rpc;
            this.dataRequested = !0,
            t.promiseInvoke(Jn.h, {
                queue: e.rpcId
            }).then(e=>{
                this.dataRequested = !1,
                this.data = e,
                this.debouncedUpdateView(),
                this.requestDataTimerId = setTimeout(()=>{
                    this.requestDataTimerId = -1,
                    this.requestData()
                }
                , 1e3)
            }
            )
        }
        updateView() {
            if (!this.displayState.visible.value)
                return;
            const {data: e} = this;
            if (void 0 === e)
                return;
            const {columns: t} = this
              , n = this.chunkQueueManager.rpc
              , i = document.createElement("table")
              , s = [];
            for (const [i,r] of e) {
                const e = n.get(i);
                if (void 0 === e)
                    continue;
                const a = [e];
                for (const e of t.values())
                    a.push(e(r));
                s.push(a)
            }
            const a = Xn(s.map(e=>Object.assign({
                type: e[0].RPC_TYPE_ID
            }, e[0].key || {})))
              , o = new Map;
            a.forEach((e,t)=>{
                o.set(s[t][0], e)
            }
            );
            {
                const e = document.createElement("thead");
                let n = document.createElement("tr");
                e.appendChild(n);
                const r = e=>{
                    const t = document.createElement("td");
                    t.textContent = e,
                    n.appendChild(t)
                }
                ;
                r("Name");
                let s = void 0;
                for (const e of t.keys()) {
                    const t = e.indexOf("/");
                    let i = e;
                    if (-1 !== t) {
                        if (i = e.substring(0, t),
                        i === s) {
                            ++n.lastElementChild.colSpan;
                            continue
                        }
                        s = i
                    }
                    r(i)
                }
                n = document.createElement("tr"),
                e.appendChild(n);
                {
                    const e = document.createElement("td");
                    n.appendChild(e)
                }
                for (const e of t.keys()) {
                    const t = e.indexOf("/");
                    let i = "";
                    -1 !== t && (i = e.substring(t + 1));
                    const r = document.createElement("td");
                    r.textContent = i,
                    n.appendChild(r)
                }
                i.appendChild(e)
            }
            const l = document.createElement("tbody");
            for (const [e,...t] of s) {
                const n = document.createElement("tr")
                  , i = e=>{
                    const t = document.createElement("td");
                    t.textContent = e,
                    n.appendChild(t)
                }
                ;
                i(o.get(e));
                for (const e of t)
                    i("" + e);
                l.appendChild(n)
            }
            i.appendChild(l),
            Object(r.b)(this.element),
            this.element.appendChild(i)
        }
    }
    var Zn = n(20);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function Qn(e, t) {
        return e.replace(new RegExp("[?&]" + t + "=[^&#]*(#.*)?$"), "$1").replace(new RegExp("([?&])" + t + "=[^&]*&"), "$1")
    }
    class ei extends f.a {
        constructor(e, t=200) {
            super(),
            this.root = e,
            this.parseError = new tt.e(void 0),
            this.registerEventListener(window, "hashchange", ()=>this.updateFromUrlHash());
            const n = J()(()=>this.setUrlHash(), t);
            this.registerDisposer(e.changed.add(n)),
            this.registerDisposer(()=>n.cancel())
        }
        setUrlHash() {
            const e = Object(s.b)(this.root)
              , {generation: t} = e;
            if (history.replaceState(null, "", Qn(window.location.href, "json_url")),
            t !== this.prevStateGeneration) {
                this.prevStateGeneration = e.generation;
                let t = (n = JSON.stringify(e.value),
                encodeURI(n).replace(/[!'()*;,]/g, (function(e) {
                    return "%" + e.charCodeAt(0).toString(16).toUpperCase()
                }
                )));
                t !== this.prevStateString && (this.prevStateString = t,
                "{}" === decodeURIComponent(t) ? history.replaceState(null, "", "#") : history.replaceState(null, "", "#!" + t))
            }
            var n
        }
        updateFromUrlHash() {
            try {
                let e = location.href.replace(/^[^#]+/, "");
                if ("" !== e && "#" !== e && "#!" !== e || (e = "#!{}"),
                e.match(/^#!(http|https|gs):\/\//)) {
                    const t = e.substring(2)
                      , n = Object(Zn.d)(t);
                    i.a.forPromise(Object(Zn.c)(n).then(e=>e.json()).then(e=>{
                        Object(nt.w)(e),
                        this.root.reset(),
                        this.root.restoreState(e)
                    }
                    ), {
                        initialMessage: `Loading state from ${t}`,
                        errorPrefix: "Error loading state:"
                    })
                } else if (e.startsWith("#!+")) {
                    e = e.slice(3),
                    e = decodeURIComponent(e);
                    let t = Object(nt.j)(e);
                    Object(nt.w)(t),
                    this.root.restoreState(t),
                    this.prevStateString = void 0
                } else {
                    if (!e.startsWith("#!"))
                        throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
                    {
                        if (e = e.slice(2),
                        e = decodeURIComponent(e),
                        e === this.prevStateString)
                            return;
                        this.prevStateString = e,
                        this.root.reset();
                        let t = Object(nt.j)(e);
                        Object(nt.w)(t),
                        this.root.restoreState(t)
                    }
                }
                this.parseError.value = void 0
            } catch (e) {
                this.parseError.value = e
            }
        }
    }
    var ti = n(62);
    n(200);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class ni extends f.a {
        constructor(e) {
            super(),
            this.selectedLayer = e,
            this.element = document.createElement("div");
            const {element: t} = this;
            t.className = "neuroglancer-annotation-tool-status-widget",
            this.registerDisposer(e.changed.add(()=>this.selectedLayerChanged())),
            this.selectedLayerChanged()
        }
        selectedLayerChanged() {
            let {unbindPreviousLayer: e} = this;
            void 0 !== e && e();
            const t = this.selectedLayer.layer;
            void 0 !== t && (this.unbindPreviousLayer = t.specificationChanged.add(()=>{
                this.updateView()
            }
            )),
            this.updateView()
        }
        disposed() {
            const {unbindPreviousLayer: e} = this;
            void 0 !== e && e(),
            this.unbindPreviousLayer = void 0
        }
        getDescriptionText() {
            const e = this.selectedLayer.layer;
            if (void 0 === e)
                return;
            const t = e.layer;
            if (null === t)
                return;
            const n = t.tool.value;
            return void 0 !== n ? n.description : void 0
        }
        updateView() {
            this.element.textContent = this.getDescriptionText() || ""
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class ii extends f.a {
        constructor(e, t={}) {
            super(),
            this.model = e,
            this.element = document.createElement("label"),
            this.inputElement = document.createElement("input");
            let {validator: n, label: i} = t;
            const {element: r, inputElement: s} = this;
            void 0 === n && (n = e instanceof tt.c ? e.validator : e=>e),
            this.validator = n,
            void 0 !== i && (r.textContent = i),
            r.appendChild(s),
            r.className = "neuroglancer-number-input",
            s.type = "input",
            this.registerDisposer(this.model.changed.add(()=>this.updateView())),
            this.registerEventListener(s, "change", ()=>this.updateModel()),
            this.updateView()
        }
        updateView() {
            this.inputElement.value = "" + this.model.value
        }
        updateModel() {
            let e = parseFloat(this.inputElement.value.trim());
            if (Number.isNaN(e))
                this.updateView();
            else
                try {
                    e = this.validator(e),
                    this.model.value = e
                } catch (e) {
                    this.updateView()
                }
        }
        disposed() {
            Object(r.c)(this.element),
            super.disposed()
        }
    }
    n(201);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function ri(e) {
        return e
    }
    class si extends f.a {
        constructor(e, t, n="") {
            super(),
            this.gl = e,
            this.frameNumberCounter = t;
            const i = n + "chunk_worker.bundle.js";
            this.worker = new Worker(i),
            this.chunkQueueManager = this.registerDisposer(new q.d(new Ne.a(this.worker),this.gl,this.frameNumberCounter,{
                gpuMemory: new q.a({
                    defaultItemLimit: 1e6,
                    defaultSizeLimit: 1e9
                }),
                systemMemory: new q.a({
                    defaultItemLimit: 1e7,
                    defaultSizeLimit: 2e9
                }),
                download: new q.a({
                    defaultItemLimit: 32,
                    defaultSizeLimit: Number.POSITIVE_INFINITY
                }),
                compute: new q.a({
                    defaultItemLimit: 128,
                    defaultSizeLimit: 5e8
                })
            })),
            this.chunkQueueManager.registerDisposer(()=>this.worker.terminate()),
            this.chunkManager = this.registerDisposer(new q.c(this.chunkQueueManager))
        }
        get rpc() {
            return this.chunkQueueManager.rpc
        }
    }
    const ai = ["showHelpButton", "showEditStateButton", "showLayerPanel", "showLocation", "showLayerHoverValues", "showAnnotationToolStatus", "showJsonPostButton"]
      , oi = ["showUIControls", "showPanelBorders", ...ai];
    class li extends class {
        constructor() {
            this.showHelpButton = new Ae.b(!0),
            this.showEditStateButton = new Ae.b(!0),
            this.showJsonPostButton = new Ae.b(!0),
            this.showLayerPanel = new Ae.b(!0),
            this.showLocation = new Ae.b(!0),
            this.showLayerHoverValues = new Ae.b(!0),
            this.showAnnotationToolStatus = new Ae.b(!0)
        }
    }
    {
        constructor() {
            super(...arguments),
            this.showUIControls = new Ae.b(!0),
            this.showPanelBorders = new Ae.b(!0)
        }
    }
    class ci extends s.a {
        constructor(e) {
            super(),
            this.viewer = e,
            this.add("dimensions", e.coordinateSpace),
            this.add("relativeDisplayScales", e.relativeDisplayScales),
            this.add("displayDimensions", e.displayDimensions),
            this.add("position", e.position),
            this.add("crossSectionOrientation", e.crossSectionOrientation),
            this.add("crossSectionScale", e.crossSectionScale),
            this.add("crossSectionDepth", e.crossSectionDepthRange),
            this.add("projectionOrientation", e.projectionOrientation),
            this.add("projectionScale", e.projectionScale),
            this.add("projectionDepth", e.projectionDepthRange),
            this.add("layers", e.layerSpecification),
            this.add("showAxisLines", e.showAxisLines),
            this.add("wireFrame", e.wireFrame),
            this.add("showScaleBar", e.showScaleBar),
            this.add("showDefaultAnnotations", e.showDefaultAnnotations),
            this.add("showSlices", e.showPerspectiveSliceViews),
            this.add("gpuMemoryLimit", e.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit),
            this.add("systemMemoryLimit", e.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit),
            this.add("concurrentDownloads", e.dataContext.chunkQueueManager.capacities.download.itemLimit),
            this.add("jsonStateServer", e.jsonStateServer),
            this.add("selectedLayer", e.selectedLayer),
            this.add("crossSectionBackgroundColor", e.crossSectionBackgroundColor),
            this.add("projectionBackgroundColor", e.perspectiveViewBackgroundColor),
            this.add("layout", e.layout),
            this.add("statistics", e.statisticsDisplayState)
        }
        restoreState(e) {
            const {viewer: t} = this;
            super.restoreState(e),
            Object(nt.B)(e, "navigation", e=>{
                Object(nt.w)(e),
                Object(nt.B)(e, "pose", e=>{
                    Object(nt.w)(e),
                    Object(nt.B)(e, "position", e=>{
                        Object(nt.w)(e),
                        Object(s.c)(e, "voxelCoordinates", t.position),
                        Object(nt.B)(e, "voxelSize", e=>{
                            const n = Object(nt.d)(new Float64Array(3), e, nt.r);
                            for (let e = 0; e < 3; ++e)
                                n[e] *= 1e-9;
                            t.coordinateSpace.value = Object(Y.z)({
                                valid: !1,
                                names: ["x", "y", "z"],
                                units: ["m", "m", "m"],
                                scales: n
                            })
                        }
                        )
                    }
                    ),
                    Object(s.c)(e, "orientation", t.crossSectionOrientation)
                }
                ),
                Object(s.c)(e, "zoomFactor", t.crossSectionScale.legacyJsonView)
            }
            ),
            Object(s.c)(e, "perspectiveOrientation", t.projectionOrientation),
            Object(s.c)(e, "perspectiveZoom", t.projectionScale.legacyJsonView),
            Object(s.c)(e, "perspectiveViewBackgroundColor", t.perspectiveViewBackgroundColor)
        }
    }
    class ui extends f.a {
        constructor(e, t={}) {
            super(),
            this.display = e,
            this.coordinateSpace = new Y.b,
            this.position = this.registerDisposer(new Q.k(this.coordinateSpace)),
            this.relativeDisplayScales = this.registerDisposer(new Q.p(this.coordinateSpace)),
            this.displayDimensions = this.registerDisposer(new Q.n(this.coordinateSpace)),
            this.displayDimensionRenderInfo = this.registerDisposer(new Q.q(this.relativeDisplayScales.addRef(),this.displayDimensions.addRef())),
            this.crossSectionOrientation = this.registerDisposer(new Q.j),
            this.crossSectionScale = this.registerDisposer(new Q.l(this.displayDimensionRenderInfo.addRef())),
            this.projectionOrientation = this.registerDisposer(new Q.j),
            this.crossSectionDepthRange = this.registerDisposer(new Q.m(-10,this.displayDimensionRenderInfo)),
            this.projectionDepthRange = this.registerDisposer(new Q.m(-50,this.displayDimensionRenderInfo)),
            this.projectionScale = this.registerDisposer(new Q.o(this.displayDimensionRenderInfo.addRef())),
            this.navigationState = this.registerDisposer(new Q.i(new Q.a(this.position.addRef(),this.displayDimensionRenderInfo.addRef(),this.crossSectionOrientation.addRef()),this.crossSectionScale.addRef(),this.crossSectionDepthRange.addRef())),
            this.perspectiveNavigationState = this.registerDisposer(new Q.i(new Q.a(this.position.addRef(),this.displayDimensionRenderInfo.addRef(),this.projectionOrientation.addRef()),this.projectionScale.addRef(),this.projectionDepthRange.addRef())),
            this.mouseState = new ie.f,
            this.layerManager = this.registerDisposer(new ie.a),
            this.selectedLayer = this.registerDisposer(new ie.h(this.layerManager.addRef())),
            this.showAxisLines = new Ae.b(!0,!0),
            this.wireFrame = new Ae.b(!1,!1),
            this.showScaleBar = new Ae.b(!0,!0),
            this.showPerspectiveSliceViews = new Ae.b(!0,!0),
            this.visibleLayerRoles = Object(De.f)(),
            this.showDefaultAnnotations = new Ae.b(!0,!0),
            this.crossSectionBackgroundColor = new ti.a(P.t.fromValues(.5, .5, .5)),
            this.perspectiveViewBackgroundColor = new ti.a(P.t.fromValues(0, 0, 0)),
            this.scaleBarOptions = new je.b,
            this.statisticsDisplayState = new qn,
            this.layerSelectedValues = this.registerDisposer(new ie.c(this.layerManager,this.mouseState)),
            this.resetInitiated = new U.a,
            this.jsonStateServer = new tt.c("",ri),
            this.uiControlVisibility = {},
            this.visible = !0;
            const {dataContext: n=new si(e.gl,e,t.bundleRoot), visibility: i=new Pe.b(Pe.b.VISIBLE), inputEventBindings: s={
                global: new de.a,
                sliceView: new de.a,
                perspectiveView: new de.a
            }, element: a=e.makeCanvasOverlayElement(), dataSourceProvider: o=Object(It.a)({
                credentialsManager: X.a
            }), uiConfiguration: l=new li} = t;
            this.visibility = i,
            this.inputEventBindings = s,
            this.element = a,
            this.dataSourceProvider = o,
            this.uiConfiguration = l,
            this.registerDisposer(()=>Object(r.c)(this.element)),
            this.dataContext = this.registerDisposer(n),
            function(e, t) {
                for (const n of oi) {
                    const i = t[n];
                    void 0 !== i && (e[n].value = i)
                }
            }(l, t);
            const c = Object.assign(Object.assign({}, "showLayerDialog: false, resetStateWhenEmpty: true"), t)
              , {resetStateWhenEmpty: u, showLayerDialog: d} = c;
            for (const e of ai)
                this.uiControlVisibility[e] = this.makeUiControlVisibilityState(e);
            this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(()=>{
                this.updateShowBorders()
            }
            )),
            this.showLayerDialog = d,
            this.resetStateWhenEmpty = u,
            this.layerSpecification = new ie.i(this.dataSourceProvider,this.layerManager,this.chunkManager,this.layerSelectedValues,this.navigationState.coordinateSpace,this.navigationState.pose.position),
            this.registerDisposer(e.updateStarted.add(()=>{
                this.onUpdateDisplay()
            }
            )),
            this.showDefaultAnnotations.changed.add(()=>{
                this.showDefaultAnnotations.value ? this.visibleLayerRoles.add(De.c.DEFAULT_ANNOTATION) : this.visibleLayerRoles.delete(De.c.DEFAULT_ANNOTATION)
            }
            ),
            this.registerDisposer(this.navigationState.changed.add(()=>{
                this.handleNavigationStateChanged()
            }
            ));
            const h = this.registerCancellable(J()(()=>{
                !this.wasDisposed && 0 === this.layerManager.managedLayers.length && this.resetStateWhenEmpty && (this.navigationState.reset(),
                this.perspectiveNavigationState.pose.orientation.reset(),
                this.perspectiveNavigationState.zoomFactor.reset(),
                this.resetInitiated.dispatch(),
                !Pt.b && this.showLayerDialog && this.visibility.visible && Object(ie.k)(this.layerSpecification, this.selectedLayer))
            }
            ));
            this.layerManager.layersChanged.add(h),
            h(),
            this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(()=>{
                this.layerSelectedValues.handleLayerChange()
            }
            )),
            this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(()=>{
                this.visible && e.scheduleRedraw()
            }
            )),
            this.makeUI(),
            this.updateShowBorders(),
            this.registerActionListeners(),
            this.registerEventActionBindings(),
            this.registerDisposer(gn(a, this.navigationState.position)),
            this.registerDisposer(new Gn(this.mouseState,this.layerManager,this.navigationState.coordinateSpace)),
            this.state = new ci(this)
        }
        get chunkManager() {
            return this.dataContext.chunkManager
        }
        get chunkQueueManager() {
            return this.dataContext.chunkQueueManager
        }
        makeUiControlVisibilityState(e) {
            const t = this.uiConfiguration.showUIControls
              , n = this.uiConfiguration[e];
            return this.registerDisposer(Object(tt.i)((e,t)=>e && t, t, n))
        }
        get inputEventMap() {
            return this.inputEventBindings.global
        }
        updateShowBorders() {
            const {element: e} = this
              , t = "neuroglancer-show-panel-borders";
            this.uiConfiguration.showPanelBorders.value ? e.classList.add(t) : e.classList.remove(t)
        }
        makeUI() {
            const e = this.element;
            e.classList.add("neuroglancer-viewer"),
            e.classList.add("neuroglancer-noselect"),
            e.style.display = "flex",
            e.style.flexDirection = "column";
            const t = document.createElement("div");
            t.title = "Right click for settings",
            t.classList.add("neuroglancer-viewer-top-row"),
            (this.contextMenu = this.registerDisposer(function(e) {
                const t = new mn
                  , {element: n} = t;
                n.classList.add("neuroglancer-viewer-context-menu");
                const i = (e,i)=>{
                    const r = t.registerDisposer(new ii(i,{
                        label: e
                    }));
                    r.element.classList.add("neuroglancer-viewer-context-menu-limit-widget"),
                    n.appendChild(r.element)
                }
                ;
                i("GPU memory limit", e.chunkQueueManager.capacities.gpuMemory.sizeLimit),
                i("System memory limit", e.chunkQueueManager.capacities.systemMemory.sizeLimit),
                i("Concurrent chunk requests", e.chunkQueueManager.capacities.download.itemLimit);
                const r = (e,i)=>{
                    const r = document.createElement("label");
                    r.textContent = e;
                    const s = t.registerDisposer(new Ae.c(i));
                    r.appendChild(s.element),
                    n.appendChild(r)
                }
                ;
                return r("Show axis lines", e.showAxisLines),
                r("Show scale bar", e.showScaleBar),
                r("Show cross sections in 3-d", e.showPerspectiveSliceViews),
                r("Show default annotations", e.showDefaultAnnotations),
                r("Show chunk statistics", e.statisticsDisplayState.visible),
                r("Wire frame rendering", e.wireFrame),
                t
            }(this))).registerParent(t),
            t.style.display = "flex",
            t.style.flexDirection = "row",
            t.style.alignItems = "stretch";
            const n = this.registerDisposer(new cn(this.navigationState.position,this.layerSpecification.coordinateSpaceCombiner));
            this.registerDisposer(new Ae.a(this.uiControlVisibility.showLocation,n.element)),
            t.appendChild(n.element);
            const i = this.registerDisposer(new un(document.createElement("div"),this.mouseState,this.navigationState.coordinateSpace));
            i.element.style.flex = "1",
            i.element.style.alignSelf = "center",
            this.registerDisposer(new Ae.a(this.uiControlVisibility.showLocation,i.element)),
            t.appendChild(i.element);
            const r = this.registerDisposer(new ni(this.selectedLayer));
            t.appendChild(r.element),
            this.registerDisposer(new Ae.a(this.uiControlVisibility.showAnnotationToolStatus,r.element));
            {
                const e = Object(Qt.a)({
                    text: "{}",
                    title: "Edit JSON state"
                });
                this.registerEventListener(e, "click", ()=>{
                    this.editJsonState()
                }
                ),
                this.registerDisposer(new Ae.a(this.uiControlVisibility.showEditStateButton,e)),
                t.appendChild(e)
            }
            {
                const e = Object(Qt.a)({
                    text: "",
                    title: "Post JSON to state server"
                });
                this.registerEventListener(e, "click", ()=>{
                    this.postJsonState()
                }
                ),
                this.registerDisposer(new Ae.a(this.uiControlVisibility.showJsonPostButton,e)),
                t.appendChild(e)
            }
            {
                const e = Object(Qt.a)({
                    text: "?",
                    title: "Help"
                });
                this.registerEventListener(e, "click", ()=>{
                    this.showHelpDialog()
                }
                ),
                this.registerDisposer(new Ae.a(this.uiControlVisibility.showHelpButton,e)),
                t.appendChild(e)
            }
            this.registerDisposer(new Ae.a(Object(tt.i)((...e)=>e.reduce((e,t)=>e || t, !1), this.uiControlVisibility.showHelpButton, this.uiControlVisibility.showEditStateButton, this.uiControlVisibility.showLocation, this.uiControlVisibility.showAnnotationToolStatus),t)),
            e.appendChild(t);
            const s = document.createElement("div");
            s.style.display = "flex",
            s.style.flex = "1",
            s.style.flexDirection = "row",
            this.layout = this.registerDisposer(new Ln(this,"4panel")),
            s.appendChild(this.layout.element);
            const a = this.registerDisposer(new Bn(this.selectedLayer.addRef()));
            s.appendChild(a.element);
            const o = this;
            a.registerDisposer(new An(a.element,{
                changed: o.selectedLayer.changed,
                get value() {
                    return o.selectedLayer.visible
                },
                set value(e) {
                    o.selectedLayer.visible = e
                }
            },this.selectedLayer.size,"horizontal",290)),
            e.appendChild(s);
            const l = this.registerDisposer(new Kn(this.chunkQueueManager,this.statisticsDisplayState));
            e.appendChild(l.element),
            l.registerDisposer(new An(l.element,this.statisticsDisplayState.visible,this.statisticsDisplayState.size,"vertical"));
            const c = ()=>{
                const t = this.visibility.visible;
                t !== this.visible && (e.style.visibility = t ? "inherit" : "hidden",
                this.visible = t)
            }
            ;
            c(),
            this.registerDisposer(this.visibility.changed.add(c))
        }
        registerEventActionBindings() {
            const {element: e} = this;
            this.registerDisposer(new de.b(e,this.inputEventMap)),
            this.registerDisposer(new ue.a(e))
        }
        bindAction(e, t) {
            this.registerDisposer(Object(o.d)(this.element, e, t))
        }
        registerActionListeners() {
            for (const e of ["recolor", "clear-segments"])
                this.bindAction(e, ()=>{
                    this.layerManager.invokeAction(e)
                }
                );
            for (const e of ["select"])
                this.bindAction(e, ()=>{
                    this.mouseState.updateUnconditionally(),
                    this.layerManager.invokeAction(e)
                }
                );
            this.bindAction("help", ()=>this.showHelpDialog());
            for (let e = 1; e <= 9; ++e)
                this.bindAction(`toggle-layer-${e}`, ()=>{
                    const t = e - 1
                      , n = this.layerManager.managedLayers;
                    if (t < n.length) {
                        let e = n[t];
                        e.setVisible(!e.visible)
                    }
                }
                ),
                this.bindAction(`select-layer-${e}`, ()=>{
                    const t = e - 1
                      , n = this.layerManager.managedLayers;
                    if (t < n.length) {
                        const e = n[t];
                        this.selectedLayer.layer = e,
                        this.selectedLayer.visible = !0
                    }
                }
                );
            this.bindAction("annotate", ()=>{
                const e = this.selectedLayer.layer;
                if (void 0 === e)
                    return void i.a.showTemporaryMessage("The annotate command requires a layer to be selected.");
                const t = e.layer;
                null !== t && void 0 !== t.tool.value ? t.tool.value.trigger(this.mouseState) : i.a.showTemporaryMessage(`The selected layer (${JSON.stringify(e.name)}) does not have an active annotation tool.`)
            }
            ),
            this.bindAction("toggle-axis-lines", ()=>this.showAxisLines.toggle()),
            this.bindAction("toggle-scale-bar", ()=>this.showScaleBar.toggle()),
            this.bindAction("toggle-default-annotations", ()=>this.showDefaultAnnotations.toggle()),
            this.bindAction("toggle-show-slices", ()=>this.showPerspectiveSliceViews.toggle()),
            this.bindAction("toggle-show-statistics", ()=>this.showStatistics())
        }
        showHelpDialog() {
            const {inputEventBindings: e} = this;
            new jt([["Global", e.global], ["Cross section view", e.sliceView], ["3-D projection view", e.perspectiveView]])
        }
        loadFromJsonUrl() {
            var e = new URLSearchParams(window.location.search);
            if (e.has("json_url")) {
                let t = e.get("json_url");
                history.replaceState(null, "", Qn(window.location.href, "json_url")),
                i.a.forPromise(Object(Zn.b)(t, {}, Zn.g).then(e=>{
                    this.state.restoreState(e)
                }
                ), {
                    initialMessage: `Retrieving state from json_url: ${t}.`,
                    delay: !0,
                    errorPrefix: "Error retrieving state: "
                })
            }
        }
        promptJsonStateServer(e) {
            let t = prompt(e, "https://json.neurodata.io/v1");
            null !== t ? (this.jsonStateServer.value = t,
            console.log("entered for JSON server:", this.jsonStateServer.value)) : (this.jsonStateServer.reset(),
            console.log("cancelled"))
        }
        postJsonState() {
            this.jsonStateServer.value || this.promptJsonStateServer("No state server found. Please enter a server URL, or hit OK to use the default server."),
            this.jsonStateServer.value && (i.a.showTemporaryMessage(`Posting state to ${this.jsonStateServer.value}.`),
            Object(Zn.b)(this.jsonStateServer.value, {
                method: "POST",
                body: JSON.stringify(this.state.toJSON())
            }, Zn.g).then(e=>{
                console.log(e.uri),
                history.replaceState(null, "", window.location.origin + window.location.pathname + "?json_url=" + e.uri)
            }
            ).catch(()=>{
                this.promptJsonStateServer("state server not responding, enter a new one?"),
                this.jsonStateServer.value && this.postJsonState()
            }
            ))
        }
        editJsonState() {
            new Hn(this)
        }
        showStatistics(e) {
            void 0 === e && (e = !this.statisticsDisplayState.visible.value),
            this.statisticsDisplayState.visible.value = e
        }
        get gl() {
            return this.display.gl
        }
        onUpdateDisplay() {
            this.visible && (this.dataContext.chunkQueueManager.chunkUpdateDeadline = null)
        }
        handleNavigationStateChanged() {
            if (this.visible) {
                let {chunkQueueManager: e} = this.dataContext;
                null === e.chunkUpdateDeadline && (e.chunkUpdateDeadline = Date.now() + 10)
            }
        }
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function di(e) {
        return Object(f.e)(document, "contextmenu", e=>{
            e.preventDefault()
        }
        ),
        Object(f.e)(document, "wheel", e=>{
            e.ctrlKey && e.preventDefault()
        }
        , {
            passive: !1
        }),
        function(e, t=document.getElementById("neuroglancer-container")) {
            try {
                let n = new W(t);
                return new ui(n,e)
            } catch (e) {
                throw i.a.showMessage(`Error: ${e.message}`),
                e
            }
        }(e)
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function hi() {
        let e = window.viewer = di();
        p(e.inputEventBindings);
        const t = e.registerDisposer(new ei(e.state));
        return e.registerDisposer(t.parseError.changed.add(()=>{
            const {value: e} = t.parseError;
            if (void 0 !== e) {
                (new i.a).setErrorMessage(`Error parsing state: ${e.message}`),
                console.log("Error parsing state", e)
            }
            t.parseError
        }
        )),
        t.updateFromUrlHash(),
        e.loadFromJsonUrl(),
        /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function(e) {
            e.registerEventListener(document, "copy", t=>{
                if (Object(r.a)(t.target))
                    return;
                const n = Object(s.b)(e.state).value
                  , {clipboardData: i} = t;
                null !== i && i.setData("text/plain", JSON.stringify(n, void 0, "  ")),
                t.preventDefault()
            }
            )
        }(e),
        a(e),
        e
    }
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    window.addEventListener("DOMContentLoaded", ()=>{
        hi()
    }
    )
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    n(159);
    var i, r = n(4), s = n(22), a = n(58), o = n(27), l = n(9), c = n(28), u = n(112), d = n(91);
    !function(e) {
        e[e.DEFAULT = 0] = "DEFAULT",
        e[e.ADDITIVE = 1] = "ADDITIVE"
    }(i || (i = {}));
    const h = new Map([[i.DEFAULT, e=>{
        e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA)
    }
    ], [i.ADDITIVE, e=>{
        e.blendFunc(e.SRC_ALPHA, e.ONE)
    }
    ]]);
    var p = n(7)
      , f = n(93)
      , m = n(34)
      , g = n(40);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const v = '#uicontrol vec3 color color(default="white")\n#uicontrol float min slider(default=0, min=0, max=1, step=0.01)\n#uicontrol float max slider(default=1, min=0, max=1, step=0.01)\n#uicontrol float brightness slider(default=0, min=-1, max=1, step=0.1)\n#uicontrol float contrast slider(default=0, min=-3, max=3, step=0.1)\n\nfloat scale(float x) {\n  return (x - min) / (max - min);\n}\n\nvoid main() {\n  emitRGB(\n    color * vec3(\n      scale(\n        toNormalized(getDataValue()))\n       + brightness) * exp(contrast)\n  );\n}';
    class b extends u.a {
        constructor(e, t) {
            const {opacity: n, blendMode: i, shaderControlState: r} = t;
            super(e, Object.assign(Object.assign({}, t), {
                fallbackShaderParameters: new p.e(Object(g.c)(v)),
                encodeShaderParameters: e=>e.source,
                shaderParameters: r.parseResult
            })),
            this.shaderControlState = r,
            this.opacity = n,
            this.blendMode = i,
            this.registerDisposer(n.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(i.changed.add(this.redrawNeeded.dispatch)),
            this.registerDisposer(r.changed.add(this.redrawNeeded.dispatch))
        }
        defineShader(e, t) {
            if (0 !== t.errors.length)
                throw new Error("Invalid UI control specification");
            e.addUniform("highp float", "uOpacity"),
            e.addFragmentCode("\nvoid emitRGBA(vec4 rgba) {\n  emit(vec4(rgba.rgb, rgba.a * uOpacity));\n}\nvoid emitRGB(vec3 rgb) {\n  emit(vec4(rgb, uOpacity));\n}\nvoid emitGrayscale(float value) {\n  emit(vec4(value, value, value, uOpacity));\n}\nvoid emitTransparent() {\n  emit(vec4(0.0, 0.0, 0.0, 0.0));\n}\n"),
            e.addFragmentCode(f.a),
            Object(g.b)(t.controls, e),
            e.setFragmentMainFunction(Object(m.e)(t.code))
        }
        initializeShader(e, t, n) {
            const {gl: i} = this;
            i.uniform1f(t.uniform("uOpacity"), this.opacity.value),
            Object(g.d)(i, t, this.shaderControlState, n.controls)
        }
        setGLBlendMode(e, t) {
            const n = this.blendMode.value;
            (n === i.ADDITIVE || t > 0) && (e.enable(e.BLEND),
            h.get(n)(e))
        }
    }
    var y = n(95)
      , S = n(82)
      , w = n(0)
      , x = (n(168),
    n(29))
      , C = n(6)
      , O = n(2)
      , k = n(5)
      , E = n(12);
    /**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const T = n(51).a.fromObject({
        arrowup: {
            action: "tab-backward"
        },
        arrowdown: {
            action: "tab-forward"
        },
        tab: {
            action: "tab-forward"
        },
        "shift+tab": {
            action: "tab-backward"
        },
        enter: {
            action: "commit"
        },
        escape: {
            action: "cancel"
        }
    });
    class M {
        constructor(e) {
            this.id = e,
            this.element = document.createElement("div"),
            this.nameContainer = document.createElement("div"),
            this.nameElement = document.createElement("input"),
            this.lowerElement = document.createElement("div"),
            this.upperElement = document.createElement("div");
            const {element: t, nameContainer: n, nameElement: i, lowerElement: r, upperElement: s} = this;
            t.classList.add("neuroglancer-channel-dimensions-widget-dim"),
            n.classList.add("neuroglancer-channel-dimensions-widget-name-container"),
            i.classList.add("neuroglancer-channel-dimensions-widget-name"),
            n.appendChild(i),
            r.classList.add("neuroglancer-channel-dimensions-widget-lower"),
            s.classList.add("neuroglancer-channel-dimensions-widget-upper"),
            t.appendChild(n),
            t.appendChild(r),
            t.appendChild(s),
            n.draggable = !0,
            i.disabled = !0,
            i.spellcheck = !1,
            i.autocomplete = "off",
            i.required = !0,
            i.placeholder = " ",
            n.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).",
            n.addEventListener("dblclick", ()=>{
                i.disabled = !1,
                i.focus(),
                i.select()
            }
            ),
            i.addEventListener("focus", ()=>{
                i.select()
            }
            )
        }
    }
    class D extends O.a {
        constructor(e) {
            super(),
            this.combiner = e,
            this.element = document.createElement("div"),
            this.dimensionWidgets = [],
            this.curCoordinateSpace = void 0,
            this.dragSource = void 0,
            this.coordinateSpace = this.combiner.combined;
            const {element: t} = this;
            t.classList.add("neuroglancer-channel-dimensions-widget");
            const n = this.registerCancellable(Object(x.a)(()=>this.updateView()));
            this.registerDisposer(e.combined.changed.add(n)),
            this.registerDisposer(new E.b(t,T)).allShortcutsAreGlobal = !0,
            this.registerDisposer(Object(E.c)(t, "cancel", e=>{
                this.forceUpdateView();
                const {target: t} = e;
                t instanceof HTMLElement && t.blur()
            }
            )),
            this.updateView()
        }
        reorderDimensionTo(e, t) {
            if (e === t)
                return;
            const {coordinateSpace: n} = this;
            n.value = Object(r.u)(n.value, e, t)
        }
        makeNewDimensionWidget(e) {
            const t = new M(e);
            return t.nameContainer.addEventListener("dragstart", e=>{
                this.dragSource = t,
                e.stopPropagation(),
                e.dataTransfer.setData("neuroglancer-dimension", "")
            }
            ),
            t.nameContainer.addEventListener("dragenter", e=>{
                const {dragSource: n} = this;
                if (void 0 === n || n === t)
                    return;
                const {dimensionWidgets: i} = this
                  , r = i.indexOf(n)
                  , s = i.indexOf(t);
                -1 !== r && -1 !== s && (e.preventDefault(),
                this.reorderDimensionTo(s, r))
            }
            ),
            t.nameContainer.addEventListener("dragend", e=>{
                this.dragSource === t && (this.dragSource = void 0)
            }
            ),
            t.nameElement.addEventListener("blur", e=>{
                t.nameElement.disabled = !0;
                const {relatedTarget: n} = e;
                this.dimensionWidgets.some(e=>e.nameElement === n) || this.updateNames() || this.forceUpdateView()
            }
            ),
            t.nameElement.addEventListener("input", ()=>{
                const {nameElement: e} = t;
                Object(k.e)(e),
                this.updateNameValidity()
            }
            ),
            Object(E.c)(t.nameElement, "commit", ()=>{
                this.updateNames()
            }
            ),
            Object(E.c)(t.nameElement, "tab-forward", e=>this.selectAdjacentField(e, t, 1)),
            Object(E.c)(t.nameElement, "tab-backward", e=>this.selectAdjacentField(e, t, -1)),
            t
        }
        selectAdjacentField(e, t, n) {
            e.stopPropagation();
            const {dimensionWidgets: i} = this
              , r = i.indexOf(t);
            if (-1 === r)
                return;
            const s = r + n;
            if (s < 0 || s >= i.length)
                return;
            const a = i[s];
            a.nameElement.disabled = !1,
            a.nameElement.focus(),
            e.preventDefault()
        }
        updateNames() {
            const {dimensionWidgets: e, coordinateSpace: t} = this
              , n = t.value
              , i = e.map(e=>e.nameElement.value);
            if (this.combiner.getRenameValidity(i).includes(!1))
                return !1;
            const r = n.names;
            if (Object(C.a)(r, i))
                return !1;
            const s = n.timestamps.map((e,t)=>r[t] === i[t] ? e : Date.now())
              , a = Object.assign(Object.assign({}, n), {
                names: i,
                timestamps: s
            });
            return t.value = a,
            !0
        }
        updateNameValidity() {
            const {dimensionWidgets: e} = this
              , t = e.map(e=>e.nameElement.value)
              , n = t.length
              , i = this.combiner.getRenameValidity(t);
            for (let t = 0; t < n; ++t)
                e[t].nameElement.dataset.isValid = !1 === i[t] ? "false" : "true"
        }
        forceUpdateView() {
            this.curCoordinateSpace = void 0,
            this.updateView()
        }
        updateView() {
            const {coordinateSpace: {value: e}} = this;
            if (this.curCoordinateSpace === e)
                return;
            this.curCoordinateSpace = e;
            const {element: t} = this
              , n = this.dimensionWidgets
              , i = this.dimensionWidgets = e.ids.map(e=>n.find(t=>t.id === e) || this.makeNewDimensionWidget(e));
            Object(k.d)(t, function*() {
                const {names: t, rank: n, bounds: {lowerBounds: r, upperBounds: s}} = e;
                for (let e = 0; e < n; ++e) {
                    const n = i[e];
                    n.nameElement.value = t[e],
                    delete n.nameElement.dataset.isValid,
                    Object(k.e)(n.nameElement),
                    n.lowerElement.textContent = r[e].toString(),
                    n.upperElement.textContent = s[e].toString(),
                    yield n.element
                }
            }
            .call(this))
        }
    }
    var L = n(102)
      , A = n(78)
      , I = n(79)
      , P = n(72)
      , R = n(87)
      , j = n(80)
      , N = n(81)
      , V = n(41);
    n.d(t, "ImageUserLayer", (function() {
        return F
    }
    ));
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const B = Object(S.a)(s.j);
    class F extends B {
        constructor(e, t) {
            super(e, t),
            this.opacity = Object(y.a)(.5),
            this.blendMode = function(e=i.DEFAULT) {
                return new d.a(i,e)
            }(),
            this.fragmentMain = function(e=v) {
                return Object(m.a)(e)
            }(),
            this.shaderError = Object(m.b)(),
            this.shaderControlState = new g.a(this.fragmentMain),
            this.sliceViewRenderScaleHistogram = new o.a,
            this.sliceViewRenderScaleTarget = Object(o.e)(1),
            this.channelCoordinateSpace = new r.b,
            this.channelCoordinateSpaceCombiner = new r.a(this.channelCoordinateSpace,r.v),
            this.localCoordinateSpaceCombiner.includeDimensionPredicate = r.x,
            this.blendMode.changed.add(this.specificationChanged.dispatch),
            this.opacity.changed.add(this.specificationChanged.dispatch),
            this.fragmentMain.changed.add(this.specificationChanged.dispatch),
            this.shaderControlState.changed.add(this.specificationChanged.dispatch),
            this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch),
            this.tabs.add("rendering", {
                label: "Rendering",
                order: -100,
                getter: ()=>new U(this)
            }),
            this.tabs.default = "rendering"
        }
        markLoading() {
            const e = super.markLoading()
              , t = this.channelCoordinateSpaceCombiner.retain();
            return ()=>{
                e(),
                t()
            }
        }
        addCoordinateSpace(e) {
            const t = super.addCoordinateSpace(e)
              , n = this.channelCoordinateSpaceCombiner.bind(e);
            return ()=>{
                t(),
                n()
            }
        }
        activateDataSubsources(e) {
            let t;
            for (const n of e) {
                if (this.addStaticAnnotations(n))
                    continue;
                const {subsourceEntry: e} = n
                  , {subsource: i} = e
                  , {volume: r} = i;
                r instanceof c.a ? t && r.dataType !== t ? n.deactivate(`Data type must be ${l.a[r.dataType].toLowerCase()}`) : (t = r.dataType,
                n.activate(()=>{
                    n.addRenderLayer(new b(r,{
                        opacity: this.opacity,
                        blendMode: this.blendMode,
                        shaderControlState: this.shaderControlState,
                        shaderError: this.shaderError,
                        transform: n.getRenderLayerTransform(this.channelCoordinateSpace),
                        renderScaleTarget: this.sliceViewRenderScaleTarget,
                        renderScaleHistogram: this.sliceViewRenderScaleHistogram,
                        localPosition: this.localPosition,
                        channelCoordinateSpace: this.channelCoordinateSpace
                    })),
                    this.shaderError.changed.dispatch()
                }
                )) : n.deactivate("Not compatible with image layer")
            }
        }
        restoreState(e) {
            super.restoreState(e),
            this.opacity.restoreState(e.opacity),
            Object(w.B)(e, "blend", e=>this.blendMode.restoreState(e)),
            this.fragmentMain.restoreState(e.shader);
            let t = {};
            "shaderControls"in e && (t = e.shaderControls),
            "min"in e && (t.min = e.min),
            "max"in e && (t.max = e.max),
            "color"in e && (t.color = e.color),
            this.shaderControlState.restoreState(t),
            this.sliceViewRenderScaleTarget.restoreState(e.crossSectionRenderScale)
        }
        toJSON() {
            const e = super.toJSON();
            return e.opacity = this.opacity.toJSON(),
            e.blend = this.blendMode.toJSON(),
            e.shader = this.fragmentMain.toJSON(),
            e.shaderControls = this.shaderControlState.toJSON(),
            e.crossSectionRenderScale = this.sliceViewRenderScaleTarget.toJSON(),
            e
        }
    }
    function _(e) {
        return new j.a({
            shaderError: e.shaderError,
            fragmentMain: e.fragmentMain,
            shaderControlState: e.shaderControlState
        })
    }
    F.type = "image";
    class U extends V.b {
        constructor(e) {
            super(),
            this.layer = e,
            this.opacityWidget = this.registerDisposer(new P.a(this.layer.opacity)),
            this.codeWidget = this.registerDisposer(_(this.layer));
            const {element: t} = this;
            t.classList.add("image-dropdown");
            let {opacityWidget: n} = this
              , i = document.createElement("div");
            i.className = "image-dropdown-top-row",
            n.promptElement.textContent = "Opacity";
            {
                const e = this.registerDisposer(new R.a(this.layer.sliceViewRenderScaleHistogram,this.layer.sliceViewRenderScaleTarget));
                e.label.textContent = "Resolution (slice)",
                t.appendChild(e.element)
            }
            {
                const n = document.createElement("label");
                n.textContent = "Blending",
                n.appendChild(this.registerDisposer(new L.a(e.blendMode)).element),
                t.appendChild(n)
            }
            let r = document.createElement("div");
            r.style.flex = "1",
            i.appendChild(this.opacityWidget.element),
            i.appendChild(r),
            i.appendChild(Object(I.a)({
                title: "Show larger editor view",
                onClick: ()=>{
                    new z(this.layer)
                }
            })),
            i.appendChild(Object(A.a)({
                title: "Documentation on image layer rendering",
                href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
            })),
            t.appendChild(i),
            t.appendChild(this.registerDisposer(new D(e.channelCoordinateSpaceCombiner)).element),
            t.appendChild(this.codeWidget.element),
            t.appendChild(this.registerDisposer(new N.a(e.shaderControlState)).element)
        }
    }
    class z extends a.a {
        constructor(e) {
            super(),
            this.layer = e,
            this.codeWidget = this.registerDisposer(_(this.layer)),
            this.content.classList.add("image-layer-shader-overlay"),
            this.content.appendChild(this.codeWidget.element),
            this.codeWidget.textEditor.refresh()
        }
    }
    Object(s.q)("image", F),
    Object(s.s)(l.b.IMAGE, F)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(99)
      , r = n(68)
      , s = n(86)
      , a = n(35)
      , o = n(23)
      , l = n(5)
      , c = n(0)
      , u = n(59)
      , d = n(3);
    class h {
        constructor() {
            this.finished = new d.b
        }
    }
    class p {
        constructor() {
            this.proxyName = `postmessageRelay${Object(u.a)()}`,
            this.rpcToken = `${Object(u.a)()}`,
            this.relayReadyService = `oauth2relayReady:${this.rpcToken}`,
            this.oauth2CallbackService = `oauth2callback:${this.rpcToken}`,
            this.pendingRequests = new Map,
            function(e, t) {
                let n = document.createElement("iframe");
                n.style.display = "none",
                n.id = e,
                n.name = e;
                const i = location.origin;
                n.src = "https://accounts.google.com/o/oauth2/postmessageRelay?" + `parent=${encodeURIComponent(i)}#rpctoken=${t}`,
                document.body.appendChild(n)
            }(this.proxyName, this.rpcToken),
            this.relayReadyPromise = new Promise(e=>{
                addEventListener("message", t=>{
                    if ("https://accounts.google.com" === t.origin)
                        try {
                            let n = Object(c.w)(JSON.parse(t.data))
                              , i = Object(c.E)(n.s);
                            if (i === this.relayReadyService && e(),
                            i === this.oauth2CallbackService) {
                                let e = Object(c.b)(n.a, e=>e)
                                  , t = Object(c.E)(e[0])
                                  , i = location.origin;
                                if (!t.startsWith(i + "#") && !t.startsWith(i + "?"))
                                    throw new Error(`oauth2callback: URL ${JSON.stringify(t)} ` + `does not match current origin ${i}.`);
                                let r = t.substring(i.length + 1).split("&")
                                  , s = new Map;
                                for (let e of r) {
                                    let t = e.match("^([a-z_]+)=(.*)$");
                                    if (null === t)
                                        throw new Error(`oauth2callback: URL part ${JSON.stringify(t)} ` + "does not match expected pattern.");
                                    s.set(t[1], t[2])
                                }
                                let a = s.get("state");
                                if (void 0 === a)
                                    throw new Error("oauth2callback: State argument is missing.");
                                let o = this.pendingRequests.get(a);
                                if (void 0 === o)
                                    return;
                                let l = s.get("error");
                                if (void 0 !== l) {
                                    let e = s.get("error_subtype")
                                      , t = l;
                                    return void 0 !== e && (t += ": " + e),
                                    void o.finished.dispatch(void 0, new Error(`Error obtaining Google OAuth2 token: ${t}`))
                                }
                                let u = s.get("access_token")
                                  , d = s.get("token_type")
                                  , h = s.get("expires_in")
                                  , p = s.get("scope");
                                if (void 0 === u || void 0 === d || void 0 === h || void 0 === p)
                                    throw new Error("oauth2callback: URL lacks expected parameters.");
                                return void o.finished.dispatch({
                                    accessToken: u,
                                    tokenType: d,
                                    expiresIn: h,
                                    scope: p
                                })
                            }
                        } catch (e) {
                            throw new Error(`Invalid message received from https://accounts.google.com: ${JSON.stringify(t.data)}: ` + `${e.message}.`)
                        }
                }
                )
            }
            )
        }
        addPendingRequest(e) {
            let t = new h;
            return this.pendingRequests.set(e, t),
            t.finished.add(()=>{
                this.pendingRequests.delete(e)
            }
            ),
            t
        }
        makeAuthRequestUrl(e) {
            let t = `https://accounts.google.com/o/oauth2/auth?client_id=${encodeURIComponent(e.clientId)}`;
            t += "&redirect_uri=postmessage",
            t += "&response_type=token";
            let {origin: n=location.origin} = e;
            return t += `&origin=${encodeURIComponent(n)}`,
            t += `&proxy=${this.proxyName}`,
            t += "&include_granted_scopes=true",
            t += `&scope=${encodeURIComponent(e.scopes.join(" "))}`,
            e.state && (t += `&state=${e.state}`),
            e.approvalPrompt && (t += `&approval_prompt=${encodeURIComponent(e.approvalPrompt)}`),
            e.loginHint && (t += `&login_hint=${encodeURIComponent(e.loginHint)}`),
            e.immediate && (t += "&immediate=true"),
            void 0 !== e.authUser && (t += `&authuser=${e.authUser}`),
            t
        }
    }
    let f;
    function m(e, t=o.e) {
        const n = Object(u.a)()
          , i = (void 0 === f && (f = new p),
        f)
          , r = i.makeAuthRequestUrl({
            state: n,
            clientId: e.clientId,
            scopes: e.scopes,
            approvalPrompt: e.approvalPrompt,
            loginHint: e.loginHint,
            immediate: e.immediate,
            authUser: e.authUser
        })
          , s = i.addPendingRequest(n)
          , a = new Promise((e,t)=>{
            s.finished.add((n,i)=>{
                void 0 !== n ? e(n) : t(i)
            }
            )
        }
        );
        if (s.finished.add(t.add(()=>{
            s.finished.dispatch(void 0, o.a)
        }
        )),
        e.immediate)
            i.relayReadyPromise.then(()=>{
                if (t.isCanceled)
                    return;
                const e = document.createElement("iframe");
                e.src = r,
                e.style.display = "none",
                document.body.appendChild(e),
                s.finished.add(()=>{
                    Object(l.c)(e)
                }
                )
            }
            );
        else if (!t.isCanceled) {
            const e = open(r);
            null !== e && s.finished.add(()=>{
                e.close()
            }
            )
        }
        return a
    }
    class g extends s.b {
        constructor(e) {
            super(),
            this.options = e,
            this.get = Object(s.c)(e=>{
                const {options: t} = this
                  , n = new a.a(!0);
                let i;
                return new Promise((r,s)=>{
                    function a(e=`${t.description} authorization required.`, i="Request authorization.") {
                        n.setText(e + "  ");
                        let r = document.createElement("button");
                        r.textContent = i,
                        n.element.appendChild(r),
                        r.addEventListener("click", ()=>{
                            l(!1)
                        }
                        ),
                        n.setVisible(!0)
                    }
                    function l(e) {
                        void 0 !== i && i.cancel(),
                        i = new o.b,
                        a(`Waiting for ${t.description} authorization...`, "Retry"),
                        m({
                            clientId: t.clientId,
                            scopes: t.scopes,
                            immediate: e,
                            authUser: 0
                        }, i).then(e=>{
                            void 0 !== i && (i = void 0,
                            n.dispose(),
                            r(e))
                        }
                        , n=>{
                            void 0 !== i && (i = void 0,
                            e ? a() : a(`${t.description} authorization failed: ${n}.`, "Retry"))
                        }
                        )
                    }
                    e.add(()=>{
                        void 0 !== i && (i.cancel(),
                        i = void 0,
                        n.dispose(),
                        s(o.a))
                    }
                    ),
                    l(!0)
                }
                )
            }
            )
        }
    }
    class v extends g {
        constructor(e) {
            super({
                clientId: e,
                scopes: ["https://www.googleapis.com/auth/brainmaps"],
                description: "Brain Maps"
            })
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    i.a.register(r.a, ()=>new v("639403125587-4k5hgdfumtrvur8v48e3pr7oo91d765k.apps.googleusercontent.com"))
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    n(178);
    var i = n(8)
      , r = n(105)
      , s = n(54)
      , a = n(4)
      , o = n(33)
      , l = n(22)
      , c = n(58)
      , u = n(38)
      , d = n(31)
      , h = n(117)
      , p = n(17)
      , f = n(7)
      , m = n(82)
      , g = n(29)
      , v = n(2)
      , b = n(5)
      , y = n(0)
      , S = n(3)
      , w = n(96)
      , x = n(78)
      , C = n(16)
      , O = n.n(C);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class k extends v.a {
        constructor(e) {
            super(),
            this.ref = e,
            this.element = document.createElement("label"),
            this.selectElement = document.createElement("select"),
            this.registerDisposer(e);
            const {element: t, selectElement: n} = this;
            t.appendChild(n),
            this.updateView(),
            this.registerEventListener(n, "change", ()=>this.updateModel()),
            this.registerDisposer(this.ref.changed.add(O()(()=>this.updateView(), 0)))
        }
        updateModel() {
            this.ref.layerName = this.selectElement.value || void 0
        }
        updateView() {
            const {selectElement: e, ref: t} = this
              , {filter: n} = t;
            Object(b.b)(e);
            const i = document.createElement("option");
            e.appendChild(i);
            for (const t of this.ref.layerManager.managedLayers)
                if (n(t)) {
                    const n = document.createElement("option")
                      , {name: i} = t;
                    n.textContent = i,
                    n.value = i,
                    e.appendChild(n)
                }
            e.value = t.layerName || ""
        }
    }
    var E = n(79)
      , T = n(87)
      , M = n(80)
      , D = n(81)
      , L = n(41);
    n.d(t, "AnnotationUserLayer", (function() {
        return N
    }
    ));
    function A(e) {
        const t = e.layer;
        return null === t || t instanceof h.SegmentationUserLayer
    }
    class I extends v.a {
        constructor(e, t, n) {
            super(),
            this.layerManager = e,
            this.annotationStates = t,
            this.annotationDisplayState = n,
            this.changed = new S.a,
            this.curGeneration = -1,
            this.wasLoading = void 0,
            this.map = new Map,
            this.registerDisposer(t.changed.add(()=>this.update())),
            this.registerDisposer(t.isLoadingChanged.add(()=>this.update())),
            this.update()
        }
        update() {
            const e = this.annotationStates.changed.count
              , t = this.annotationStates.isLoading;
            if (this.curGeneration === e && t === this.wasLoading)
                return;
            this.wasLoading = t,
            this.curGeneration = e;
            const {map: n} = this;
            let i = !1;
            for (const t of this.annotationStates.relationships) {
                let r = n.get(t);
                void 0 === r && (r = this.addRelationship(t),
                i = !0),
                r.seenGeneration = e
            }
            if (!t)
                for (const [t,r] of n)
                    r.seenGeneration !== e && (n.delete(t),
                    i = !0);
            i && this.changed.dispatch()
        }
        addRelationship(e) {
            const t = this.annotationDisplayState.relationshipStates.get(e)
              , n = new l.b(this.layerManager.addRef(),A);
            n.registerDisposer(n.changed.add(()=>{
                t.segmentationState.value = void 0 === n.layerName ? void 0 : function(e) {
                    if (void 0 === e)
                        return null;
                    const t = e.layer;
                    return null === t ? null : t instanceof h.SegmentationUserLayer ? t.displayState : null
                }(n.layer)
            }
            ));
            const {showMatches: i} = t
              , r = {
                layerRef: n,
                showMatches: i,
                seenGeneration: -1
            };
            return n.changed.add(this.changed.dispatch),
            i.changed.add(this.changed.dispatch),
            this.map.set(e, r),
            r
        }
        get(e) {
            return this.update(),
            this.map.get(e)
        }
        unbind(e) {
            e.layerRef.changed.remove(this.changed.dispatch),
            e.showMatches.changed.remove(this.changed.dispatch)
        }
        reset() {
            for (const e of this.map.values())
                e.showMatches.reset()
        }
        toJSON() {
            const {map: e} = this;
            if (0 === e.size)
                return {};
            let t = void 0;
            const n = [];
            for (const [i,r] of e) {
                r.showMatches.value && n.push(i);
                const {layerName: e} = r.layerRef;
                void 0 !== e && ((t = t || {})[i] = e)
            }
            return n.sort(),
            {
                linkedSegmentationLayer: t,
                filterBySegmentation: 0 === n.length ? void 0 : n
            }
        }
        restoreState(e) {
            const {isLoading: t} = this.annotationStates;
            Object(y.B)(e, "linkedSegmentationLayer", e=>{
                "string" == typeof e && (e = {
                    segments: e
                }),
                Object(y.w)(e);
                for (const n of Object.keys(e)) {
                    const i = Object(y.E)(e[n]);
                    let r = this.map.get(n);
                    if (void 0 === r) {
                        if (!t)
                            continue;
                        r = this.addRelationship(n)
                    }
                    r.layerRef.layerName = i
                }
                for (const [t,n] of this.map)
                    Object.prototype.hasOwnProperty.call(e, t) || (n.layerRef.layerName = void 0)
            }
            ),
            Object(y.B)(e, "filterBySegmentation", e=>{
                "boolean" == typeof e && (e = !0 === e ? ["segments"] : []);
                for (const n of Object(y.F)(e)) {
                    let e = this.map.get(n);
                    if (void 0 === e) {
                        if (!t)
                            continue;
                        e = this.addRelationship(n)
                    }
                    e.showMatches.value = !0
                }
            }
            )
        }
        disposed() {
            const {map: e} = this;
            for (const t of e.values())
                this.unbind(t);
            e.clear(),
            super.disposed()
        }
    }
    class P extends v.a {
        constructor(e, t) {
            super(),
            this.relationship = e,
            this.state = t,
            this.element = document.createElement("label"),
            this.seenGeneration = -1;
            const {element: n} = this
              , i = this.registerDisposer(new p.c(t.showMatches))
              , r = new k(t.layerRef);
            n.appendChild(i.element),
            n.appendChild(document.createTextNode(e)),
            n.appendChild(r.element)
        }
    }
    class R extends v.a {
        constructor(e) {
            super(),
            this.linkedSegmentationLayers = e,
            this.widgets = new Map,
            this.element = document.createElement("div"),
            this.element.style.display = "contents";
            const t = this.registerCancellable(Object(g.a)(()=>this.updateView()));
            this.registerDisposer(this.linkedSegmentationLayers.annotationStates.changed.add(t)),
            this.updateView()
        }
        updateView() {
            const {linkedSegmentationLayers: e} = this
              , {annotationStates: t} = e
              , n = t.changed.count
              , {widgets: i} = this;
            for (const [e,t] of i)
                t.seenGeneration !== n && (t.dispose(),
                i.delete(e));
            Object(b.d)(this.element, function*() {
                for (const r of t.relationships) {
                    let t = i.get(r);
                    void 0 === t && (t = new P(r,e.get(r))),
                    t.seenGeneration = n,
                    yield t.element
                }
            }
            .call(this))
        }
        disposed() {
            super.disposed();
            for (const e of this.widgets.values())
                e.dispose()
        }
    }
    const j = Object(m.a)(l.j);
    class N extends j {
        constructor(e, t) {
            super(e, t),
            this.annotationProperties = new f.e(void 0),
            this.localAnnotationsJson = void 0,
            this.pointAnnotationsJson = void 0,
            this.linkedSegmentationLayers = this.registerDisposer(new I(this.manager.rootLayers,this.annotationStates,this.annotationDisplayState)),
            this.linkedSegmentationLayers.restoreState(t),
            this.linkedSegmentationLayers.changed.add(this.specificationChanged.dispatch),
            this.annotationDisplayState.ignoreNullSegmentFilter.changed.add(this.specificationChanged.dispatch),
            this.annotationCrossSectionRenderScaleTarget.changed.add(this.specificationChanged.dispatch),
            this.localAnnotationsJson = t.annotations,
            this.pointAnnotationsJson = t.points,
            this.annotationCrossSectionRenderScaleTarget.restoreState(t.crossSectionAnnotationSpacing),
            this.annotationProjectionRenderScaleTarget.restoreState(t.projectionAnnotationSpacing),
            this.annotationDisplayState.ignoreNullSegmentFilter.restoreState(t.ignoreNullSegmentFilter),
            this.tabs.add("rendering", {
                label: "Rendering",
                order: -100,
                getter: ()=>new F(this)
            }),
            this.tabs.default = "annotations"
        }
        disposed() {
            const {localAnnotations: e} = this;
            void 0 !== e && e.dispose(),
            super.disposed()
        }
        getLegacyDataSourceSpecifications(e, t, n) {
            if (Object.prototype.hasOwnProperty.call(t, "source"))
                return super.getLegacyDataSourceSpecifications(e, t, n);
            const i = Object(y.B)(t, "voxelSize", e=>Object(y.d)(new Float64Array(3), e, e=>Object(y.r)(e) / 1e9))
              , r = ["m", "m", "m"];
            if (void 0 !== i) {
                const e = Object(a.z)({
                    rank: 3,
                    units: r,
                    scales: i,
                    names: ["x", "y", "z"]
                });
                n = void 0 === n ? {
                    outputSpace: e,
                    sourceRank: 3,
                    transform: void 0,
                    inputSpace: e
                } : Object.assign(Object.assign({}, n), {
                    inputSpace: e
                })
            }
            return [{
                url: o.e,
                transform: n,
                enableDefaultSubsources: !0,
                subsources: new Map
            }]
        }
        activateDataSubsources(e) {
            let t, n = !1;
            for (const s of e) {
                const {subsourceEntry: e} = s
                  , {local: a} = e.subsource;
                if (a === o.c.annotations) {
                    if (n) {
                        s.deactivate("Only one local annotations source per layer is supported");
                        continue
                    }
                    n = !0,
                    s.activate(t=>{
                        const n = this.localAnnotations = new i.f(s.loadedDataSource.transform);
                        try {
                            n.restoreState(this.localAnnotationsJson)
                        } catch (e) {}
                        t.registerDisposer(()=>{
                            n.dispose(),
                            this.localAnnotations = void 0
                        }
                        ),
                        t.registerDisposer(this.localAnnotations.changed.add(this.specificationChanged.dispatch));
                        try {
                            a = this.localAnnotations,
                            void 0 !== (o = this.pointAnnotationsJson) && Object(y.b)(o, (e,t)=>{
                                a.add({
                                    type: i.e.POINT,
                                    id: "" + t,
                                    point: Object(y.m)(e),
                                    properties: []
                                })
                            }
                            )
                        } catch (e) {}
                        var a, o;
                        this.pointAnnotationsJson = void 0,
                        this.localAnnotationsJson = void 0;
                        const l = new r.b({
                            localPosition: this.localPosition,
                            transform: t.registerDisposer(Object(u.g)(this.manager.root.coordinateSpace, this.localPosition.coordinateSpace, s.loadedDataSource.transform, void 0)),
                            source: n.addRef(),
                            displayState: this.annotationDisplayState,
                            dataSource: s.loadedDataSource.layerDataSource,
                            subsourceIndex: s.subsourceIndex,
                            subsourceId: e.id,
                            role: d.c.ANNOTATION
                        });
                        this.addAnnotationLayerState(l, s)
                    }
                    );
                    continue
                }
                const {annotation: l} = e.subsource;
                if (void 0 === l)
                    s.deactivate("Not compatible with annotation layer");
                else {
                    if (void 0 !== t && Object(y.h)(l.properties) !== Object(y.h)(t)) {
                        s.deactivate("Annotation properties are not compatible");
                        continue
                    }
                    t = l.properties,
                    s.activate(()=>{
                        const t = new r.b({
                            localPosition: this.localPosition,
                            transform: s.getRenderLayerTransform(),
                            source: l,
                            displayState: this.annotationDisplayState,
                            dataSource: s.loadedDataSource.layerDataSource,
                            subsourceIndex: s.subsourceIndex,
                            subsourceId: e.id,
                            role: d.c.ANNOTATION
                        });
                        this.addAnnotationLayerState(t, s)
                    }
                    )
                }
            }
            const s = this.annotationProperties.value;
            Object(y.h)(s) !== Object(y.h)(t) && (this.annotationProperties.value = t)
        }
        initializeAnnotationLayerViewTab(e) {
            const t = e.registerDisposer(Object(f.h)(e=>e.some(e=>e.source instanceof s.b), this.annotationStates))
              , n = e.registerDisposer(new w.a(t,(e,t,n)=>{
                if (e) {
                    {
                        const e = n.registerDisposer(new T.a(this.annotationCrossSectionRenderScaleHistogram,this.annotationCrossSectionRenderScaleTarget));
                        e.label.textContent = "Spacing (cross section)",
                        t.appendChild(e.element)
                    }
                    {
                        const e = n.registerDisposer(new T.a(this.annotationProjectionRenderScaleHistogram,this.annotationProjectionRenderScaleTarget));
                        e.label.textContent = "Spacing (projection)",
                        t.appendChild(e.element)
                    }
                }
            }
            ));
            e.element.insertBefore(n.element, e.element.firstChild);
            {
                const t = e.registerDisposer(new p.c(this.annotationDisplayState.ignoreNullSegmentFilter))
                  , n = document.createElement("label");
                n.appendChild(document.createTextNode("Ignore null related segment filter")),
                n.title = "Display all annotations if filtering by related segments is enabled but no segments are selected",
                n.appendChild(t.element),
                e.element.appendChild(n)
            }
            e.element.appendChild(e.registerDisposer(new R(this.linkedSegmentationLayers)).element)
        }
        toJSON() {
            const e = super.toJSON();
            return e.crossSectionAnnotationSpacing = this.annotationCrossSectionRenderScaleTarget.toJSON(),
            e.projectionAnnotationSpacing = this.annotationProjectionRenderScaleTarget.toJSON(),
            void 0 !== this.localAnnotations ? e.annotations = this.localAnnotations.toJSON() : void 0 !== this.localAnnotationsJson && (e.annotations = this.localAnnotationsJson),
            e.ignoreNullSegmentFilter = this.annotationDisplayState.ignoreNullSegmentFilter.toJSON(),
            Object.assign(e, this.linkedSegmentationLayers.toJSON()),
            e
        }
    }
    function V(e) {
        return new M.a({
            shaderError: e.annotationDisplayState.shaderError,
            fragmentMain: e.annotationDisplayState.shader,
            shaderControlState: e.annotationDisplayState.shaderControls
        })
    }
    N.type = "annotation";
    class B extends c.a {
        constructor(e) {
            super(),
            this.layer = e,
            this.codeWidget = this.registerDisposer(V(this.layer)),
            this.content.appendChild(this.codeWidget.element),
            this.codeWidget.textEditor.refresh()
        }
    }
    class F extends L.b {
        constructor(e) {
            super(),
            this.layer = e,
            this.codeWidget = this.registerDisposer(V(this.layer));
            const {element: t} = this;
            t.appendChild(this.registerDisposer(new w.a(e.annotationProperties,(e,t)=>{
                if (void 0 !== e)
                    for (const n of e) {
                        const e = document.createElement("div");
                        e.classList.add("neuroglancer-annotation-shader-property");
                        const i = document.createElement("span");
                        i.classList.add("neuroglancer-annotation-shader-property-type"),
                        i.textContent = n.type;
                        const r = document.createElement("span");
                        r.classList.add("neuroglancer-annotation-shader-property-identifier"),
                        r.textContent = `prop_${n.identifier}`,
                        e.appendChild(i),
                        e.appendChild(r);
                        const {description: s} = n;
                        void 0 !== s && (e.title = s),
                        t.appendChild(e)
                    }
            }
            )).element);
            let n = document.createElement("div");
            n.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
            let i = document.createElement("div");
            i.style.flex = "1",
            i.textContent = "Annotation shader:",
            n.appendChild(i),
            n.appendChild(Object(E.a)({
                title: "Show larger editor view",
                onClick: ()=>{
                    new B(this.layer)
                }
            })),
            n.appendChild(Object(x.a)({
                title: "Documentation on annotation rendering",
                href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/annotation/rendering.md"
            })),
            t.appendChild(n),
            t.appendChild(this.codeWidget.element),
            t.appendChild(this.registerDisposer(new D.a(e.annotationDisplayState.shaderControls)).element)
        }
    }
    Object(l.q)("annotation", N),
    Object(l.q)("pointAnnotation", N),
    Object(l.r)(e=>e.local === o.c.annotations ? N : void 0 !== e.annotation ? N : void 0)
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    var i = n(99)
      , r = n(73)
      , s = n(86)
      , a = n(35)
      , o = n(23)
      , l = n(0)
      , c = n(59)
      , u = n(3);
    /**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class d {
        constructor() {
            this.finished = new u.b
        }
    }
    class h {
        constructor() {
            this.oidcCallbackService = "bossAuthCallback",
            this.pendingRequests = new Map,
            this.registerListener()
        }
        registerListener() {
            addEventListener("message", e=>{
                if (e.origin === location.origin)
                    try {
                        let t = Object(l.w)(JSON.parse(e.data));
                        if (Object(l.E)(t.service) === this.oidcCallbackService) {
                            let e = Object(l.E)(t.access_token)
                              , n = Object(l.E)(t.state)
                              , i = this.pendingRequests.get(n);
                            if (void 0 === i)
                                return;
                            i.finished.dispatch(e)
                        }
                    } catch (e) {}
            }
            )
        }
        addPendingRequest(e) {
            let t = new d;
            return this.pendingRequests.set(e, t),
            t.finished.add(()=>{
                this.pendingRequests.delete(e)
            }
            ),
            t
        }
        makeAuthRequestUrl(e) {
            let t = `${e.authServer}/realms/BOSS/protocol/openid-connect/auth?`;
            return t += `client_id=${encodeURIComponent(e.clientId)}`,
            t += `&redirect_uri=${encodeURIComponent(e.redirect_uri)}`,
            t += "&response_mode=fragment",
            t += "&response_type=code%20id_token%20token",
            e.state && (t += `&state=${e.state}`),
            e.nonce && (t += `&nonce=${e.nonce}`),
            t
        }
    }
    let p;
    function f(e, t=o.e) {
        const n = Object(c.a)()
          , i = Object(c.a)()
          , r = (void 0 === p && (p = new h),
        p)
          , s = r.makeAuthRequestUrl({
            state: n,
            clientId: e.clientId,
            redirect_uri: new URL("bossauth.html",window.location.href).href,
            authServer: e.authServer,
            nonce: i
        })
          , a = r.addPendingRequest(n)
          , l = new Promise((e,t)=>{
            a.finished.add((n,i)=>{
                void 0 !== n ? e(n) : t(i)
            }
            )
        }
        );
        if (a.finished.add(t.add(()=>{
            a.finished.dispatch(void 0, o.a)
        }
        )),
        !t.isCanceled) {
            const e = open(s);
            null !== e && a.finished.add(()=>{
                e.close()
            }
            )
        }
        return l
    }
    class m extends s.b {
        constructor(e) {
            super(),
            this.authServer = e,
            this.get = Object(s.c)(e=>{
                const t = new a.a(!0);
                let n;
                return new Promise((i,r)=>{
                    function s(e="Boss authorization required.", r="Request authorization.") {
                        t.setText(e + " ");
                        let l = document.createElement("button");
                        l.textContent = r,
                        t.element.appendChild(l),
                        l.addEventListener("click", ()=>{
                            !function() {
                                void 0 !== n && n.cancel();
                                n = new o.b,
                                s("Waiting for Boss authorization...", "Retry"),
                                f({
                                    realm: "boss",
                                    clientId: "endpoint",
                                    authServer: a
                                }, n).then(e=>{
                                    void 0 !== n && (n = void 0,
                                    t.dispose(),
                                    i(e))
                                }
                                , e=>{
                                    void 0 !== n && (n = void 0,
                                    s(`Boss authorization failed: ${e}.`, "Retry"))
                                }
                                )
                            }()
                        }
                        ),
                        t.setVisible(!0)
                    }
                    e.add(()=>{
                        void 0 !== n && (n.cancel(),
                        n = void 0,
                        t.dispose(),
                        r(o.a))
                    }
                    );
                    let a = this.authServer;
                    s()
                }
                )
            }
            )
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    i.a.register(r.a, e=>new m(e))
}
]);
//# sourceMappingURL=main.bundle.js.map
